/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["HyphaCore"] = factory();
	else
		root["HyphaCore"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/hypha-core.js":
/*!***************************!*\
  !*** ./src/hypha-core.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HyphaCore: () => (/* binding */ HyphaCore),\n/* harmony export */   WebSocket: () => (/* reexport safe */ mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket),\n/* harmony export */   WebsocketRPCConnection: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_3__.WebsocketRPCConnection),\n/* harmony export */   Workspace: () => (/* reexport safe */ _workspace__WEBPACK_IMPORTED_MODULE_4__.Workspace),\n/* harmony export */   connectToServer: () => (/* binding */ connectToServer),\n/* harmony export */   hyphaWebsocketClient: () => (/* reexport safe */ hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient),\n/* harmony export */   imjoyRPC: () => (/* reexport safe */ imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__.imjoyRPC)\n/* harmony export */ });\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mock-socket */ \"./node_modules/mock-socket/dist/mock-socket.js\");\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mock_socket__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! imjoy-rpc */ \"./node_modules/imjoy-rpc/index.js\");\n/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _workspace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./workspace */ \"./src/workspace.js\");\n/* harmony import */ var _utils_redis_mock__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/redis-mock */ \"./src/utils/redis-mock.js\");\n/* harmony import */ var _utils_redis_mock__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_utils_redis_mock__WEBPACK_IMPORTED_MODULE_5__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\n\n\n\n\n\nconst connectToServer = hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.connectToServer;\nconst AUTH0_NAMESPACE = \"https://api.imjoy.io/\";\nconst _HyphaCore = class extends _utils__WEBPACK_IMPORTED_MODULE_3__.MessageEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.redis = _utils_redis_mock__WEBPACK_IMPORTED_MODULE_5__;\n    this.port = config.port || 8080;\n    this.baseUrl = config.base_url || new URL(\"./\", document.location.href).href;\n    if (!this.baseUrl.endsWith(\"/\")) {\n      this.baseUrl += \"/\";\n    }\n    if (config.url && config.port) {\n      throw new Error(\"Please provide either url or port, not both.\");\n    }\n    this.WebSocketClass = mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket;\n    if (config.url && (config.url.startsWith(\"wss://\") || config.url.startsWith(\"ws://\"))) {\n      if (!config.url.endsWith(\"/ws\")) {\n        throw new Error(\"Please provide a valid wss url ending with /ws\");\n      }\n      this.url = config.url.replace(\"wss://\", \"https://\").replace(\"ws://\", \"http://\").slice(0, -3);\n      this.wsUrl = config.url;\n    } else {\n      this.url = config.url || \"https://local-hypha-server:\" + this.port;\n      this.wsUrl = this.url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\") + \"/ws\";\n    }\n    this.api = null;\n    this.server = null;\n    this.workspaceManagerId = \"workspace-manager\";\n    this.connections = {};\n    this.defaultServices = config.default_service || {};\n    this.imjoyPluginWindows = /* @__PURE__ */ new Map();\n    this.on(\"add_window\", (config2) => {\n      console.log(\"Creating window: \", config2);\n    });\n  }\n  emit(event, data) {\n    return __async(this, null, function* () {\n      this._fire(event, data);\n    });\n  }\n  _handleImJoyPlugin(event) {\n    const contentWindow = event.source;\n    const data = event.data;\n    let cid = null;\n    for (const [key, value] of Object.entries(this.connections)) {\n      if (value.source === contentWindow) {\n        cid = key;\n        break;\n      }\n    }\n    if (!cid) {\n      console.error(\"Client id not found for the plugin: \", data);\n      return;\n    }\n    const defaultService = this.workspaceManager.getDefaultService();\n    const coreInterface = {};\n    for (const key in defaultService) {\n      const camelKey = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.toCamelCase)(key);\n      if (typeof defaultService[key] === \"function\") {\n        coreInterface[camelKey] = (...args) => __async(this, null, function* () {\n          return yield defaultService[key](...args, { ws: this.connections[cid].workspace, from: `${cid}`, to: `${this.connections[cid].workspace}/${this.workspaceManagerId}` });\n        });\n      } else {\n        coreInterface[camelKey] = defaultService[key];\n      }\n    }\n    const coreConnection = {\n      peer_id: data.peer_id,\n      fire(m) {\n        if (coreConnection._messageHandler[m.type]) {\n          coreConnection._messageHandler[m.type](m);\n        }\n      },\n      disconnect: function() {\n      },\n      emit: (msg) => {\n        msg.peer_id = coreConnection.peer_id;\n        contentWindow.postMessage(msg, \"*\");\n      },\n      on: function(event2, handler) {\n        coreConnection._messageHandler[event2] = handler;\n      },\n      _messageHandler: {},\n      execute(code) {\n        return __async(this, null, function* () {\n          coreConnection.emit({ type: \"execute\", code });\n        });\n      }\n    };\n    const pluginConfig = data.config;\n    if (data.error) {\n      console.error(\"Failed to initialize the plugin\", data.error);\n      return;\n    }\n    if (!data.peer_id) {\n      throw \"Please provide a peer_id for the connection.\";\n    }\n    this.imjoyPluginWindows.set(\n      event.source,\n      {\n        coreConnection,\n        cid\n      }\n    );\n    console.log(\"plugin initialized:\", pluginConfig);\n    const core = new imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__.imjoyRPC.RPC(coreConnection, { name: \"core\" });\n    core.setInterface(coreInterface);\n    core.on(\"interfaceSetAsRemote\", () => {\n      core.on(\"remoteReady\", () => __async(this, null, function* () {\n        const api = core.getRemote();\n        api.id = `${cid}:default`;\n        api.type = \"imjoy\";\n        yield this.workspaceManager.eventBus.emit(\"service_added\", api);\n      }));\n      core.requestRemote();\n    });\n    core.sendInterface();\n  }\n  _handleClientMessage(event) {\n    if (event.data && event.data.type === \"hyphaClientReady\") {\n      for (const key in this.connections) {\n        if (this.connections[key].source === event.currentTarget) {\n          const conn = this.connections[key];\n          this.emit(\"connection_ready\", conn);\n          break;\n        }\n      }\n    }\n    const workspace = event.data.workspace;\n    if (!workspace) {\n      if (event.data.type === \"initialized\") {\n        this._handleImJoyPlugin(event);\n      } else if (this.imjoyPluginWindows.has(event.source)) {\n        const coreConnection = this.imjoyPluginWindows.get(event.source).coreConnection;\n        coreConnection.fire(event.data);\n      }\n      return;\n    }\n    const clientId = event.data.from;\n    if (!clientId || !this.connections[workspace + \"/\" + clientId]) {\n      console.warn(\"Connection not found for client: \", clientId);\n      return;\n    }\n    const connection = this.connections[workspace + \"/\" + clientId];\n    const ws = connection.websocket;\n    if (event.data.type === \"message\") {\n      ws.send(event.data.data);\n    } else if (event.data.type === \"close\") {\n      ws.close();\n    } else if (event.data.type === \"connect\") {\n      const ws2 = new mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket(event.data.url);\n      ws2.onmessage = (evt) => {\n        connection.postMessage({ type: \"message\", data: evt.data, to: clientId });\n      };\n      ws2.onopen = () => {\n        connection.postMessage({ type: \"connected\", to: clientId });\n      };\n      ws2.onclose = () => {\n        connection.postMessage({ type: \"closed\", to: clientId });\n      };\n      connection.websocket = ws2;\n    }\n  }\n  start(config) {\n    return __async(this, null, function* () {\n      if (_HyphaCore.servers[this.url]) {\n        throw new Error(`Server already running at ${this.url}`);\n      } else {\n        this.server = new mock_socket__WEBPACK_IMPORTED_MODULE_0__.Server(this.wsUrl, { mock: false });\n        _HyphaCore.servers[this.url] = this.server;\n        this.messageHandler = this._handleClientMessage.bind(this);\n        window.addEventListener(\"message\", this.messageHandler);\n        this.workspaceManager = new _workspace__WEBPACK_IMPORTED_MODULE_4__.Workspace(this);\n        yield this.workspaceManager.setup({\n          client_id: this.workspaceManagerId,\n          method_timeout: 60,\n          default_service: this.defaultServices\n        });\n      }\n      this.server.on(\"connection\", (websocket) => __async(this, null, function* () {\n        let config2 = {};\n        try {\n          const data = yield new Promise((resolve, reject) => {\n            websocket.on(\"message\", resolve);\n            websocket.on(\"error\", reject);\n          });\n          const authInfo = JSON.parse(data);\n          Object.assign(config2, authInfo);\n        } catch (e) {\n          console.error(e);\n          websocket.close();\n          return;\n        }\n        let userInfo;\n        if (config2.token) {\n          if (_workspace__WEBPACK_IMPORTED_MODULE_4__.Workspace.tokens[config2.token]) {\n            const ws = _workspace__WEBPACK_IMPORTED_MODULE_4__.Workspace.tokens[config2.token].workspace;\n            if (config2.workspace && config2.workspace !== ws.id) {\n              throw new Error(\"Invalid workspace token\");\n            }\n            config2.workspace = ws.id;\n            userInfo = { id: ws.id, is_anonymous: true, email: \"\" };\n          } else {\n            const info = parseJwt(config2.token);\n            const expiresAt = info[\"exp\"];\n            userInfo = {\n              id: info[\"sub\"],\n              is_anonymous: !info[AUTH0_NAMESPACE + \"email\"],\n              email: info[AUTH0_NAMESPACE + \"email\"],\n              roles: info[AUTH0_NAMESPACE + \"roles\"],\n              scopes: info[\"scope\"],\n              expires_at: expiresAt\n            };\n            config2.workspace = userInfo.id;\n          }\n        } else {\n          userInfo = { id: \"anonymous\", is_anonymous: true, email: \"anonymous@imjoy.io\" };\n        }\n        if (!config2.workspace) {\n          config2.workspace = \"workspace-\" + (0,_utils__WEBPACK_IMPORTED_MODULE_3__.randId)();\n        }\n        const baseUrl = this.url.endsWith(\"/\") ? this.url.slice(0, -1) : this.url;\n        websocket.send(JSON.stringify({\n          \"type\": \"connection_info\",\n          \"hypha_version\": \"0.1.0\",\n          \"public_base_url\": baseUrl,\n          \"local_base_url\": baseUrl,\n          \"manager_id\": this.workspaceManagerId,\n          \"workspace\": config2.workspace,\n          \"client_id\": config2.client_id,\n          \"user\": userInfo,\n          \"reconnection_token\": null\n        }));\n        const conn = new _utils__WEBPACK_IMPORTED_MODULE_3__.RedisRPCConnection(this, config2.workspace, config2.client_id, userInfo, this.workspaceManagerId);\n        conn.on_message((data) => {\n          websocket.send(data);\n        });\n        websocket.on(\"message\", (data) => {\n          conn.emit_message(data);\n        });\n      }));\n      config = config || {};\n      config.server = this;\n      config.workspace = config.workspace || \"default\";\n      config.client_id = config.client_id || \"default-client\";\n      const api = yield connectToServer(config);\n      this.api = api;\n      return api;\n    });\n  }\n  connect(config) {\n    return __async(this, null, function* () {\n      config = config || {};\n      config.server = this;\n      config.workspace = config.workspace || \"default\";\n      config.client_id = config.client_id || (0,_utils__WEBPACK_IMPORTED_MODULE_3__.randId)();\n      return yield connectToServer(config);\n    });\n  }\n  reset() {\n    return __async(this, null, function* () {\n      this.close();\n      yield this.start();\n    });\n  }\n  close() {\n    for (const ws of Object.values(_workspace__WEBPACK_IMPORTED_MODULE_4__.Workspace.workspaces)) {\n      ws.eventBus.off(\"service_added\");\n    }\n    window.removeEventListener(\"message\", this.messageHandler);\n    this.server.stop();\n    delete _HyphaCore.servers[this.server.url];\n  }\n};\nlet HyphaCore = _HyphaCore;\n__publicField(HyphaCore, \"servers\", {});\nfunction parseJwt(token) {\n  var base64Url = token.split(\".\")[1];\n  var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  var jsonPayload = decodeURIComponent(window.atob(base64).split(\"\").map(function(c) {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"));\n  return JSON.parse(jsonPayload);\n}\n\n\n\n//# sourceURL=webpack://HyphaCore/./src/hypha-core.js?");

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageEmitter: () => (/* binding */ MessageEmitter),\n/* harmony export */   RedisRPCConnection: () => (/* binding */ RedisRPCConnection),\n/* harmony export */   WebsocketRPCConnection: () => (/* binding */ WebsocketRPCConnection),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   parsePluginCode: () => (/* binding */ parsePluginCode),\n/* harmony export */   randId: () => (/* binding */ randId),\n/* harmony export */   toCamelCase: () => (/* binding */ toCamelCase)\n/* harmony export */ });\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony import */ var _pluginParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginParser */ \"./src/utils/pluginParser.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\nfunction toCamelCase(str) {\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      if (this._event_handlers[event])\n        this._event_handlers[event] = [];\n    } else {\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout);\n    });\n  }\n}\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nclass WebsocketRPCConnection {\n  constructor(eventBus, clients, clientId, workspace, managerId, timeout = 60) {\n    this._clients = clients;\n    this._clientId = clientId;\n    this._handle_message = null;\n    this._handle_connected = null;\n    this._handle_disconnected = null;\n    this._reconnection_token = null;\n    this._timeout = timeout * 1e3;\n    this.workspace = workspace;\n    this.connection_info = null;\n    this.manager_id = managerId;\n    this.eventBus = eventBus;\n  }\n  mount(config) {\n    assert(config.id && config.workspace && config.websocket && config.user_info, \"Invalid client config\");\n    config.websocket.on(\"message\", (data) => {\n      const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n      const unpacker = decoder.decodeMulti(data);\n      const { value: message } = unpacker.next();\n      const targetId = message.to.includes(\"/\") ? message.to.split(\"/\")[1] : message.to;\n      if (targetId === this._clientId) {\n        this._handle_message(data.buffer);\n      } else {\n        this.emit_message(data);\n      }\n    });\n  }\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n  emit_message(data) {\n    return __async(this, null, function* () {\n      assert(this._handle_message, \"No handler for message\");\n      const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n      const unpacker = decoder.decodeMulti(data);\n      const { value: message } = unpacker.next();\n      let targetId = message.to;\n      if (!targetId.includes(\"/\")) {\n        targetId = `${this.workspace}/${targetId}`;\n      }\n      if (!this._clients[targetId]) {\n        console.error(\"No client found for targetId:\", targetId);\n        return;\n      }\n      const client = this._clients[targetId];\n      const websocket = client.websocket;\n      if (!message.from.includes(\"/\")) {\n        message.from = `${this.workspace}/${message.from}`;\n      }\n      const updatedMessage = __spreadProps(__spreadValues({}, message), {\n        ws: this.workspace,\n        to: targetId,\n        from: message.from,\n        user: client.userInfo\n      });\n      const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(updatedMessage);\n      const pos = decoder.pos;\n      const remainingData = data.slice(pos);\n      const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n      finalData.set(encodedUpdatedMessage, 0);\n      finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n      if (!websocket || !websocket.send) {\n        console.error(\"No websocket found for targetId:\", targetId);\n        return;\n      }\n      websocket.send(finalData.buffer);\n    });\n  }\n  disconnect(reason) {\n    console.info(`Websocket connection disconnected (${reason})`);\n  }\n}\nclass RedisRPCConnection {\n  /**\n   * Represent a Redis connection for handling RPC-like messaging.\n   * @param {EventBus} eventBus - Event bus for messaging.\n   * @param {string} workspace - Workspace identifier.\n   * @param {string} clientId - Client identifier.\n   * @param {UserInfo} userInfo - User information.\n   * @param {string} managerId - Manager identifier.\n   */\n  constructor(eventBus, workspace, clientId, userInfo, managerId) {\n    if (!workspace || clientId.includes(\"/\")) {\n      throw new Error(\"Invalid workspace or client ID\");\n    }\n    this._workspace = workspace;\n    this._clientId = clientId;\n    this._userInfo = userInfo;\n    this._stop = false;\n    this._eventBus = eventBus;\n    this._handleConnected = null;\n    this._handleDisconnected = null;\n    this._handleMessage = null;\n    this.manager_id = managerId;\n  }\n  /**\n   * Register a disconnection event handler.\n   * @param {function} handler - Disconnection handler.\n   */\n  on_disconnected(handler) {\n    this._handleDisconnected = handler;\n  }\n  /**\n   * Register a connection open event handler.\n   * @param {function} handler - Connection handler.\n   */\n  on_connected(handler) {\n    this._handleConnected = handler;\n  }\n  /**\n   * Set message handler.\n   * @param {function} handler - Message handler.\n   */\n  on_message(handler) {\n    this._handleMessage = handler;\n    this._eventBus.on(`${this._workspace}/${this._clientId}:msg`, handler);\n    this._eventBus.on(`${this._workspace}/*:msg`, handler);\n    if (this._handleConnected) {\n      this._handleConnected(this);\n    }\n  }\n  /**\n   * Send message after packing additional info.\n   * @param {Object|Uint8Array} data - Data to send.\n   */\n  emit_message(data) {\n    return __async(this, null, function* () {\n      if (this._stop) {\n        throw new Error(`Connection has already been closed (client: ${this._workspace}/${this._clientId})`);\n      }\n      if (!(data instanceof Uint8Array)) {\n        console.log(\"Skipping text message\", data);\n        return;\n      }\n      const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n      const unpacker = decoder.decodeMulti(data);\n      const { value: message } = unpacker.next();\n      const pos = decoder.pos;\n      let targetId = message.to;\n      if (!targetId.includes(\"/\")) {\n        if (targetId.includes(\"/workspace-manager-\")) {\n          throw new Error(`Invalid target ID: ${targetId}, it appears that the target is a workspace manager (target_id should starts with */)`);\n        }\n        targetId = `${this._workspace}/${targetId}`;\n      }\n      const sourceId = `${this._workspace}/${this._clientId}`;\n      message.ws = this._workspace === \"*\" ? targetId.split(\"/\")[0] : this._workspace;\n      message.to = targetId;\n      message.from = sourceId;\n      message.user = this._userInfo;\n      const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(message);\n      const remainingData = data.slice(pos);\n      const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n      finalData.set(encodedUpdatedMessage, 0);\n      finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n      this._eventBus.emit(`${targetId}:msg`, finalData.buffer);\n    });\n  }\n  /**\n   * Handle disconnection.\n   * @param {string} [reason] - Reason for disconnection.\n   */\n  disconnect(reason) {\n    return __async(this, null, function* () {\n      this._stop = true;\n      if (this._handleMessage) {\n        this._eventBus.off(`${this._workspace}/${this._clientId}:msg`, this._handleMessage);\n        this._eventBus.off(`${this._workspace}/*:msg`, this._handleMessage);\n      }\n      this._handleMessage = null;\n      console.info(`Redis Connection Disconnected: ${reason}`);\n      if (this._handleDisconnected) {\n        yield this._handleDisconnected(reason);\n      }\n    });\n  }\n}\nconst CONFIGURABLE_FIELDS = [\n  \"env\",\n  \"requirements\",\n  \"dependencies\",\n  \"icon\",\n  \"ui\",\n  \"type\",\n  \"flags\",\n  \"labels\",\n  \"cover\",\n  \"base_frame\",\n  \"base_worker\",\n  \"passive\"\n];\nfunction parsePluginCode(code, overwrite_config) {\n  overwrite_config = overwrite_config || {};\n  try {\n    const pluginComp = (0,_pluginParser__WEBPACK_IMPORTED_MODULE_0__.parseComponent)(code);\n    let config;\n    if (pluginComp.config[0].attrs.lang === \"yaml\") {\n      throw new Error(\"YAML not supported\");\n    } else if (pluginComp.config[0].attrs.lang === \"json\") {\n      config = JSON.parse(pluginComp.config[0].content);\n    } else {\n      config = JSON.parse(pluginComp.config[0].content);\n      if (compareVersions(config.api_version, \">\", \"0.1.5\")) {\n        throw `Unsupported config language ${pluginComp.config[0].attrs.lang}, please set lang=\"json\" or lang=\"yaml\"`;\n      }\n    }\n    config.tag = overwrite_config.tag || config.tags && config.tags[0];\n    config.hot_reloading = overwrite_config.hot_reloading, config.scripts = [];\n    for (let i = 0; i < pluginComp.script.length; i++) {\n      if (pluginComp.script[i].attrs.tag === config.tag) {\n        config.script = pluginComp.script[i].content;\n      }\n      if (!pluginComp.script[i].attrs.tag || pluginComp.script[i].attrs.tag === config.tag) {\n        config.scripts.push(pluginComp.script[i]);\n      }\n    }\n    if (!config.script && pluginComp.script.length > 0) {\n      config.script = pluginComp.script[0].content;\n      config.lang = pluginComp.script[0].attrs.lang;\n    }\n    config.links = pluginComp.link || null;\n    config.windows = pluginComp.window || null;\n    config.styles = pluginComp.style || null;\n    config.docs = pluginComp.docs && pluginComp.docs[0] || config.docs;\n    config.attachments = pluginComp.attachment || null;\n    config._id = overwrite_config._id || config.name.replace(/ /g, \"_\");\n    config.uri = overwrite_config.uri;\n    config.origin = overwrite_config.origin;\n    config.namespace = overwrite_config.namespace;\n    config.code = code;\n    config.id = config.name.trim().replace(/ /g, \"_\") + \"_\" + randId();\n    config.runnable = config.runnable === false ? false : true;\n    config.requirements = config.requirements || [];\n    for (let i = 0; i < CONFIGURABLE_FIELDS.length; i++) {\n      const obj = config[CONFIGURABLE_FIELDS[i]];\n      if (obj && typeof obj === \"object\" && !(obj instanceof Array)) {\n        if (config.tag) {\n          config[CONFIGURABLE_FIELDS[i]] = obj[config.tag];\n          if (!Object.prototype.hasOwnProperty.call(obj, config.tag)) {\n            console.log(\n              \"WARNING: \" + CONFIGURABLE_FIELDS[i] + \" do not contain a tag named: \" + config.tag\n            );\n          }\n        } else {\n          throw \"You must use 'tags' with configurable fields.\";\n        }\n      }\n    }\n    config.lang = config.lang || \"javascript\";\n    return config;\n  } catch (e) {\n    console.error(e);\n    throw `Failed to parse the plugin file, error: ${e}`;\n  }\n}\n\n\n//# sourceURL=webpack://HyphaCore/./src/utils/index.js?");

/***/ }),

/***/ "./src/utils/pluginParser.js":
/*!***********************************!*\
  !*** ./src/utils/pluginParser.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseComponent: () => (/* binding */ parseComponent)\n/* harmony export */ });\nvar splitRE = /\\r?\\n/g;\nvar emptyRE = /^\\s*$/;\nvar needFixRE = /^(\\r?\\n)*[\\t\\s]/;\nvar deIndent = function deindent(str) {\n  if (!needFixRE.test(str)) {\n    return str;\n  }\n  var lines = str.split(splitRE);\n  var min = Infinity;\n  var type, cur, c;\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    if (!emptyRE.test(line)) {\n      if (!type) {\n        c = line.charAt(0);\n        if (c === \" \" || c === \"\t\") {\n          type = c;\n          cur = count(line, type);\n          if (cur < min) {\n            min = cur;\n          }\n        } else {\n          return str;\n        }\n      } else {\n        cur = count(line, type);\n        if (cur < min) {\n          min = cur;\n        }\n      }\n    }\n  }\n  return lines.map(function(line2) {\n    return line2.slice(min);\n  }).join(\"\\n\");\n};\nfunction count(line, type) {\n  var i = 0;\n  while (line.charAt(i) === type) {\n    i++;\n  }\n  return i;\n}\nvar emptyObject = Object.freeze({});\nfunction isUndef(v) {\n  return v === void 0 || v === null;\n}\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || // $flow-disable-line\n  typeof value === \"symbol\" || typeof value === \"boolean\";\n}\nfunction isObject(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\nvar _toString = Object.prototype.toString;\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === \"[object Object]\";\n}\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction makeMap(str, expectsLowerCase) {\n  var map = /* @__PURE__ */ Object.create(null);\n  var list = str.split(\",\");\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function(val) {\n    return map[val.toLowerCase()];\n  } : function(val) {\n    return map[val];\n  };\n}\nvar isBuiltInTag = makeMap(\"slot,component\", true);\nvar isReservedAttribute = makeMap(\"key,ref,slot,slot-scope,is\");\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\nfunction cached(fn) {\n  var cache = /* @__PURE__ */ Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function(str) {\n  return str.replace(camelizeRE, function(_, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n});\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  boundFn._length = fn.length;\n  return boundFn;\n}\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\nfunction noop(a, b, c) {\n}\nvar no = function(a, b, c) {\n  return false;\n};\nvar identity = function(_) {\n  return _;\n};\nfunction genStaticKeys(modules) {\n  return modules.reduce(function(keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(\",\");\n}\nvar isUnaryTag = makeMap(\n  \"area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr\"\n);\nvar canBeLeftOpenTag = makeMap(\n  \"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source\"\n);\nvar isNonPhrasingTag = makeMap(\n  \"address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track\"\n);\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\w\\\\-\\\\.]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\nvar IS_REGEX_CAPTURING_BROKEN = false;\n\"x\".replace(/x(.)?/g, function(m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === \"\";\n});\nvar isPlainTextElement = makeMap(\"script,style,textarea\", true);\nvar reCache = {};\nvar decodingMap = {\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&amp;\": \"&\",\n  \"&#10;\": \"\\n\",\n  \"&#9;\": \"\t\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\nvar isIgnoreNewlineTag = makeMap(\"pre,textarea\", true);\nvar shouldIgnoreFirstNewline = function(tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === \"\\n\";\n};\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function(match) {\n    return decodingMap[match];\n  });\n}\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf(\"<\");\n      if (textEnd === 0) {\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf(\"-->\");\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(\"]>\");\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue;\n        }\n      }\n      var text = void 0, rest = void 0, next = void 0;\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          next = rest.indexOf(\"<\", 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n      if (textEnd < 0) {\n        text = html;\n        html = \"\";\n      }\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(\n        \"([\\\\s\\\\S]*?)(</\" + stackedTag + \"[^>]*>)\",\n        \"i\"\n      ));\n      var rest$1 = html.replace(reStackedTag, function(all, text2, endTag2) {\n        endTagLength = endTag2.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== \"noscript\") {\n          text2 = text2.replace(/<!\\--([\\s\\S]*?)-->/g, \"$1\").replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1\");\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text2)) {\n          text2 = text2.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text2);\n        }\n        return \"\";\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (!stack.length && options.warn) {\n        options.warn('Mal-formatted tag at end of template: \"' + html + '\"');\n      }\n      break;\n    }\n  }\n  parseEndTag();\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n    if (expectHTML) {\n      if (lastTag === \"p\" && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === \"\") {\n          delete args[3];\n        }\n        if (args[4] === \"\") {\n          delete args[4];\n        }\n        if (args[5] === \"\") {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || \"\";\n      var shouldDecodeNewlines = tagName === \"a\" && args[1] === \"href\" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs\n      });\n      lastTag = tagName;\n    }\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      pos = 0;\n    }\n    if (pos >= 0) {\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ((i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === \"br\") {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === \"p\") {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\nvar splitRE$1 = /\\r?\\n/g;\nvar replaceRE = /./g;\nvar isSpecialTag = makeMap(\"script,style,template\", true);\nfunction parseComponent(content, options) {\n  if (options === void 0)\n    options = {};\n  var sfc = {\n    script: [],\n    style: [],\n    config: [],\n    window: [],\n    docs: [],\n    attachment: [],\n    link: [],\n    others: []\n  };\n  var depth = 0;\n  var currentBlock = null;\n  function start(tag, attrs, unary, start2, end2) {\n    if (depth === 0) {\n      currentBlock = {\n        type: tag,\n        content: \"\",\n        start: end2,\n        attrs: attrs.reduce(function(cumulated, ref) {\n          var name = ref.name;\n          var value = ref.value;\n          cumulated[name] = value || true;\n          return cumulated;\n        }, {})\n      };\n      if (sfc[tag]) {\n        checkAttrs(currentBlock, attrs);\n        sfc[tag].push(currentBlock);\n      } else {\n        sfc.others.push(currentBlock);\n      }\n    }\n    if (!unary) {\n      depth++;\n    }\n  }\n  function checkAttrs(block, attrs) {\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (attr.name === \"lang\") {\n        block.lang = attr.value;\n      }\n      if (attr.name === \"scoped\") {\n        block.scoped = true;\n      }\n      if (attr.name === \"module\") {\n        block.module = attr.value || true;\n      }\n      if (attr.name === \"src\") {\n        block.src = attr.value;\n      }\n    }\n  }\n  function end(tag, start2, end2) {\n    if (depth === 1 && currentBlock) {\n      currentBlock.end = start2;\n      var text = deIndent(content.slice(currentBlock.start, currentBlock.end));\n      if (currentBlock.type !== \"template\" && options.pad) {\n        text = padContent(currentBlock, options.pad) + text;\n      }\n      currentBlock.content = text;\n      currentBlock = null;\n    }\n    depth--;\n  }\n  function padContent(block, pad) {\n    if (pad === \"space\") {\n      return content.slice(0, block.start).replace(replaceRE, \" \");\n    } else {\n      var offset = content.slice(0, block.start).split(splitRE$1).length;\n      var padChar = block.type === \"script\" && !block.lang ? \"//\\n\" : \"\\n\";\n      return Array(offset).join(padChar);\n    }\n  }\n  parseHTML(content, {\n    start,\n    end\n  });\n  return sfc;\n}\n\n\n//# sourceURL=webpack://HyphaCore/./src/utils/pluginParser.js?");

/***/ }),

/***/ "./src/utils/redis-mock.js":
/*!*********************************!*\
  !*** ./src/utils/redis-mock.js ***!
  \*********************************/
/***/ (function(module, exports) {

eval("(function() {\n  \"use strict\";\n  var root = this;\n  var redismock = {};\n  function exists(v) {\n    return typeof v !== \"undefined\" && v !== null;\n  }\n  if (true) {\n    if ( true && module.exports) {\n      exports = module.exports = redismock;\n    }\n    exports.redismock = redismock;\n  } else {}\n  if (typeof setImmediate === \"undefined\" || typeof setImmediate !== \"function\") {\n    var setImmediate = function(f) {\n      setTimeout(f, 0);\n    };\n  }\n  redismock.Array = Array;\n  function SortedSet() {\n    this.scores = [];\n    this.set = {};\n    this.invset = {};\n    this.indices = {};\n    this.lengths = {};\n    this.card = 0;\n    return this;\n  }\n  SortedSet.prototype.add = function(score, member) {\n    var ret = 1;\n    if (exists(this.invset[member])) {\n      this.rem(member);\n      ret = 0;\n    }\n    if (!exists(this.set[score])) {\n      this.scores.push(score);\n      this.set[score] = [];\n      this.lengths[score] = 0;\n    }\n    this.set[score].push(member);\n    this.invset[member] = score;\n    this.indices[member] = this.set[score].length - 1;\n    this.lengths[score] += 1;\n    this.card += 1;\n    return ret;\n  };\n  SortedSet.prototype.rem = function(member) {\n    var score;\n    if (!exists(this.invset[member])) {\n      return 0;\n    }\n    score = this.invset[member];\n    this.set[score].splice(this.set[score].indexOf(member), 1);\n    this.lengths[score] -= 1;\n    if (this.lengths[score] === 0) {\n      this.set[score] = void 0;\n      this.scores.splice(this.scores.indexOf(score), 1);\n    }\n    this.invset[member] = void 0;\n    this.indices[member] = void 0;\n    this.card -= 1;\n    return 1;\n  };\n  SortedSet.prototype.sortScores = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(a, 10) - parseInt(b, 10);\n    });\n    return this;\n  };\n  SortedSet.prototype.sortScoresRev = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(b, 10) - parseInt(a, 10);\n    });\n    return this;\n  };\n  redismock.SortedSet = function() {\n    return new SortedSet();\n  };\n  var cache = {};\n  var timeouts = {};\n  var subscribers = [];\n  var watchers = {};\n  var sets = \"sets-\" + Math.random();\n  var zsets = \"zsets-\" + Math.random();\n  var hashes = \"hashes-\" + Math.random();\n  cache[sets] = {};\n  cache[zsets] = {};\n  cache[hashes] = {};\n  String.prototype.escape = function() {\n    var escapable = /[.\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    var meta;\n    meta = {\n      // table of character substitutions\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      \".\": \"\\\\.\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    };\n    function escapechar(a) {\n      var c = meta[a];\n      return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n    }\n    return this.replace(escapable, escapechar);\n  };\n  function translate(pat) {\n    var i = 0, j, n = pat.length || 0, res, c, stuff;\n    res = \"^\";\n    while (i < n) {\n      c = pat[i];\n      i = i + 1;\n      if (c === \"*\") {\n        res = res + \".*\";\n      } else if (c === \"?\") {\n        res = res + \".\";\n      } else if (c === \"[\") {\n        j = i;\n        if (j < n && pat[j] === \"!\") {\n          j = j + 1;\n        }\n        if (j < n && pat[j] === \"]\") {\n          j = j + 1;\n        }\n        while (j < n && pat[j] !== \"]\") {\n          j = j + 1;\n        }\n        if (j >= n) {\n          res = res + \"\\\\[\";\n        } else {\n          stuff = pat.slice(i, j).replace(\"\\\\\", \"\\\\\\\\\");\n          i = j + 1;\n          if (stuff[0] === \"!\") {\n            stuff = \"^\" + stuff.slice(1);\n          } else if (stuff[0] === \"^\") {\n            stuff = \"\\\\\" + stuff;\n          }\n          res = res + \"[\" + stuff + \"]\";\n        }\n      } else {\n        res = res + c.escape();\n      }\n    }\n    return res + \"$\";\n  }\n  var cb = function(callback, context) {\n    return function() {\n      var args = arguments;\n      if (callback && typeof callback === \"function\") {\n        setImmediate(function() {\n          callback.apply(context, args);\n        });\n      }\n      if (args[0] instanceof Error) {\n        return args[0];\n      }\n      return args[1];\n    };\n  };\n  var gather = function() {\n    return function() {\n      var idx, len = arguments.length;\n      var callback;\n      var list = [];\n      for (idx = len - 1; idx >= 0; idx -= 1) {\n        if (!callback && typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        } else if (exists(arguments[idx])) {\n          list.unshift(arguments[idx]);\n        }\n      }\n      return {\n        callback,\n        list\n      };\n    };\n  };\n  var wrongType = function(callback) {\n    return cb(callback)(new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n  };\n  redismock.ifType = function(key2, type, callback) {\n    var that = this;\n    return {\n      thenex: function(f) {\n        this._ifex = f;\n        return this;\n      },\n      thennx: function(f) {\n        this._ifnx = f;\n        return this;\n      },\n      then: function(f) {\n        this._then = f;\n        return this;\n      },\n      end: function() {\n        var ret;\n        if (that.exists(key2)) {\n          if (that.type(key2) !== type) {\n            return wrongType(callback);\n          }\n          if (typeof this._ifex === \"function\") {\n            ret = this._ifex.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        } else {\n          if (typeof this._ifnx === \"function\") {\n            ret = this._ifnx.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        }\n        if (typeof this._then === \"function\") {\n          ret = this._then.call(that);\n          if (ret && ret instanceof Error) {\n            return cb(callback)(ret);\n          }\n        }\n        return cb(callback)(null, ret);\n      }\n    };\n  };\n  redismock.del = function(key2, callback) {\n    var that = this;\n    var count = 0;\n    var g = gather(this.del).apply(this, arguments);\n    callback = g.callback;\n    var deleter = function(k) {\n      if (that.exists(k)) {\n        if (k in cache) {\n          cache[k] = void 0;\n        } else if (k in cache[sets]) {\n          cache[sets][k] = void 0;\n        } else if (k in cache[zsets]) {\n          cache[zsets][k] = void 0;\n        } else if (k in cache[hashes]) {\n          cache[hashes][k] = void 0;\n        }\n        return 1;\n      }\n      return 0;\n    };\n    var toDelete = g.list;\n    if (typeof g.list[0] === \"object\") {\n      toDelete = g.list[0];\n    }\n    toDelete.forEach(function(k) {\n      count += deleter(k);\n    });\n    return cb(callback)(null, count);\n  };\n  redismock.dump = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.exists = function(key2, callback) {\n    return cb(callback)(null, exists(cache[key2]) || exists(cache[sets][key2]) || exists(cache[zsets][key2]) || exists(cache[hashes][key2]) ? 1 : 0);\n  };\n  redismock.expire = function(key2, seconds, callback) {\n    return this.pexpire(key2, seconds * 1e3, callback);\n  };\n  redismock.expireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp * 1e3 - now.getTime(), callback);\n  };\n  redismock.keys = function(pattern, callback) {\n    var keys = [], key2;\n    var regex = new RegExp(translate(pattern));\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    return cb(callback)(null, keys);\n  };\n  redismock.migrate = function(host, port, key2, destination_db, timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.move = function(key2, db, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.object = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.persist = function(key2, callback) {\n    if (this.exists(key2) && timeouts[key2]) {\n      clearTimeout(timeouts[key2].timeout);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock.pexpire = function(key2, milliseconds, callback) {\n    var that = this;\n    if (this.exists(key2)) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n      if (milliseconds <= 0) {\n        this.del(key2);\n      } else {\n        timeouts[key2] = {};\n        timeouts[key2].start = /* @__PURE__ */ new Date();\n        timeouts[key2].end = new Date(timeouts[key2].start.getTime() + milliseconds);\n        timeouts[key2].timeout = setTimeout(function() {\n          timeouts[key2] = void 0;\n          that.del(key2);\n        }, milliseconds);\n      }\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock.pexpireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp - now.getTime(), callback);\n  };\n  redismock.pttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, timeouts[key2].end.getTime() - now.getTime());\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock.randomkey = function(callback) {\n    var rando = null;\n    function loop_through(count, looper) {\n      var key2;\n      for (key2 in looper) {\n        if (key2 === sets) {\n          count = loop_through(count, cache[sets]);\n          continue;\n        } else if (key2 === zsets) {\n          count = loop_through(count, cache[zsets]);\n          continue;\n        } else if (key2 === hashes) {\n          count = loop_through(count, cache[hashes]);\n          continue;\n        } else if (Math.random() < 1 / count) {\n          rando = key2;\n        }\n        count += 1;\n      }\n      return count;\n    }\n    loop_through(1, cache);\n    return cb(callback)(null, rando);\n  };\n  redismock.rename = function(key2, newkey, callback) {\n    var type;\n    if (!this.exists(key2)) {\n      return cb(callback)(new Error(\"ERR no such key\"));\n    }\n    if (key2 === newkey) {\n      return cb(callback)(null, \"OK\");\n    }\n    type = this.type(key2);\n    if (type === \"string\" || type === \"list\") {\n      cache[newkey] = cache[key2];\n    } else if (type === \"set\") {\n      cache[sets][newkey] = cache[sets][key2];\n    } else if (type === \"zset\") {\n      cache[zsets][newkey] = cache[zsets][key2];\n    } else if (type === \"hash\") {\n      cache[hashes][newkey] = cache[hashes][key2];\n    }\n    this.del(key2);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.renamenx = function(key2, newkey, callback) {\n    var r;\n    if (this.exists(newkey)) {\n      return cb(callback)(null, 0);\n    }\n    r = this.rename(key2, newkey);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, 1);\n  };\n  redismock.restore = function(key2, ttl, serialized_value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.sort = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.ttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, (timeouts[key2].end.getTime() - now.getTime()) / 1e3);\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock.type = function(key2, callback) {\n    if (this.exists(key2)) {\n      var type = typeof cache[key2];\n      if (type === \"object\") {\n        if (cache[key2] instanceof Array) {\n          type = \"list\";\n        }\n      } else if (type === \"undefined\") {\n        if (key2 in cache[sets] && cache[sets][key2]) {\n          type = \"set\";\n        } else if (key2 in cache[zsets] && cache[zsets][key2]) {\n          type = \"zset\";\n        } else if (key2 in cache[hashes] && cache[hashes][key2]) {\n          type = \"hash\";\n        }\n      }\n      return cb(callback)(null, type);\n    }\n    return cb(callback)(null, \"none\");\n  };\n  redismock.scan = function(cursor, callback) {\n    var g = gather(this.scan).apply(null, arguments);\n    var idx = 0;\n    var key2;\n    var reply = [];\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    for (key2 in cache) {\n      if (cache.hasOwnProperty(key2)) {\n        if (key2 === sets || key2 === zsets || key2 === hashes) {\n          continue;\n        }\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    if (!reply.length) {\n      idx = 0;\n    }\n    return cb(callback)(null, [idx, reply]);\n  };\n  redismock.append = function(key2, value, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      cache[key2] += value;\n      return null;\n    }).thennx(function() {\n      return this.set(key2, value);\n    }).then(function() {\n      return cache[key2].length;\n    }).end();\n  };\n  redismock.bitcount = function(key2, callback) {\n    var g = gather(this.bitcount).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length === 3) {\n      start = g.list[1];\n      end = g.list[2];\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var idx, n, count;\n      if (!exists(start)) {\n        start = 0;\n      }\n      if (!exists(end)) {\n        end = cache[key2].length - 1;\n      }\n      if (end >= cache[key2].length) {\n        end = cache[key2].length - 1;\n      }\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return 0;\n      }\n      count = 0;\n      for (idx = start; idx <= end; idx += 1) {\n        n = cache[key2].charCodeAt(idx);\n        while (n) {\n          count += n & 1;\n          n >>= 1;\n        }\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.bitop = function(operation, destkey, key2, callback) {\n    var that = this;\n    var g = gather(this.bitop).apply(this, arguments);\n    var longest, strings, string, r;\n    operation = typeof operation === \"string\" ? operation.toLowerCase() : \"\";\n    if (operation !== \"and\" && operation !== \"or\" && operation !== \"xor\" && operation !== \"not\") {\n      return cb(callback)(new Error(\"ERR syntax error\"));\n    }\n    callback = g.callback;\n    strings = g.list.slice(2).map(function(k) {\n      if (that.exists(k) && that.type(k) !== \"string\") {\n        return null;\n      }\n      return that.exists(k) ? cache[k] : \"\";\n    });\n    if (strings.some(function(str) {\n      return str === null;\n    })) {\n      return wrongType(callback);\n    }\n    longest = strings.reduce(function(length, str) {\n      return str.length > length ? str.length : length;\n    }, 0);\n    strings = strings.map(function(str) {\n      while (str.length < longest) {\n        str += \"\\0\";\n      }\n      return str;\n    });\n    string = strings.reduce(function(cur, str, index) {\n      var idx, n, s;\n      s = \"\";\n      for (idx = 0; idx < longest; idx += 1) {\n        if (operation === \"and\") {\n          n = cur.charCodeAt(idx) & str.charCodeAt(idx);\n        } else if (operation === \"or\") {\n          n = cur.charCodeAt(idx) | str.charCodeAt(idx);\n        } else if (operation === \"xor\") {\n          if (index > 0) {\n            n = cur.charCodeAt(idx) ^ str.charCodeAt(idx);\n          } else {\n            n = cur.charCodeAt(idx);\n          }\n        } else if (operation === \"not\") {\n          n = ~cur.charCodeAt(idx);\n        }\n        s += String.fromCharCode(n);\n      }\n      return s;\n    }, strings[0]);\n    r = this.set(destkey, string);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, string.length);\n  };\n  redismock.bitpos = function(key2, bit, callback) {\n    var g = gather(this.bitpos).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length > 2) {\n      start = g.list[2];\n      end = g.list[3];\n    }\n    if (typeof start === \"undefined\") {\n      start = 0;\n    }\n    if (bit !== 0 && bit !== 1) {\n      return cb(callback)(new Error(\"ERR The bit argument must be 1 or 0.\"));\n    }\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      if (bit === 0) {\n        return 0;\n      }\n      return -1;\n    }).thenex(function() {\n      var idx, ch, cnt, noend = false;\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (typeof end === \"undefined\") {\n        noend = true;\n        end = cache[key2].length - 1;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return -1;\n      }\n      for (idx = start; idx <= end; idx += 1) {\n        ch = cache[key2].charCodeAt(idx);\n        cnt = 0;\n        while (cnt < 8) {\n          if (bit === 0 && (ch & 128) !== 128) {\n            return idx * 8 + cnt;\n          }\n          if (bit === 1 && (ch & 128) === 128) {\n            return idx * 8 + cnt;\n          }\n          ch <<= 1;\n          cnt += 1;\n        }\n      }\n      if (bit === 1) {\n        return -1;\n      }\n      if (bit === 0 && noend) {\n        return idx * 8;\n      }\n      return -1;\n    }).end();\n  };\n  redismock.decr = function(key2, callback) {\n    return this.decrby(key2, 1, callback);\n  };\n  redismock.decrby = function(key2, decrement, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt - decrement);\n      return asInt - decrement;\n    }).end();\n  };\n  redismock.get = function(key2, callback) {\n    if (this.type(key2) === \"string\") {\n      return cb(callback)(null, cache[key2]);\n    }\n    return cb(callback)(null, null);\n  };\n  redismock.getbit = function(key2, offset, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var n, pos;\n      if (offset >= cache[key2].length * 8) {\n        return 0;\n      }\n      n = cache[key2].charCodeAt(Math.floor(offset / 8));\n      pos = offset % 8;\n      return n >> pos & 1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.getrange = function(key2, start, end, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var len = 0;\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start < 0) {\n        len = end - (cache[key2].length + start) + 1;\n      } else {\n        len = end - start + 1;\n      }\n      return cache[key2].substr(start, len);\n    }).thennx(function() {\n      return \"\";\n    }).end();\n  };\n  redismock.getset = function(key2, value, callback) {\n    var prev = this.get(key2);\n    this.set(key2, value);\n    return cb(callback)(null, prev);\n  };\n  redismock.incr = function(key2, callback) {\n    return this.incrby(key2, 1, callback);\n  };\n  redismock.incrby = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return asInt + increment;\n    }).end();\n  };\n  redismock.incrbyfloat = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseFloat(this.get(key2));\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return this.get(key2);\n    }).end();\n  };\n  redismock.mget = function(key2, callback) {\n    var g = gather(this.mget).apply(this, arguments);\n    callback = g.callback;\n    var data = typeof g.list[0] === \"object\" ? g.list[0] : g.list;\n    return cb(callback)(null, data.map(function(k) {\n      return cache[k] || null;\n    }));\n  };\n  redismock.mset = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.mset).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.msetnx = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.msetnx).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    if (kvs.some(function(kv) {\n      return that.exists(kv[0]);\n    })) {\n      return cb(callback)(null, 0);\n    }\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, 1);\n  };\n  redismock.psetex = function(key2, milliseconds, value, callback) {\n    this.set(key2, value);\n    this.pexpire(key2, milliseconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.set = function(key2, value, callback) {\n    var nx = false, xx = false, ex = -1, px = -1;\n    var g = gather(this.set).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (opt === \"nx\" || opt === \"NX\") {\n        nx = true;\n      } else if (opt === \"xx\" || opt === \"XX\") {\n        xx = true;\n      } else if (opt === \"ex\" || opt === \"EX\") {\n        ex = g.list[index + 1];\n      } else if (opt === \"px\" || opt === \"PX\") {\n        px = g.list[index + 1];\n      }\n    });\n    if (nx) {\n      if (this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    if (xx) {\n      if (!this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    cache[key2] = exists(value) ? value.toString() : \"\";\n    if (px !== -1) {\n      redismock.pexpire(key2, px);\n    }\n    if (ex !== -1) {\n      redismock.expire(key2, ex);\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.setbit = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var byteIdx = Math.floor(offset / 8);\n      var bitIdx = offset % 8;\n      var idx, bit, mask;\n      var code;\n      if (value !== 0 && value !== 1) {\n        return new Error(\"ERR bit is not an integer or out of range\");\n      }\n      while (cache[key2].length < byteIdx + 1) {\n        cache[key2] += \"\\0\";\n      }\n      code = cache[key2].charCodeAt(byteIdx);\n      idx = 0;\n      mask = 128;\n      while (idx < bitIdx) {\n        mask >>= 1;\n        idx += 1;\n      }\n      bit = (code & mask) === 0 ? 0 : 1;\n      if (value === 0) {\n        code = code & ~mask;\n      } else {\n        code = code | mask;\n      }\n      cache[key2] = cache[key2].substr(0, byteIdx) + String.fromCharCode(code) + cache[key2].substr(byteIdx + 1);\n      return bit;\n    }).end();\n  };\n  redismock.setex = function(key2, seconds, value, callback) {\n    this.set(key2, value);\n    this.expire(key2, seconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.setnx = function(key2, value, callback) {\n    if (!this.exists(key2)) {\n      this.set(key2, value);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock.setrange = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var idx, newValue;\n      if (cache[key2].length < offset + value.length - 1) {\n        for (idx = cache[key2].length; idx < offset + value.length; idx += 1) {\n          cache[key2] += \"\\0\";\n        }\n      }\n      newValue = cache[key2].substr(0, offset);\n      for (idx = offset; idx < offset + value.length; idx += 1) {\n        newValue += value[idx - offset];\n      }\n      newValue += cache[key2].substr(offset + value.length);\n      cache[key2] = newValue;\n      return cache[key2].length;\n    }).end();\n  };\n  redismock.strlen = function(key2, callback) {\n    if (!this.exists(key2)) {\n      return cb(callback)(null, 0);\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.blpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.blpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    var f, timedout = false;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.lpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock.brpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.brpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    var f, timedout = false;\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.rpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock.brpoplpush = function(source, destination, timeout, callback) {\n    var that = this;\n    var f, timedout = false;\n    f = function() {\n      var len;\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      len = that.llen(source);\n      if (len instanceof Error) {\n        return cb(callback)(len);\n      }\n      if (len > 0) {\n        that.rpoplpush(source, destination, callback);\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock.lindex = function(key2, i, callback) {\n    var elem = null;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (i >= 0 && i < cache[key2].length) {\n        elem = cache[key2][i];\n      } else if (i < 0 && cache[key2].length + 1 >= 0) {\n        elem = cache[key2][cache[key2].length + i];\n      }\n    }).then(function() {\n      return elem;\n    }).end();\n  };\n  redismock.linsert = function(key2, beforeafter, pivot, value, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx = cache[key2].indexOf(pivot);\n      if (idx !== -1) {\n        if (beforeafter === \"before\") {\n          cache[key2].splice(idx, 0, value);\n        } else if (beforeafter === \"after\") {\n          cache[key2].splice(idx + 1, 0, value);\n        }\n        return cache[key2].length;\n      }\n      return -1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.llen = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.lpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].shift();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.lpush = function(key2, element, callback) {\n    var g = gather(this.lpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock.Array();\n    }).then(function() {\n      g.list.slice(1).forEach(function(elem) {\n        cache[key2].unshift(elem);\n      });\n      return cache[key2].length;\n    }).end();\n  };\n  redismock.lpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].unshift(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.lrange = function(key2, start, end, callback) {\n    var l = [];\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (start > cache[key2].length - 1) {\n        l = [];\n      } else {\n        if (start < 0) {\n          start = cache[key2].length + start;\n        }\n        if (end < 0) {\n          end = cache[key2].length + end;\n        }\n        if (start > end) {\n          l = [];\n        } else {\n          l = cache[key2].slice(start, end + 1);\n        }\n      }\n    }).then(function() {\n      return l;\n    }).end();\n  };\n  redismock.lrem = function(key2, count, element, callback) {\n    var cnt = 0;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx;\n      while (true) {\n        idx = cache[key2].indexOf(element);\n        if (idx === -1) {\n          break;\n        }\n        cache[key2].splice(idx, 1);\n        cnt += 1;\n        if (count > 0 && cnt === count) {\n          break;\n        }\n      }\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return cnt;\n    }).end();\n  };\n  redismock.lset = function(key2, index, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (index >= cache[key2].length) {\n        return new Error(\"ERR index out of range\");\n      }\n      cache[key2][index] = element;\n      return \"OK\";\n    }).thennx(function() {\n      return new Error(\"ERR no such key\");\n    }).end();\n  };\n  redismock.ltrim = function(key2, start, end, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var tmpS, tmpE;\n      if (start > cache[key2].length - 1 || start > end) {\n        cache[key2] = new redismock.Array();\n      } else {\n        if (start < 0 && end < 0) {\n          tmpE = cache[key2].length + end;\n          tmpS = cache[key2].length + start;\n          if (tmpS < 0) {\n            tmpS = 0;\n          }\n          start = tmpS;\n          end = tmpE;\n        }\n        if (end > cache[key2].length - 1) {\n          end = cache[key2].length - 1;\n        }\n        cache[key2] = cache[key2].slice(start, end + 1);\n      }\n    }).then(function() {\n      if (this.exists(key2) && !cache[key2].length) {\n        this.del(key2);\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock.rpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].pop();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.rpoplpush = function(source, dest, callback) {\n    var element = null, reply;\n    if (this.exists(source) && this.type(source) !== \"list\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"list\") {\n      return wrongType(callback);\n    }\n    element = this.rpop(source);\n    if (element instanceof Error) {\n      return cb(callback)(element);\n    }\n    if (element) {\n      reply = this.lpush(dest, element);\n      if (reply instanceof Error) {\n        return cb(callback)(reply);\n      }\n    }\n    return cb(callback)(null, element);\n  };\n  redismock.rpush = function(key2, element, callback) {\n    var g = gather(this.rpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock.Array();\n    }).then(function() {\n      cache[key2] = cache[key2].concat(g.list.slice(1));\n      return cache[key2].length;\n    }).end();\n  };\n  redismock.rpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].push(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.sadd = function(key2, member, callback) {\n    var g = gather(this.sadd).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      cache[sets][key2] = {};\n    }).then(function() {\n      g.list.slice(1).forEach(function(m) {\n        m = m ? m.toString() : \"\";\n        if (m.length === 0) {\n          return;\n        }\n        if (!(m in cache[sets][key2])) {\n          cache[sets][key2][m] = \"\";\n          count += 1;\n        }\n      });\n      return count;\n    }).end();\n  };\n  redismock.scard = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]).length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.sdiff = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sdiff).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(diff, k) {\n        return diff.filter(function(d) {\n          return !(d in cache[sets][k]);\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock.sdiffstore = function(destination, key2, callback) {\n    var g = gather(this.sdiffstore).apply(this, arguments);\n    var diff = this.sdiff.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (diff instanceof Error) {\n      return cb(callback)(diff);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    this.sadd.apply(this, [destination].concat(diff));\n    return cb(callback)(null, diff.length);\n  };\n  redismock.sinter = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sinter).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(inter, k) {\n        return inter.filter(function(i) {\n          return i in cache[sets][k];\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock.sinterstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sinterstore).apply(this, arguments);\n    var inter = this.sinter.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (inter instanceof Error) {\n      return cb(callback)(inter);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    inter.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, inter.length);\n  };\n  redismock.sismember = function(key2, member, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return member in cache[sets][key2] ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.smembers = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]);\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.smove = function(source, dest, member, callback) {\n    var r, e;\n    if (this.exists(source) && this.type(source) !== \"set\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"set\") {\n      return wrongType(callback);\n    }\n    r = redismock.srem(source, member);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    if (r === 1) {\n      e = redismock.sadd(dest, member);\n      if (e instanceof Error) {\n        return cb(callback)(e);\n      }\n    }\n    return cb(callback)(null, r);\n  };\n  redismock.spop = function(key2, callback) {\n    var r;\n    var rando = this.srandmember(key2);\n    if (rando instanceof Error) {\n      return cb(callback)(rando);\n    }\n    r = this.srem(key2, rando);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, rando);\n  };\n  redismock.srandmember = function(key2, callback) {\n    var that = this;\n    var count;\n    if (arguments.length === 2 && typeof callback !== \"function\") {\n      count = callback;\n      callback = null;\n    }\n    if (arguments.length === 3) {\n      count = callback;\n      callback = arguments[2];\n    }\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      var k = Object.keys(cache[sets][key2]);\n      var randos, rando;\n      var len = that.scard(key2);\n      if (count === 0) {\n        return null;\n      }\n      if (count) {\n        randos = [];\n        while (randos.length < Math.abs(count)) {\n          rando = k[Math.floor(Math.random() * k.length)];\n          if (count < 0) {\n            randos.push(rando);\n          } else {\n            if (randos.indexOf(rando) === -1) {\n              randos.push(rando);\n              if (randos.length === len) {\n                break;\n              }\n            }\n          }\n        }\n        return randos;\n      }\n      return k[Math.floor(Math.random() * k.length)];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.srem = function(key2, member, callback) {\n    var g = gather(this.srem).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      g.list.slice(1).forEach(function(m) {\n        var k = m ? m.toString() : \"\";\n        if (k in cache[sets][key2]) {\n          delete cache[sets][key2][k];\n          count += 1;\n        }\n      });\n      if (!Object.keys(cache[sets][key2]).length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock.sunion = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sunion).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return Object.keys(g.list.reduce(function(set, k) {\n        Object.keys(cache[sets][k]).filter(function(u) {\n          return !(u in set);\n        }).forEach(function(u) {\n          set[u] = \"\";\n        });\n        return set;\n      }, {}));\n    }).end();\n  };\n  redismock.sunionstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sunionstore).apply(this, arguments);\n    var union = this.sunion.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (union instanceof Error) {\n      return cb(callback)(union);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    union.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, union.length);\n  };\n  redismock.sscan = function(key2, cursor, callback) {\n    var g = gather(this.sscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).then(function() {\n      var arr = [];\n      this.smembers(key2).slice(cursor).some(function(member) {\n        if (typeof match === \"undefined\" || member.match(match)) {\n          arr.push(member);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock.zadd = function(key2, score, member, callback) {\n    var g = gather(this.zadd).apply(this, arguments);\n    callback = g.callback;\n    g.list = g.list.slice(1);\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock.SortedSet();\n    }).then(function() {\n      var count = g.list.map(function(elem, index) {\n        if (index % 2 === 0) {\n          return [parseFloat(g.list[index]), g.list[index + 1]];\n        }\n        return null;\n      }).filter(function(elem) {\n        return elem !== null;\n      }).map(function(sm) {\n        return cache[zsets][key2].add(sm[0], sm[1].toString());\n      }).reduce(function(cnt, ret) {\n        return cnt + ret;\n      }, 0);\n      return count;\n    }).end();\n  };\n  redismock.zcard = function(key2, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      return cache[zsets][key2].card;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.zcount = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = cache[zsets][key2].scores.filter(function(score) {\n        return min <= score && score <= max;\n      }).reduce(function(cnt, score) {\n        return cnt + cache[zsets][key2].lengths[score];\n      }, 0);\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.zincrby = function(key2, increment, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock.SortedSet();\n    }).then(function() {\n      var newScore, score;\n      if (!exists(cache[zsets][key2].invset[member])) {\n        this.zadd(key2, increment, member);\n        return increment;\n      }\n      score = cache[zsets][key2].invset[member];\n      newScore = score + increment;\n      this.zadd(key2, newScore, member);\n      return newScore;\n    }).end();\n  };\n  redismock.zinterstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zinterstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(inter, k) {\n      var arr = [];\n      var idx, len = inter.length;\n      var score, ms;\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        score = cache[zsets][k].invset[inter[idx]];\n        if (!exists(score)) {\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        ms = [inter[idx + 1], inter[idx]];\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, inter) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, inter[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock.zlexcount = function(key2, min, max, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock.zrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = Math.max(this.zcard(key2) + start, 0);\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].lengths[score] > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].lengths[score];\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        while (from < to) {\n          if (exists(cache[zsets][key2].set[score][from])) {\n            arr.push(cache[zsets][key2].set[score][from]);\n          }\n          from += 1;\n        }\n        arr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.zrangebylex = function(key2, min, max, callback) {\n    function verify(r) {\n      return typeof r === \"string\" && (r.charAt(0) === \"(\" || r.charAt(0) === \"[\" || r.charAt(0) === \"-\" || r.charAt(0) === \"+\");\n    }\n    if (!verify(min) || !verify(max)) {\n      return cb(callback)(new Error(\"ERR min or max not valid string range item\"));\n    }\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      var minStr = min.substr(1), maxStr = max.substr(1);\n      var minInclusive = min.charAt(0) === \"[\", maxInclusive = max.charAt(0) === \"[\";\n      var maxAll = max.charAt(0) === \"+\";\n      var range = [];\n      if (min.charAt(0) === \"+\") {\n        return [];\n      }\n      if (max.charAt(0) === \"-\") {\n        return [];\n      }\n      cache[zsets][key2].scores.forEach(function(score) {\n        cache[zsets][key2].set[score].forEach(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if (member > minStr && (member < maxStr || maxAll)) {\n            range.push(member);\n          } else if (member === minStr && minInclusive) {\n            range.push(member);\n          } else if (member === maxStr && maxInclusive) {\n            range.push(member);\n          }\n        });\n      });\n      range.sort(function(a, b) {\n        return a.localeCompare(b);\n      });\n      return range;\n    }).end();\n  };\n  redismock.zrevrangebylex = function(key2, max, min, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.reverse());\n  };\n  redismock.zrangebyscore = function(key2, min, max, callback) {\n    var withscores = false;\n    var limitOffset = -1, limitCount = -1;\n    var idx, len;\n    var arr = [], offset, count;\n    var minInclusive = true, maxInclusive = true;\n    if (typeof callback !== \"function\") {\n      len = arguments.length;\n      for (idx = 3; idx < len; idx += 1) {\n        if (arguments[idx] === \"withscores\") {\n          withscores = true;\n        }\n        if (typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        }\n        if (arguments[idx] === \"limit\") {\n          limitOffset = arguments[idx + 1];\n          limitCount = arguments[idx + 2];\n        }\n      }\n    }\n    if (min === \"-inf\") {\n      min = Number.NEGATIVE_INFINITY;\n    }\n    if (min === \"+inf\") {\n      min = Number.POSITIVE_INFINITY;\n    }\n    if (max === \"-inf\") {\n      max = Number.NEGATIVE_INFINITY;\n    }\n    if (max === \"+inf\") {\n      max = Number.POSITIVE_INFINITY;\n    }\n    if (min.toString().charAt(0) === \"(\") {\n      minInclusive = false;\n      min = parseFloat(min.toString().substr(1));\n    }\n    if (max.toString().charAt(0) === \"(\") {\n      maxInclusive = false;\n      max = parseFloat(max.toString().substr(1));\n    }\n    offset = 0;\n    count = 0;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        var memberArr = [], scoreArr = [], concatArr = [];\n        cache[zsets][key2].set[score].some(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if ((minInclusive && min <= score || !minInclusive && min < score) && (maxInclusive && score <= max || !maxInclusive && score < max)) {\n            if (limitOffset !== -1 && offset >= limitOffset) {\n              if (limitCount !== -1) {\n                if (count + memberArr.length < limitCount) {\n                  memberArr.push(member);\n                  if (withscores) {\n                    scoreArr.push(score);\n                  }\n                } else {\n                  return true;\n                }\n              }\n            } else if (limitOffset === -1) {\n              memberArr.push(member);\n              if (withscores) {\n                scoreArr.push(score);\n              }\n            }\n          }\n          offset += 1;\n          return false;\n        });\n        count += memberArr.length;\n        memberArr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          memberArr.forEach(function(m, idx2) {\n            concatArr.push(m, scoreArr[idx2]);\n          });\n        } else {\n          concatArr = memberArr;\n        }\n        arr = arr.concat(concatArr);\n        if (limitCount !== -1 && count === limitCount) {\n          return true;\n        }\n        return false;\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.zrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx = 0;\n      var found;\n      cache[zsets][key2].sortScores();\n      found = cache[zsets][key2].scores.some(function(score) {\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return true;\n        }\n        idx += 1;\n        return false;\n      });\n      if (!found) {\n        return null;\n      }\n      return idx;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.zrem = function(key2, member, callback) {\n    var g = gather(this.zrem).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = g.list.reduce(function(cnt, m) {\n        return cnt + cache[zsets][key2].rem(m);\n      }, 0);\n      if (cache[zsets][key2].scores.length === 0) {\n        this.del(key2);\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.zremrangebylex = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebylex(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock.zremrangebyrank = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var that = this;\n      var idx, len = cache[zsets][key2].scores.length, jdx, nel;\n      var cnt;\n      var score;\n      var toRem = [];\n      var card = this.zcard(key2);\n      if (min < 0) {\n        min = card + min;\n      }\n      if (max < 0) {\n        max = card + max;\n      }\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = 0; idx < len; idx += 1) {\n        score = cache[zsets][key2].scores[idx];\n        nel = cache[zsets][key2].set[score].length;\n        for (jdx = 0; jdx < nel; jdx += 1, cnt += 1) {\n          if (min <= cnt && cnt <= max) {\n            toRem.push(cache[zsets][key2].set[score][jdx]);\n          }\n          if (cnt > max) {\n            break;\n          }\n        }\n        if (cnt > max) {\n          break;\n        }\n      }\n      toRem.forEach(function(r) {\n        that.zrem(key2, r);\n      });\n      return toRem.length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.zremrangebyscore = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebyscore(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock.zrevrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = this.zcard(key2) + start;\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScoresRev().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].set[score].length > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].set[score].length;\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        arr = cache[zsets][key2].set[score].slice(from, to);\n        arr.sort(function(a, b) {\n          return b.localeCompare(a);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.zrevrangebyscore = function(key2, max, min, callback) {\n    var g = gather(this.zrevrangebyscore).apply(this, arguments);\n    var r, tmpM;\n    callback = g.callback;\n    tmpM = g.list[1];\n    g.list[1] = g.list[2];\n    g.list[2] = tmpM;\n    r = this.zrangebyscore.apply(this, g.list);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    r.reverse();\n    if (g.list.some(function(arg) {\n      return arg === \"withscores\";\n    })) {\n      r = r.map(function(e, idx) {\n        if (idx % 2 === 0) {\n          return r[idx + 1];\n        }\n        return r[idx - 1];\n      });\n    }\n    return cb(callback)(null, r);\n  };\n  redismock.zrevrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx, len = cache[zsets][key2].scores.length, cnt;\n      var score;\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = len - 1; idx >= 0; idx -= 1, cnt += 1) {\n        score = cache[zsets][key2].scores[idx];\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return cnt;\n        }\n      }\n      return null;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.zscore = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var score = null;\n      if (exists(cache[zsets][key2].invset[member])) {\n        score = cache[zsets][key2].invset[member];\n      }\n      return score;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.zunionstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zunionstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2, 2 + numkeys).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(union, k) {\n      var arr = [];\n      var idx, len = union.length;\n      var score, ms;\n      var hashk = cache[zsets][k].invset;\n      var hashu = {};\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        ms = [union[idx + 1], union[idx]];\n        score = cache[zsets][k].invset[union[idx]];\n        hashu[ms[1]] = ms[0];\n        if (!exists(score)) {\n          arr.push(ms[1], ms[0]);\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      Object.keys(hashk).forEach(function(member) {\n        if (!exists(hashk[member])) {\n          return;\n        }\n        if (!(member in hashu)) {\n          score = hashk[member];\n          if (k in weights) {\n            score *= weights[k];\n          }\n          arr.push(member, score);\n        }\n      });\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, union) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, union[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock.zscan = function(key2, cursor, callback) {\n    var g = gather(this.zscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).then(function() {\n      var arr = [];\n      var cnt = 0;\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        cache[zsets][key2].set[score].some(function(member) {\n          if (cursor <= cnt) {\n            if (typeof match === \"undefined\" || member.match(match)) {\n              arr.push([member, score]);\n            }\n            cursor += 1;\n          }\n          if (arr.length >= count) {\n            return true;\n          }\n          cnt += 1;\n          return false;\n        });\n        if (arr.length >= count) {\n          return true;\n        }\n        return false;\n      });\n      arr = arr.reduce(function(unnested, ms) {\n        return unnested.concat(ms);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock.hdel = function(key2, field, callback) {\n    var count = 0;\n    var g = gather(this.hdel).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list.forEach(function(field2) {\n        if (field2 in cache[hashes][key2]) {\n          cache[hashes][key2][field2] = void 0;\n          count += 1;\n        }\n      });\n      if (Object.keys(cache[hashes][key2]).length === 0) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock.hexists = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field] !== void 0 ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock.hget = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.hgetall = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var obj = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        prev[fv[0]] = fv[1];\n        return prev;\n      }, {});\n      return obj;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock.hgetall_array = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var arr = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.hincrby = function(key2, field, increment, callback) {\n    increment = parseInt(increment, 10);\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseInt(this.hget(key2, field), 10);\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not an integer\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock.hincrbyfloat = function(key2, field, increment, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseFloat(this.hget(key2, field));\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not a valid float\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock.hkeys = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return Object.keys(cache[hashes][key2]).filter(function(f) {\n        return cache[hashes][key2][f] !== void 0;\n      });\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.hlen = function(key2, callback) {\n    var r = this.hkeys(key2);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock.hmget = function(key2, field, callback) {\n    var g = gather(this.hmget).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list = g.list.slice(1);\n      var arr = g.list.map(function(f) {\n        return cache[hashes][key2][f];\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock.hmset = function(key2, field, callback) {\n    var g = gather(this.hmset).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var that = this;\n      var first = g.list[1];\n      if (g.list.length === 2 && typeof first === \"object\" && !(first instanceof Array)) {\n        Object.keys(first).forEach(function(fv) {\n          that.hset(key2, fv, first[fv]);\n        });\n      } else {\n        g.list = g.list.slice(1);\n        g.list.map(function(fv, index) {\n          if (index % 2 === 0) {\n            return [fv, g.list[index + 1]];\n          }\n          return null;\n        }).filter(function(fv) {\n          return fv !== null;\n        }).forEach(function(fv) {\n          that.hset(key2, fv[0], fv[1]);\n        });\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock.hset = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n      } else {\n        ret = 1;\n      }\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      cache[hashes][key2][field] = value;\n      return ret;\n    }).end();\n  };\n  redismock.hsetnx = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n        return;\n      }\n      ret = 1;\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      if (ret === 1) {\n        cache[hashes][key2][field] = value;\n      }\n      return ret;\n    }).end();\n  };\n  redismock.hstrlen = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      return 0;\n    }).thenex(function() {\n      if (!exists(cache[hashes][key2][field])) {\n        return 0;\n      }\n      return cache[hashes][key2][field].toString().length;\n    }).end();\n  };\n  redismock.hvals = function(key2, callback) {\n    var vals = [];\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      vals = Object.keys(cache[hashes][key2]).filter(function(field) {\n        return cache[hashes][key2][field] !== void 0;\n      }).map(function(field) {\n        return cache[hashes][key2][field];\n      });\n    }).then(function() {\n      return vals;\n    }).end();\n  };\n  redismock.hscan = function(key2, cursor, callback) {\n    var g = gather(this.hscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).then(function() {\n      var arr = [];\n      this.hgetall_array(key2).slice(cursor * 2).some(function(forv, index, hgetall) {\n        if (index % 2 !== 0) {\n          return false;\n        }\n        if (typeof match === \"undefined\" || forv.match(match)) {\n          arr.push([forv, hgetall[index + 1]]);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      arr = arr.reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock.on = function(event, callback) {\n    if (!exists(this.listeners)) {\n      this.listeners = {};\n    }\n    if (!exists(this.listeners[event])) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n    return this;\n  };\n  function emit(rm, event) {\n    var g = gather(emit).apply(null, arguments);\n    if (exists(rm.listeners[event])) {\n      rm.listeners[event].forEach(function(cb2) {\n        setImmediate(function() {\n          cb2.apply(rm, g.list.slice(2));\n        });\n      });\n    }\n  }\n  function Subscriber(rm) {\n    this.rm = rm;\n    return this;\n  }\n  Subscriber.prototype.subscribe = function(channel) {\n    this.channel = channel;\n    emit(this.rm, \"subscribe\", channel, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.psubscribe = function(pattern) {\n    this.originalPattern = pattern;\n    this.pattern = new RegExp(translate(pattern));\n    emit(this.rm, \"psubscribe\", pattern, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.matches = function(channel) {\n    if (exists(this.channel) && this.channel === channel) {\n      return true;\n    }\n    if (exists(this.pattern) && channel.match(this.pattern)) {\n      return true;\n    }\n    return false;\n  };\n  Subscriber.prototype.message = function(channel, message) {\n    if (this.matches(channel)) {\n      if (exists(this.channel)) {\n        emit(this.rm, \"message\", channel, message);\n        return true;\n      } else if (exists(this.pattern)) {\n        emit(this.rm, \"pmessage\", this.originalPattern, channel, message);\n        return true;\n      }\n    }\n    return false;\n  };\n  Subscriber.prototype.unsubscribe = function(count) {\n    if (exists(this.channel)) {\n      emit(this.rm, \"unsubscribe\", this.channel, count);\n    }\n    if (exists(this.pattern)) {\n      emit(this.rm, \"punsubscribe\", this.originalPattern, count);\n    }\n    return this;\n  };\n  redismock.psubscribe = function(pattern, callback) {\n    var that = this;\n    var g = gather(this.psubscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(pat) {\n      subscribers.push(new Subscriber(that).psubscribe(pat));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.pubsub = function(subcommand, callback) {\n    var g = gather(this.pubsub).apply(this, arguments);\n    var ret = null, pat;\n    if (subcommand === \"channels\") {\n      if (g.list[1]) {\n        pat = new RegExp(translate(g.list[1]));\n      }\n      ret = subscribers.map(function(subscriber) {\n        if (exists(subscriber.channel) && (!pat || subscriber.channel.match(pat))) {\n          return subscriber.channel;\n        }\n        return null;\n      }).filter(function(channel) {\n        return channel !== null;\n      });\n    } else if (subcommand === \"numsub\") {\n      ret = g.list.slice(1).map(function(channel) {\n        return subscribers.reduce(function(count, subscriber) {\n          if (subscriber.channel === channel) {\n            return count + 1;\n          }\n          return count;\n        }, 0);\n      }).reduce(function(flattened, cc) {\n        return flattened.concat(cc);\n      }, []);\n    } else if (subcommand === \"numpat\") {\n      ret = subscribers.reduce(function(count, subscriber) {\n        if (exists(subscriber.pattern)) {\n          return count + 1;\n        }\n        return count;\n      }, 0);\n    }\n    callback = g.callback;\n    return cb(callback)(null, ret);\n  };\n  redismock.publish = function(channel, message, callback) {\n    var count = subscribers.reduce(function(cnt, subscriber) {\n      if (subscriber.message(channel.toString(), message.toString())) {\n        return cnt + 1;\n      }\n      return cnt;\n    }, 0);\n    return cb(callback)(null, count);\n  };\n  redismock.punsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.punsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.pattern)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.pattern);\n      });\n    } else {\n      g.list.forEach(function(pattern) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.originalPattern === pattern) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.subscribe = function(channel, callback) {\n    var that = this;\n    var g = gather(this.subscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(chan) {\n      subscribers.push(new Subscriber(that).subscribe(chan));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.unsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.unsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.channel)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.channel);\n      });\n    } else {\n      g.list.forEach(function(chan) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.channel === chan) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n          }\n          return subscriber.channel !== chan;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.discard = function(callback) {\n    return cb(callback)(new Error(\"ERR DISCARD without MULTI\"));\n  };\n  redismock.multi = function(commands) {\n    var rc = {};\n    var that = this;\n    var toApply = [], replies = [];\n    if (exists(commands)) {\n      toApply = toApply.concat(commands.map(function(command) {\n        var args = command.slice(1);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        return [command[0], that[command[0]], that, args];\n      }));\n    }\n    Object.keys(this).forEach(function(key2) {\n      rc[key2] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        toApply.push([key2, that[key2], that, args]);\n        return this;\n      };\n    });\n    rc.exec = function(callback) {\n      if (toApply.some(function(apply) {\n        var check = apply[3][0];\n        if (exists(watchers[check]) && watchers[check].modified && watchers[check].watchers.indexOf(that) !== -1) {\n          return true;\n        }\n        return false;\n      })) {\n        that.unwatch();\n        return cb(callback)(null, null);\n      }\n      toApply.forEach(function(apply) {\n        apply[1].apply(apply[2], apply[3]);\n      });\n      that.unwatch();\n      return cb(callback)(null, replies);\n    };\n    rc.discard = function(callback) {\n      toApply = [];\n      that.unwatch();\n      return cb(callback)(null, \"OK\");\n    };\n    return rc;\n  };\n  redismock.unwatch = function(callback) {\n    var that = this;\n    Object.keys(watchers).forEach(function(k) {\n      if (exists(watchers[k])) {\n        watchers[k].watchers = watchers[k].watchers.filter(function(mock) {\n          return that !== mock;\n        });\n        if (watchers[k].watchers.length === 0) {\n          watchers[k] = void 0;\n        }\n      }\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.watch = function(key2, callback) {\n    if (!exists(watchers[key2])) {\n      watchers[key2] = {\n        modified: false,\n        watchers: []\n      };\n    }\n    watchers[key2].watchers.push(this);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.eval = function(script, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.evalsha = function(sha1, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.script_exists = function(script, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.script_flush = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.script_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.script_load = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.auth = function(password, callback) {\n    if (!redismock.password) {\n      return cb(callback)(new Error(\"ERR Client sent AUTH, but no password is set\"));\n    }\n    if (password === redismock.password) {\n      return cb(callback)(null, \"OK\");\n    }\n    return cb(callback)(new Error(\"ERR invalid password\"));\n  };\n  redismock.echo = function(message, callback) {\n    return cb(callback)(null, message);\n  };\n  redismock.ping = function(callback) {\n    return cb(callback)(null, \"PONG\");\n  };\n  redismock.quit = function(callback) {\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.select = function(index, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.createClient = function() {\n    return redismock.copy();\n  };\n  redismock.bgrewriteaof = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.bgsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.client_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.client_list = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.client_getname = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.client_pause = function(timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.client_setname = function(connection_name, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.cluster_slots = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.command = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.command_count = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.command_getkeys = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.command_info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.config_get = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.config_rewrite = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.config_set = function(parameter, value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.config_resetstat = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.dbsize = function(callback) {\n    var count = 0, key2;\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    return cb(callback)(null, count);\n  };\n  redismock.debug_object = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.debug_segfault = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.flushall = function(callback) {\n    return this.flushdb(callback);\n  };\n  redismock.flushdb = function(callback) {\n    cache = {};\n    cache[sets] = {};\n    cache[zsets] = {};\n    cache[hashes] = {};\n    Object.keys(timeouts).forEach(function(key2) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n    });\n    timeouts = {};\n    return cb(callback)(null, \"OK\");\n  };\n  redismock.info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.lastsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.monitor = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.role = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.save = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.shutdown = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.slaveof = function(host, port, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.slowlog = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.sync = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock.time = function(callback) {\n    var now = /* @__PURE__ */ new Date();\n    var epoch = now.getTime();\n    var us;\n    if (root.performance) {\n      if (root.performance.now) {\n        now = root.performance.now();\n        us = (now - Math.floor(now)) * 1e5;\n      } else if (root.performance.webkitNow) {\n        now = root.performance.webkitNow();\n        us = (now - Math.floor(now)) * 1e5;\n      } else {\n        us = 0;\n      }\n    } else if (typeof process !== \"undefined\" && process.hrtime) {\n      us = process.hrtime()[1] / 1e3;\n    } else {\n      us = 0;\n    }\n    return cb(callback)(null, [epoch, us]);\n  };\n  var modifiers = [\"del\", \"mset\", \"msetnx\", \"psetex\", \"set\", \"setbit\", \"setex\", \"setrange\", \"incr\", \"decr\", \"incrby\", \"decrby\", \"incrbyfloat\", \"blpop\", \"brpop\", \"brpoplpush\", \"linsert\", \"lpush\", \"lpushx\", \"rpush\", \"rpushx\", \"lpop\", \"rpop\", \"rpoplpush\", \"ltrim\", \"lset\", \"lrem\", \"sadd\", \"smove\", \"spop\", \"sdiffstore\", \"sinterstore\", \"srem\", \"sunionstore\", \"zadd\", \"zrem\", \"zunionstore\", \"zinterstore\", \"zincrby\", \"zremrangebylex\", \"zremrangebyrank\", \"zremrangebyscore\", \"hdel\", \"hincrby\", \"hincrbyfloat\", \"hset\", \"hmset\", \"hsetnx\"];\n  var capture = {};\n  var fkeys = [];\n  for (var key in redismock) {\n    if (typeof redismock[key] === \"function\") {\n      fkeys.push(key);\n      capture[key] = redismock[key];\n    }\n  }\n  fkeys.forEach(function(key2) {\n    redismock[key2] = function() {\n      if (arguments.length < capture[key2].length - 1) {\n        return cb(arguments[arguments.length - 1])(new Error(\"ERR wrong number of arguments for '\" + key2 + \"' command\"));\n      }\n      return capture[key2].apply(this, arguments);\n    };\n  });\n  modifiers.forEach(function(modifier) {\n    var mod = redismock[modifier];\n    redismock[modifier] = function() {\n      var key2 = arguments[0];\n      if (exists(watchers[key2])) {\n        watchers[key2].modified = true;\n      }\n      return mod.apply(this, arguments);\n    };\n  });\n  function toPromise(f, context, deferFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      var deferred = deferFactory(), promise;\n      var callback;\n      while (args.length < f.length - 1) {\n        args.push(void 0);\n      }\n      if (typeof args[args.length - 1] === \"function\") {\n        callback = args[args.length - 1];\n        args.pop();\n      }\n      args.push(function(err, reply) {\n        if (err) {\n          if (callback && typeof callback === \"function\") {\n            callback(err);\n          }\n          return deferred.reject(err);\n        }\n        if (callback && typeof callback === \"function\") {\n          callback(null, reply);\n        }\n        deferred.resolve(reply);\n      });\n      f.apply(context, args);\n      promise = deferred.promise;\n      if (typeof promise === \"function\") {\n        promise = promise();\n      }\n      return promise;\n    };\n  }\n  redismock.toPromiseStyle = function(deferFactory) {\n    var that = this;\n    return Object.keys(this).filter(function(key2) {\n      return typeof that[key2] === \"function\" && key2 !== \"multi\";\n    }).map(function(key2) {\n      return [key2, toPromise(that[key2], that, deferFactory)];\n    }).reduce(function(promised, f) {\n      promised[f[0]] = f[1];\n      return promised;\n    }, { multi: this.multi });\n  };\n  redismock.copy = function() {\n    var copied = {};\n    fkeys.forEach(function(key2) {\n      copied[key2] = function() {\n        return redismock[key2].apply(copied, arguments);\n      };\n    });\n    copied.toPromiseStyle = redismock.toPromiseStyle;\n    copied.listeners = {};\n    return copied;\n  };\n  redismock.unref = function() {\n  };\n  if (typeof process !== \"undefined\" && process.env.REDIS_JS_TO_NODE_REDIS === \"1\") {\n    var asNodeRedis;\n    var node_redis_args = [];\n    if (process.env.REDIS_JS_NODE_REDIS_PORT) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_PORT);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_HOST) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_HOST);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_OPTIONS) {\n      node_redis_args.push(JSON.parse(process.env.REDIS_JS_NODE_REDIS_OPTIONS));\n    }\n  }\n}).call(this);\n\n\n//# sourceURL=webpack://HyphaCore/./src/utils/redis-mock.js?");

/***/ }),

/***/ "./src/workspace.js":
/*!**************************!*\
  !*** ./src/workspace.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Workspace: () => (/* binding */ Workspace)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\nconst _allowedCharacters = /^[a-zA-Z0-9-_/*]*$/;\nfunction validateKeyPart(keyPart) {\n  if (!_allowedCharacters.test(keyPart)) {\n    throw new Error(`Invalid characters in query part: ${keyPart}`);\n  }\n}\nconst _Workspace = class {\n  constructor(hyphaCore) {\n    this._server = hyphaCore;\n    this._redis = hyphaCore.redis;\n    this.connections = hyphaCore.connections;\n    this.eventBus = hyphaCore;\n    this.serverUrl = hyphaCore.url;\n    this.baseUrl = hyphaCore.baseUrl;\n  }\n  waitForClient(cid, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        const ccid = info.id.split(\":\")[0];\n        if (ccid !== cid) {\n          return;\n        }\n        this.eventBus.off(\"service_added\", handler);\n        if (info.type === \"imjoy\") {\n          clearTimeout(timeoutId);\n          resolve(info);\n          return;\n        } else {\n          if (!info.id.endsWith(\":default\")) {\n            logger.error(\"Unexpected service added:\", info);\n            return;\n          }\n          const defaultService = info;\n          clearTimeout(timeoutId);\n          this._rpc.get_remote_service(defaultService.id).then((svc) => __async(this, null, function* () {\n            try {\n              yield this.eventBus.emit(\"client_ready\", svc);\n              resolve(svc);\n            } catch (e) {\n              reject(e);\n            }\n          }));\n        }\n      };\n      let timeoutId = setTimeout(() => {\n        this.eventBus.off(\"service_added\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"service_added\", handler);\n    });\n  }\n  setup(config) {\n    return __async(this, null, function* () {\n      if (!config.client_id) {\n        throw new Error(\"client_id is required in the config\");\n      }\n      const workspace = \"*\";\n      const connection = new _utils__WEBPACK_IMPORTED_MODULE_0__.RedisRPCConnection(\n        this.eventBus,\n        workspace,\n        config.client_id,\n        null,\n        null\n      );\n      this.windows = [];\n      this.services = {};\n      this.plugins = {};\n      this.eventBus.on(\"client_ready\", (svc) => __async(this, null, function* () {\n        this.plugins[svc.id] = svc;\n      }));\n      const rpc = new hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.RPC(connection, {\n        client_id: config.client_id,\n        default_context: { connection_type: \"websocket\" },\n        workspace,\n        server_base_url: this.serverUrl,\n        silent: false\n      });\n      this._rpc = rpc;\n      const defaultServices = this.getDefaultService();\n      yield rpc.register_service(Object.assign(defaultServices, config.default_service || {}), { notify: false });\n    });\n  }\n  registerService(service2, context) {\n    return __async(this, null, function* () {\n      const ws = context.ws;\n      const clientId2 = context.from;\n      service2.config = service2.config || {};\n      service2.config.workspace = ws;\n      if (!service2.id.includes(\"/\")) {\n        service2.id = `${ws}/${service2.id}`;\n      }\n      if (!service2.id.includes(\":\")) {\n        throw new Error(\"Service id info must contain ':'\");\n      }\n      service2.app_id = service2.app_id || \"*\";\n      service2.config.visibility = service2.config.visibility || \"protected\";\n      const serviceExists = this._redis.exists(`services:*:${service2.id}@${service2.app_id}`);\n      const key = `services:${service2.config.visibility}:${service2.id}@${service2.app_id}`;\n      for (const [k, v] of Object.entries(service2)) {\n        this._redis.hset(key, k, v);\n      }\n      if (serviceExists) {\n        if (key.includes(\":built-in@\")) {\n          this.eventBus.emit(\"client_updated\", { id: clientId2, workspace: ws });\n          console.info(`Updating built-in service: ${service2.id}`);\n        } else {\n          this.eventBus.emit(\"service_updated\", service2);\n          console.info(`Updating service: ${service2.id}`);\n        }\n      } else {\n        if (key.includes(\":default@\")) {\n          try {\n            const svc = yield this._rpc.get_remote_service(`${clientId2}:default`);\n            if (svc.setup) {\n              yield svc.setup();\n            }\n          } catch (e) {\n            console.error(`Failed to run setup for default service \\`${clientId2}\\`: ${e}`);\n          }\n        }\n        if (key.includes(\":built-in@\")) {\n          this.eventBus.emit(\"client_connected\", { id: clientId2, workspace: ws });\n          console.info(`Adding built-in service: ${service2.id}, key: ${key}`);\n        } else {\n          this.eventBus.emit(\"service_added\", service2);\n          console.info(`Adding service ${service2.id}, key: ${key}`);\n        }\n      }\n    });\n  }\n  unregisterService(serviceId, context) {\n    return __async(this, null, function* () {\n      const ws = context.ws;\n      if (!serviceId.includes(\"/\")) {\n        serviceId = `${ws}/${serviceId}`;\n      }\n      if (!serviceId.includes(\":\")) {\n        throw new Error(\"Service id info must contain ':'\");\n      }\n      if (!serviceId.includes(\"@\")) {\n        serviceId = serviceId + \"@*\";\n      }\n      const key = `services:*:${serviceId}`;\n      console.info(`Removing service: ${key}`);\n      const serviceExists = this._redis.exists(key);\n      if (serviceExists) {\n        this._redis.delete(key);\n        if (key.includes(\":built-in@\")) {\n          this.eventBus.emit(\"client_disconnected\", { id: clientId, workspace: ws });\n        } else {\n          this.eventBus.emit(\"service_removed\", service);\n        }\n      } else {\n        console.warning(`Service ${key} does not exist and cannot be removed.`);\n      }\n    });\n  }\n  getService(_0, _1, _2) {\n    return __async(this, arguments, function* (query, { mode = \"default\", skipTimeout = false, timeout = 5 }, context) {\n      const ws = context.ws;\n      const userInfo = context.user;\n      let serviceId;\n      if (typeof query === \"string\") {\n        serviceId = query;\n        query = { id: serviceId };\n      } else {\n        if (!query.id) {\n          serviceId = query.service_id || \"*\";\n        } else {\n          serviceId = query.id;\n        }\n      }\n      if (typeof serviceId !== \"string\") {\n        throw new Error(\"Service ID must be a string\");\n      }\n      if ((serviceId.match(/\\//g) || []).length > 1) {\n        throw new Error(\"Service id must contain at most one '/'\");\n      }\n      if ((serviceId.match(/:/g) || []).length > 1) {\n        throw new Error(\"Service id must contain at most one ':'\");\n      }\n      if ((serviceId.match(/@/g) || []).length > 1) {\n        throw new Error(\"Service id must contain at most one '@'\");\n      }\n      if (serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n        serviceId += \":default\";\n        query.workspace = serviceId.split(\"/\")[0];\n        if (query.client_id && query.client_id !== serviceId.split(\"/\")[1]) {\n          throw new Error(`client_id (${query.client_id}) does not match service_id (${serviceId})`);\n        }\n        query.client_id = serviceId.split(\"/\")[1];\n      } else if (!serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n        const workspace = query.workspace || \"*\";\n        serviceId = `${workspace}/*:${serviceId}`;\n        query.workspace = workspace;\n        query.client_id = \"*\";\n      } else if (!serviceId.includes(\"/\") && serviceId.includes(\":\")) {\n        const workspace = query.workspace || ws;\n        query.client_id = serviceId.split(\":\")[0];\n        serviceId = `${workspace}/${serviceId}`;\n        query.workspace = workspace;\n      } else {\n        const workspace = serviceId.split(\"/\")[0];\n        query.client_id = serviceId.split(\"/\")[1].split(\":\")[0];\n        query.workspace = workspace;\n        if (!serviceId.includes(\"*\")) {\n          const serviceApi = yield this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          } else {\n            return null;\n          }\n        }\n      }\n      let appId = \"*\";\n      if (serviceId.includes(\"@\")) {\n        [serviceId, appId] = serviceId.split(\"@\");\n        if (query.app_id && query.app_id !== appId) {\n          throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n        }\n      }\n      query.app_id = query.app_id || appId;\n      query.service_id = serviceId.split(\"/\")[1].split(\":\")[1];\n      console.info(\"Getting service:\", query);\n      const originalVisibility = query.visibility || \"*\";\n      let visibility;\n      if (query.workspace === \"*\") {\n        visibility = \"public\";\n      } else {\n        visibility = \"*\";\n      }\n      const pattern = `services:${visibility}:${query.workspace}/${query.client_id}:${query.service_id}@${query.app_id}`;\n      if (!pattern.startsWith(\"services:\")) {\n        throw new Error(\"Query pattern does not start with 'services:'.\");\n      }\n      if (pattern.includes(\"{\") || pattern.includes(\"}\")) {\n        throw new Error(\"Query pattern contains invalid characters.\");\n      }\n      console.debug(\"Query services using pattern:\", pattern);\n      const keys = this._redis.keys(pattern);\n      if (query.workspace === \"*\") {\n        const wsPattern = `services:${originalVisibility}:${ws}/${query.client_id}:${query.service_id}@${query.app_id}`;\n        keys.push(...this._redis.keys(wsPattern));\n      }\n      console.debug(\"Found service keys:\", keys);\n      const withinWorkspaceKeys = [];\n      const outsideWorkspaceKeys = [];\n      keys.forEach((key) => {\n        const keyWorkspace = key.split(\"/\")[1];\n        if (keyWorkspace === ws) {\n          withinWorkspaceKeys.push(key);\n        } else {\n          outsideWorkspaceKeys.push(key);\n        }\n      });\n      if (mode === \"random\") {\n        withinWorkspaceKeys.sort(() => Math.random() - 0.5);\n        outsideWorkspaceKeys.sort(() => Math.random() - 0.5);\n      } else {\n        withinWorkspaceKeys.sort();\n        outsideWorkspaceKeys.sort();\n      }\n      const sortedKeys = [...withinWorkspaceKeys, ...outsideWorkspaceKeys];\n      for (const key of sortedKeys) {\n        try {\n          const parts = key.split(\":\");\n          serviceId = parts[2] + \":\" + parts[3];\n          [serviceId, appId] = serviceId.split(\"@\");\n          const workspace = serviceId.split(\"/\")[0];\n          const serviceApi = yield this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        } catch (e) {\n          if (skipTimeout && e instanceof TimeoutError) {\n            console.warning(`Timeout while getting service ${serviceId}, skipping to the next one.`);\n            continue;\n          } else {\n            throw new Error(`Timeout while getting service ${serviceId}`);\n          }\n        }\n      }\n      if (query.app_id && query.app_id !== \"*\") {\n        const serviceApi = yield this._launch_application_for_service(query, context);\n        return serviceApi;\n      }\n      return null;\n    });\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    return serviceApi;\n  }\n  listServices(query, context) {\n    return __async(this, null, function* () {\n      if (!context) {\n        throw new Error(\"context is required\");\n      }\n      const cws = context.ws;\n      const userInfo = context.user;\n      if (!query) {\n        query = {\n          visibility: \"*\",\n          workspace: cws,\n          client_id: \"*\",\n          service_id: \"*\"\n        };\n      } else if (typeof query === \"string\") {\n        let visibility2 = \"*\";\n        let workspace2 = \"*\";\n        let clientId3 = \"*\";\n        let serviceId2 = \"*\";\n        if (query.includes(\"/\") && query.includes(\":\")) {\n          const [workspacePart, remaining] = query.split(\"/\");\n          const [clientPart, servicePart] = remaining.split(\":\");\n          workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n          clientId3 = clientPart;\n          serviceId2 = servicePart || \"*\";\n          query = { visibility: visibility2, workspace: workspace2, client_id: clientId3, service_id: serviceId2 };\n        } else if (query.includes(\":\")) {\n          const [clientPart, servicePart] = query.split(\":\");\n          clientId3 = clientPart;\n          serviceId2 = servicePart || \"*\";\n          query = { visibility: visibility2, workspace: workspace2, client_id: clientId3, service_id: serviceId2 };\n        } else if (query.includes(\"/\")) {\n          const [workspacePart, servicePart] = query.split(\"/\");\n          workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n          serviceId2 = servicePart || \"*\";\n          query = { visibility: visibility2, workspace: workspace2, client_id: clientId3, service_id: serviceId2 };\n        } else {\n          workspace2 = query;\n          query = { visibility: visibility2, workspace: workspace2, client_id: clientId3, service_id: serviceId2 };\n        }\n      } else {\n        if (query.id) {\n          if (query.service_id) {\n            throw new Error(\"Cannot specify both 'id' and 'service_id' in the query.\");\n          }\n          query.service_id = query.id;\n          delete query.id;\n        }\n      }\n      const originalVisibility = query.visibility || \"*\";\n      const workspace = query.workspace || \"*\";\n      if (workspace === \"*\") {\n        if (originalVisibility === \"protected\") {\n          throw new Error(\"Cannot list protected services in all workspaces.\");\n        }\n        query.visibility = \"public\";\n      } else if (workspace !== \"public\" && workspace !== cws) {\n      }\n      const visibility = query.visibility || \"*\";\n      const clientId2 = query.client_id || \"*\";\n      const serviceId = query.service_id || \"*\";\n      const typeFilter = query.type || null;\n      let appId = \"*\";\n      if (serviceId.includes(\"@\")) {\n        [serviceId, appId] = serviceId.split(\"@\");\n        if (query.app_id && query.app_id !== appId) {\n          throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n        }\n      }\n      appId = query.app_id || appId;\n      const allowedKeys = [\"visibility\", \"workspace\", \"client_id\", \"service_id\", \"type\", \"app_id\"];\n      if (Object.keys(query).some((key) => !allowedKeys.includes(key))) {\n        console.error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n        throw new Error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n      }\n      validateKeyPart(visibility);\n      validateKeyPart(workspace);\n      validateKeyPart(clientId2);\n      validateKeyPart(serviceId);\n      validateKeyPart(appId);\n      const pattern = `services:${visibility}:${workspace}/${clientId2}:${serviceId}@${appId}`;\n      if (!pattern.startsWith(\"services:\")) {\n        throw new Error(\"Query pattern does not start with 'services:'.\");\n      }\n      console.log(\"Listing services using pattern:\", pattern);\n      const keys = this._redis.keys(pattern);\n      if (workspace === \"*\") {\n        const wsPattern = `services:${originalVisibility}:${cws}/${clientId2}:${serviceId}@${appId}`;\n        keys.push(...this._redis.keys(wsPattern));\n        console.log(\"Listing more services using pattern:\", wsPattern);\n      }\n      const services = [];\n      for (const key of new Set(keys)) {\n        const serviceData = this._redis.hgetall(key);\n        const convertedServiceData = {};\n        for (const [k, v] of Object.entries(serviceData)) {\n          const keyStr = k;\n          let valueStr = v;\n          if (typeof valueStr === \"string\" && (valueStr.startsWith(\"{\") && valueStr.endsWith(\"}\") || valueStr.startsWith(\"[\") && valueStr.endsWith(\"]\"))) {\n            valueStr = JSON.parse(valueStr);\n          }\n          convertedServiceData[keyStr] = valueStr;\n        }\n        if (typeFilter) {\n          if (convertedServiceData.type === typeFilter) {\n            services.push(convertedServiceData);\n          }\n        } else {\n          services.push(convertedServiceData);\n        }\n      }\n      return services;\n    });\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    return serviceApi;\n  }\n  createWindow(config, extra_config, context) {\n    return __async(this, null, function* () {\n      let elem;\n      const ws = context.ws;\n      const clientId2 = \"client-\" + Date.now();\n      this.connections[ws + \"/\" + clientId2] = {\n        id: ws + \"/\" + clientId2,\n        workspace: ws,\n        websocket: null,\n        postMessage: (data) => {\n          elem.contentWindow.postMessage(data);\n        }\n      };\n      if (config.type === \"iframe\") {\n        elem = document.createElement(\"iframe\");\n        elem.src = config.src;\n        elem.id = config.window_id || \"window-\" + Date.now();\n        elem.style.width = config.width || \"100%\";\n        elem.style.height = config.height || \"100%\";\n        elem.style.display = \"none\";\n        document.body.appendChild(elem);\n      } else if (config.window_id) {\n        let count = 0;\n        while (!document.getElementById(config.window_id) && count < 9) {\n          yield new Promise((resolve) => setTimeout(resolve, 500));\n          count++;\n        }\n        elem = document.getElementById(config.window_id);\n        if (!elem) {\n          throw new Error(\"Window element not found: \" + config.window_id);\n        }\n      } else {\n        config.window_id = \"window-\" + Date.now();\n        config.workspace = ws;\n        yield this.eventBus.emit(\"add_window\", config);\n        yield new Promise((resolve) => setTimeout(resolve, 0));\n        let count = 0;\n        while (!document.getElementById(config.window_id) && count < 9) {\n          yield new Promise((resolve) => setTimeout(resolve, 500));\n          count++;\n        }\n        elem = document.getElementById(config.window_id);\n        if (!elem) {\n          throw new Error(`iframe element not found ${config.window_id} in ${9 * 500 / 1e3} s`);\n        }\n      }\n      if (elem.tagName !== \"IFRAME\") {\n        const iframe = document.createElement(\"iframe\");\n        iframe.style.width = config.width || \"100%\";\n        iframe.style.height = config.height || \"100%\";\n        iframe.src = config.src;\n        elem.appendChild(iframe);\n        elem = iframe;\n      }\n      this.connections[ws + \"/\" + clientId2].source = elem.contentWindow;\n      let waitClientPromise;\n      if (!config.passive) {\n        waitClientPromise = this.waitForClient(ws + \"/\" + clientId2, 18e4);\n      }\n      yield new Promise((resolve, reject) => {\n        elem.onload = resolve;\n        elem.onerror = reject;\n      });\n      if (config.passive) {\n        delete this.connections[ws + \"/\" + clientId2];\n        return;\n      }\n      elem.contentWindow.postMessage({\n        type: \"initializeHyphaClient\",\n        server_url: this.serverUrl,\n        client_id: clientId2,\n        workspace: ws,\n        config\n      });\n      const svc = yield waitClientPromise;\n      if (svc.setup) {\n        yield svc.setup();\n      }\n      if (svc.run && config) {\n        yield svc.run({ data: config.data, config: config.config });\n      }\n      this.windows.push({ id: config.window_id, name: config.name || config.src, service: svc });\n      return svc;\n    });\n  }\n  getWindow(config, context) {\n    return __async(this, null, function* () {\n      if (typeof config === \"string\") {\n        return this.windows.find((w) => w.name === config);\n      } else if (config.id) {\n        return this.windows.find((w) => w.id === config.id);\n      } else if (config.name) {\n        return this.windows.find((w) => w.name === config.name);\n      }\n    });\n  }\n  loadApp(config, extra_config, context) {\n    return __async(this, null, function* () {\n      let code;\n      const ws = context.ws;\n      const src = config.src;\n      if (src.startsWith(\"http\") && !src.split(\"?\")[0].endsWith(\".imjoy.html\")) {\n        return yield this.createWindow(config, extra_config, context);\n      }\n      if (src.startsWith(\"http\")) {\n        const resp = yield fetch(src);\n        code = yield resp.text();\n      } else if (src.includes(\"\\n\")) {\n        code = src;\n      } else {\n        throw new Error(\"Only local plugins are supported in the workspace manager.\");\n      }\n      config = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.parsePluginCode)(code, {});\n      switch (config.type) {\n        case \"web-worker\":\n          return yield this.createWorker(config, ws, this.baseUrl + \"hypha-app-webworker.js\");\n        case \"window\":\n        case \"iframe\":\n          config.src = this.baseUrl + \"hypha-app-iframe.html\";\n          return yield this.createWindow(config, extra_config, context);\n        case \"web-python\":\n          return yield this.createWorker(config, ws, this.baseUrl + \"hypha-app-webpython.js\");\n        default:\n          throw new Error(\"Unsupported plugin type: \" + config.type);\n      }\n    });\n  }\n  _waitForConnection(conn_id, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        if (info.id === conn_id) {\n          this.eventBus.off(\"connection_ready\", handler);\n          clearTimeout(timeoutId);\n          resolve(info);\n        }\n      };\n      const timeoutId = setTimeout(() => {\n        this.eventBus.off(\"connection_ready\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"connection_ready\", handler);\n    });\n  }\n  createWorker(config, workspace, workerUrl) {\n    return __async(this, null, function* () {\n      const worker = new Worker(workerUrl);\n      const clientId2 = \"client-\" + Date.now();\n      this.connections[workspace + \"/\" + clientId2] = {\n        id: workspace + \"/\" + clientId2,\n        source: worker,\n        workspace,\n        websocket: null,\n        postMessage: (data) => {\n          worker.postMessage(data);\n        }\n      };\n      worker.onmessage = this._server.messageHandler;\n      yield this._waitForConnection(workspace + \"/\" + clientId2, 6e4);\n      worker.postMessage({\n        type: \"initializeHyphaClient\",\n        server_url: this.serverUrl,\n        workspace,\n        client_id: clientId2,\n        config\n      });\n      return yield this.waitForClient(workspace + \"/\" + clientId2, 6e4);\n    });\n  }\n  getApp(config, extra_config, context) {\n    return __async(this, null, function* () {\n      if (typeof config === \"string\") {\n        return yield this.loadApp({ src: config }, {}, context);\n      } else if (config.id) {\n        return this.plugins[config.id];\n      } else if (config.name) {\n        for (const [key, value] of Object.entries(this.plugins)) {\n          if (value.name === config.name) {\n            return value;\n          }\n        }\n      } else {\n        throw new Error(\"Please provide either id or name for the plugin\");\n      }\n    });\n  }\n  getDefaultService() {\n    const service2 = {\n      \"id\": \"default\",\n      \"name\": \"Default workspace management service\",\n      \"description\": \"Services for managing workspace.\",\n      \"config\": {\n        \"require_context\": true,\n        \"visibility\": \"public\"\n      },\n      \"emit\": (type, data, context) => __async(this, null, function* () {\n        const workspaceId = context.ws;\n        yield this.eventBus.emit(type, data);\n      }),\n      \"on\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.on(event, handler);\n      },\n      \"off\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.off(event, handler);\n      },\n      \"echo\": (msg, context) => {\n        return msg;\n      },\n      \"alert\": (msg, context) => {\n        alert(msg);\n      },\n      \"confirm\": (msg, context) => {\n        return confirm(msg);\n      },\n      \"prompt\": (msg, default_value, context) => {\n        return prompt(msg, default_value);\n      },\n      \"show_progress\": (progress, context) => {\n        console.log(\"showProgress\", progress);\n      },\n      \"show_message\": (msg, context) => {\n        console.log(msg);\n      },\n      \"log\": (msg, context) => {\n        console.log(msg);\n      },\n      \"info\": (msg, context) => {\n        console.info(msg);\n      },\n      \"error\": (msg, context) => {\n        console.error(msg);\n      },\n      \"warning\": (msg, context) => {\n        console.warn(msg);\n      },\n      \"critical\": (msg, context) => {\n        console.error(msg);\n      },\n      \"register_service\": (service3, context) => __async(this, null, function* () {\n        const workspaceId = context.ws;\n        const sv = yield this._rpc.get_remote_service(context[\"from\"] + \":built-in\");\n        service3[\"config\"] = service3[\"config\"] || {};\n        service3[\"config\"][\"workspace\"] = workspaceId;\n        service3 = yield sv.register_service(service3);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!service3[\"id\"].includes(\"/\"), \"Service id must not contain '/'\");\n        service3[\"id\"] = workspaceId + \"/\" + service3[\"id\"];\n        return service3;\n      }),\n      \"get_service\": this.getService.bind(this),\n      \"list_services\": this.listServices.bind(this),\n      \"generate_token\": (context) => __async(this, null, function* () {\n        const workspaceId = context.ws;\n        const token = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n        _Workspace.tokens[token] = {\n          \"workspace\": workspaceId\n        };\n        return token;\n      }),\n      \"load_app\": (config, extra_config, context) => __async(this, null, function* () {\n        return this.loadApp(config, extra_config, context);\n      }),\n      \"create_window\": (config, extra_config, context) => __async(this, null, function* () {\n        return this.createWindow(config, extra_config, context);\n      }),\n      \"get_app\": (config, extra_config, context) => __async(this, null, function* () {\n        return this.getApp(config, extra_config, context);\n      }),\n      \"register_service\": (service3, context) => __async(this, null, function* () {\n        return yield this.registerService(service3, context);\n      })\n    };\n    service2.getPlugin = service2.get_app;\n    service2.loadPlugin = service2.load_app;\n    return service2;\n  }\n};\nlet Workspace = _Workspace;\n__publicField(Workspace, \"workspaces\", {});\n__publicField(Workspace, \"tokens\", {});\n__publicField(Workspace, \"clients\", {});\n\n\n//# sourceURL=webpack://HyphaCore/./src/workspace.js?");

/***/ }),

/***/ "./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/rpc.js\":\n/*!********************!*\\\n  !*** ./src/rpc.js ***!\n  \\********************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_667__) => {\n\n__nested_webpack_require_667__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_667__.d(__nested_webpack_exports__, {\n/* harmony export */   API_VERSION: () => (/* binding */ API_VERSION),\n/* harmony export */   RPC: () => (/* binding */ RPC)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_667__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _utils_schema__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_667__(/*! ./utils/schema */ \"./src/utils/schema.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_667__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_667__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\n\n\n\n\nconst API_VERSION = 2;\nconst CHUNK_SIZE = 1024 * 500;\n\nconst ArrayBufferView = Object.getPrototypeOf(\n  Object.getPrototypeOf(new Uint8Array()),\n).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));\n  else if (is.length === 0) return obj;\n  else return indexObject(obj[is[0]], is.slice(1));\n}\n\nfunction _get_schema(obj, name = null, skipContext = false) {\n  if (obj instanceof Object) {\n    let schema = {};\n    for (let k in obj) {\n      schema[k] = _get_schema(obj[k], k, skipContext);\n    }\n    return schema;\n  }\n  if (obj instanceof Array) {\n    return obj.map((v, i) => _get_schema(v, null, skipContext));\n  }\n  if (typeof obj === \"function\") {\n    if (obj.__schema__) {\n      const schema = JSON.parse(JSON.stringify(obj.__schema__));\n      if (name) {\n        schema.name = name;\n        obj.__schema__.name = name;\n      }\n      if (skipContext) {\n        if (schema.parameters && schema.parameters.properties) {\n          delete schema.parameters.properties[\"context\"];\n        }\n      }\n      return { type: \"function\", function: schema };\n    } else {\n      return { type: \"function\" };\n    }\n  } else if (typeof obj === \"number\") {\n    return { type: \"number\" };\n  } else if (typeof obj === \"string\") {\n    return { type: \"string\" };\n  } else if (typeof obj === \"boolean\") {\n    return { type: \"boolean\" };\n  } else if (obj === null) {\n    return { type: \"null\" };\n  } else {\n    return {};\n  }\n}\n\nfunction _annotate_service(service, serviceTypeInfo) {\n  function validateKeys(serviceDict, schemaDict, path = \"root\") {\n    // Validate that all keys in schemaDict exist in serviceDict\n    for (let key in schemaDict) {\n      if (!serviceDict.hasOwnProperty(key)) {\n        throw new Error(`Missing key '${key}' in service at path '${path}'`);\n      }\n    }\n\n    // Check for any unexpected keys in serviceDict\n    for (let key in serviceDict) {\n      if (key !== \"type\" && !schemaDict.hasOwnProperty(key)) {\n        throw new Error(`Unexpected key '${key}' in service at path '${path}'`);\n      }\n    }\n  }\n\n  function annotateRecursive(newService, schemaInfo, path = \"root\") {\n    if (typeof newService === \"object\" && !Array.isArray(newService)) {\n      validateKeys(newService, schemaInfo, path);\n      for (let k in newService) {\n        let v = newService[k];\n        let newPath = `${path}.${k}`;\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n          annotateRecursive(v, schemaInfo[k], newPath);\n        } else if (typeof v === \"function\") {\n          if (schemaInfo.hasOwnProperty(k)) {\n            newService[k] = (0,_utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n              name: schemaInfo[k][\"name\"],\n              description: schemaInfo[k].description || \"\",\n              parameters: schemaInfo[k][\"parameters\"],\n            });\n          } else {\n            throw new Error(\n              `Missing schema for function '${k}' at path '${newPath}'`,\n            );\n          }\n        }\n      }\n    } else if (Array.isArray(newService)) {\n      if (newService.length !== schemaInfo.length) {\n        throw new Error(`Length mismatch at path '${path}'`);\n      }\n      newService.forEach((v, i) => {\n        let newPath = `${path}[${i}]`;\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n          annotateRecursive(v, schemaInfo[i], newPath);\n        } else if (typeof v === \"function\") {\n          if (schemaInfo.hasOwnProperty(i)) {\n            newService[i] = (0,_utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n              name: schemaInfo[i][\"name\"],\n              description: schemaInfo[i].description || \"\",\n              parameters: schemaInfo[i][\"parameters\"],\n            });\n          } else {\n            throw new Error(\n              `Missing schema for function at index ${i} in path '${newPath}'`,\n            );\n          }\n        }\n      });\n    }\n  }\n\n  validateKeys(service, serviceTypeInfo[\"definition\"]);\n  annotateRecursive(service, serviceTypeInfo[\"definition\"]);\n  return service;\n}\n\nfunction getFunctionInfo(func) {\n  const funcString = func.toString();\n\n  // Extract function name\n  const nameMatch = funcString.match(/function\\s*(\\w*)/);\n  const name = (nameMatch && nameMatch[1]) || \"\";\n\n  // Extract function parameters, excluding comments\n  const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n  let params = \"\";\n  if (paramsMatch) {\n    params = paramsMatch[1]\n      .split(\",\")\n      .map((p) =>\n        p\n          .replace(/\\/\\*.*?\\*\\//g, \"\") // Remove block comments\n          .replace(/\\/\\/.*$/g, \"\"),\n      ) // Remove line comments\n      .filter((p) => p.trim().length > 0) // Remove empty strings after removing comments\n      .map((p) => p.trim()) // Trim remaining whitespace\n      .join(\", \");\n  }\n\n  // Extract function docstring (block comment)\n  let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n  const docstringBlock = (docMatch && docMatch[1].trim()) || \"\";\n\n  // Extract function docstring (line comment)\n  docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n  const docstringLine =\n    (docMatch &&\n      docMatch[1]\n        .split(\"\\n\")\n        .map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim())\n        .join(\"\\n\")) ||\n    \"\";\n\n  const docstring = docstringBlock || docstringLine;\n  return (\n    name &&\n    params.length > 0 && {\n      name: name,\n      sig: params,\n      doc: docstring,\n    }\n  );\n}\n\nfunction concatArrayBuffers(buffers) {\n  var buffersLengths = buffers.map(function (b) {\n      return b.byteLength;\n    }),\n    totalBufferlength = buffersLengths.reduce(function (p, c) {\n      return p + c;\n    }, 0),\n    unit8Arr = new Uint8Array(totalBufferlength);\n  buffersLengths.reduce(function (p, c, i) {\n    unit8Arr.set(new Uint8Array(buffers[i]), p);\n    return p + c;\n  }, 0);\n  return unit8Arr.buffer;\n}\n\nclass Timer {\n  constructor(timeout, callback, args, label) {\n    this._timeout = timeout;\n    this._callback = callback;\n    this._args = args;\n    this._label = label || \"timer\";\n    this._task = null;\n    this.started = false;\n  }\n\n  start() {\n    if (this.started) {\n      this.reset();\n    } else {\n      this._task = setTimeout(() => {\n        this._callback.apply(this, this._args);\n      }, this._timeout * 1000);\n      this.started = true;\n    }\n  }\n\n  clear() {\n    if (this._task && this.started) {\n      clearTimeout(this._task);\n      this._task = null;\n      this.started = false;\n    } else {\n      console.warn(`Clearing a timer (${this._label}) which is not started`);\n    }\n  }\n\n  reset() {\n    if (this._task) {\n      clearTimeout(this._task);\n    }\n    this._task = setTimeout(() => {\n      this._callback.apply(this, this._args);\n    }, this._timeout * 1000);\n    this.started = true;\n  }\n}\n\nclass RemoteService extends Object {}\n\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\nclass RPC extends _utils__WEBPACK_IMPORTED_MODULE_0__.MessageEmitter {\n  constructor(\n    connection,\n    {\n      client_id = null,\n      default_context = null,\n      name = null,\n      codecs = null,\n      method_timeout = null,\n      max_message_buffer_size = 0,\n      debug = false,\n      workspace = null,\n      silent = false,\n      app_id = null,\n      server_base_url = null,\n    },\n  ) {\n    super(debug);\n    this._codecs = codecs || {};\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id && typeof client_id === \"string\");\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id, \"client_id is required\");\n    this._client_id = client_id;\n    this._name = name;\n    this._app_id = app_id || \"*\";\n    this._local_workspace = workspace;\n    this._silent = silent;\n    this.default_context = default_context || {};\n    this._method_annotations = new WeakMap();\n    this._max_message_buffer_size = max_message_buffer_size;\n    this._chunk_store = {};\n    this._method_timeout = method_timeout || 30;\n    this._server_base_url = server_base_url;\n\n    // make sure there is an execute function\n    this._services = {};\n    this._object_store = {\n      services: this._services,\n    };\n\n    if (connection) {\n      this.add_service({\n        id: \"built-in\",\n        type: \"built-in\",\n        name: `Built-in services for ${this._local_workspace}/${this._client_id}`,\n        config: {\n          require_context: true,\n          visibility: \"public\",\n          api_version: API_VERSION,\n        },\n        ping: this._ping.bind(this),\n        get_service: this.get_local_service.bind(this),\n        message_cache: {\n          create: this._create_message.bind(this),\n          append: this._append_message.bind(this),\n          process: this._process_message.bind(this),\n          remove: this._remove_message.bind(this),\n        },\n      });\n      this.on(\"method\", this._handle_method.bind(this));\n      this.on(\"error\", console.error);\n\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(connection.emit_message && connection.on_message);\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        connection.manager_id !== undefined,\n        \"Connection must have manager_id\",\n      );\n      this._emit_message = connection.emit_message.bind(connection);\n      connection.on_message(this._on_message.bind(this));\n      this._connection = connection;\n      const onConnected = async (connectionInfo) => {\n        if (!this._silent && this._connection.manager_id) {\n          console.debug(\"Connection established, reporting services...\");\n          const manager = await this.get_manager_service({\n            timeout: 10,\n            case_conversion: \"camel\",\n          });\n          for (let service of Object.values(this._services)) {\n            const serviceInfo = this._extract_service_info(service);\n            await manager.registerService(serviceInfo);\n          }\n        } else {\n          // console.debug(\"Connection established\", connectionInfo);\n        }\n        if (connectionInfo) {\n          if (connectionInfo.public_base_url) {\n            this._server_base_url = connectionInfo.public_base_url;\n          }\n          this._fire(\"connected\", connectionInfo);\n        }\n      };\n      connection.on_connected(onConnected);\n      onConnected();\n    } else {\n      this._emit_message = function () {\n        console.log(\"No connection to emit message\");\n      };\n    }\n  }\n\n  register_codec(config) {\n    if (!config[\"name\"] || (!config[\"encoder\"] && !config[\"decoder\"])) {\n      throw new Error(\n        \"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\",\n      );\n    } else {\n      if (config.type) {\n        for (let k of Object.keys(this._codecs)) {\n          if (this._codecs[k].type === config.type || k === config.name) {\n            delete this._codecs[k];\n            console.warn(\"Remove duplicated codec: \" + k);\n          }\n        }\n      }\n      this._codecs[config[\"name\"]] = config;\n    }\n  }\n\n  async _ping(msg, context) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(msg == \"ping\");\n    return \"pong\";\n  }\n\n  async ping(client_id, timeout) {\n    let method = this._generate_remote_method({\n      _rserver: this._server_base_url,\n      _rtarget: client_id,\n      _rmethod: \"services.built-in.ping\",\n      _rpromise: true,\n      _rdoc: \"Ping a remote client\",\n    });\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((await method(\"ping\", timeout)) == \"pong\");\n  }\n\n  _create_message(key, heartbeat, overwrite, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    if (!this._object_store[\"message_cache\"]) {\n      this._object_store[\"message_cache\"] = {};\n    }\n    if (!overwrite && this._object_store[\"message_cache\"][key]) {\n      throw new Error(\n        `Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`,\n      );\n    }\n\n    this._object_store[\"message_cache\"][key] = [];\n  }\n\n  _append_message(key, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n    cache[key].push(data);\n  }\n\n  _remove_message(key, context) {\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    delete cache[key];\n  }\n\n  _process_message(key, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!context, \"Context is required\");\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    cache[key] = concatArrayBuffers(cache[key]);\n    // console.debug(`Processing message ${key} (bytes=${cache[key].byteLength})`);\n    let unpacker = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(cache[key]);\n    const { done, value } = unpacker.next();\n    const main = value;\n    // Make sure the fields are from trusted source\n    Object.assign(main, {\n      from: context.from,\n      to: context.to,\n      ws: context.ws,\n      user: context.user,\n    });\n    main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n    Object.assign(main[\"ctx\"], this.default_context);\n    if (!done) {\n      let extra = unpacker.next();\n      Object.assign(main, extra.value);\n    }\n    this._fire(main[\"type\"], main);\n    // console.debug(\n    //   this._client_id,\n    //   `Processed message ${key} (bytes=${cache[key].byteLength})`,\n    // );\n    delete cache[key];\n  }\n\n  _on_message(message) {\n    if (typeof message === \"string\") {\n      const main = JSON.parse(message);\n      this._fire(main[\"type\"], main);\n    } else if (message instanceof ArrayBuffer) {\n      let unpacker = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(message);\n      const { done, value } = unpacker.next();\n      const main = value;\n      // Add trusted context to the method call\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n      if (!done) {\n        let extra = unpacker.next();\n        Object.assign(main, extra.value);\n      }\n      this._fire(main[\"type\"], main);\n    } else if (typeof message === \"object\") {\n      this._fire(message[\"type\"], message);\n    } else {\n      throw new Error(\"Invalid message format\");\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._services = {};\n  }\n\n  async disconnect() {\n    this._fire(\"disconnected\");\n    await this._connection.disconnect();\n  }\n\n  async get_manager_service(config) {\n    config = config || {};\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(this._connection.manager_id, \"Manager id is not set\");\n    const svc = await this.get_remote_service(\n      `*/${this._connection.manager_id}:default`,\n      config,\n    );\n    return svc;\n  }\n\n  get_all_local_services() {\n    return this._services;\n  }\n  get_local_service(service_id, context) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(service_id);\n    const [ws, client_id] = context[\"to\"].split(\"/\");\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      client_id === this._client_id,\n      \"Services can only be accessed locally\",\n    );\n\n    const service = this._services[service_id];\n    if (!service) {\n      throw new Error(\"Service not found: \" + service_id);\n    }\n\n    service.config[\"workspace\"] = context[\"ws\"];\n    // allow access for the same workspace\n    if (service.config.visibility == \"public\") {\n      return service;\n    }\n\n    // allow access for the same workspace\n    if (context[\"ws\"] === ws) {\n      return service;\n    }\n\n    throw new Error(\n      `Permission denied for getting protected service: ${service_id}, workspace mismatch: ${ws} != ${context[\"ws\"]}`,\n    );\n  }\n  async get_remote_service(service_uri, config) {\n    let { timeout, case_conversion, kwargs_expansion } = config || {};\n    timeout = timeout === undefined ? this._method_timeout : timeout;\n    if (!service_uri && this._connection.manager_id) {\n      service_uri = \"*/\" + this._connection.manager_id;\n    } else if (!service_uri.includes(\":\")) {\n      service_uri = this._client_id + \":\" + service_uri;\n    }\n    const provider = service_uri.split(\":\")[0];\n    let service_id = service_uri.split(\":\")[1];\n    if (service_id.includes(\"@\")) {\n      service_id = service_id.split(\"@\")[0];\n      const app_id = service_uri.split(\"@\")[1];\n      if (this._app_id && this._app_id !== \"*\")\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          app_id === this._app_id,\n          `Invalid app id: ${app_id} != ${this._app_id}`,\n        );\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, `Invalid service uri: ${service_uri}`);\n\n    try {\n      const method = this._generate_remote_method({\n        _rserver: this._server_base_url,\n        _rtarget: provider,\n        _rmethod: \"services.built-in.get_service\",\n        _rpromise: true,\n        _rdoc: \"Get a remote service\",\n      });\n      let svc = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.waitFor)(\n        method(service_id),\n        timeout,\n        \"Timeout Error: Failed to get remote service: \" + service_uri,\n      );\n      svc.id = `${provider}:${service_id}`;\n      if (kwargs_expansion) {\n        svc = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.expandKwargs)(svc);\n      }\n      if (case_conversion)\n        return Object.assign(\n          new RemoteService(),\n          (0,_utils__WEBPACK_IMPORTED_MODULE_0__.convertCase)(svc, case_conversion),\n        );\n      else return Object.assign(new RemoteService(), svc);\n    } catch (e) {\n      console.warn(\"Failed to get remote service: \" + service_uri, e);\n      throw e;\n    }\n  }\n  _annotate_service_methods(\n    aObject,\n    object_id,\n    require_context,\n    run_in_executor,\n    visibility,\n  ) {\n    if (typeof aObject === \"function\") {\n      // mark the method as a remote method that requires context\n      let method_name = object_id.split(\".\")[1];\n      this._method_annotations.set(aObject, {\n        require_context: Array.isArray(require_context)\n          ? require_context.includes(method_name)\n          : !!require_context,\n        run_in_executor: run_in_executor,\n        method_id: \"services.\" + object_id,\n        visibility: visibility,\n      });\n    } else if (aObject instanceof Array || aObject instanceof Object) {\n      for (let key of Object.keys(aObject)) {\n        let val = aObject[key];\n        if (typeof val === \"function\" && val.__rpc_object__) {\n          let client_id = val.__rpc_object__._rtarget;\n          if (client_id.includes(\"/\")) {\n            client_id = client_id.split(\"/\")[1];\n          }\n          if (this._client_id === client_id) {\n            if (aObject instanceof Array) {\n              aObject = aObject.slice();\n            }\n            // recover local method\n            aObject[key] = indexObject(\n              this._object_store,\n              val.__rpc_object__._rmethod,\n            );\n            val = aObject[key]; // make sure it's annotated later\n          } else {\n            throw new Error(\n              `Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`,\n            );\n          }\n        }\n        this._annotate_service_methods(\n          val,\n          object_id + \".\" + key,\n          require_context,\n          run_in_executor,\n          visibility,\n        );\n      }\n    }\n  }\n  add_service(api, overwrite) {\n    if (!api || Array.isArray(api)) throw new Error(\"Invalid service object\");\n    if (api.constructor === Object) {\n      api = Object.assign({}, api);\n    } else {\n      const normApi = {};\n      const props = Object.getOwnPropertyNames(api).concat(\n        Object.getOwnPropertyNames(Object.getPrototypeOf(api)),\n      );\n      for (let k of props) {\n        if (k !== \"constructor\") {\n          if (typeof api[k] === \"function\") normApi[k] = api[k].bind(api);\n          else normApi[k] = api[k];\n        }\n      }\n      // For class instance, we need set a default id\n      api.id = api.id || \"default\";\n      api = normApi;\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      api.id && typeof api.id === \"string\",\n      `Service id not found: ${api}`,\n    );\n    if (!api.name) {\n      api.name = api.id;\n    }\n    if (!api.config) {\n      api.config = {};\n    }\n    if (!api.type) {\n      api.type = \"generic\";\n    }\n    // require_context only applies to the top-level functions\n    let require_context = false,\n      run_in_executor = false;\n    if (api.config.require_context)\n      require_context = api.config.require_context;\n    if (api.config.run_in_executor) run_in_executor = true;\n    const visibility = api.config.visibility || \"protected\";\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)([\"protected\", \"public\"].includes(visibility));\n    this._annotate_service_methods(\n      api,\n      api[\"id\"],\n      require_context,\n      run_in_executor,\n      visibility,\n    );\n\n    if (this._services[api.id]) {\n      if (overwrite) {\n        delete this._services[api.id];\n      } else {\n        throw new Error(\n          `Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`,\n        );\n      }\n    }\n    this._services[api.id] = api;\n    return api;\n  }\n\n  _extract_service_info(service) {\n    const config = service.config || {};\n    config.workspace =\n      config.workspace || this._local_workspace || this._connection.workspace;\n    const skipContext = config.require_context;\n    const serviceSchema = _get_schema(service, null, skipContext);\n    const serviceInfo = {\n      config: config,\n      id: `${config.workspace}/${this._client_id}:${service[\"id\"]}`,\n      name: service.name || service[\"id\"],\n      description: service.description || \"\",\n      type: service.type || \"generic\",\n      docs: service.docs || null,\n      app_id: this._app_id,\n      service_schema: serviceSchema,\n    };\n    return serviceInfo;\n  }\n\n  async get_service_schema(service) {\n    const skipContext = service.config.require_context;\n    return _get_schema(service, null, skipContext);\n  }\n\n  async register_service(api, config) {\n    let { check_type, notify, overwrite } = config || {};\n    notify = notify === undefined ? true : notify;\n    let manager;\n    if (check_type && api.type) {\n      try {\n        manager = await this.get_manager_service({\n          timeout: 10,\n          case_conversion: \"camel\",\n        });\n        const type_info = await manager.get_service_type(api.type);\n        api = _annotate_service(api, type_info);\n      } catch (e) {\n        throw new Error(`Failed to get service type ${api.type}, error: ${e}`);\n      }\n    }\n\n    const service = this.add_service(api, overwrite);\n    const serviceInfo = this._extract_service_info(service);\n    if (notify) {\n      try {\n        manager =\n          manager ||\n          (await this.get_manager_service({\n            timeout: 10,\n            case_conversion: \"camel\",\n          }));\n        await manager.registerService(serviceInfo);\n      } catch (e) {\n        throw new Error(`Failed to notify workspace manager: ${e}`);\n      }\n    }\n    return serviceInfo;\n  }\n\n  async unregister_service(service, notify) {\n    notify = notify === undefined ? true : notify;\n    let service_id;\n    if (typeof service === \"string\") {\n      service_id = service;\n    } else {\n      service_id = service.id;\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      service_id && typeof service_id === \"string\",\n      `Invalid service id: ${service_id}`,\n    );\n    if (service_id.includes(\":\")) {\n      service_id = service_id.split(\":\")[1];\n    }\n    if (service_id.includes(\"@\")) {\n      service_id = service_id.split(\"@\")[0];\n    }\n    if (!this._services[service_id]) {\n      throw new Error(`Service not found: ${service_id}`);\n    }\n    if (notify) {\n      const manager = await this.get_manager_service({\n        timeout: 10,\n        case_conversion: \"camel\",\n      });\n      await manager.unregisterService(service_id);\n    }\n    delete this._services[service_id];\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(typedArray);\n    if (dtype && dtype !== _dtype) {\n      throw (\n        \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype\n      );\n    }\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype,\n    };\n  }\n\n  _encode_callback(\n    name,\n    callback,\n    session_id,\n    clear_after_called,\n    timer,\n    local_workspace,\n    description,\n  ) {\n    let method_id = `${session_id}.${name}`;\n    let encoded = {\n      _rtype: \"method\",\n      _rtarget: local_workspace\n        ? `${local_workspace}/${this._client_id}`\n        : this._client_id,\n      _rmethod: method_id,\n      _rpromise: false,\n    };\n\n    const self = this;\n    let wrapped_callback = function () {\n      try {\n        callback.apply(null, Array.prototype.slice.call(arguments));\n      } catch (error) {\n        console.error(\n          `Error in callback(${method_id}, ${description}): ${error}`,\n        );\n      } finally {\n        if (timer && timer.started) {\n          timer.clear();\n        }\n        if (clear_after_called && self._object_store[session_id]) {\n          // console.log(\"Deleting session\", session_id, \"from\", self._client_id);\n          delete self._object_store[session_id];\n        }\n      }\n    };\n    wrapped_callback.__name__ = `callback(${method_id})`;\n    return [encoded, wrapped_callback];\n  }\n\n  async _encode_promise(\n    resolve,\n    reject,\n    session_id,\n    clear_after_called,\n    timer,\n    local_workspace,\n    description,\n  ) {\n    let store = this._get_session_store(session_id, true);\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      store,\n      `Failed to create session store ${session_id} due to invalid parent`,\n    );\n    let encoded = {};\n\n    if (timer && reject && this._method_timeout) {\n      [encoded.heartbeat, store.heartbeat] = this._encode_callback(\n        \"heartbeat\",\n        timer.reset.bind(timer),\n        session_id,\n        false,\n        null,\n        local_workspace,\n        // `heartbeat (${description})`,\n      );\n      store.timer = timer;\n      encoded.interval = this._method_timeout / 2;\n    } else {\n      timer = null;\n    }\n\n    [encoded.resolve, store.resolve] = this._encode_callback(\n      \"resolve\",\n      resolve,\n      session_id,\n      clear_after_called,\n      timer,\n      local_workspace,\n      `resolve (${description})`,\n    );\n    [encoded.reject, store.reject] = this._encode_callback(\n      \"reject\",\n      reject,\n      session_id,\n      clear_after_called,\n      timer,\n      local_workspace,\n      `reject (${description})`,\n    );\n    return encoded;\n  }\n\n  async _send_chunks(data, target_id, session_id) {\n    let remote_services = await this.get_remote_service(\n      `${target_id}:built-in`,\n    );\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      remote_services.message_cache,\n      \"Remote client does not support message caching for long message.\",\n    );\n    let message_cache = remote_services.message_cache;\n    let message_id = session_id || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n    await message_cache.create(message_id, !!session_id);\n    let total_size = data.length;\n    let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n    for (let idx = 0; idx < chunk_num; idx++) {\n      let start_byte = idx * CHUNK_SIZE;\n      await message_cache.append(\n        message_id,\n        data.slice(start_byte, start_byte + CHUNK_SIZE),\n        !!session_id,\n      );\n      // console.debug(\n      //   `Sending chunk ${idx + 1}/${chunk_num} (${total_size} bytes)`,\n      // );\n    }\n    // console.log(`All chunks sent (${chunk_num})`);\n    await message_cache.process(message_id, !!session_id);\n  }\n\n  emit(main_message, extra_data) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      typeof main_message === \"object\" && main_message.type,\n      \"Invalid message, must be an object with a `type` fields.\",\n    );\n    if (!main_message.to) {\n      this._fire(main_message.type, main_message);\n      return;\n    }\n    let message_package = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n    if (extra_data) {\n      const extra = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n      message_package = new Uint8Array([...message_package, ...extra]);\n    }\n    const total_size = message_package.length;\n    if (total_size <= CHUNK_SIZE + 1024) {\n      return this._emit_message(message_package);\n    } else {\n      throw new Error(\"Message is too large to send in one go.\");\n    }\n  }\n\n  _generate_remote_method(\n    encoded_method,\n    remote_parent,\n    local_parent,\n    remote_workspace,\n    local_workspace,\n  ) {\n    let target_id = encoded_method._rtarget;\n    if (remote_workspace && !target_id.includes(\"/\")) {\n      if (remote_workspace !== target_id) {\n        target_id = remote_workspace + \"/\" + target_id;\n      }\n      // Fix the target id to be an absolute id\n      encoded_method._rtarget = target_id;\n    }\n    let method_id = encoded_method._rmethod;\n    let with_promise = encoded_method._rpromise || false;\n    const description = `method: ${method_id}, docs: ${encoded_method._rdoc}`;\n    const self = this;\n\n    function remote_method() {\n      return new Promise(async (resolve, reject) => {\n        let local_session_id = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n        if (local_parent) {\n          // Store the children session under the parent\n          local_session_id = local_parent + \".\" + local_session_id;\n        }\n        let store = self._get_session_store(local_session_id, true);\n        if (!store) {\n          reject(\n            new Error(\n              `Runtime Error: Failed to get session store ${local_session_id} (context: ${description})`,\n            ),\n          );\n          return;\n        }\n        store[\"target_id\"] = target_id;\n        const args = await self._encode(\n          Array.prototype.slice.call(arguments),\n          local_session_id,\n          local_workspace,\n        );\n        const argLength = args.length;\n        // if the last argument is an object, mark it as kwargs\n        const withKwargs =\n          argLength > 0 &&\n          typeof args[argLength - 1] === \"object\" &&\n          args[argLength - 1] !== null &&\n          args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n\n        let from_client;\n        if (!self._local_workspace) {\n          from_client = self._client_id;\n        } else {\n          from_client = self._local_workspace + \"/\" + self._client_id;\n        }\n\n        let main_message = {\n          type: \"method\",\n          from: from_client,\n          to: target_id,\n          method: method_id,\n        };\n        let extra_data = {};\n        if (args) {\n          extra_data[\"args\"] = args;\n        }\n        if (withKwargs) {\n          extra_data[\"with_kwargs\"] = withKwargs;\n        }\n\n        // console.log(\n        //   `Calling remote method ${target_id}:${method_id}, session: ${local_session_id}`\n        // );\n        if (remote_parent) {\n          // Set the parent session\n          // Note: It's a session id for the remote, not the current client\n          main_message[\"parent\"] = remote_parent;\n        }\n\n        let timer = null;\n        if (with_promise) {\n          // Only pass the current session id to the remote\n          // if we want to received the result\n          // I.e. the session id won't be passed for promises themselves\n          main_message[\"session\"] = local_session_id;\n          let method_name = `${target_id}:${method_id}`;\n          timer = new Timer(\n            self._method_timeout,\n            reject,\n            [`Method call time out: ${method_name}, context: ${description}`],\n            method_name,\n          );\n          // By default, hypha will clear the session after the method is called\n          // However, if the args contains _rintf === true, we will not clear the session\n          let clear_after_called = true;\n          for (let arg of args) {\n            if (typeof arg === \"object\" && arg._rintf === true) {\n              clear_after_called = false;\n              break;\n            }\n          }\n          const promiseData = await self._encode_promise(\n            resolve,\n            reject,\n            local_session_id,\n            clear_after_called,\n            timer,\n            local_workspace,\n            description,\n          );\n\n          if (with_promise === true) {\n            extra_data[\"promise\"] = promiseData;\n          } else if (with_promise === \"*\") {\n            extra_data[\"promise\"] = \"*\";\n            extra_data[\"t\"] = self._method_timeout / 2;\n          } else {\n            throw new Error(`Unsupported promise type: ${with_promise}`);\n          }\n        }\n        // The message consists of two segments, the main message and extra data\n        let message_package = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n        if (extra_data) {\n          const extra = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n          message_package = new Uint8Array([...message_package, ...extra]);\n        }\n        const total_size = message_package.length;\n        if (total_size <= CHUNK_SIZE + 1024 || remote_method.__no_chunk__) {\n          self\n            ._emit_message(message_package)\n            .then(function () {\n              if (timer) {\n                // If resolved successfully, reset the timer\n                timer.reset();\n              }\n            })\n            .catch(function (err) {\n              console.error(\"Failed to send message\", err);\n              reject(err);\n              if (timer) {\n                timer.clear();\n              }\n            });\n        } else {\n          // send chunk by chunk\n          self\n            ._send_chunks(message_package, target_id, remote_parent)\n            .then(function () {\n              if (timer) {\n                // If resolved successfully, reset the timer\n                timer.reset();\n              }\n            })\n            .catch(function (err) {\n              console.error(\"Failed to send message\", err);\n              reject(err);\n              if (timer) {\n                timer.clear();\n              }\n            });\n        }\n      });\n    }\n\n    // Generate debugging information for the method\n    remote_method.__rpc_object__ = encoded_method;\n    const parts = method_id.split(\".\");\n    remote_method.__name__ = parts[parts.length - 1];\n    if (remote_method.__name__.includes(\"#\")) {\n      remote_method.__name__ = remote_method.__name__.split(\"#\")[1];\n    }\n    remote_method.__doc__ =\n      encoded_method._rdoc || `Remote method: ${method_id}`;\n    remote_method.__schema__ = encoded_method._rschema;\n    // Prevent circular chunk sending\n    remote_method.__no_chunk__ =\n      encoded_method._rmethod === \"services.built-in.message_cache.append\";\n    return remote_method;\n  }\n\n  get_client_info() {\n    const services = [];\n    for (let service of Object.values(this._services)) {\n      services.push(this._extract_service_info(service));\n    }\n\n    return {\n      id: this._client_id,\n      services: services,\n    };\n  }\n\n  async _handle_method(data) {\n    let reject = null;\n    let heartbeat_task = null;\n    try {\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data.method && data.ctx && data.from);\n      const method_name = data.from + \":\" + data.method;\n      const remote_workspace = data.from.split(\"/\")[0];\n      const remote_client_id = data.from.split(\"/\")[1];\n      // Make sure the target id is an absolute id\n      data[\"to\"] = data[\"to\"].includes(\"/\")\n        ? data[\"to\"]\n        : remote_workspace + \"/\" + data[\"to\"];\n      data[\"ctx\"][\"to\"] = data[\"to\"];\n      let local_workspace;\n      if (!this._local_workspace) {\n        local_workspace = data[\"to\"].split(\"/\")[0];\n      } else {\n        if (this._local_workspace && this._local_workspace !== \"*\") {\n          (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n            data[\"to\"].split(\"/\")[0] === this._local_workspace,\n            \"Workspace mismatch: \" +\n              data[\"to\"].split(\"/\")[0] +\n              \" != \" +\n              this._local_workspace,\n          );\n        }\n        local_workspace = this._local_workspace;\n      }\n      const local_parent = data.parent;\n\n      let resolve, reject;\n      if (data.promise) {\n        // Decode the promise with the remote session id\n        // Such that the session id will be passed to the remote as a parent session id\n        const promise = await this._decode(\n          data.promise === \"*\" ? this._expand_promise(data) : data.promise,\n          data.session,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        resolve = promise.resolve;\n        reject = promise.reject;\n        if (promise.heartbeat && promise.interval) {\n          async function heartbeat() {\n            try {\n              // console.debug(\"Reset heartbeat timer: \" + data.method);\n              await promise.heartbeat();\n            } catch (err) {\n              console.error(err);\n            }\n          }\n          heartbeat_task = setInterval(heartbeat, promise.interval * 1000);\n        }\n      }\n\n      let method;\n\n      try {\n        method = indexObject(this._object_store, data[\"method\"]);\n      } catch (e) {\n        // console.debug(\"Failed to find method\", method_name, this._client_id, e);\n        throw new Error(\n          `Method not found: ${method_name} at ${this._client_id}`,\n        );\n      }\n\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        method && typeof method === \"function\",\n        \"Invalid method: \" + method_name,\n      );\n\n      // Check permission\n      if (this._method_annotations.has(method)) {\n        // For services, it should not be protected\n        if (this._method_annotations.get(method).visibility === \"protected\") {\n          if (\n            local_workspace !== remote_workspace &&\n            (remote_workspace !== \"*\" ||\n              remote_client_id !== this._connection.manager_id)\n          ) {\n            throw new Error(\n              \"Permission denied for invoking protected method \" +\n                method_name +\n                \", workspace mismatch: \" +\n                local_workspace +\n                \" != \" +\n                remote_workspace,\n            );\n          }\n        }\n      } else {\n        // For sessions, the target_id should match exactly\n        let session_target_id =\n          this._object_store[data.method.split(\".\")[0]].target_id;\n        if (\n          local_workspace === remote_workspace &&\n          session_target_id &&\n          session_target_id.indexOf(\"/\") === -1\n        ) {\n          session_target_id = local_workspace + \"/\" + session_target_id;\n        }\n        if (session_target_id !== data.from) {\n          throw new Error(\n            \"Access denied for method call (\" +\n              method_name +\n              \") from \" +\n              data.from +\n              \" to target \" +\n              session_target_id,\n          );\n        }\n      }\n\n      // Make sure the parent session is still open\n      if (local_parent) {\n        // The parent session should be a session that generate the current method call\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          this._get_session_store(local_parent, true) !== null,\n          \"Parent session was closed: \" + local_parent,\n        );\n      }\n      let args;\n      if (data.args) {\n        args = await this._decode(\n          data.args,\n          data.session,\n          null,\n          remote_workspace,\n          null,\n        );\n      } else {\n        args = [];\n      }\n      if (\n        this._method_annotations.has(method) &&\n        this._method_annotations.get(method).require_context\n      ) {\n        // if args.length + 1 is less than the required number of arguments we will pad with undefined\n        // so we make sure the last argument is the context\n        if (args.length + 1 < method.length) {\n          for (let i = args.length; i < method.length - 1; i++) {\n            args.push(undefined);\n          }\n        }\n        args.push(data.ctx);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          args.length === method.length,\n          `Runtime Error: Invalid number of arguments for method ${method_name}, expected ${method.length} but got ${args.length}`,\n        );\n      }\n      // console.debug(`Executing method: ${method_name} (${data.method})`);\n      if (data.promise) {\n        const result = method.apply(null, args);\n        if (result instanceof Promise) {\n          result\n            .then((result) => {\n              resolve(result);\n              clearInterval(heartbeat_task);\n            })\n            .catch((err) => {\n              reject(err);\n              clearInterval(heartbeat_task);\n            });\n        } else {\n          resolve(result);\n          clearInterval(heartbeat_task);\n        }\n      } else {\n        method.apply(null, args);\n        clearInterval(heartbeat_task);\n      }\n    } catch (err) {\n      if (reject) {\n        reject(err);\n        // console.debug(\"Error during calling method: \", err);\n      } else {\n        console.error(\"Error during calling method: \", err);\n      }\n      // make sure we clear the heartbeat timer\n      clearInterval(heartbeat_task);\n    }\n  }\n\n  encode(aObject, session_id) {\n    return this._encode(aObject, session_id);\n  }\n\n  _get_session_store(session_id, create) {\n    let store = this._object_store;\n    const levels = session_id.split(\".\");\n    if (create) {\n      const last_index = levels.length - 1;\n      for (let level of levels.slice(0, last_index)) {\n        if (!store[level]) {\n          return null;\n        }\n        store = store[level];\n      }\n      // Create the last level\n      if (!store[levels[last_index]]) {\n        store[levels[last_index]] = {};\n      }\n      return store[levels[last_index]];\n    } else {\n      for (let level of levels) {\n        if (!store[level]) {\n          return null;\n        }\n        store = store[level];\n      }\n      return store;\n    }\n  }\n\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n  async _encode(aObject, session_id, local_workspace) {\n    const aType = typeof aObject;\n    if (\n      aType === \"number\" ||\n      aType === \"string\" ||\n      aType === \"boolean\" ||\n      aObject === null ||\n      aObject === undefined ||\n      aObject instanceof Uint8Array\n    ) {\n      return aObject;\n    }\n    if (aObject instanceof ArrayBuffer) {\n      return {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject),\n      };\n    }\n    // Reuse the remote object\n    if (aObject.__rpc_object__) {\n      const _server = aObject.__rpc_object__._rserver || this._server_base_url;\n      if (_server === this._server_base_url) {\n        return aObject.__rpc_object__;\n      } // else {\n      //   console.debug(\n      //     `Encoding remote function from a different server ${_server}, current server: ${this._server_base_url}`,\n      //   );\n      // }\n    }\n\n    let bObject;\n\n    // skip if already encoded\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      const temp = aObject._rtype;\n      delete aObject._rtype;\n      bObject = await this._encode(aObject, session_id, local_workspace);\n      bObject._rtype = temp;\n      return bObject;\n    }\n\n    if (typeof aObject === \"function\") {\n      if (this._method_annotations.has(aObject)) {\n        let annotation = this._method_annotations.get(aObject);\n        bObject = {\n          _rtype: \"method\",\n          _rserver: this._server_base_url,\n          _rtarget: this._client_id,\n          _rmethod: annotation.method_id,\n          _rpromise: \"*\",\n        };\n      } else {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof session_id === \"string\");\n        let object_id;\n        if (aObject.__name__) {\n          object_id = `${(0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)()}#${aObject.__name__}`;\n        } else {\n          object_id = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n        }\n        bObject = {\n          _rtype: \"method\",\n          _rserver: this._server_base_url,\n          _rtarget: this._client_id,\n          _rmethod: `${session_id}.${object_id}`,\n          _rpromise: \"*\",\n        };\n        let store = this._get_session_store(session_id, true);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          store !== null,\n          `Failed to create session store ${session_id} due to invalid parent`,\n        );\n        store[object_id] = aObject;\n      }\n      bObject._rdoc = aObject.__doc__;\n      if (!bObject._rdoc) {\n        try {\n          const funcInfo = getFunctionInfo(aObject);\n          if (funcInfo && !bObject._rdoc) {\n            bObject._rdoc = `${funcInfo.doc}`;\n          }\n        } catch (e) {\n          console.error(\"Failed to extract function docstring:\", aObject);\n        }\n      }\n      bObject._rschema = aObject.__schema__;\n      return bObject;\n    }\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name;\n        // encode the functions in the interface object\n        if (typeof encodedObj === \"object\") {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(\n            encodedObj,\n            session_id,\n            local_workspace,\n          );\n          encodedObj._rtype = temp;\n        }\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n      /*global tf*/\n      typeof tf !== \"undefined\" &&\n      tf.Tensor &&\n      aObject instanceof tf.Tensor\n    ) {\n      const v_buffer = aObject.dataSync();\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(v_buffer.buffer),\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype,\n      };\n    } else if (\n      /*global nj*/\n      typeof nj !== \"undefined\" &&\n      nj.NdArray &&\n      aObject instanceof nj.NdArray\n    ) {\n      const dtype = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject.selection.data);\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(aObject.selection.data.buffer),\n        _rshape: aObject.shape,\n        _rdtype: dtype,\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString(),\n        _rtrace: aObject.stack,\n      };\n    }\n    // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (\n      aObject !== Object(aObject) ||\n      aObject instanceof Boolean ||\n      aObject instanceof String ||\n      aObject instanceof Date ||\n      aObject instanceof RegExp ||\n      aObject instanceof ImageData ||\n      (typeof FileList !== \"undefined\" && aObject instanceof FileList) ||\n      (typeof FileSystemDirectoryHandle !== \"undefined\" &&\n        aObject instanceof FileSystemDirectoryHandle) ||\n      (typeof FileSystemFileHandle !== \"undefined\" &&\n        aObject instanceof FileSystemFileHandle) ||\n      (typeof FileSystemHandle !== \"undefined\" &&\n        aObject instanceof FileSystemHandle) ||\n      (typeof FileSystemWritableFileStream !== \"undefined\" &&\n        aObject instanceof FileSystemWritableFileStream)\n    ) {\n      bObject = aObject;\n      // TODO: avoid object such as DynamicPlugin instance.\n    } else if (aObject instanceof Blob) {\n      let _current_pos = 0;\n      async function read(length) {\n        let blob;\n        if (length) {\n          blob = aObject.slice(_current_pos, _current_pos + length);\n        } else {\n          blob = aObject.slice(_current_pos);\n        }\n        const ret = new Uint8Array(await blob.arrayBuffer());\n        _current_pos = _current_pos + ret.byteLength;\n        return ret;\n      }\n      function seek(pos) {\n        _current_pos = pos;\n      }\n      bObject = {\n        _rtype: \"iostream\",\n        _rnative: \"js:blob\",\n        type: aObject.type,\n        name: aObject.name,\n        size: aObject.size,\n        path: aObject._path || aObject.webkitRelativePath,\n        read: await this._encode(read, session_id, local_workspace),\n        seek: await this._encode(seek, session_id, local_workspace),\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      const dtype = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: new Uint8Array(aObject.buffer),\n        _rdtype: dtype,\n      };\n    } else if (aObject instanceof DataView) {\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject.buffer),\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(\n          Array.from(aObject),\n          session_id,\n          local_workspace,\n        ),\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(\n          Array.from(aObject),\n          session_id,\n          local_workspace,\n        ),\n      };\n    } else if (\n      aObject.constructor instanceof Object ||\n      Array.isArray(aObject)\n    ) {\n      bObject = isarray ? [] : {};\n      const keys = Object.keys(aObject);\n      for (let k of keys) {\n        bObject[k] = await this._encode(\n          aObject[k],\n          session_id,\n          local_workspace,\n        );\n      }\n    } else {\n      throw `hypha-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n    return bObject;\n  }\n\n  async decode(aObject) {\n    return await this._decode(aObject);\n  }\n\n  async _decode(\n    aObject,\n    remote_parent,\n    local_parent,\n    remote_workspace,\n    local_workspace,\n  ) {\n    if (!aObject) {\n      return aObject;\n    }\n    let bObject;\n    if (aObject._rtype) {\n      if (\n        this._codecs[aObject._rtype] &&\n        this._codecs[aObject._rtype].decoder\n      ) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        aObject = await this._decode(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        aObject._rtype = temp;\n\n        bObject = await Promise.resolve(\n          this._codecs[aObject._rtype].decoder(aObject),\n        );\n      } else if (aObject._rtype === \"method\") {\n        bObject = this._generate_remote_method(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n          bObject = nj\n            .array(new Uint8(aObject._rvalue), aObject._rdtype)\n            .reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n          const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n          bObject = tf.tensor(\n            new arraytype(aObject._rvalue),\n            aObject._rshape,\n            aObject._rdtype,\n          );\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(\n          \"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"),\n        );\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n        if (!arraytype)\n          throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n        const buffer = aObject._rvalue.buffer.slice(\n          aObject._rvalue.byteOffset,\n          aObject._rvalue.byteOffset + aObject._rvalue.byteLength,\n        );\n        bObject = new arraytype(buffer);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = aObject._rvalue.buffer.slice(\n          aObject._rvalue.byteOffset,\n          aObject._rvalue.byteOffset + aObject._rvalue.byteLength,\n        ); // ArrayBuffer\n      } else if (aObject._rtype === \"iostream\") {\n        if (aObject._rnative === \"js:blob\") {\n          const read = await this._generate_remote_method(\n            aObject.read,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          );\n          const bytes = await read();\n          bObject = new Blob([bytes], {\n            type: aObject.type,\n            name: aObject.name,\n          });\n        } else {\n          bObject = {};\n          for (let k of Object.keys(aObject)) {\n            if (!k.startsWith(\"_\")) {\n              bObject[k] = await this._decode(\n                aObject[k],\n                remote_parent,\n                local_parent,\n                remote_workspace,\n                local_workspace,\n              );\n            }\n          }\n        }\n        bObject[\"__rpc_object__\"] = aObject;\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(\n          await this._decode(\n            aObject._rvalue,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          ),\n        );\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(\n          await this._decode(\n            aObject._rvalue,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          ),\n        );\n      } else {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._decode(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        bObject._rtype = temp;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(\n            v,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          );\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    }\n    return bObject;\n  }\n\n  _expand_promise(data) {\n    return {\n      heartbeat: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".heartbeat\",\n        _rdoc: `heartbeat callback for method: ${data.method}`,\n      },\n      resolve: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".resolve\",\n        _rdoc: `resolve callback for method: ${data.method}`,\n      },\n      reject: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".reject\",\n        _rdoc: `reject callback for method: ${data.method}`,\n      },\n      interval: data.t,\n    };\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/index.js\":\n/*!****************************!*\\\n  !*** ./src/utils/index.js ***!\n  \\****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_59320__) => {\n\n__nested_webpack_require_59320__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_59320__.d(__nested_webpack_exports__, {\n/* harmony export */   MessageEmitter: () => (/* binding */ MessageEmitter),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   cacheRequirements: () => (/* binding */ cacheRequirements),\n/* harmony export */   convertCase: () => (/* binding */ convertCase),\n/* harmony export */   dtypeToTypedArray: () => (/* binding */ dtypeToTypedArray),\n/* harmony export */   expandKwargs: () => (/* binding */ expandKwargs),\n/* harmony export */   loadRequirements: () => (/* binding */ loadRequirements),\n/* harmony export */   loadRequirementsInWebworker: () => (/* binding */ loadRequirementsInWebworker),\n/* harmony export */   loadRequirementsInWindow: () => (/* binding */ loadRequirementsInWindow),\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig),\n/* harmony export */   parseServiceUrl: () => (/* binding */ parseServiceUrl),\n/* harmony export */   randId: () => (/* binding */ randId),\n/* harmony export */   toCamelCase: () => (/* binding */ toCamelCase),\n/* harmony export */   toSnakeCase: () => (/* binding */ toSnakeCase),\n/* harmony export */   typedArrayToDtype: () => (/* binding */ typedArrayToDtype),\n/* harmony export */   typedArrayToDtypeMapping: () => (/* binding */ typedArrayToDtypeMapping),\n/* harmony export */   urlJoin: () => (/* binding */ urlJoin),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\n\nfunction toCamelCase(str) {\n  // Check if the string is already in camelCase\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  // Convert from snake_case to camelCase\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\n\nfunction toSnakeCase(str) {\n  // Convert from camelCase to snake_case\n  return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n}\n\nfunction expandKwargs(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj; // Return the value if obj is not an object\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n\n      if (typeof value === \"function\") {\n        newObj[key] = (...args) => {\n          if (args.length === 0) {\n            throw new Error(`Function \"${key}\" expects at least one argument.`);\n          }\n\n          // Check if the last argument is an object\n          const lastArg = args[args.length - 1];\n          let kwargs = {};\n\n          if (\n            typeof lastArg === \"object\" &&\n            lastArg !== null &&\n            !Array.isArray(lastArg)\n          ) {\n            // Extract kwargs from the last argument\n            kwargs = { ...lastArg, _rkwarg: true };\n            args = args.slice(0, -1); // Remove the last argument from args\n          }\n\n          // Call the original function with positional args followed by kwargs\n          return value(...args, kwargs);\n        };\n\n        // Preserve metadata like __name__ and __schema__\n        newObj[key].__name__ = key;\n        if (value.__schema__) {\n          newObj[key].__schema__ = { ...value.__schema__ };\n          newObj[key].__schema__.name = key;\n        }\n      } else {\n        newObj[key] = expandKwargs(value); // Recursively process nested objects\n      }\n    }\n  }\n\n  return newObj;\n}\n\nfunction convertCase(obj, caseType) {\n  if (typeof obj !== \"object\" || obj === null || !caseType) {\n    return obj; // Return the value if obj is not an object\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n      const camelKey = toCamelCase(key);\n      const snakeKey = toSnakeCase(key);\n\n      if (caseType === \"camel\") {\n        newObj[camelKey] = convertCase(value, caseType);\n        if (typeof value === \"function\") {\n          newObj[camelKey].__name__ = camelKey;\n          if (value.__schema__) {\n            newObj[camelKey].__schema__ = { ...value.__schema__ };\n            newObj[camelKey].__schema__.name = camelKey;\n          }\n        }\n      } else if (caseType === \"snake\") {\n        newObj[snakeKey] = convertCase(value, caseType);\n        if (typeof value === \"function\") {\n          newObj[snakeKey].__name__ = snakeKey;\n          if (value.__schema__) {\n            newObj[snakeKey].__schema__ = { ...value.__schema__ };\n            newObj[snakeKey].__schema__.name = snakeKey;\n          }\n        }\n      } else {\n        // TODO handle schema for camel + snake\n        if (caseType.includes(\"camel\")) {\n          newObj[camelKey] = convertCase(value, \"camel\");\n        }\n        if (caseType.includes(\"snake\")) {\n          newObj[snakeKey] = convertCase(value, \"snake\");\n        }\n      }\n    }\n  }\n\n  return newObj;\n}\n\nfunction parseServiceUrl(url) {\n  // Ensure no trailing slash\n  url = url.replace(/\\/$/, \"\");\n\n  // Regex pattern to match the URL structure\n  const pattern = new RegExp(\n    \"^(https?:\\\\/\\\\/[^/]+)\" + // server_url (http or https followed by domain)\n      \"\\\\/([a-z0-9_-]+)\" + // workspace (lowercase letters, numbers, - or _)\n      \"\\\\/services\\\\/\" + // static part of the URL\n      \"(?:(?<clientId>[a-zA-Z0-9_-]+):)?\" + // optional client_id\n      \"(?<serviceId>[a-zA-Z0-9_-]+)\" + // service_id\n      \"(?:@(?<appId>[a-zA-Z0-9_-]+))?\", // optional app_id\n  );\n\n  const match = url.match(pattern);\n  if (!match) {\n    throw new Error(\"URL does not match the expected pattern\");\n  }\n\n  const serverUrl = match[1];\n  const workspace = match[2];\n  const clientId = match.groups?.clientId || \"*\";\n  const serviceId = match.groups?.serviceId;\n  const appId = match.groups?.appId || \"*\";\n\n  return { serverUrl, workspace, clientId, serviceId, appId };\n}\n\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array,\n};\n\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  }\n\n  // support importScripts outside web worker\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (\n    requirements &&\n    (Array.isArray(requirements) || typeof requirements === \"string\")\n  ) {\n    try {\n      var link_node;\n      requirements =\n        typeof requirements === \"string\" ? [requirements] : requirements;\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (\n            requirements[i].toLowerCase().endsWith(\".css\") ||\n            requirements[i].startsWith(\"css:\")\n          ) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (\n            requirements[i].toLowerCase().endsWith(\".mjs\") ||\n            requirements[i].startsWith(\"mjs:\")\n          ) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n            await import(/* webpackIgnore: true */ requirements[i]);\n          } else if (\n            requirements[i].toLowerCase().endsWith(\".js\") ||\n            requirements[i].startsWith(\"js:\")\n          ) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {\n            //ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\n\nasync function loadRequirementsInWebworker(requirements) {\n  if (\n    requirements &&\n    (Array.isArray(requirements) || typeof requirements === \"string\")\n  ) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n      for (var i = 0; i < requirements.length; i++) {\n        if (\n          requirements[i].toLowerCase().endsWith(\".css\") ||\n          requirements[i].startsWith(\"css:\")\n        ) {\n          throw \"unable to import css in a webworker\";\n        } else if (\n          requirements[i].toLowerCase().endsWith(\".js\") ||\n          requirements[i].startsWith(\"js:\")\n        ) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {\n          //ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\n\nfunction loadRequirements(requirements) {\n  if (\n    typeof WorkerGlobalScope !== \"undefined\" &&\n    self instanceof WorkerGlobalScope\n  ) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\n\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description =\n    config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false;\n  // remove functions\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\",\n};\n\nconst typedArrayToDtypeKeys = [];\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url,\n    };\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n    const messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [\n        messageChannel.port2,\n      ]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n\n    await cacheUrlInServiceWorker(req).catch((e) => {\n      console.error(e);\n    });\n  }\n}\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\n//#Source https://bit.ly/2neWfJ2\nfunction urlJoin(...args) {\n  return args\n    .join(\"/\")\n    .replace(/[\\/]+/g, \"/\")\n    .replace(/^(.+):\\//, \"$1://\")\n    .replace(/^file:/, \"file:/\")\n    .replace(/\\/(\\?|&|#[^!])/g, \"$1\")\n    .replace(/\\?/g, \"&\")\n    .replace(\"&\", \"?\");\n}\n\nfunction waitFor(prom, time, error) {\n  let timer;\n  return Promise.race([\n    prom,\n    new Promise(\n      (_r, rej) =>\n        (timer = setTimeout(() => {\n          rej(error || \"Timeout Error\");\n        }, time * 1000)),\n    ),\n  ]).finally(() => clearTimeout(timer));\n}\n\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout);\n    });\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/schema.js\":\n/*!*****************************!*\\\n  !*** ./src/utils/schema.js ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_75184__) => {\n\n__nested_webpack_require_75184__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_75184__.d(__nested_webpack_exports__, {\n/* harmony export */   schemaFunction: () => (/* binding */ schemaFunction)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_75184__(/*! . */ \"./src/utils/index.js\");\n\n\nfunction schemaFunction(\n  func,\n  { schema_type = \"auto\", name = null, description = null, parameters = null },\n) {\n  if (!func || typeof func !== \"function\") {\n    throw Error(\"func should be a function\");\n  }\n  (0,___WEBPACK_IMPORTED_MODULE_0__.assert)(schema_type === \"auto\", \"schema_type should be auto\");\n  (0,___WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"name should not be null\");\n  (0,___WEBPACK_IMPORTED_MODULE_0__.assert)(\n    parameters && parameters.type === \"object\",\n    \"parameters should be an object\",\n  );\n  func.__schema__ = {\n    name: name,\n    description: description,\n    parameters: parameters || [],\n  };\n  return func;\n}\n\n\n/***/ }),\n\n/***/ \"./src/webrtc-client.js\":\n/*!******************************!*\\\n  !*** ./src/webrtc-client.js ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_76391__) => {\n\n__nested_webpack_require_76391__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_76391__.d(__nested_webpack_exports__, {\n/* harmony export */   getRTCService: () => (/* binding */ getRTCService),\n/* harmony export */   registerRTCService: () => (/* binding */ registerRTCService)\n/* harmony export */ });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_76391__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_76391__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_76391__(/*! ./utils/schema.js */ \"./src/utils/schema.js\");\n\n\n\n\nclass WebRTCConnection {\n  constructor(channel) {\n    this._data_channel = channel;\n    this._handle_message = null;\n    this._reconnection_token = null;\n    this._handle_disconnected = null;\n    this._handle_connected = () => {};\n    this.manager_id = null;\n    this._data_channel.onopen = async () => {\n      this._handle_connected &&\n        this._handle_connected({ channel: this._data_channel });\n    };\n    this._data_channel.onmessage = async (event) => {\n      let data = event.data;\n      if (data instanceof Blob) {\n        data = await data.arrayBuffer();\n      }\n      this._handle_message(data);\n    };\n    const self = this;\n    this._data_channel.onclose = function () {\n      if (this._handle_disconnected) this._handle_disconnected(\"closed\");\n      console.log(\"websocket closed\");\n      self._data_channel = null;\n    };\n  }\n\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  on_message(handler) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  async emit_message(data) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this._handle_message, \"No handler for message\");\n    try {\n      this._data_channel.send(data);\n    } catch (exp) {\n      //   data = msgpack_unpackb(data);\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  async disconnect(reason) {\n    this._data_channel = null;\n    console.info(`data channel connection disconnected (${reason})`);\n  }\n}\n\nasync function _setupRPC(config) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(config.channel, \"No channel provided\");\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(config.workspace, \"No workspace provided\");\n  const channel = config.channel;\n  const clientId = config.client_id || (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n  const connection = new WebRTCConnection(channel);\n  config.context = config.context || {};\n  config.context.connection_type = \"webrtc\";\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC(connection, {\n    client_id: clientId,\n    default_context: config.context,\n    name: config.name,\n    method_timeout: config.method_timeout || 10.0,\n    workspace: config.workspace,\n  });\n  return rpc;\n}\n\nasync function _createOffer(params, server, config, onInit, context) {\n  config = config || {};\n  let offer = new RTCSessionDescription({\n    sdp: params.sdp,\n    type: params.type,\n  });\n\n  let pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [\n      { urls: [\"stun:stun.l.google.com:19302\"] },\n    ],\n    sdpSemantics: \"unified-plan\",\n  });\n\n  if (server) {\n    pc.addEventListener(\"datachannel\", async (event) => {\n      const channel = event.channel;\n      let ctx = null;\n      if (context && context.user) ctx = { user: context.user, ws: context.ws };\n      const rpc = await _setupRPC({\n        channel: channel,\n        client_id: channel.label,\n        workspace: server.config.workspace,\n        context: ctx,\n      });\n      // Map all the local services to the webrtc client\n      rpc._services = server.rpc._services;\n    });\n  }\n\n  if (onInit) {\n    await onInit(pc);\n  }\n\n  await pc.setRemoteDescription(offer);\n\n  let answer = await pc.createAnswer();\n  await pc.setLocalDescription(answer);\n\n  return {\n    sdp: pc.localDescription.sdp,\n    type: pc.localDescription.type,\n    workspace: server.config.workspace,\n  };\n}\n\nasync function getRTCService(server, service_id, config) {\n  config = config || {};\n  config.peer_id = config.peer_id || (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n\n  const pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [\n      { urls: [\"stun:stun.l.google.com:19302\"] },\n    ],\n    sdpSemantics: \"unified-plan\",\n  });\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      pc.addEventListener(\n        \"connectionstatechange\",\n        () => {\n          if (pc.connectionState === \"failed\") {\n            pc.close();\n            reject(new Error(\"WebRTC Connection failed\"));\n          } else if (pc.connectionState === \"closed\") {\n            reject(new Error(\"WebRTC Connection closed\"));\n          } else {\n            console.log(\"WebRTC Connection state: \", pc.connectionState);\n          }\n        },\n        false,\n      );\n\n      if (config.on_init) {\n        await config.on_init(pc);\n        delete config.on_init;\n      }\n      let channel = pc.createDataChannel(config.peer_id, { ordered: true });\n      channel.binaryType = \"arraybuffer\";\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      const svc = await server.getService(service_id);\n      const answer = await svc.offer({\n        sdp: pc.localDescription.sdp,\n        type: pc.localDescription.type,\n      });\n\n      channel.onopen = () => {\n        config.channel = channel;\n        config.workspace = answer.workspace;\n        // Wait for the channel to be open before returning the rpc\n        // This is needed for safari to work\n        setTimeout(async () => {\n          const rpc = await _setupRPC(config);\n          pc.rpc = rpc;\n          async function get_service(name, ...args) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n              !name.includes(\":\"),\n              \"WebRTC service name should not contain ':'\",\n            );\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n              !name.includes(\"/\"),\n              \"WebRTC service name should not contain '/'\",\n            );\n            return await rpc.get_remote_service(\n              config.workspace + \"/\" + config.peer_id + \":\" + name,\n              ...args,\n            );\n          }\n          async function disconnect() {\n            await rpc.disconnect();\n            pc.close();\n          }\n          pc.getService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(get_service, {\n            name: \"getService\",\n            description: \"Get a remote service via webrtc\",\n            parameters: {\n              type: \"object\",\n              properties: {\n                service_id: {\n                  type: \"string\",\n                  description:\n                    \"Service ID. This should be a service id in the format: 'workspace/service_id', 'workspace/client_id:service_id' or 'workspace/client_id:service_id@app_id'\",\n                },\n                config: {\n                  type: \"object\",\n                  description: \"Options for the service\",\n                },\n              },\n              required: [\"id\"],\n            },\n          });\n          pc.disconnect = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(disconnect, {\n            name: \"disconnect\",\n            description: \"Disconnect from the webrtc connection via webrtc\",\n            parameters: { type: \"object\", properties: {} },\n          });\n          pc.registerCodec = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_codec, {\n            name: \"registerCodec\",\n            description: \"Register a codec for the webrtc connection\",\n            parameters: {\n              type: \"object\",\n              properties: {\n                codec: {\n                  type: \"object\",\n                  description: \"Codec to register\",\n                  properties: {\n                    name: { type: \"string\" },\n                    type: {},\n                    encoder: { type: \"function\" },\n                    decoder: { type: \"function\" },\n                  },\n                },\n              },\n            },\n          });\n          resolve(pc);\n        }, 500);\n      };\n\n      channel.onclose = () => reject(new Error(\"Data channel closed\"));\n\n      await pc.setRemoteDescription(\n        new RTCSessionDescription({\n          sdp: answer.sdp,\n          type: answer.type,\n        }),\n      );\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nasync function registerRTCService(server, service_id, config) {\n  config = config || {\n    visibility: \"protected\",\n    require_context: true,\n  };\n  const onInit = config.on_init;\n  delete config.on_init;\n  return await server.registerService({\n    id: service_id,\n    config,\n    offer: (params, context) =>\n      _createOffer(params, server, config, onInit, context),\n  });\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n  \\*************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_85842__) => {\n\n__nested_webpack_require_85842__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_85842__.d(__nested_webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_85842__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n  \\********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_89357__) => {\n\n__nested_webpack_require_89357__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_89357__.d(__nested_webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_91322__) => {\n\n__nested_webpack_require_91322__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_91322__.d(__nested_webpack_exports__, {\n/* harmony export */   DataViewIndexOutOfBoundsError: () => (/* binding */ DataViewIndexOutOfBoundsError),\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_91322__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_91322__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_91322__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_91322__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_91322__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_91322__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_91322__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nvar DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxBinLength === void 0) { maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxArrayLength === void 0) { maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxMapLength === void 0) { maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxExtLength === void 0) { maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n        this.view = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* State.ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* State.MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* State.MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* State.MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: 1 /* State.MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: 0 /* State.ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.TEXT_DECODER_THRESHOLD) {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeTD)(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeJs)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* State.MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_125048__) => {\n\n__nested_webpack_require_125048__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_125048__.d(__nested_webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_125048__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_125048__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_125048__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_125048__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER_THRESHOLD) {\n            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeTE)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeJs)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_140973__) => {\n\n__nested_webpack_require_140973__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_140973__.d(__nested_webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n  \\***********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_141874__) => {\n\n__nested_webpack_require_141874__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_141874__.d(__nested_webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_141874__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_141874__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n  \\***************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_145401__) => {\n\n__nested_webpack_require_145401__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_145401__.d(__nested_webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeMulti: () => (/* binding */ decodeMulti),\n/* harmony export */   defaultDecodeOptions: () => (/* binding */ defaultDecodeOptions)\n/* harmony export */ });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_145401__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n\nvar defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n  \\***************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_147816__) => {\n\n__nested_webpack_require_147816__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_147816__.d(__nested_webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_147816__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_149313__) => {\n\n__nested_webpack_require_149313__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_149313__.d(__nested_webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_149313__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_149313__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_154351__) => {\n\n__nested_webpack_require_154351__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_154351__.d(__nested_webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n  \\*************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_156167__) => {\n\n__nested_webpack_require_156167__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_156167__.d(__nested_webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n  \\**************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_156962__) => {\n\n__nested_webpack_require_156962__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_156962__.d(__nested_webpack_exports__, {\n/* harmony export */   createDataView: () => (/* binding */ createDataView),\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_158361__) => {\n\n__nested_webpack_require_158361__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_158361__.d(__nested_webpack_exports__, {\n/* harmony export */   TEXT_DECODER_THRESHOLD: () => (/* binding */ TEXT_DECODER_THRESHOLD),\n/* harmony export */   TEXT_ENCODER_THRESHOLD: () => (/* binding */ TEXT_ENCODER_THRESHOLD),\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\n/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_158361__(/*! ./int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\nvar _a, _b, _c;\n/* eslint-disable @typescript-eslint/no-unnecessary-condition */\n\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX\n    : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX\n    : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\"\n        ? 200\n        : 0;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_165480__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_165480__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_165480__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_165480__.o(definition, key) && !__nested_webpack_require_165480__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_165480__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_165480__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n/*!*********************************!*\\\n  !*** ./src/websocket-client.js ***!\n  \\*********************************/\n__nested_webpack_require_165480__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_165480__.d(__nested_webpack_exports__, {\n/* harmony export */   API_VERSION: () => (/* reexport safe */ _rpc_js__WEBPACK_IMPORTED_MODULE_0__.API_VERSION),\n/* harmony export */   LocalWebSocket: () => (/* binding */ LocalWebSocket),\n/* harmony export */   RPC: () => (/* reexport safe */ _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC),\n/* harmony export */   connectToServer: () => (/* binding */ connectToServer),\n/* harmony export */   getRTCService: () => (/* reexport safe */ _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService),\n/* harmony export */   getRemoteService: () => (/* binding */ getRemoteService),\n/* harmony export */   loadRequirements: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.loadRequirements),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   registerRTCService: () => (/* reexport safe */ _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService),\n/* harmony export */   schemaFunction: () => (/* reexport safe */ _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction),\n/* harmony export */   setupLocalClient: () => (/* binding */ setupLocalClient)\n/* harmony export */ });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_165480__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_165480__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_165480__(/*! ./utils/schema.js */ \"./src/utils/schema.js\");\n/* harmony import */ var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_165480__(/*! ./webrtc-client.js */ \"./src/webrtc-client.js\");\n\n\n\n\n\n\n\n\n\nconst MAX_RETRY = 1000000;\n\nclass WebsocketRPCConnection {\n  constructor(\n    server_url,\n    client_id,\n    workspace,\n    token,\n    reconnection_token = null,\n    timeout = 60,\n    WebSocketClass = null,\n    token_refresh_interval = 2 * 60 * 60,\n  ) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(server_url && client_id, \"server_url and client_id are required\");\n    this._server_url = server_url;\n    this._client_id = client_id;\n    this._workspace = workspace;\n    this._token = token;\n    this._reconnection_token = reconnection_token;\n    this._websocket = null;\n    this._handle_message = null;\n    this._handle_connected = null; // Connection open event handler\n    this._handle_disconnected = null; // Disconnection event handler\n    this._timeout = timeout;\n    this._WebSocketClass = WebSocketClass || WebSocket; // Allow overriding the WebSocket class\n    this._closed = false;\n    this._legacy_auth = null;\n    this.connection_info = null;\n    this._enable_reconnect = false;\n    this._token_refresh_interval = token_refresh_interval;\n    this.manager_id = null;\n    this._refresh_token_task = null;\n  }\n\n  on_message(handler) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  async _attempt_connection(server_url, attempt_fallback = true) {\n    return new Promise((resolve, reject) => {\n      this._legacy_auth = false;\n      const websocket = new this._WebSocketClass(server_url);\n      websocket.binaryType = \"arraybuffer\";\n\n      websocket.onopen = () => {\n        console.info(\"WebSocket connection established\");\n        resolve(websocket);\n      };\n\n      websocket.onerror = (event) => {\n        console.error(\"WebSocket connection error:\", event);\n        reject(new Error(`WebSocket connection error: ${event}`));\n      };\n\n      websocket.onclose = (event) => {\n        if (event.code === 1003 && attempt_fallback) {\n          console.info(\n            \"Received 1003 error, attempting connection with query parameters.\",\n          );\n          this._legacy_auth = true;\n          this._attempt_connection_with_query_params(server_url)\n            .then(resolve)\n            .catch(reject);\n        } else if (this._handle_disconnected) {\n          this._handle_disconnected(event.reason);\n        }\n      };\n    });\n  }\n\n  async _attempt_connection_with_query_params(server_url) {\n    // Initialize an array to hold parts of the query string\n    const queryParamsParts = [];\n\n    // Conditionally add each parameter if it has a non-empty value\n    if (this._client_id)\n      queryParamsParts.push(`client_id=${encodeURIComponent(this._client_id)}`);\n    if (this._workspace)\n      queryParamsParts.push(`workspace=${encodeURIComponent(this._workspace)}`);\n    if (this._token)\n      queryParamsParts.push(`token=${encodeURIComponent(this._token)}`);\n    if (this._reconnection_token)\n      queryParamsParts.push(\n        `reconnection_token=${encodeURIComponent(this._reconnection_token)}`,\n      );\n\n    // Join the parts with '&' to form the final query string, prepend '?' if there are any parameters\n    const queryString =\n      queryParamsParts.length > 0 ? `?${queryParamsParts.join(\"&\")}` : \"\";\n\n    // Construct the full URL by appending the query string if it exists\n    const full_url = server_url + queryString;\n\n    return await this._attempt_connection(full_url, false);\n  }\n\n  _establish_connection() {\n    return new Promise((resolve, reject) => {\n      this._websocket.onmessage = (event) => {\n        const data = event.data;\n        const first_message = JSON.parse(data);\n        if (first_message.type == \"connection_info\") {\n          this.connection_info = first_message;\n          if (this._workspace) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n              this.connection_info.workspace === this._workspace,\n              `Connected to the wrong workspace: ${this.connection_info.workspace}, expected: ${this._workspace}`,\n            );\n          }\n          if (this.connection_info.reconnection_token) {\n            this._reconnection_token = this.connection_info.reconnection_token;\n          }\n          if (this.connection_info.reconnection_token_life_time) {\n            // make sure the token refresh interval is less than the token life time\n            if (\n              this.token_refresh_interval >\n              this.connection_info.reconnection_token_life_time / 1.5\n            ) {\n              console.warn(\n                `Token refresh interval is too long (${this.token_refresh_interval}), setting it to 1.5 times of the token life time(${this.connection_info.reconnection_token_life_time}).`,\n              );\n              this.token_refresh_interval =\n                this.connection_info.reconnection_token_life_time / 1.5;\n            }\n          }\n          this.manager_id = this.connection_info.manager_id || null;\n          console.log(\n            `Successfully connected to the server, workspace: ${this.connection_info.workspace}, manager_id: ${this.manager_id}`,\n          );\n          if (this.connection_info.announcement) {\n            console.log(`${this.connection_info.announcement}`);\n          }\n          resolve(this.connection_info);\n        } else if (first_message.type == \"error\") {\n          const error = \"ConnectionAbortedError: \" + first_message.message;\n          console.error(\"Failed to connect, \" + error);\n          reject(new Error(error));\n          return;\n        } else {\n          console.error(\n            \"ConnectionAbortedError: Unexpected message received from the server:\",\n            data,\n          );\n          reject(\n            new Error(\n              \"ConnectionAbortedError: Unexpected message received from the server\",\n            ),\n          );\n          return;\n        }\n      };\n    });\n  }\n\n  async open() {\n    console.log(\n      \"Creating a new websocket connection to\",\n      this._server_url.split(\"?\")[0],\n    );\n    try {\n      this._websocket = await this._attempt_connection(this._server_url);\n      if (this._legacy_auth) {\n        throw new Error(\n          \"NotImplementedError: Legacy authentication is not supported\",\n        );\n      }\n      // Send authentication info as the first message if connected without query params\n      const authInfo = JSON.stringify({\n        client_id: this._client_id,\n        workspace: this._workspace,\n        token: this._token,\n        reconnection_token: this._reconnection_token,\n      });\n      this._websocket.send(authInfo);\n      // Wait for the first message from the server\n      await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.waitFor)(\n        this._establish_connection(),\n        this._timeout,\n        \"Failed to receive the first message from the server\",\n      );\n      if (this._token_refresh_interval > 0) {\n        setTimeout(() => {\n          this._send_refresh_token();\n          this._refresh_token_task = setInterval(() => {\n            this._send_refresh_token();\n          }, this._token_refresh_interval * 1000);\n        }, 2000);\n      }\n      // Listen to messages from the server\n      this._enable_reconnect = true;\n      this._closed = false;\n      this._websocket.onmessage = (event) => {\n        if (typeof event.data === \"string\") {\n          const parsedData = JSON.parse(event.data);\n          // Check if the message is a reconnection token\n          if (parsedData.type === \"reconnection_token\") {\n            this._reconnection_token = parsedData.reconnection_token;\n            console.log(\"Reconnection token received\");\n          } else {\n            console.log(\"Received message from the server:\", parsedData);\n          }\n        } else {\n          this._handle_message(event.data);\n        }\n      };\n\n      this._websocket.onerror = (event) => {\n        console.error(\"WebSocket connection error:\", event);\n      };\n\n      this._websocket.onclose = this._handle_close.bind(this);\n\n      if (this._handle_connected) {\n        this._handle_connected(this.connection_info);\n      }\n      return this.connection_info;\n    } catch (error) {\n      console.error(\n        \"Failed to connect to\",\n        this._server_url.split(\"?\")[0],\n        error,\n      );\n      throw error;\n    }\n  }\n\n  _send_refresh_token() {\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      const refreshMessage = JSON.stringify({ type: \"refresh_token\" });\n      this._websocket.send(refreshMessage);\n      console.log(\"Requested refresh token\");\n    }\n  }\n\n  _handle_close(event) {\n    if (\n      !this._closed &&\n      this._websocket &&\n      this._websocket.readyState === WebSocket.CLOSED\n    ) {\n      if ([1000, 1001].includes(event.code)) {\n        console.info(\n          `Websocket connection closed (code: ${event.code}): ${event.reason}`,\n        );\n        if (this._handle_disconnected) {\n          this._handle_disconnected(event.reason);\n        }\n        this._closed = true;\n      } else if (this._enable_reconnect) {\n        console.warn(\n          \"Websocket connection closed unexpectedly (code: %s): %s\",\n          event.code,\n          event.reason,\n        );\n        let retry = 0;\n        const reconnect = async () => {\n          try {\n            console.warn(\n              `Reconnecting to ${this._server_url.split(\"?\")[0]} (attempt #${retry})`,\n            );\n            await this.open();\n            console.warn(\n              `Successfully reconnected to server ${this._server_url}`,\n            );\n          } catch (e) {\n            if (`${e}`.includes(\"ConnectionAbortedError:\")) {\n              console.warn(\"Failed to reconnect, connection aborted:\", e);\n              return;\n            } else if (`${e}`.includes(\"NotImplementedError:\")) {\n              console.error(\n                `${e}\\nIt appears that you are trying to connect to a hypha server that is older than 0.20.0, please upgrade the hypha server or use the websocket client in imjoy-rpc(https://www.npmjs.com/package/imjoy-rpc) instead`,\n              );\n              return;\n            }\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n            if (\n              this._websocket &&\n              this._websocket.readyState === WebSocket.CONNECTED\n            ) {\n              return;\n            }\n            retry += 1;\n            if (retry < MAX_RETRY) {\n              await reconnect();\n            } else {\n              console.error(\"Failed to reconnect after\", MAX_RETRY, \"attempts\");\n            }\n          }\n        };\n        reconnect();\n      }\n    } else {\n      if (this._handle_disconnected) {\n        this._handle_disconnected(event.reason);\n      }\n    }\n  }\n\n  async emit_message(data) {\n    if (this._closed) {\n      throw new Error(\"Connection is closed\");\n    }\n    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n      await this.open();\n    }\n    try {\n      this._websocket.send(data);\n    } catch (exp) {\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  disconnect(reason) {\n    this._closed = true;\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      this._websocket.close(1000, reason);\n    }\n    if (this._refresh_token_task) {\n      clearInterval(this._refresh_token_task);\n    }\n    console.info(`WebSocket connection disconnected (${reason})`);\n  }\n}\n\nfunction normalizeServerUrl(server_url) {\n  if (!server_url) throw new Error(\"server_url is required\");\n  if (server_url.startsWith(\"http://\")) {\n    server_url =\n      server_url.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n  } else if (server_url.startsWith(\"https://\")) {\n    server_url =\n      server_url.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n  }\n  return server_url;\n}\n\nasync function login(config) {\n  const service_id = config.login_service_id || \"public/hypha-login\";\n  const workspace = config.workspace;\n  const expires_in = config.expires_in;\n  const timeout = config.login_timeout || 60;\n  const callback = config.login_callback;\n  const profile = config.profile;\n\n  const server = await connectToServer({\n    name: \"initial login client\",\n    server_url: config.server_url,\n  });\n  try {\n    const svc = await server.getService(service_id);\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(svc, `Failed to get the login service: ${service_id}`);\n    let context;\n    if (workspace) {\n      context = await svc.start({ workspace, expires_in, _rkwargs: true });\n    } else {\n      context = await svc.start();\n    }\n    if (callback) {\n      await callback(context);\n    } else {\n      console.log(`Please open your browser and login at ${context.login_url}`);\n    }\n    return await svc.check(context.key, { timeout, profile, _rkwargs: true });\n  } catch (error) {\n    throw error;\n  } finally {\n    await server.disconnect();\n  }\n}\n\nasync function webrtcGetService(wm, rtc_service_id, query, config) {\n  config = config || {};\n  const webrtc = config.webrtc;\n  const webrtc_config = config.webrtc_config;\n  if (config.webrtc !== undefined) delete config.webrtc;\n  if (config.webrtc_config !== undefined) delete config.webrtc_config;\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n    [undefined, true, false, \"auto\"].includes(webrtc),\n    \"webrtc must be true, false or 'auto'\",\n  );\n\n  const svc = await wm.getService(query, config);\n  if (webrtc === true || webrtc === \"auto\") {\n    if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n      try {\n        // Assuming that the client registered a webrtc service with the client_id + \"-rtc\"\n        const peer = await (0,_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService)(wm, rtc_service_id, webrtc_config);\n        const rtcSvc = await peer.getService(svc.id.split(\":\")[1], config);\n        rtcSvc._webrtc = true;\n        rtcSvc._peer = peer;\n        rtcSvc._service = svc;\n        return rtcSvc;\n      } catch (e) {\n        console.warn(\n          \"Failed to get webrtc service, using websocket connection\",\n          e,\n        );\n      }\n    }\n    if (webrtc === true) {\n      throw new Error(\"Failed to get the service via webrtc\");\n    }\n  }\n  return svc;\n}\n\nasync function connectToServer(config) {\n  if (config.server) {\n    config.server_url = config.server_url || config.server.url;\n    config.WebSocketClass =\n      config.WebSocketClass || config.server.WebSocketClass;\n  }\n  let clientId = config.client_id;\n  if (!clientId) {\n    clientId = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n    config.client_id = clientId;\n  }\n\n  let server_url = normalizeServerUrl(config.server_url);\n\n  let connection = new WebsocketRPCConnection(\n    server_url,\n    clientId,\n    config.workspace,\n    config.token,\n    config.reconnection_token,\n    config.method_timeout || 60,\n    config.WebSocketClass,\n  );\n  const connection_info = await connection.open();\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n    connection_info,\n    \"Failed to connect to the server, no connection info obtained. This issue is most likely due to an outdated Hypha server version. Please use `imjoy-rpc` for compatibility, or upgrade the Hypha server to the latest version.\",\n  );\n  if (config.workspace && connection_info.workspace !== config.workspace) {\n    throw new Error(\n      `Connected to the wrong workspace: ${connection_info.workspace}, expected: ${config.workspace}`,\n    );\n  }\n  const workspace = connection_info.workspace;\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC(connection, {\n    client_id: clientId,\n    workspace,\n    default_context: { connection_type: \"websocket\" },\n    name: config.name,\n    method_timeout: config.method_timeout,\n    app_id: config.app_id,\n    server_base_url: connection_info.public_base_url,\n  });\n  const wm = await rpc.get_manager_service({\n    timeout: config.method_timeout,\n    case_conversion: \"camel\",\n    kwargs_expansion: config.kwargs_expansion || false,\n  });\n  wm.rpc = rpc;\n\n  async function _export(api) {\n    api.id = \"default\";\n    api.name = api.name || config.name || api.id;\n    api.description = api.description || config.description;\n    await rpc.register_service(api, { overwrite: true });\n  }\n\n  async function getApp(clientId) {\n    clientId = clientId || \"*\";\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!clientId.includes(\":\"), \"clientId should not contain ':'\");\n    if (!clientId.includes(\"/\")) {\n      clientId = connection_info.workspace + \"/\" + clientId;\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n      clientId.split(\"/\").length === 2,\n      \"clientId should match pattern workspace/clientId\",\n    );\n    return await wm.getService(`${clientId}:default`);\n  }\n\n  async function listApps(ws) {\n    ws = ws || workspace;\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\":\"), \"workspace should not contain ':'\");\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\"/\"), \"workspace should not contain '/'\");\n    const query = { workspace: ws, service_id: \"default\" };\n    return await wm.listServices(query);\n  }\n\n  if (connection_info) {\n    wm.config = Object.assign(wm.config, connection_info);\n  }\n  wm.export = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_export, {\n    name: \"export\",\n    description: \"Export the api.\",\n    parameters: {\n      properties: { api: { description: \"The api to export\", type: \"object\" } },\n      required: [\"api\"],\n      type: \"object\",\n    },\n  });\n  wm.getApp = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(getApp, {\n    name: \"getApp\",\n    description: \"Get the app.\",\n    parameters: {\n      properties: {\n        clientId: { default: \"*\", description: \"The clientId\", type: \"string\" },\n      },\n      type: \"object\",\n    },\n  });\n  wm.listApps = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(listApps, {\n    name: \"listApps\",\n    description: \"List the apps.\",\n    parameters: {\n      properties: {\n        workspace: {\n          default: workspace,\n          description: \"The workspace\",\n          type: \"string\",\n        },\n      },\n      type: \"object\",\n    },\n  });\n  wm.disconnect = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.disconnect.bind(rpc), {\n    name: \"disconnect\",\n    description: \"Disconnect from the server.\",\n    parameters: { type: \"object\", properties: {}, required: [] },\n  });\n  wm.registerCodec = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_codec.bind(rpc), {\n    name: \"registerCodec\",\n    description: \"Register a codec for the webrtc connection\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        codec: {\n          type: \"object\",\n          description: \"Codec to register\",\n          properties: {\n            name: { type: \"string\" },\n            type: {},\n            encoder: { type: \"function\" },\n            decoder: { type: \"function\" },\n          },\n        },\n      },\n    },\n  });\n\n  wm.emit = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.emit.bind(rpc), {\n    name: \"emit\",\n    description: \"Emit a message.\",\n    parameters: {\n      properties: { data: { description: \"The data to emit\", type: \"object\" } },\n      required: [\"data\"],\n      type: \"object\",\n    },\n  });\n\n  wm.on = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.on.bind(rpc), {\n    name: \"on\",\n    description: \"Register a message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to listen to\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.off = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.off.bind(rpc), {\n    name: \"off\",\n    description: \"Remove a message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to remove\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.once = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.once.bind(rpc), {\n    name: \"once\",\n    description: \"Register a one-time message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to listen to\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.getServiceSchema = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.get_service_schema, {\n    name: \"getServiceSchema\",\n    description: \"Get the service schema.\",\n    parameters: {\n      properties: {\n        service: {\n          description: \"The service to extract schema\",\n          type: \"object\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n\n  wm.registerService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_service.bind(rpc), {\n    name: \"registerService\",\n    description: \"Register a service.\",\n    parameters: {\n      properties: {\n        service: { description: \"The service to register\", type: \"object\" },\n        force: {\n          default: false,\n          description: \"Force to register the service\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n  wm.unregisterService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.unregister_service.bind(rpc), {\n    name: \"unregisterService\",\n    description: \"Unregister a service.\",\n    parameters: {\n      properties: {\n        service: {\n          description: \"The service id to unregister\",\n          type: \"string\",\n        },\n        notify: {\n          default: true,\n          description: \"Notify the workspace manager\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n  if (connection.manager_id) {\n    rpc.on(\"force-exit\", async (message) => {\n      if (message.from === \"*/\" + connection.manager_id) {\n        console.log(\"Disconnecting from server, reason:\", message.reason);\n        await rpc.disconnect();\n      }\n    });\n  }\n  if (config.webrtc) {\n    await (0,_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService)(wm, `${clientId}-rtc`, config.webrtc_config);\n    // make a copy of wm, so webrtc can use the original wm.getService\n    const _wm = Object.assign({}, wm);\n    const description = _wm.getService.__schema__.description;\n    // TODO: Fix the schema for adding options for webrtc\n    const parameters = _wm.getService.__schema__.parameters;\n    wm.getService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(\n      webrtcGetService.bind(null, _wm, `${workspace}/${clientId}-rtc`),\n      {\n        name: \"getService\",\n        description,\n        parameters,\n      },\n    );\n\n    wm.getRTCService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService.bind(null, wm), {\n      name: \"getRTCService\",\n      description: \"Get the webrtc connection, returns a peer connection.\",\n      parameters: {\n        properties: {\n          config: {\n            description: \"The config for the webrtc service\",\n            type: \"object\",\n          },\n        },\n        required: [\"config\"],\n        type: \"object\",\n      },\n    });\n  } else {\n    const _getService = wm.getService;\n    wm.getService = (query, config) => {\n      config = config || {};\n      return _getService(query, config);\n    };\n    wm.getService.__schema__ = _getService.__schema__;\n  }\n\n  async function registerProbes(probes) {\n    probes.id = \"probes\";\n    probes.name = \"Probes\";\n    probes.config = { visibility: \"public\" };\n    probes.type = \"probes\";\n    probes.description = `Probes Service, visit ${server_url}/${workspace}services/probes for the available probes.`;\n    return await wm.registerService(probes, { overwrite: true });\n  }\n\n  wm.registerProbes = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(registerProbes, {\n    name: \"registerProbes\",\n    description: \"Register probes service\",\n    parameters: {\n      properties: {\n        probes: {\n          description:\n            \"The probes to register, e.g. {'liveness': {'type': 'function', 'description': 'Check the liveness of the service'}}\",\n          type: \"object\",\n        },\n      },\n      required: [\"probes\"],\n      type: \"object\",\n    },\n  });\n\n  return wm;\n}\n\nasync function getRemoteService(serviceUri, config = {}) {\n  const { serverUrl, workspace, clientId, serviceId, appId } =\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.parseServiceUrl)(serviceUri);\n  const fullServiceId = `${workspace}/${clientId}:${serviceId}@${appId}`;\n\n  if (config.serverUrl) {\n    if (config.serverUrl !== serverUrl) {\n      throw new Error(\n        \"server_url in config does not match the server_url in the url\",\n      );\n    }\n  }\n  config.serverUrl = serverUrl;\n  const server = await connectToServer(config);\n  return await server.getService(fullServiceId);\n}\n\nclass LocalWebSocket {\n  constructor(url, client_id, workspace) {\n    this.url = url;\n    this.onopen = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.client_id = client_id;\n    this.workspace = workspace;\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    this.postMessage = (message) => {\n      if (isWindow) {\n        window.parent.postMessage(message, \"*\");\n      } else {\n        self.postMessage(message);\n      }\n    };\n\n    this.readyState = WebSocket.CONNECTING;\n    context.addEventListener(\n      \"message\",\n      (event) => {\n        const { type, data, to } = event.data;\n        if (to !== this.client_id) {\n          // console.debug(\"message not for me\", to, this.client_id);\n          return;\n        }\n        switch (type) {\n          case \"message\":\n            if (this.readyState === WebSocket.OPEN && this.onmessage) {\n              this.onmessage({ data: data });\n            }\n            break;\n          case \"connected\":\n            this.readyState = WebSocket.OPEN;\n            this.onopen(event);\n            break;\n          case \"closed\":\n            this.readyState = WebSocket.CLOSED;\n            this.onclose(event);\n            break;\n          default:\n            break;\n        }\n      },\n      false,\n    );\n\n    if (!this.client_id) throw new Error(\"client_id is required\");\n    if (!this.workspace) throw new Error(\"workspace is required\");\n    this.postMessage({\n      type: \"connect\",\n      url: this.url,\n      from: this.client_id,\n      workspace: this.workspace,\n    });\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.postMessage({\n        type: \"message\",\n        data: data,\n        from: this.client_id,\n        workspace: this.workspace,\n      });\n    }\n  }\n\n  close() {\n    this.readyState = WebSocket.CLOSING;\n    this.postMessage({\n      type: \"close\",\n      from: this.client_id,\n      workspace: this.workspace,\n    });\n    this.onclose();\n  }\n\n  addEventListener(type, listener) {\n    if (type === \"message\") {\n      this.onmessage = listener;\n    }\n    if (type === \"open\") {\n      this.onopen = listener;\n    }\n    if (type === \"close\") {\n      this.onclose = listener;\n    }\n    if (type === \"error\") {\n      this.onerror = listener;\n    }\n  }\n}\n\nfunction setupLocalClient({\n  enable_execution = false,\n  on_ready = null,\n}) {\n  return new Promise((resolve, reject) => {\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    context.addEventListener(\n      \"message\",\n      (event) => {\n        const {\n          type,\n          server_url,\n          workspace,\n          client_id,\n          token,\n          method_timeout,\n          name,\n          config,\n        } = event.data;\n\n        if (type === \"initializeHyphaClient\") {\n          if (!server_url || !workspace || !client_id) {\n            console.error(\"server_url, workspace, and client_id are required.\");\n            return;\n          }\n\n          if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n            console.error(\n              \"server_url should start with https://local-hypha-server:\",\n            );\n            return;\n          }\n\n          class FixedLocalWebSocket extends LocalWebSocket {\n            constructor(url) {\n              // Call the parent class's constructor with fixed values\n              super(url, client_id, workspace);\n            }\n          }\n          connectToServer({\n            server_url,\n            workspace,\n            client_id,\n            token,\n            method_timeout,\n            name,\n            WebSocketClass: FixedLocalWebSocket,\n          }).then(async (server) => {\n            globalThis.api = server;\n            try {\n              // for iframe\n              if (isWindow && enable_execution) {\n                function loadScript(script) {\n                  return new Promise((resolve, reject) => {\n                    const scriptElement = document.createElement(\"script\");\n                    scriptElement.innerHTML = script.content;\n                    scriptElement.lang = script.lang;\n\n                    scriptElement.onload = () => resolve();\n                    scriptElement.onerror = (e) => reject(e);\n\n                    document.head.appendChild(scriptElement);\n                  });\n                }\n                if (config.styles && config.styles.length > 0) {\n                  for (const style of config.styles) {\n                    const styleElement = document.createElement(\"style\");\n                    styleElement.innerHTML = style.content;\n                    styleElement.lang = style.lang;\n                    document.head.appendChild(styleElement);\n                  }\n                }\n                if (config.links && config.links.length > 0) {\n                  for (const link of config.links) {\n                    const linkElement = document.createElement(\"a\");\n                    linkElement.href = link.url;\n                    linkElement.innerText = link.text;\n                    document.body.appendChild(linkElement);\n                  }\n                }\n                if (config.windows && config.windows.length > 0) {\n                  for (const w of config.windows) {\n                    document.body.innerHTML = w.content;\n                    break;\n                  }\n                }\n                if (config.scripts && config.scripts.length > 0) {\n                  for (const script of config.scripts) {\n                    if (script.lang !== \"javascript\")\n                      throw new Error(\"Only javascript scripts are supported\");\n                    await loadScript(script); // Await the loading of each script\n                  }\n                }\n              }\n              // for web worker\n              else if (\n                !isWindow &&\n                enable_execution &&\n                config.scripts &&\n                config.scripts.length > 0\n              ) {\n                for (const script of config.scripts) {\n                  if (script.lang !== \"javascript\")\n                    throw new Error(\"Only javascript scripts are supported\");\n                  eval(script.content);\n                }\n              }\n\n              if (on_ready) {\n                await on_ready(server, config);\n              }\n              resolve(server);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        }\n      },\n      false,\n    );\n    if (isWindow) {\n      window.parent.postMessage({ type: \"hyphaClientReady\" }, \"*\");\n    } else {\n      self.postMessage({ type: \"hyphaClientReady\" });\n    }\n  });\n}\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=hypha-rpc-websocket.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/hypha-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hypha-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js\")};\n\n//# sourceURL=webpack://HyphaCore/./node_modules/hypha-rpc/index.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js":
/*!******************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js ***!
  \******************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_569__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_569__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_569__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_569__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_569__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_569__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_569__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_569__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_569__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_569__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_569__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_569__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_569__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_569__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_569__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_569__(__nested_webpack_require_569__.s = \"./src/hypha/sse-client.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n  \\*************************************************************************/\n/*! exports provided: CachedKeyDecoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_4429__) {\n\n\"use strict\";\n__nested_webpack_require_4429__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_4429__.d(__nested_webpack_exports__, \"CachedKeyDecoder\", function() { return CachedKeyDecoder; });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4429__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n  \\********************************************************************/\n/*! exports provided: DecodeError */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_7955__) {\n\n\"use strict\";\n__nested_webpack_require_7955__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_7955__.d(__nested_webpack_exports__, \"DecodeError\", function() { return DecodeError; });\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n  \\****************************************************************/\n/*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_9951__) {\n\n\"use strict\";\n__nested_webpack_require_9951__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_9951__.d(__nested_webpack_exports__, \"DataViewIndexOutOfBoundsError\", function() { return DataViewIndexOutOfBoundsError; });\n/* harmony export (binding) */ __nested_webpack_require_9951__.d(__nested_webpack_exports__, \"Decoder\", function() { return Decoder; });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_9951__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_9951__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_9951__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_9951__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_9951__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_9951__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_9951__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nvar DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxBinLength === void 0) { maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxArrayLength === void 0) { maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxMapLength === void 0) { maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxExtLength === void 0) { maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n        this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n    };\n    /**\n     * @throws {DecodeError}\n     * @throws {RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n        }\n        this.stack.push({\n            type: 1 /* MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n        }\n        this.stack.push({\n            type: 0 /* ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n            object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n        }\n        else {\n            object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n  \\****************************************************************/\n/*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_43757__) {\n\n\"use strict\";\n__nested_webpack_require_43757__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_43757__.d(__nested_webpack_exports__, \"DEFAULT_MAX_DEPTH\", function() { return DEFAULT_MAX_DEPTH; });\n/* harmony export (binding) */ __nested_webpack_require_43757__.d(__nested_webpack_exports__, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() { return DEFAULT_INITIAL_BUFFER_SIZE; });\n/* harmony export (binding) */ __nested_webpack_require_43757__.d(__nested_webpack_exports__, \"Encoder\", function() { return Encoder; });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_43757__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_43757__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_43757__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_43757__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.getUint8Array = function () {\n        return this.bytes.subarray(0, this.pos);\n    };\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.getUint8Array();\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \" + depth);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n            var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \" + size);\n        }\n        var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \" + size);\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \" + size);\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \" + size);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n  \\****************************************************************/\n/*! exports provided: ExtData */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_59326__) {\n\n\"use strict\";\n__nested_webpack_require_59326__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_59326__.d(__nested_webpack_exports__, \"ExtData\", function() { return ExtData; });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n  \\***********************************************************************/\n/*! exports provided: ExtensionCodec */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_60234__) {\n\n\"use strict\";\n__nested_webpack_require_60234__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_60234__.d(__nested_webpack_exports__, \"ExtensionCodec\", function() { return ExtensionCodec; });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60234__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_60234__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n  \\***************************************************************/\n/*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_63810__) {\n\n\"use strict\";\n__nested_webpack_require_63810__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_63810__.d(__nested_webpack_exports__, \"defaultDecodeOptions\", function() { return defaultDecodeOptions; });\n/* harmony export (binding) */ __nested_webpack_require_63810__.d(__nested_webpack_exports__, \"decode\", function() { return decode; });\n/* harmony export (binding) */ __nested_webpack_require_63810__.d(__nested_webpack_exports__, \"decodeMulti\", function() { return decodeMulti; });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_63810__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n\nvar defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n */\nfunction decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n */\nfunction decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n  \\********************************************************************/\n/*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_66065__) {\n\n\"use strict\";\n__nested_webpack_require_66065__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_66065__.d(__nested_webpack_exports__, \"decodeAsync\", function() { return decodeAsync; });\n/* harmony export (binding) */ __nested_webpack_require_66065__.d(__nested_webpack_exports__, \"decodeArrayStream\", function() { return decodeArrayStream; });\n/* harmony export (binding) */ __nested_webpack_require_66065__.d(__nested_webpack_exports__, \"decodeMultiStream\", function() { return decodeMultiStream; });\n/* harmony export (binding) */ __nested_webpack_require_66065__.d(__nested_webpack_exports__, \"decodeStream\", function() { return decodeStream; });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_66065__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_66065__(/*! ./utils/stream.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\");\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_66065__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nfunction decodeAsync(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    return __awaiter(this, void 0, void 0, function () {\n        var stream, decoder;\n        return __generator(this, function (_a) {\n            stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return [2 /*return*/, decoder.decodeAsync(stream)];\n        });\n    });\n}\nfunction decodeArrayStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeArrayStream(stream);\n}\nfunction decodeMultiStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeStream(stream);\n}\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nfunction decodeStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    return decodeMultiStream(streamLike, options);\n}\n//# sourceMappingURL=decodeAsync.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n  \\***************************************************************/\n/*! exports provided: encode */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_72179__) {\n\n\"use strict\";\n__nested_webpack_require_72179__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_72179__.d(__nested_webpack_exports__, \"encode\", function() { return encode; });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_72179__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encode(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n  \\**************************************************************/\n/*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_73969__) {\n\n\"use strict\";\n__nested_webpack_require_73969__.r(__nested_webpack_exports__);\n/* harmony import */ var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_73969__(/*! ./encode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"encode\", function() { return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"]; });\n\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_73969__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decode\", function() { return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeMulti\", function() { return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"]; });\n\n/* harmony import */ var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_73969__(/*! ./decodeAsync.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeAsync\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeArrayStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeMultiStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"]; });\n\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_73969__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"Decoder\", function() { return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"DataViewIndexOutOfBoundsError\", function() { return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"]; });\n\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_73969__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"DecodeError\", function() { return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"]; });\n\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_73969__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"Encoder\", function() { return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"]; });\n\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_73969__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"ExtensionCodec\", function() { return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"]; });\n\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_73969__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"ExtData\", function() { return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"]; });\n\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_73969__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"EXT_TIMESTAMP\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"encodeDateToTimeSpec\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"encodeTimeSpecToTimestamp\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeTimestampToTimeSpec\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"encodeTimestampExtension\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73969__.d(__nested_webpack_exports__, \"decodeTimestampExtension\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"]; });\n\n// Main Functions:\n\n\n\n\n\n\n\n\n\n\n\n// Utilitiies for Extension Types:\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n  \\******************************************************************/\n/*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_79719__) {\n\n\"use strict\";\n__nested_webpack_require_79719__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"EXT_TIMESTAMP\", function() { return EXT_TIMESTAMP; });\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"encodeTimeSpecToTimestamp\", function() { return encodeTimeSpecToTimestamp; });\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"encodeDateToTimeSpec\", function() { return encodeDateToTimeSpec; });\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"encodeTimestampExtension\", function() { return encodeTimestampExtension; });\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"decodeTimestampToTimeSpec\", function() { return decodeTimestampToTimeSpec; });\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"decodeTimestampExtension\", function() { return decodeTimestampExtension; });\n/* harmony export (binding) */ __nested_webpack_require_79719__.d(__nested_webpack_exports__, \"timestampExtension\", function() { return timestampExtension; });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_79719__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_79719__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n  \\******************************************************************/\n/*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_85143__) {\n\n\"use strict\";\n__nested_webpack_require_85143__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_85143__.d(__nested_webpack_exports__, \"UINT32_MAX\", function() { return UINT32_MAX; });\n/* harmony export (binding) */ __nested_webpack_require_85143__.d(__nested_webpack_exports__, \"setUint64\", function() { return setUint64; });\n/* harmony export (binding) */ __nested_webpack_require_85143__.d(__nested_webpack_exports__, \"setInt64\", function() { return setInt64; });\n/* harmony export (binding) */ __nested_webpack_require_85143__.d(__nested_webpack_exports__, \"getInt64\", function() { return getInt64; });\n/* harmony export (binding) */ __nested_webpack_require_85143__.d(__nested_webpack_exports__, \"getUint64\", function() { return getUint64; });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n  \\*************************************************************************/\n/*! exports provided: prettyByte */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_87182__) {\n\n\"use strict\";\n__nested_webpack_require_87182__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_87182__.d(__nested_webpack_exports__, \"prettyByte\", function() { return prettyByte; });\nfunction prettyByte(byte) {\n    return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n  \\*********************************************************************/\n/*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_87997__) {\n\n\"use strict\";\n__nested_webpack_require_87997__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_87997__.d(__nested_webpack_exports__, \"isAsyncIterable\", function() { return isAsyncIterable; });\n/* harmony export (binding) */ __nested_webpack_require_87997__.d(__nested_webpack_exports__, \"asyncIterableFromStream\", function() { return asyncIterableFromStream; });\n/* harmony export (binding) */ __nested_webpack_require_87997__.d(__nested_webpack_exports__, \"ensureAsyncIterable\", function() { return ensureAsyncIterable; });\n// utility for whatwg streams\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nfunction isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nfunction assertNonNull(value) {\n    if (value == null) {\n        throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n    }\n}\nfunction asyncIterableFromStream(stream) {\n    return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n        var reader, _a, done, value;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (false) {}\n                    return [4 /*yield*/, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done) return [3 /*break*/, 5];\n                    return [4 /*yield*/, __await(void 0)];\n                case 4: return [2 /*return*/, _b.sent()];\n                case 5:\n                    assertNonNull(value);\n                    return [4 /*yield*/, __await(value)];\n                case 6: return [4 /*yield*/, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3 /*break*/, 2];\n                case 8: return [3 /*break*/, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7 /*endfinally*/];\n                case 10: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n  \\**************************************************************************/\n/*! exports provided: ensureUint8Array, createDataView */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_93698__) {\n\n\"use strict\";\n__nested_webpack_require_93698__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_93698__.d(__nested_webpack_exports__, \"ensureUint8Array\", function() { return ensureUint8Array; });\n/* harmony export (binding) */ __nested_webpack_require_93698__.d(__nested_webpack_exports__, \"createDataView\", function() { return createDataView; });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n  \\*******************************************************************/\n/*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_95258__) {\n\n\"use strict\";\n__nested_webpack_require_95258__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"utf8Count\", function() { return utf8Count; });\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"utf8EncodeJs\", function() { return utf8EncodeJs; });\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"TEXT_ENCODER_THRESHOLD\", function() { return TEXT_ENCODER_THRESHOLD; });\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"utf8EncodeTE\", function() { return utf8EncodeTE; });\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"utf8DecodeJs\", function() { return utf8DecodeJs; });\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"TEXT_DECODER_THRESHOLD\", function() { return TEXT_DECODER_THRESHOLD; });\n/* harmony export (binding) */ __nested_webpack_require_95258__.d(__nested_webpack_exports__, \"utf8DecodeTD\", function() { return utf8DecodeTD; });\n/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_95258__(/*! ./int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"]\n    : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"]\n    : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map\n\n/***/ }),\n\n/***/ \"./package.json\":\n/*!**********************!*\\\n  !*** ./package.json ***!\n  \\**********************/\n/*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.5.59\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"types\\\":\\\"index.d.ts\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\\",\\\"watch\\\":\\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\\",\\\"publish-npm\\\":\\\"npm install && npm run build && npm publish\\\",\\\"serve\\\":\\\"webpack-dev-server\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\",\\\"test-watch\\\":\\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{\\\"@msgpack/msgpack\\\":\\\"^2.7.1\\\",\\\"socket.io-client\\\":\\\"^4.6.2\\\"},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.16.12\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.8.3\\\",\\\"@babel/polyfill\\\":\\\"^7.12.1\\\",\\\"@babel/preset-env\\\":\\\"^7.16.11\\\",\\\"@types/requirejs\\\":\\\"^2.1.34\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"^8.2.3\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.3.6\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.1.2\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^6.3.12\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^2.0.1\\\",\\\"karma-sourcemap-loader\\\":\\\"^0.3.8\\\",\\\"karma-spec-reporter\\\":\\\"0.0.32\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^6.0.3\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^10.1.0\\\",\\\"postcss\\\":\\\"^7.0.36\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"ts-loader\\\":\\\"^9.4.3\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.46.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^4.7.0\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\",\\\"webpack-dev-server\\\":\\\"^3.11.3\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"workbox-webpack-plugin\\\":\\\"^4.3.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");\n\n/***/ }),\n\n/***/ \"./src/hypha/rpc.js\":\n/*!**************************!*\\\n  !*** ./src/hypha/rpc.js ***!\n  \\**************************/\n/*! exports provided: API_VERSION, RPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_105798__) {\n\n\"use strict\";\n__nested_webpack_require_105798__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_105798__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __nested_webpack_require_105798__.d(__nested_webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_105798__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_105798__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\n\nconst API_VERSION = \"0.3.0\";\nconst CHUNK_SIZE = 1024 * 500;\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\n}\n\nfunction getFunctionInfo(func) {\n  const funcString = func.toString(); // Extract function name\n\n  const nameMatch = funcString.match(/function\\s*(\\w*)/);\n  const name = nameMatch && nameMatch[1] || \"\"; // Extract function parameters, excluding comments\n\n  const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n  let params = \"\";\n\n  if (paramsMatch) {\n    params = paramsMatch[1].split(\",\").map(p => p.replace(/\\/\\*.*?\\*\\//g, \"\") // Remove block comments\n    .replace(/\\/\\/.*$/g, \"\")) // Remove line comments\n    .filter(p => p.trim().length > 0) // Remove empty strings after removing comments\n    .map(p => p.trim()) // Trim remaining whitespace\n    .join(\", \");\n  } // Extract function docstring (block comment)\n\n\n  let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n  const docstringBlock = docMatch && docMatch[1].trim() || \"\"; // Extract function docstring (line comment)\n\n  docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n  const docstringLine = docMatch && docMatch[1].split(\"\\n\").map(s => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n  const docstring = docstringBlock || docstringLine;\n  return name && params.length > 0 && {\n    name: name,\n    sig: params,\n    doc: docstring\n  };\n}\n\nfunction concatArrayBuffers(buffers) {\n  var buffersLengths = buffers.map(function (b) {\n    return b.byteLength;\n  }),\n      totalBufferlength = buffersLengths.reduce(function (p, c) {\n    return p + c;\n  }, 0),\n      unit8Arr = new Uint8Array(totalBufferlength);\n  buffersLengths.reduce(function (p, c, i) {\n    unit8Arr.set(new Uint8Array(buffers[i]), p);\n    return p + c;\n  }, 0);\n  return unit8Arr.buffer;\n}\n\nclass Timer {\n  constructor(timeout, callback, args, label) {\n    this._timeout = timeout;\n    this._callback = callback;\n    this._args = args;\n    this._label = label || \"timer\";\n    this._task = null;\n    this.started = false;\n  }\n\n  start() {\n    if (this.started) {\n      this.reset();\n    } else {\n      this._task = setTimeout(() => {\n        this._callback.apply(this, this._args);\n      }, this._timeout * 1000);\n      this.started = true;\n    }\n  }\n\n  clear() {\n    if (this._task) {\n      clearTimeout(this._task);\n      this._task = null;\n      this.started = false;\n    } else {\n      console.warn(`Clearing a timer (${this._label}) which is not started`);\n    }\n  }\n\n  reset() {\n    if (this._task) {\n      clearTimeout(this._task);\n    }\n\n    this._task = setTimeout(() => {\n      this._callback.apply(this, this._args);\n    }, this._timeout * 1000);\n    this.started = true;\n  }\n\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, {\n    client_id = null,\n    manager_id = null,\n    default_context = null,\n    name = null,\n    codecs = null,\n    method_timeout = null,\n    max_message_buffer_size = 0,\n    debug = false,\n    workspace = null\n  }) {\n    super(debug);\n    this._codecs = codecs || {};\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n    this._client_id = client_id;\n    this._name = name;\n    this._connection_info = null;\n    this._workspace = null;\n    this._local_workspace = workspace;\n    this.manager_id = manager_id;\n    this.default_context = default_context || {};\n    this._method_annotations = new WeakMap();\n    this._manager_service = null;\n    this._max_message_buffer_size = max_message_buffer_size;\n    this._chunk_store = {};\n    this._method_timeout = method_timeout || 30; // make sure there is an execute function\n\n    this._services = {};\n    this._object_store = {\n      services: this._services\n    };\n\n    if (connection) {\n      this.add_service({\n        id: \"built-in\",\n        type: \"built-in\",\n        name: \"RPC built-in services\",\n        config: {\n          require_context: true,\n          visibility: \"public\"\n        },\n        ping: this._ping.bind(this),\n        get_service: this.get_local_service.bind(this),\n        register_service: this.register_service.bind(this),\n        message_cache: {\n          create: this._create_message.bind(this),\n          append: this._append_message.bind(this),\n          process: this._process_message.bind(this),\n          remove: this._remove_message.bind(this)\n        }\n      });\n      this.on(\"method\", this._handle_method.bind(this));\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n      this._emit_message = connection.emit_message.bind(connection);\n      connection.on_message(this._on_message.bind(this));\n      this._connection = connection; // Update the server and obtain client info\n\n      this._get_connection_info();\n    } else {\n      this._emit_message = function () {\n        console.log(\"No connection to emit message\");\n      };\n    }\n  }\n\n  async _get_connection_info() {\n    if (this.manager_id) {\n      // try to get the root service\n      try {\n        await this.get_manager_service(30.0);\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n        this._connection_info = await this._manager_service.get_connection_info();\n\n        if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n          this._local_workspace = this._connection_info.workspace;\n        }\n\n        if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n          this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n\n          const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8; // console.info(\n          //   `Reconnection token obtained: ${this._connection_info.reconnection_token}, will be refreshed in ${reconnection_expires_in} seconds`\n          // );\n\n          this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1000);\n        }\n      } catch (exp) {\n        console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n      }\n    }\n  }\n\n  register_codec(config) {\n    if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n      throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n    } else {\n      if (config.type) {\n        for (let k of Object.keys(this._codecs)) {\n          if (this._codecs[k].type === config.type || k === config.name) {\n            delete this._codecs[k];\n            console.warn(\"Remove duplicated codec: \" + k);\n          }\n        }\n      }\n\n      this._codecs[config[\"name\"]] = config;\n    }\n  }\n\n  async _ping(msg, context) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n    return \"pong\";\n  }\n\n  async ping(client_id, timeout) {\n    let method = this._generate_remote_method({\n      _rtarget: client_id,\n      _rmethod: \"services.built-in.ping\",\n      _rpromise: true,\n      _rdoc: \"Ping a remote client\",\n      _rsig: \"ping(msg)\"\n    });\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])((await method(\"ping\", timeout)) == \"pong\");\n  }\n\n  _create_message(key, heartbeat, overwrite, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    if (!this._object_store[\"message_cache\"]) {\n      this._object_store[\"message_cache\"] = {};\n    }\n\n    if (!overwrite && this._object_store[\"message_cache\"][key]) {\n      throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n    }\n\n    this._object_store[\"message_cache\"][key] = [];\n  }\n\n  _append_message(key, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    const cache = this._object_store[\"message_cache\"];\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n    cache[key].push(data);\n  }\n\n  _remove_message(key, context) {\n    const cache = this._object_store[\"message_cache\"];\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    delete cache[key];\n  }\n\n  _process_message(key, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    const cache = this._object_store[\"message_cache\"];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    cache[key] = concatArrayBuffers(cache[key]);\n    console.debug(`Processing message ${key} (size=${cache[key].length})`);\n    let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n    const {\n      done,\n      value\n    } = unpacker.next();\n    const main = value; // Make sure the fields are from trusted source\n\n    Object.assign(main, {\n      from: context.from,\n      to: context.to,\n      user: context.user\n    });\n    main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n    Object.assign(main[\"ctx\"], this.default_context);\n\n    if (!done) {\n      let extra = unpacker.next();\n      Object.assign(main, extra.value);\n    }\n\n    this._fire(main[\"type\"], main);\n\n    delete cache[key];\n  }\n\n  _on_message(message) {\n    try {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n      let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n      const {\n        done,\n        value\n      } = unpacker.next();\n      const main = value; // Add trusted context to the method call\n\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n\n      if (!done) {\n        let extra = unpacker.next();\n        Object.assign(main, extra.value);\n      }\n\n      this._fire(main[\"type\"], main);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._services = {};\n  }\n\n  async disconnect() {\n    if (this._get_connection_info_task) {\n      clearTimeout(this._get_connection_info_task);\n      this._get_connection_info_task = null;\n    }\n\n    this._fire(\"disconnect\");\n  }\n\n  async get_manager_service(timeout) {\n    if (this.manager_id && !this._manager_service) {\n      this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n    }\n  }\n\n  get_all_local_services() {\n    return this._services;\n  }\n\n  get_local_service(service_id, context) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n    const [ws, client_id] = context[\"to\"].split(\"/\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n    const service = this._services[service_id];\n\n    if (!service) {\n      throw new Error(\"Service not found: \" + service_id);\n    } // allow access for the same workspace\n\n\n    if (service.config.visibility == \"public\") {\n      return service;\n    } // allow access for the same workspace\n\n\n    if (context[\"from\"].startsWith(ws + \"/\")) {\n      return service;\n    }\n\n    throw new Error(\"Permission denied for service: \" + service_id);\n  }\n\n  async get_remote_service(service_uri, timeout) {\n    timeout = timeout === undefined ? this._method_timeout : timeout;\n\n    if (!service_uri && this.manager_id) {\n      service_uri = this.manager_id;\n    } else if (!service_uri.includes(\":\")) {\n      service_uri = this._client_id + \":\" + service_uri;\n    }\n\n    const provider = service_uri.split(\":\")[0];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n\n    try {\n      const method = this._generate_remote_method({\n        _rtarget: provider,\n        _rmethod: \"services.built-in.get_service\",\n        _rpromise: true,\n        _rdoc: \"Get a remote service\",\n        _rsig: \"get_service(service_id)\"\n      });\n\n      const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n      svc.id = service_uri;\n      return svc;\n    } catch (e) {\n      console.error(\"Failed to get remote service: \" + service_uri, e);\n      throw e;\n    }\n  }\n\n  _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n    if (typeof aObject === \"function\") {\n      // mark the method as a remote method that requires context\n      let method_name = object_id.split(\".\")[1];\n\n      this._method_annotations.set(aObject, {\n        require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n        run_in_executor: run_in_executor,\n        method_id: \"services.\" + object_id,\n        visibility: visibility\n      });\n    } else if (aObject instanceof Array || aObject instanceof Object) {\n      for (let key of Object.keys(aObject)) {\n        let val = aObject[key];\n\n        if (typeof val === \"function\" && val.__rpc_object__) {\n          let client_id = val.__rpc_object__._rtarget;\n\n          if (client_id.includes(\"/\")) {\n            client_id = client_id.split(\"/\")[1];\n          }\n\n          if (this._client_id === client_id) {\n            if (aObject instanceof Array) {\n              aObject = aObject.slice();\n            } // recover local method\n\n\n            aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n            val = aObject[key]; // make sure it's annotated later\n          } else {\n            throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n          }\n        }\n\n        this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n      }\n    }\n  }\n\n  add_service(api, overwrite) {\n    if (!api || Array.isArray(api)) throw new Error(\"Invalid service object\");\n\n    if (api.constructor === Object) {\n      api = Object.assign({}, api);\n    } else {\n      const normApi = {};\n      const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n\n      for (let k of props) {\n        if (k !== \"constructor\") {\n          if (typeof api[k] === \"function\") normApi[k] = api[k].bind(api);else normApi[k] = api[k];\n        }\n      } // For class instance, we need set a default id\n\n\n      api.id = api.id || \"default\";\n      api = normApi;\n    }\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n\n    if (!api.name) {\n      api.name = api.id;\n    }\n\n    if (!api.config) {\n      api.config = {};\n    }\n\n    if (!api.type) {\n      api.type = \"generic\";\n    } // require_context only applies to the top-level functions\n\n\n    let require_context = false,\n        run_in_executor = false;\n    if (api.config.require_context) require_context = api.config.require_context;\n    if (api.config.run_in_executor) run_in_executor = true;\n    const visibility = api.config.visibility || \"protected\";\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n\n    this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n\n    if (this._services[api.id]) {\n      if (overwrite) {\n        delete this._services[api.id];\n      } else {\n        throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n      }\n    }\n\n    this._services[api.id] = api;\n    return api;\n  }\n\n  async register_service(api, overwrite, notify, context) {\n    if (notify === undefined) notify = true;\n\n    if (context) {\n      // If this function is called from remote, we need to make sure\n      const [workspace, client_id] = context[\"to\"].split(\"/\");\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n    }\n\n    const service = this.add_service(api, overwrite);\n\n    if (notify) {\n      this._fire(\"service-updated\", {\n        service_id: service[\"id\"],\n        api: service,\n        type: \"add\"\n      });\n\n      await this._notify_service_update();\n    }\n\n    return {\n      id: `${this._client_id}:${service[\"id\"]}`,\n      type: service[\"type\"],\n      name: service[\"name\"],\n      description: service[\"description\"] || \"\",\n      config: service[\"config\"]\n    };\n  }\n\n  async unregister_service(service, notify) {\n    if (service instanceof Object) {\n      service = service.id;\n    }\n\n    if (!this._services[service]) {\n      throw new Error(`Service not found: ${service}`);\n    }\n\n    const api = this._services[service];\n    delete this._services[service];\n\n    this._fire(\"service-updated\", {\n      service_id: service,\n      api: api,\n      type: \"remove\"\n    });\n\n    await this._notify_service_update();\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n\n  _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n    let method_id = `${session_id}.${name}`;\n    let encoded = {\n      _rtype: \"method\",\n      _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n      _rmethod: method_id,\n      _rpromise: false\n    };\n    const self = this;\n\n    let wrapped_callback = function () {\n      try {\n        callback.apply(null, Array.prototype.slice.call(arguments));\n      } catch (error) {\n        console.error(\"Error in callback:\", method_id, error);\n      } finally {\n        if (clear_after_called && self._object_store[session_id]) {\n          // console.log(\"Deleting session\", session_id, \"from\", self._client_id);\n          delete self._object_store[session_id];\n        }\n\n        if (timer && timer.started) {\n          timer.clear();\n        }\n      }\n    };\n\n    return [encoded, wrapped_callback];\n  }\n\n  async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n    let store = this._get_session_store(session_id, true);\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n    let encoded = {};\n\n    if (timer && reject && this._method_timeout) {\n      encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n      encoded.interval = this._method_timeout / 2;\n      store.timer = timer;\n    } else {\n      timer = null;\n    }\n\n    [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n    [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n    return encoded;\n  }\n\n  async _send_chunks(data, target_id, session_id) {\n    let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n    let message_cache = remote_services.message_cache;\n    let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n    await message_cache.create(message_id, !!session_id);\n    let total_size = data.length;\n    let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n\n    for (let idx = 0; idx < chunk_num; idx++) {\n      let start_byte = idx * CHUNK_SIZE;\n      await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id); // console.log(\n      //   `Sending chunk ${idx + 1}/${chunk_num} (${total_size} bytes)`\n      // );\n    } // console.log(`All chunks sent (${chunk_num})`);\n\n\n    await message_cache.process(message_id, !!session_id);\n  }\n\n  emit(main_message, extra_data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n    let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n\n    if (extra_data) {\n      const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n      message_package = new Uint8Array([...message_package, ...extra]);\n    }\n\n    const total_size = message_package.length;\n\n    if (total_size <= CHUNK_SIZE + 1024) {\n      return this._emit_message(message_package);\n    } else {\n      throw new Error(\"Message is too large to send in one go.\");\n    }\n  }\n\n  _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n    let target_id = encoded_method._rtarget;\n\n    if (remote_workspace && !target_id.includes(\"/\")) {\n      if (remote_workspace !== target_id) {\n        target_id = remote_workspace + \"/\" + target_id;\n      } // Fix the target id to be an absolute id\n\n\n      encoded_method._rtarget = target_id;\n    }\n\n    let method_id = encoded_method._rmethod;\n    let with_promise = encoded_method._rpromise;\n    const self = this;\n\n    function remote_method() {\n      return new Promise(async (resolve, reject) => {\n        let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n        if (local_parent) {\n          // Store the children session under the parent\n          local_session_id = local_parent + \".\" + local_session_id;\n        }\n\n        let store = self._get_session_store(local_session_id, true);\n\n        if (!store) {\n          reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n          return;\n        }\n\n        store[\"target_id\"] = target_id;\n        const args = await self._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n        let main_message = {\n          type: \"method\",\n          from: self._local_workspace ? self._local_workspace + \"/\" + self._client_id : self._client_id,\n          to: target_id,\n          method: method_id\n        };\n        let extra_data = {};\n\n        if (args) {\n          extra_data[\"args\"] = args;\n        }\n\n        if (withKwargs) {\n          extra_data[\"with_kwargs\"] = withKwargs;\n        } // console.log(\n        //   `Calling remote method ${target_id}:${method_id}, session: ${local_session_id}`\n        // );\n\n\n        if (remote_parent) {\n          // Set the parent session\n          // Note: It's a session id for the remote, not the current client\n          main_message[\"parent\"] = remote_parent;\n        }\n\n        let timer = null;\n\n        if (with_promise) {\n          // Only pass the current session id to the remote\n          // if we want to received the result\n          // I.e. the session id won't be passed for promises themselves\n          main_message[\"session\"] = local_session_id;\n          let method_name = `${target_id}:${method_id}`;\n          timer = new Timer(self._method_timeout, reject, [`Method call time out: ${method_name}`], method_name); // By default, hypha will clear the session after the method is called\n          // However, if the args contains _rintf === true, we will not clear the session\n\n          let clear_after_called = true;\n\n          for (let arg of args) {\n            if (typeof arg === \"object\" && arg._rintf === true) {\n              clear_after_called = false;\n              break;\n            }\n          }\n\n          extra_data[\"promise\"] = await self._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n        } // The message consists of two segments, the main message and extra data\n\n\n        let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n\n        if (extra_data) {\n          const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n          message_package = new Uint8Array([...message_package, ...extra]);\n        }\n\n        const total_size = message_package.length;\n\n        if (total_size <= CHUNK_SIZE + 1024) {\n          self._emit_message(message_package).then(function () {\n            if (timer) {\n              // console.log(`Start watchdog timer.`);\n              // Only start the timer after we send the message successfully\n              timer.start();\n            }\n          });\n        } else {\n          // send chunk by chunk\n          self._send_chunks(message_package, target_id, remote_parent).then(function () {\n            if (timer) {\n              // console.log(`Start watchdog timer.`);\n              // Only start the timer after we send the message successfully\n              timer.start();\n            }\n          });\n        }\n      });\n    } // Generate debugging information for the method\n\n\n    remote_method.__rpc_object__ = encoded_method;\n    const parts = method_id.split(\".\");\n    remote_method.__name__ = parts[parts.length - 1];\n    remote_method.__doc__ = encoded_method._rdoc;\n    remote_method.__sig__ = encoded_method._rsig;\n    return remote_method;\n  }\n\n  async _notify_service_update() {\n    if (this.manager_id) {\n      // try to get the root service\n      try {\n        await this.get_manager_service(30.0);\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n        await this._manager_service.update_client_info(this.get_client_info());\n      } catch (exp) {\n        // pylint: disable=broad-except\n        console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n      }\n    }\n  }\n\n  get_client_info() {\n    const services = [];\n\n    for (let service of Object.values(this._services)) {\n      services.push({\n        id: `${this._client_id}:${service[\"id\"]}`,\n        type: service[\"type\"],\n        name: service[\"name\"],\n        description: service[\"description\"] || \"\",\n        config: service[\"config\"]\n      });\n    }\n\n    return {\n      id: this._client_id,\n      services: services\n    };\n  }\n\n  async _handle_method(data) {\n    let reject = null;\n    let heartbeat_task = null;\n\n    try {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n      const method_name = data.from + \":\" + data.method;\n      const remote_workspace = data.from.split(\"/\")[0]; // Make sure the target id is an absolute id\n\n      data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n      data[\"ctx\"][\"to\"] = data[\"to\"];\n      const local_workspace = data.to.split(\"/\")[0];\n      const local_parent = data.parent;\n      let resolve, reject;\n\n      if (data.promise) {\n        // Decode the promise with the remote session id\n        // Such that the session id will be passed to the remote as a parent session id\n        const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n        resolve = promise.resolve;\n        reject = promise.reject;\n\n        if (promise.heartbeat && promise.interval) {\n          async function heartbeat() {\n            try {\n              // console.log(\"Reset heartbeat timer: \" + data.method);\n              await promise.heartbeat();\n            } catch (err) {\n              console.error(err);\n            }\n          }\n\n          heartbeat_task = setInterval(heartbeat, promise.interval * 1000);\n        }\n      }\n\n      let method;\n\n      try {\n        method = indexObject(this._object_store, data[\"method\"]);\n      } catch (e) {\n        console.debug(\"Failed to find method\", method_name, e);\n        throw new Error(`Method not found: ${method_name}`);\n      }\n\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name); // Check permission\n\n      if (this._method_annotations.has(method)) {\n        // For services, it should not be protected\n        if (this._method_annotations.get(method).visibility === \"protected\") {\n          if (local_workspace !== remote_workspace) {\n            throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n          }\n        }\n      } else {\n        // For sessions, the target_id should match exactly\n        let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n\n        if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n          session_target_id = local_workspace + \"/\" + session_target_id;\n        }\n\n        if (session_target_id !== data.from) {\n          throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n        }\n      } // Make sure the parent session is still open\n\n\n      if (local_parent) {\n        // The parent session should be a session that generate the current method call\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n      }\n\n      let args;\n\n      if (data.args) {\n        args = await this._decode(data.args, data.session, null, remote_workspace, null);\n      } else {\n        args = [];\n      }\n\n      if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n        args.push(data.ctx);\n      } // console.log(\"Executing method: \" + method_name);\n\n\n      if (data.promise) {\n        const result = method.apply(null, args);\n\n        if (result instanceof Promise) {\n          result.then(result => {\n            resolve(result);\n            clearInterval(heartbeat_task);\n          }).catch(err => {\n            reject(err);\n            clearInterval(heartbeat_task);\n          });\n        } else {\n          resolve(result);\n          clearInterval(heartbeat_task);\n        }\n      } else {\n        method.apply(null, args);\n        clearInterval(heartbeat_task);\n      }\n    } catch (err) {\n      if (reject) {\n        reject(err);\n        console.debug(\"Error during calling method: \", err);\n      } else {\n        console.error(\"Error during calling method: \", err);\n      } // make sure we clear the heartbeat timer\n\n\n      clearInterval(heartbeat_task);\n    }\n  }\n\n  encode(aObject, session_id) {\n    return this._encode(aObject, session_id);\n  }\n\n  _get_session_store(session_id, create) {\n    let store = this._object_store;\n    const levels = session_id.split(\".\");\n\n    if (create) {\n      const last_index = levels.length - 1;\n\n      for (let level of levels.slice(0, last_index)) {\n        if (!store[level]) {\n          return null;\n        }\n\n        store = store[level];\n      } // Create the last level\n\n\n      if (!store[levels[last_index]]) {\n        store[levels[last_index]] = {};\n      }\n\n      return store[levels[last_index]];\n    } else {\n      for (let level of levels) {\n        if (!store[level]) {\n          return null;\n        }\n\n        store = store[level];\n      }\n\n      return store;\n    }\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  async _encode(aObject, session_id, local_workspace) {\n    const aType = typeof aObject;\n\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof Uint8Array) {\n      return aObject;\n    }\n\n    if (aObject instanceof ArrayBuffer) {\n      return {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject)\n      };\n    } // Reuse the remote object\n\n\n    if (aObject.__rpc_object__) {\n      return aObject.__rpc_object__;\n    }\n\n    let bObject; // skip if already encoded\n\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      const temp = aObject._rtype;\n      delete aObject._rtype;\n      bObject = await this._encode(aObject, session_id, local_workspace);\n      bObject._rtype = temp;\n      return bObject;\n    }\n\n    if (typeof aObject === \"function\") {\n      if (this._method_annotations.has(aObject)) {\n        let annotation = this._method_annotations.get(aObject);\n\n        bObject = {\n          _rtype: \"method\",\n          _rtarget: this._client_id,\n          _rmethod: annotation.method_id,\n          _rpromise: true\n        };\n      } else {\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n        let object_id;\n\n        if (aObject.__name__) {\n          object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n        } else {\n          object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n        }\n\n        bObject = {\n          _rtype: \"method\",\n          _rtarget: this._client_id,\n          _rmethod: `${session_id}.${object_id}`,\n          _rpromise: true\n        };\n\n        let store = this._get_session_store(session_id, true);\n\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n        store[object_id] = aObject;\n      }\n\n      bObject._rdoc = aObject.__doc__;\n      bObject._rsig = aObject.__sig__;\n\n      if (!bObject._rdoc || !bObject._rsig) {\n        try {\n          const funcInfo = getFunctionInfo(aObject);\n\n          if (funcInfo && !bObject._rdoc) {\n            bObject._rdoc = `${funcInfo.doc}`;\n          }\n\n          if (funcInfo && !bObject._rsig) {\n            bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n          }\n        } catch (e) {\n          console.error(\"Failed to extract function docstring:\", aObject);\n        }\n      }\n\n      return bObject;\n    }\n\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\n\n        if (typeof encodedObj === \"object\") {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n          encodedObj._rtype = temp;\n        }\n\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n    /*global tf*/\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\n      const v_buffer = aObject.dataSync();\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(v_buffer.buffer),\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype\n      };\n    } else if (\n    /*global nj*/\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(aObject.selection.data.buffer),\n        _rshape: aObject.shape,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString(),\n        _rtrace: aObject.stack\n      };\n    } // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\n    } else if (aObject instanceof Blob) {\n      let _current_pos = 0;\n\n      async function read(length) {\n        let blob;\n\n        if (length) {\n          blob = aObject.slice(_current_pos, _current_pos + length);\n        } else {\n          blob = aObject.slice(_current_pos);\n        }\n\n        const ret = new Uint8Array(await blob.arrayBuffer());\n        _current_pos = _current_pos + ret.byteLength;\n        return ret;\n      }\n\n      function seek(pos) {\n        _current_pos = pos;\n      }\n\n      bObject = {\n        _rtype: \"iostream\",\n        _rnative: \"js:blob\",\n        type: aObject.type,\n        name: aObject.name,\n        size: aObject.size,\n        path: aObject._path || aObject.webkitRelativePath,\n        read: await this._encode(read, session_id, local_workspace),\n        seek: await this._encode(seek, session_id, local_workspace)\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: new Uint8Array(aObject.buffer),\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof DataView) {\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject.buffer)\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n      };\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n      bObject = isarray ? [] : {};\n      const keys = Object.keys(aObject);\n\n      for (let k of keys) {\n        bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n      }\n    } else {\n      throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n\n    return bObject;\n  }\n\n  async decode(aObject) {\n    return await this._decode(aObject);\n  }\n\n  async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (aObject._rtype) {\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n        aObject._rtype = temp;\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n      } else if (aObject._rtype === \"method\") {\n        bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n\n        const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n\n        bObject = new arraytype(buffer);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength); // ArrayBuffer\n      } else if (aObject._rtype === \"iostream\") {\n        if (aObject._rnative === \"js:blob\") {\n          const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n          const bytes = await read();\n          bObject = new Blob([bytes], {\n            type: aObject.type,\n            name: aObject.name\n          });\n        } else {\n          bObject = {};\n\n          for (let k of Object.keys(aObject)) {\n            if (!k.startsWith(\"_\")) {\n              bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n            }\n          }\n        }\n\n        bObject[\"__rpc_object__\"] = aObject;\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n      } else {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n        bObject._rtype = temp;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    }\n\n    return bObject;\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/hypha/sse-client.js\":\n/*!*********************************!*\\\n  !*** ./src/hypha/sse-client.js ***!\n  \\*********************************/\n/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, getRTCService, registerRTCService, login, connectToServer */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_151978__) {\n\n\"use strict\";\n__nested_webpack_require_151978__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"login\", function() { return login; });\n/* harmony export (binding) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"connectToServer\", function() { return connectToServer; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_151978__(/*! ./rpc.js */ \"./src/hypha/rpc.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"API_VERSION\"]; });\n\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_151978__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"loadRequirements\"]; });\n\n/* harmony import */ var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_151978__(/*! ./webrtc-client.js */ \"./src/hypha/webrtc-client.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"getRTCService\", function() { return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"registerRTCService\", function() { return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_151978__(/*! ../../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__nested_webpack_require_151978__.t(/*! ../../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __nested_webpack_require_151978__.d(__nested_webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_3__[\"version\"]; });\n\n\n\n\n\n\n\n\n\nfunction b64toArrayBuffer(base64, type = \"application/octet-stream\") {\n  return fetch(`data:${type};base64,${base64}`).then(res => res.arrayBuffer());\n}\n\nclass SSERPCConnection {\n  constructor(server_url, client_id, workspace, token, timeout = 120) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(server_url && client_id, \"server_url and client_id are required\");\n    server_url = server_url + \"?client_id=\" + client_id;\n\n    if (workspace) {\n      server_url += \"&workspace=\" + workspace;\n    }\n\n    if (token) {\n      server_url += \"&token=\" + token;\n    }\n\n    server_url += \"&session_id=\" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n    this._events = null;\n    this._handle_message = null;\n    this._reconnection_token = null;\n    this._server_url = server_url;\n    this._timeout = timeout * 1000; // converting to ms\n\n    this._opening = false;\n    this._retry_count = 0;\n    this._closing = false;\n  }\n\n  set_reconnection_token(token) {\n    this._reconnection_token = token;\n  }\n\n  on_message(handler) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  open() {\n    if (this._opening) return this._opening;\n    this._opening = new Promise((resolve, reject) => {\n      const server_url = this._reconnection_token ? `${this._server_url}&reconnection_token=${this._reconnection_token}` : this._server_url;\n      console.info(\"Creating a new connection to \", server_url.split(\"?\")[0]);\n      this._events = new EventSource(server_url);\n\n      this._events.onmessage = async event => {\n        const data = await b64toArrayBuffer(event.data);\n\n        this._handle_message(data);\n      };\n\n      this._events.onclose = event => {\n        console.log(\"eventsource closed\");\n\n        if (!this._closing) {\n          console.log(\"Connection interrupted, retrying...\");\n          this._retry_count++;\n          setTimeout(() => this.open(), this._timeout);\n        }\n\n        this._events = null;\n        this._opening = false;\n        reject(\"closed\");\n      };\n\n      this._events.onerror = event => {\n        console.trace();\n        console.log(\"Error occurred in eventsource connection: \", event.message); // this._events = null;\n\n        debugger; // this._opening = false;\n\n        reject(event.toString());\n      };\n\n      this._events.onopen = event => {\n        resolve(true);\n      };\n    });\n    return this._opening;\n  }\n\n  async _send(data) {\n    await fetch(this._server_url, {\n      method: \"POST\",\n      mode: \"cors\",\n      // no-cors, *cors, same-origin\n      cache: \"no-cache\",\n      // *default, no-cache, reload, force-cache, only-if-cached\n      credentials: \"same-origin\",\n      // include, *same-origin, omit\n      headers: {\n        \"Content-Type\": \"octet-stream\" // 'Content-Type': 'application/x-www-form-urlencoded',\n\n      },\n      redirect: \"follow\",\n      // manual, *follow, error\n      referrerPolicy: \"no-referrer\",\n      // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n      body: data // body data type must match \"Content-Type\" header\n\n    });\n  }\n\n  async emit_message(data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n\n    if (!this._events || this._events.readyState === EventSource.CLOSED) {\n      await this.open();\n    }\n\n    await this._send(data);\n  }\n\n  disconnect(reason) {\n    this._closing = true;\n    const ev = this._events;\n    this._events = null;\n\n    if (ev && ev.readyState === EventSource.OPEN) {\n      ev.close();\n    }\n\n    console.info(`EventSource connection disconnected (${reason})`);\n  }\n\n}\n\nfunction normalizeServerUrl(server_url) {\n  if (!server_url) throw new Error(\"server_url is required\");\n  server_url = server_url.replace(/\\/$/, \"\") + \"/sse\";\n  return server_url;\n}\n\nasync function login(config) {\n  const service_id = config.login_service_id || \"public/*:hypha-login\";\n  const timeout = config.login_timeout || 120;\n  const callback = config.login_callback;\n  const server = await connectToServer({\n    name: \"initial login client\",\n    server_url: config.server_url,\n    method_timeout: timeout\n  });\n\n  try {\n    const svc = await server.get_service(service_id);\n    const context = await svc.start();\n\n    if (callback) {\n      await callback(context);\n    } else {\n      console.log(`Please open your browser and login at ${context.login_url}`);\n    }\n\n    return await svc.check(context.key, timeout);\n  } catch (error) {\n    throw error;\n  } finally {\n    await server.disconnect();\n  }\n}\nasync function connectToServer(config) {\n  let clientId = config.client_id;\n\n  if (!clientId) {\n    clientId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n  }\n\n  let server_url = normalizeServerUrl(config.server_url);\n  let connection = new SSERPCConnection(server_url, clientId, config.workspace, config.token, config.method_timeout || 120);\n  await connection.open();\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n    client_id: clientId,\n    manager_id: \"workspace-manager\",\n    default_context: {\n      connection_type: \"eventsource\"\n    },\n    name: config.name,\n    method_timeout: config.method_timeout\n  });\n  const wm = await rpc.get_remote_service(\"workspace-manager:default\", config.method_timeout);\n  wm.rpc = rpc;\n\n  async function _export(api) {\n    api.id = \"default\";\n    api.name = config.name || api.id;\n    await rpc.register_service(api, true); // const svc = await rpc.get_remote_service(rpc._client_id + \":default\");\n    // if (svc.setup) {\n    //   await svc.setup();\n    // }\n  }\n\n  async function getPlugin(query) {\n    return await wm.get_service(query + \":default\");\n  }\n\n  async function disconnect() {\n    await rpc.disconnect();\n    await connection.disconnect();\n  }\n\n  wm.export = _export;\n  wm.getPlugin = getPlugin;\n  wm.listPlugins = wm.listServices;\n  wm.disconnect = disconnect;\n  wm.registerCodec = rpc.register_codec.bind(rpc);\n\n  if (config.webrtc) {\n    await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"])(wm, clientId + \"-rtc\", config.webrtc_config);\n  }\n\n  if (wm.get_service || wm.getService) {\n    const _get_service = wm.get_service || wm.getService;\n\n    wm.get_service = async function (query, webrtc, webrtc_config) {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])([undefined, true, false, \"auto\"].includes(webrtc), \"webrtc must be true, false or 'auto'\");\n      const svc = await _get_service(query);\n\n      if (webrtc === true || webrtc === \"auto\") {\n        if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n          const client = svc.id.split(\":\")[0];\n\n          try {\n            // Assuming that the client registered a webrtc service with the client_id + \"-rtc\"\n            const peer = await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"])(wm, client + \":\" + client.split(\"/\")[1] + \"-rtc\", webrtc_config);\n            const rtcSvc = await peer.get_service(svc.id.split(\":\")[1]);\n            rtcSvc._webrtc = true;\n            rtcSvc._peer = peer;\n            rtcSvc._service = svc;\n            return rtcSvc;\n          } catch (e) {\n            console.warn(\"Failed to get webrtc service, using eventsource connection\", e);\n          }\n        }\n\n        if (webrtc === true) {\n          throw new Error(\"Failed to get the service via webrtc\");\n        }\n      }\n\n      return svc;\n    };\n\n    wm.getService = wm.get_service;\n  }\n\n  return wm;\n}\n\n/***/ }),\n\n/***/ \"./src/hypha/utils.js\":\n/*!****************************!*\\\n  !*** ./src/hypha/utils.js ***!\n  \\****************************/\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_162063__) {\n\n\"use strict\";\n__nested_webpack_require_162063__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"assert\", function() { return assert; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"waitFor\", function() { return waitFor; });\n/* harmony export (binding) */ __nested_webpack_require_162063__.d(__nested_webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array\n};\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  } // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      var link_node;\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            await import(\n            /* webpackIgnore: true */\n            requirements[i]);\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nasync function loadRequirementsInWebworker(requirements) {\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n\n      for (var i = 0; i < requirements.length; i++) {\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n          throw \"unable to import css in a webworker\";\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nfunction loadRequirements(requirements) {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false; // remove functions\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\nconst typedArrayToDtypeKeys = [];\n\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n    await cacheUrlInServiceWorker(req).catch(e => {\n      console.error(e);\n    });\n  }\n}\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    baseUrl = baseUrl || \"/\";\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\n      // Registration was successful\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n    }, function (err) {\n      // registration failed :(\n      console.log(\"ServiceWorker registration failed: \", err);\n    });\n    targetOrigin = targetOrigin || \"*\";\n    cacheCallback = cacheCallback || cacheRequirements;\n\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\n      throw new Error(\"config.cache_requirements must be a function\");\n    }\n\n    window.addEventListener(\"message\", function (e) {\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n        const m = e.data;\n\n        if (m.type === \"cacheRequirements\") {\n          cacheCallback(m.requirements);\n        }\n      }\n    });\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nfunction waitFor(prom, time, error) {\n  let timer;\n  return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n    rej(error || \"Timeout Error\");\n  }, time * 1000))]).finally(() => clearTimeout(timer));\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/hypha/webrtc-client.js\":\n/*!************************************!*\\\n  !*** ./src/hypha/webrtc-client.js ***!\n  \\************************************/\n/*! exports provided: getRTCService, registerRTCService */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_174603__) {\n\n\"use strict\";\n__nested_webpack_require_174603__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_174603__.d(__nested_webpack_exports__, \"getRTCService\", function() { return getRTCService; });\n/* harmony export (binding) */ __nested_webpack_require_174603__.d(__nested_webpack_exports__, \"registerRTCService\", function() { return registerRTCService; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_174603__(/*! ./rpc.js */ \"./src/hypha/rpc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_174603__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n\n\n\nclass WebRTCConnection {\n  constructor(channel) {\n    this._data_channel = channel;\n    this._handle_message = null;\n    this._reconnection_token = null;\n\n    this._data_channel.onmessage = async event => {\n      let data = event.data;\n\n      if (data instanceof Blob) {\n        data = await data.arrayBuffer();\n      }\n\n      this._handle_message(data);\n    };\n\n    const self = this;\n\n    this._data_channel.onclose = function () {\n      console.log(\"websocket closed\");\n      self._data_channel = null;\n    };\n  }\n\n  set_reconnection_token(token) {\n    this._reconnection_token = token;\n  }\n\n  on_message(handler) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  async emit_message(data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n\n    try {\n      this._data_channel.send(data);\n    } catch (exp) {\n      //   data = msgpack_unpackb(data);\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  async disconnect(reason) {\n    this._data_channel = null;\n    console.info(`data channel connection disconnected (${reason})`);\n  }\n\n}\n\nasync function _setupRPC(config) {\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.channel, \"No channel provided\");\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.workspace, \"No workspace provided\");\n  const channel = config.channel;\n  const clientId = config.client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n  const connection = new WebRTCConnection(channel);\n  config.context = config.context || {};\n  config.context.connection_type = \"webrtc\";\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n    client_id: clientId,\n    manager_id: null,\n    default_context: config.context,\n    name: config.name,\n    method_timeout: config.method_timeout || 10.0,\n    workspace: config.workspace\n  });\n  return rpc;\n}\n\nasync function _createOffer(params, server, config, onInit, context) {\n  config = config || {};\n  let offer = new RTCSessionDescription({\n    sdp: params.sdp,\n    type: params.type\n  });\n  let pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [{\n      urls: [\"stun:stun.l.google.com:19302\"]\n    }],\n    sdpSemantics: \"unified-plan\"\n  });\n\n  if (server) {\n    pc.addEventListener(\"datachannel\", async event => {\n      const channel = event.channel;\n      let ctx = null;\n      if (context && context.user) ctx = {\n        user: context.user\n      };\n      const rpc = await _setupRPC({\n        channel: channel,\n        client_id: channel.label,\n        workspace: server.config.workspace,\n        context: ctx\n      }); // Map all the local services to the webrtc client\n\n      rpc._services = server.rpc._services;\n    });\n  }\n\n  if (onInit) {\n    await onInit(pc);\n  }\n\n  await pc.setRemoteDescription(offer);\n  let answer = await pc.createAnswer();\n  await pc.setLocalDescription(answer);\n  return {\n    sdp: pc.localDescription.sdp,\n    type: pc.localDescription.type,\n    workspace: server.config.workspace\n  };\n}\n\nasync function getRTCService(server, service_id, config) {\n  config = config || {};\n  config.peer_id = config.peer_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n  const pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [{\n      urls: [\"stun:stun.l.google.com:19302\"]\n    }],\n    sdpSemantics: \"unified-plan\"\n  });\n  return new Promise(async (resolve, reject) => {\n    try {\n      pc.addEventListener(\"connectionstatechange\", () => {\n        if (pc.connectionState === \"failed\") {\n          pc.close();\n          reject(new Error(\"Connection failed\"));\n        }\n      }, false);\n\n      if (config.on_init) {\n        await config.on_init(pc);\n        delete config.on_init;\n      }\n\n      let channel = pc.createDataChannel(config.peer_id, {\n        ordered: true\n      });\n      channel.binaryType = \"arraybuffer\";\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      const svc = await server.getService(service_id);\n      const answer = await svc.offer({\n        sdp: pc.localDescription.sdp,\n        type: pc.localDescription.type\n      });\n\n      channel.onopen = () => {\n        config.channel = channel;\n        config.workspace = answer.workspace; // Wait for the channel to be open before returning the rpc\n        // This is needed for safari to work\n\n        setTimeout(async () => {\n          const rpc = await _setupRPC(config);\n          pc.rpc = rpc;\n\n          async function getService(name) {\n            return await rpc.get_remote_service(config.peer_id + \":\" + name);\n          }\n\n          async function disconnect() {\n            await rpc.disconnect();\n            pc.close();\n          }\n\n          pc.get_service = getService;\n          pc.getService = getService;\n          pc.disconnect = disconnect;\n          pc.register_codec = rpc.register_codec;\n          pc.registerCodec = rpc.register_codec;\n          resolve(pc);\n        }, 500);\n      };\n\n      channel.onclose = () => reject(new Error(\"Data channel closed\"));\n\n      await pc.setRemoteDescription(new RTCSessionDescription({\n        sdp: answer.sdp,\n        type: answer.type\n      }));\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nasync function registerRTCService(server, service_id, config) {\n  config = config || {\n    visibility: \"protected\",\n    require_context: true\n  };\n  const onInit = config.on_init;\n  delete config.on_init;\n  await server.registerService({\n    id: service_id,\n    config,\n    offer: (params, context) => _createOffer(params, server, config, onInit, context)\n  });\n}\n\n\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=hypha-rpc-sse.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_587__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_587__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_587__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_587__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_587__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_587__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_587__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_587__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_587__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_587__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_587__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_587__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_587__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_587__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_587__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_587__(__nested_webpack_require_587__.s = \"./src/hypha/websocket-client.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n  \\*************************************************************************/\n/*! exports provided: CachedKeyDecoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_4453__) {\n\n\"use strict\";\n__nested_webpack_require_4453__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_4453__.d(__nested_webpack_exports__, \"CachedKeyDecoder\", function() { return CachedKeyDecoder; });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4453__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n  \\********************************************************************/\n/*! exports provided: DecodeError */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_7979__) {\n\n\"use strict\";\n__nested_webpack_require_7979__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_7979__.d(__nested_webpack_exports__, \"DecodeError\", function() { return DecodeError; });\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n  \\****************************************************************/\n/*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_9975__) {\n\n\"use strict\";\n__nested_webpack_require_9975__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_9975__.d(__nested_webpack_exports__, \"DataViewIndexOutOfBoundsError\", function() { return DataViewIndexOutOfBoundsError; });\n/* harmony export (binding) */ __nested_webpack_require_9975__.d(__nested_webpack_exports__, \"Decoder\", function() { return Decoder; });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_9975__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_9975__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_9975__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_9975__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_9975__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_9975__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_9975__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nvar DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxBinLength === void 0) { maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxArrayLength === void 0) { maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxMapLength === void 0) { maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxExtLength === void 0) { maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n        this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n    };\n    /**\n     * @throws {DecodeError}\n     * @throws {RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n        }\n        this.stack.push({\n            type: 1 /* MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n        }\n        this.stack.push({\n            type: 0 /* ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n            object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n        }\n        else {\n            object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n  \\****************************************************************/\n/*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_43781__) {\n\n\"use strict\";\n__nested_webpack_require_43781__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_43781__.d(__nested_webpack_exports__, \"DEFAULT_MAX_DEPTH\", function() { return DEFAULT_MAX_DEPTH; });\n/* harmony export (binding) */ __nested_webpack_require_43781__.d(__nested_webpack_exports__, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() { return DEFAULT_INITIAL_BUFFER_SIZE; });\n/* harmony export (binding) */ __nested_webpack_require_43781__.d(__nested_webpack_exports__, \"Encoder\", function() { return Encoder; });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_43781__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_43781__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_43781__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_43781__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.getUint8Array = function () {\n        return this.bytes.subarray(0, this.pos);\n    };\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.getUint8Array();\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \" + depth);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n            var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \" + size);\n        }\n        var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \" + size);\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \" + size);\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \" + size);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n  \\****************************************************************/\n/*! exports provided: ExtData */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_59350__) {\n\n\"use strict\";\n__nested_webpack_require_59350__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_59350__.d(__nested_webpack_exports__, \"ExtData\", function() { return ExtData; });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n  \\***********************************************************************/\n/*! exports provided: ExtensionCodec */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_60258__) {\n\n\"use strict\";\n__nested_webpack_require_60258__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_60258__.d(__nested_webpack_exports__, \"ExtensionCodec\", function() { return ExtensionCodec; });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60258__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_60258__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n  \\***************************************************************/\n/*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_63834__) {\n\n\"use strict\";\n__nested_webpack_require_63834__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_63834__.d(__nested_webpack_exports__, \"defaultDecodeOptions\", function() { return defaultDecodeOptions; });\n/* harmony export (binding) */ __nested_webpack_require_63834__.d(__nested_webpack_exports__, \"decode\", function() { return decode; });\n/* harmony export (binding) */ __nested_webpack_require_63834__.d(__nested_webpack_exports__, \"decodeMulti\", function() { return decodeMulti; });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_63834__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n\nvar defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n */\nfunction decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n */\nfunction decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n  \\********************************************************************/\n/*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_66089__) {\n\n\"use strict\";\n__nested_webpack_require_66089__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_66089__.d(__nested_webpack_exports__, \"decodeAsync\", function() { return decodeAsync; });\n/* harmony export (binding) */ __nested_webpack_require_66089__.d(__nested_webpack_exports__, \"decodeArrayStream\", function() { return decodeArrayStream; });\n/* harmony export (binding) */ __nested_webpack_require_66089__.d(__nested_webpack_exports__, \"decodeMultiStream\", function() { return decodeMultiStream; });\n/* harmony export (binding) */ __nested_webpack_require_66089__.d(__nested_webpack_exports__, \"decodeStream\", function() { return decodeStream; });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_66089__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_66089__(/*! ./utils/stream.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\");\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_66089__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nfunction decodeAsync(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    return __awaiter(this, void 0, void 0, function () {\n        var stream, decoder;\n        return __generator(this, function (_a) {\n            stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return [2 /*return*/, decoder.decodeAsync(stream)];\n        });\n    });\n}\nfunction decodeArrayStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeArrayStream(stream);\n}\nfunction decodeMultiStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeStream(stream);\n}\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nfunction decodeStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    return decodeMultiStream(streamLike, options);\n}\n//# sourceMappingURL=decodeAsync.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n  \\***************************************************************/\n/*! exports provided: encode */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_72203__) {\n\n\"use strict\";\n__nested_webpack_require_72203__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_72203__.d(__nested_webpack_exports__, \"encode\", function() { return encode; });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_72203__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encode(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n  \\**************************************************************/\n/*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_73993__) {\n\n\"use strict\";\n__nested_webpack_require_73993__.r(__nested_webpack_exports__);\n/* harmony import */ var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_73993__(/*! ./encode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"encode\", function() { return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"]; });\n\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_73993__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decode\", function() { return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeMulti\", function() { return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"]; });\n\n/* harmony import */ var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_73993__(/*! ./decodeAsync.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeAsync\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeArrayStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeMultiStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"]; });\n\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_73993__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"Decoder\", function() { return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"DataViewIndexOutOfBoundsError\", function() { return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"]; });\n\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_73993__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"DecodeError\", function() { return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"]; });\n\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_73993__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"Encoder\", function() { return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"]; });\n\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_73993__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"ExtensionCodec\", function() { return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"]; });\n\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_73993__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"ExtData\", function() { return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"]; });\n\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_73993__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"EXT_TIMESTAMP\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"encodeDateToTimeSpec\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"encodeTimeSpecToTimestamp\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeTimestampToTimeSpec\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"encodeTimestampExtension\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73993__.d(__nested_webpack_exports__, \"decodeTimestampExtension\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"]; });\n\n// Main Functions:\n\n\n\n\n\n\n\n\n\n\n\n// Utilitiies for Extension Types:\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n  \\******************************************************************/\n/*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_79743__) {\n\n\"use strict\";\n__nested_webpack_require_79743__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"EXT_TIMESTAMP\", function() { return EXT_TIMESTAMP; });\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"encodeTimeSpecToTimestamp\", function() { return encodeTimeSpecToTimestamp; });\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"encodeDateToTimeSpec\", function() { return encodeDateToTimeSpec; });\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"encodeTimestampExtension\", function() { return encodeTimestampExtension; });\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"decodeTimestampToTimeSpec\", function() { return decodeTimestampToTimeSpec; });\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"decodeTimestampExtension\", function() { return decodeTimestampExtension; });\n/* harmony export (binding) */ __nested_webpack_require_79743__.d(__nested_webpack_exports__, \"timestampExtension\", function() { return timestampExtension; });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_79743__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_79743__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n  \\******************************************************************/\n/*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_85167__) {\n\n\"use strict\";\n__nested_webpack_require_85167__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_85167__.d(__nested_webpack_exports__, \"UINT32_MAX\", function() { return UINT32_MAX; });\n/* harmony export (binding) */ __nested_webpack_require_85167__.d(__nested_webpack_exports__, \"setUint64\", function() { return setUint64; });\n/* harmony export (binding) */ __nested_webpack_require_85167__.d(__nested_webpack_exports__, \"setInt64\", function() { return setInt64; });\n/* harmony export (binding) */ __nested_webpack_require_85167__.d(__nested_webpack_exports__, \"getInt64\", function() { return getInt64; });\n/* harmony export (binding) */ __nested_webpack_require_85167__.d(__nested_webpack_exports__, \"getUint64\", function() { return getUint64; });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n  \\*************************************************************************/\n/*! exports provided: prettyByte */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_87206__) {\n\n\"use strict\";\n__nested_webpack_require_87206__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_87206__.d(__nested_webpack_exports__, \"prettyByte\", function() { return prettyByte; });\nfunction prettyByte(byte) {\n    return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n  \\*********************************************************************/\n/*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_88021__) {\n\n\"use strict\";\n__nested_webpack_require_88021__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_88021__.d(__nested_webpack_exports__, \"isAsyncIterable\", function() { return isAsyncIterable; });\n/* harmony export (binding) */ __nested_webpack_require_88021__.d(__nested_webpack_exports__, \"asyncIterableFromStream\", function() { return asyncIterableFromStream; });\n/* harmony export (binding) */ __nested_webpack_require_88021__.d(__nested_webpack_exports__, \"ensureAsyncIterable\", function() { return ensureAsyncIterable; });\n// utility for whatwg streams\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nfunction isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nfunction assertNonNull(value) {\n    if (value == null) {\n        throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n    }\n}\nfunction asyncIterableFromStream(stream) {\n    return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n        var reader, _a, done, value;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (false) {}\n                    return [4 /*yield*/, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done) return [3 /*break*/, 5];\n                    return [4 /*yield*/, __await(void 0)];\n                case 4: return [2 /*return*/, _b.sent()];\n                case 5:\n                    assertNonNull(value);\n                    return [4 /*yield*/, __await(value)];\n                case 6: return [4 /*yield*/, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3 /*break*/, 2];\n                case 8: return [3 /*break*/, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7 /*endfinally*/];\n                case 10: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n  \\**************************************************************************/\n/*! exports provided: ensureUint8Array, createDataView */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_93722__) {\n\n\"use strict\";\n__nested_webpack_require_93722__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_93722__.d(__nested_webpack_exports__, \"ensureUint8Array\", function() { return ensureUint8Array; });\n/* harmony export (binding) */ __nested_webpack_require_93722__.d(__nested_webpack_exports__, \"createDataView\", function() { return createDataView; });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n  \\*******************************************************************/\n/*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_95282__) {\n\n\"use strict\";\n__nested_webpack_require_95282__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"utf8Count\", function() { return utf8Count; });\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"utf8EncodeJs\", function() { return utf8EncodeJs; });\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"TEXT_ENCODER_THRESHOLD\", function() { return TEXT_ENCODER_THRESHOLD; });\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"utf8EncodeTE\", function() { return utf8EncodeTE; });\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"utf8DecodeJs\", function() { return utf8DecodeJs; });\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"TEXT_DECODER_THRESHOLD\", function() { return TEXT_DECODER_THRESHOLD; });\n/* harmony export (binding) */ __nested_webpack_require_95282__.d(__nested_webpack_exports__, \"utf8DecodeTD\", function() { return utf8DecodeTD; });\n/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_95282__(/*! ./int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"]\n    : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"]\n    : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map\n\n/***/ }),\n\n/***/ \"./package.json\":\n/*!**********************!*\\\n  !*** ./package.json ***!\n  \\**********************/\n/*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.5.59\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"types\\\":\\\"index.d.ts\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\\",\\\"watch\\\":\\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\\",\\\"publish-npm\\\":\\\"npm install && npm run build && npm publish\\\",\\\"serve\\\":\\\"webpack-dev-server\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\",\\\"test-watch\\\":\\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{\\\"@msgpack/msgpack\\\":\\\"^2.7.1\\\",\\\"socket.io-client\\\":\\\"^4.6.2\\\"},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.16.12\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.8.3\\\",\\\"@babel/polyfill\\\":\\\"^7.12.1\\\",\\\"@babel/preset-env\\\":\\\"^7.16.11\\\",\\\"@types/requirejs\\\":\\\"^2.1.34\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"^8.2.3\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.3.6\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.1.2\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^6.3.12\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^2.0.1\\\",\\\"karma-sourcemap-loader\\\":\\\"^0.3.8\\\",\\\"karma-spec-reporter\\\":\\\"0.0.32\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^6.0.3\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^10.1.0\\\",\\\"postcss\\\":\\\"^7.0.36\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"ts-loader\\\":\\\"^9.4.3\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.46.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^4.7.0\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\",\\\"webpack-dev-server\\\":\\\"^3.11.3\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"workbox-webpack-plugin\\\":\\\"^4.3.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");\n\n/***/ }),\n\n/***/ \"./src/hypha/rpc.js\":\n/*!**************************!*\\\n  !*** ./src/hypha/rpc.js ***!\n  \\**************************/\n/*! exports provided: API_VERSION, RPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_105822__) {\n\n\"use strict\";\n__nested_webpack_require_105822__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_105822__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __nested_webpack_require_105822__.d(__nested_webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_105822__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_105822__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\n\nconst API_VERSION = \"0.3.0\";\nconst CHUNK_SIZE = 1024 * 500;\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\n}\n\nfunction getFunctionInfo(func) {\n  const funcString = func.toString(); // Extract function name\n\n  const nameMatch = funcString.match(/function\\s*(\\w*)/);\n  const name = nameMatch && nameMatch[1] || \"\"; // Extract function parameters, excluding comments\n\n  const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n  let params = \"\";\n\n  if (paramsMatch) {\n    params = paramsMatch[1].split(\",\").map(p => p.replace(/\\/\\*.*?\\*\\//g, \"\") // Remove block comments\n    .replace(/\\/\\/.*$/g, \"\")) // Remove line comments\n    .filter(p => p.trim().length > 0) // Remove empty strings after removing comments\n    .map(p => p.trim()) // Trim remaining whitespace\n    .join(\", \");\n  } // Extract function docstring (block comment)\n\n\n  let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n  const docstringBlock = docMatch && docMatch[1].trim() || \"\"; // Extract function docstring (line comment)\n\n  docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n  const docstringLine = docMatch && docMatch[1].split(\"\\n\").map(s => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n  const docstring = docstringBlock || docstringLine;\n  return name && params.length > 0 && {\n    name: name,\n    sig: params,\n    doc: docstring\n  };\n}\n\nfunction concatArrayBuffers(buffers) {\n  var buffersLengths = buffers.map(function (b) {\n    return b.byteLength;\n  }),\n      totalBufferlength = buffersLengths.reduce(function (p, c) {\n    return p + c;\n  }, 0),\n      unit8Arr = new Uint8Array(totalBufferlength);\n  buffersLengths.reduce(function (p, c, i) {\n    unit8Arr.set(new Uint8Array(buffers[i]), p);\n    return p + c;\n  }, 0);\n  return unit8Arr.buffer;\n}\n\nclass Timer {\n  constructor(timeout, callback, args, label) {\n    this._timeout = timeout;\n    this._callback = callback;\n    this._args = args;\n    this._label = label || \"timer\";\n    this._task = null;\n    this.started = false;\n  }\n\n  start() {\n    if (this.started) {\n      this.reset();\n    } else {\n      this._task = setTimeout(() => {\n        this._callback.apply(this, this._args);\n      }, this._timeout * 1000);\n      this.started = true;\n    }\n  }\n\n  clear() {\n    if (this._task) {\n      clearTimeout(this._task);\n      this._task = null;\n      this.started = false;\n    } else {\n      console.warn(`Clearing a timer (${this._label}) which is not started`);\n    }\n  }\n\n  reset() {\n    if (this._task) {\n      clearTimeout(this._task);\n    }\n\n    this._task = setTimeout(() => {\n      this._callback.apply(this, this._args);\n    }, this._timeout * 1000);\n    this.started = true;\n  }\n\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, {\n    client_id = null,\n    manager_id = null,\n    default_context = null,\n    name = null,\n    codecs = null,\n    method_timeout = null,\n    max_message_buffer_size = 0,\n    debug = false,\n    workspace = null\n  }) {\n    super(debug);\n    this._codecs = codecs || {};\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n    this._client_id = client_id;\n    this._name = name;\n    this._connection_info = null;\n    this._workspace = null;\n    this._local_workspace = workspace;\n    this.manager_id = manager_id;\n    this.default_context = default_context || {};\n    this._method_annotations = new WeakMap();\n    this._manager_service = null;\n    this._max_message_buffer_size = max_message_buffer_size;\n    this._chunk_store = {};\n    this._method_timeout = method_timeout || 30; // make sure there is an execute function\n\n    this._services = {};\n    this._object_store = {\n      services: this._services\n    };\n\n    if (connection) {\n      this.add_service({\n        id: \"built-in\",\n        type: \"built-in\",\n        name: \"RPC built-in services\",\n        config: {\n          require_context: true,\n          visibility: \"public\"\n        },\n        ping: this._ping.bind(this),\n        get_service: this.get_local_service.bind(this),\n        register_service: this.register_service.bind(this),\n        message_cache: {\n          create: this._create_message.bind(this),\n          append: this._append_message.bind(this),\n          process: this._process_message.bind(this),\n          remove: this._remove_message.bind(this)\n        }\n      });\n      this.on(\"method\", this._handle_method.bind(this));\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n      this._emit_message = connection.emit_message.bind(connection);\n      connection.on_message(this._on_message.bind(this));\n      this._connection = connection; // Update the server and obtain client info\n\n      this._get_connection_info();\n    } else {\n      this._emit_message = function () {\n        console.log(\"No connection to emit message\");\n      };\n    }\n  }\n\n  async _get_connection_info() {\n    if (this.manager_id) {\n      // try to get the root service\n      try {\n        await this.get_manager_service(30.0);\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n        this._connection_info = await this._manager_service.get_connection_info();\n\n        if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n          this._local_workspace = this._connection_info.workspace;\n        }\n\n        if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n          this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n\n          const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8; // console.info(\n          //   `Reconnection token obtained: ${this._connection_info.reconnection_token}, will be refreshed in ${reconnection_expires_in} seconds`\n          // );\n\n          this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1000);\n        }\n      } catch (exp) {\n        console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n      }\n    }\n  }\n\n  register_codec(config) {\n    if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n      throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n    } else {\n      if (config.type) {\n        for (let k of Object.keys(this._codecs)) {\n          if (this._codecs[k].type === config.type || k === config.name) {\n            delete this._codecs[k];\n            console.warn(\"Remove duplicated codec: \" + k);\n          }\n        }\n      }\n\n      this._codecs[config[\"name\"]] = config;\n    }\n  }\n\n  async _ping(msg, context) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n    return \"pong\";\n  }\n\n  async ping(client_id, timeout) {\n    let method = this._generate_remote_method({\n      _rtarget: client_id,\n      _rmethod: \"services.built-in.ping\",\n      _rpromise: true,\n      _rdoc: \"Ping a remote client\",\n      _rsig: \"ping(msg)\"\n    });\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])((await method(\"ping\", timeout)) == \"pong\");\n  }\n\n  _create_message(key, heartbeat, overwrite, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    if (!this._object_store[\"message_cache\"]) {\n      this._object_store[\"message_cache\"] = {};\n    }\n\n    if (!overwrite && this._object_store[\"message_cache\"][key]) {\n      throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n    }\n\n    this._object_store[\"message_cache\"][key] = [];\n  }\n\n  _append_message(key, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    const cache = this._object_store[\"message_cache\"];\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n    cache[key].push(data);\n  }\n\n  _remove_message(key, context) {\n    const cache = this._object_store[\"message_cache\"];\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    delete cache[key];\n  }\n\n  _process_message(key, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    const cache = this._object_store[\"message_cache\"];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    cache[key] = concatArrayBuffers(cache[key]);\n    console.debug(`Processing message ${key} (size=${cache[key].length})`);\n    let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n    const {\n      done,\n      value\n    } = unpacker.next();\n    const main = value; // Make sure the fields are from trusted source\n\n    Object.assign(main, {\n      from: context.from,\n      to: context.to,\n      user: context.user\n    });\n    main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n    Object.assign(main[\"ctx\"], this.default_context);\n\n    if (!done) {\n      let extra = unpacker.next();\n      Object.assign(main, extra.value);\n    }\n\n    this._fire(main[\"type\"], main);\n\n    delete cache[key];\n  }\n\n  _on_message(message) {\n    try {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n      let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n      const {\n        done,\n        value\n      } = unpacker.next();\n      const main = value; // Add trusted context to the method call\n\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n\n      if (!done) {\n        let extra = unpacker.next();\n        Object.assign(main, extra.value);\n      }\n\n      this._fire(main[\"type\"], main);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._services = {};\n  }\n\n  async disconnect() {\n    if (this._get_connection_info_task) {\n      clearTimeout(this._get_connection_info_task);\n      this._get_connection_info_task = null;\n    }\n\n    this._fire(\"disconnect\");\n  }\n\n  async get_manager_service(timeout) {\n    if (this.manager_id && !this._manager_service) {\n      this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n    }\n  }\n\n  get_all_local_services() {\n    return this._services;\n  }\n\n  get_local_service(service_id, context) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n    const [ws, client_id] = context[\"to\"].split(\"/\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n    const service = this._services[service_id];\n\n    if (!service) {\n      throw new Error(\"Service not found: \" + service_id);\n    } // allow access for the same workspace\n\n\n    if (service.config.visibility == \"public\") {\n      return service;\n    } // allow access for the same workspace\n\n\n    if (context[\"from\"].startsWith(ws + \"/\")) {\n      return service;\n    }\n\n    throw new Error(\"Permission denied for service: \" + service_id);\n  }\n\n  async get_remote_service(service_uri, timeout) {\n    timeout = timeout === undefined ? this._method_timeout : timeout;\n\n    if (!service_uri && this.manager_id) {\n      service_uri = this.manager_id;\n    } else if (!service_uri.includes(\":\")) {\n      service_uri = this._client_id + \":\" + service_uri;\n    }\n\n    const provider = service_uri.split(\":\")[0];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n\n    try {\n      const method = this._generate_remote_method({\n        _rtarget: provider,\n        _rmethod: \"services.built-in.get_service\",\n        _rpromise: true,\n        _rdoc: \"Get a remote service\",\n        _rsig: \"get_service(service_id)\"\n      });\n\n      const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n      svc.id = service_uri;\n      return svc;\n    } catch (e) {\n      console.error(\"Failed to get remote service: \" + service_uri, e);\n      throw e;\n    }\n  }\n\n  _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n    if (typeof aObject === \"function\") {\n      // mark the method as a remote method that requires context\n      let method_name = object_id.split(\".\")[1];\n\n      this._method_annotations.set(aObject, {\n        require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n        run_in_executor: run_in_executor,\n        method_id: \"services.\" + object_id,\n        visibility: visibility\n      });\n    } else if (aObject instanceof Array || aObject instanceof Object) {\n      for (let key of Object.keys(aObject)) {\n        let val = aObject[key];\n\n        if (typeof val === \"function\" && val.__rpc_object__) {\n          let client_id = val.__rpc_object__._rtarget;\n\n          if (client_id.includes(\"/\")) {\n            client_id = client_id.split(\"/\")[1];\n          }\n\n          if (this._client_id === client_id) {\n            if (aObject instanceof Array) {\n              aObject = aObject.slice();\n            } // recover local method\n\n\n            aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n            val = aObject[key]; // make sure it's annotated later\n          } else {\n            throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n          }\n        }\n\n        this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n      }\n    }\n  }\n\n  add_service(api, overwrite) {\n    if (!api || Array.isArray(api)) throw new Error(\"Invalid service object\");\n\n    if (api.constructor === Object) {\n      api = Object.assign({}, api);\n    } else {\n      const normApi = {};\n      const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n\n      for (let k of props) {\n        if (k !== \"constructor\") {\n          if (typeof api[k] === \"function\") normApi[k] = api[k].bind(api);else normApi[k] = api[k];\n        }\n      } // For class instance, we need set a default id\n\n\n      api.id = api.id || \"default\";\n      api = normApi;\n    }\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n\n    if (!api.name) {\n      api.name = api.id;\n    }\n\n    if (!api.config) {\n      api.config = {};\n    }\n\n    if (!api.type) {\n      api.type = \"generic\";\n    } // require_context only applies to the top-level functions\n\n\n    let require_context = false,\n        run_in_executor = false;\n    if (api.config.require_context) require_context = api.config.require_context;\n    if (api.config.run_in_executor) run_in_executor = true;\n    const visibility = api.config.visibility || \"protected\";\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n\n    this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n\n    if (this._services[api.id]) {\n      if (overwrite) {\n        delete this._services[api.id];\n      } else {\n        throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n      }\n    }\n\n    this._services[api.id] = api;\n    return api;\n  }\n\n  async register_service(api, overwrite, notify, context) {\n    if (notify === undefined) notify = true;\n\n    if (context) {\n      // If this function is called from remote, we need to make sure\n      const [workspace, client_id] = context[\"to\"].split(\"/\");\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n    }\n\n    const service = this.add_service(api, overwrite);\n\n    if (notify) {\n      this._fire(\"service-updated\", {\n        service_id: service[\"id\"],\n        api: service,\n        type: \"add\"\n      });\n\n      await this._notify_service_update();\n    }\n\n    return {\n      id: `${this._client_id}:${service[\"id\"]}`,\n      type: service[\"type\"],\n      name: service[\"name\"],\n      description: service[\"description\"] || \"\",\n      config: service[\"config\"]\n    };\n  }\n\n  async unregister_service(service, notify) {\n    if (service instanceof Object) {\n      service = service.id;\n    }\n\n    if (!this._services[service]) {\n      throw new Error(`Service not found: ${service}`);\n    }\n\n    const api = this._services[service];\n    delete this._services[service];\n\n    this._fire(\"service-updated\", {\n      service_id: service,\n      api: api,\n      type: \"remove\"\n    });\n\n    await this._notify_service_update();\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n\n  _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n    let method_id = `${session_id}.${name}`;\n    let encoded = {\n      _rtype: \"method\",\n      _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n      _rmethod: method_id,\n      _rpromise: false\n    };\n    const self = this;\n\n    let wrapped_callback = function () {\n      try {\n        callback.apply(null, Array.prototype.slice.call(arguments));\n      } catch (error) {\n        console.error(\"Error in callback:\", method_id, error);\n      } finally {\n        if (clear_after_called && self._object_store[session_id]) {\n          // console.log(\"Deleting session\", session_id, \"from\", self._client_id);\n          delete self._object_store[session_id];\n        }\n\n        if (timer && timer.started) {\n          timer.clear();\n        }\n      }\n    };\n\n    return [encoded, wrapped_callback];\n  }\n\n  async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n    let store = this._get_session_store(session_id, true);\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n    let encoded = {};\n\n    if (timer && reject && this._method_timeout) {\n      encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n      encoded.interval = this._method_timeout / 2;\n      store.timer = timer;\n    } else {\n      timer = null;\n    }\n\n    [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n    [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n    return encoded;\n  }\n\n  async _send_chunks(data, target_id, session_id) {\n    let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n    let message_cache = remote_services.message_cache;\n    let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n    await message_cache.create(message_id, !!session_id);\n    let total_size = data.length;\n    let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n\n    for (let idx = 0; idx < chunk_num; idx++) {\n      let start_byte = idx * CHUNK_SIZE;\n      await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id); // console.log(\n      //   `Sending chunk ${idx + 1}/${chunk_num} (${total_size} bytes)`\n      // );\n    } // console.log(`All chunks sent (${chunk_num})`);\n\n\n    await message_cache.process(message_id, !!session_id);\n  }\n\n  emit(main_message, extra_data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n    let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n\n    if (extra_data) {\n      const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n      message_package = new Uint8Array([...message_package, ...extra]);\n    }\n\n    const total_size = message_package.length;\n\n    if (total_size <= CHUNK_SIZE + 1024) {\n      return this._emit_message(message_package);\n    } else {\n      throw new Error(\"Message is too large to send in one go.\");\n    }\n  }\n\n  _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n    let target_id = encoded_method._rtarget;\n\n    if (remote_workspace && !target_id.includes(\"/\")) {\n      if (remote_workspace !== target_id) {\n        target_id = remote_workspace + \"/\" + target_id;\n      } // Fix the target id to be an absolute id\n\n\n      encoded_method._rtarget = target_id;\n    }\n\n    let method_id = encoded_method._rmethod;\n    let with_promise = encoded_method._rpromise;\n    const self = this;\n\n    function remote_method() {\n      return new Promise(async (resolve, reject) => {\n        let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n        if (local_parent) {\n          // Store the children session under the parent\n          local_session_id = local_parent + \".\" + local_session_id;\n        }\n\n        let store = self._get_session_store(local_session_id, true);\n\n        if (!store) {\n          reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n          return;\n        }\n\n        store[\"target_id\"] = target_id;\n        const args = await self._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n        let main_message = {\n          type: \"method\",\n          from: self._local_workspace ? self._local_workspace + \"/\" + self._client_id : self._client_id,\n          to: target_id,\n          method: method_id\n        };\n        let extra_data = {};\n\n        if (args) {\n          extra_data[\"args\"] = args;\n        }\n\n        if (withKwargs) {\n          extra_data[\"with_kwargs\"] = withKwargs;\n        } // console.log(\n        //   `Calling remote method ${target_id}:${method_id}, session: ${local_session_id}`\n        // );\n\n\n        if (remote_parent) {\n          // Set the parent session\n          // Note: It's a session id for the remote, not the current client\n          main_message[\"parent\"] = remote_parent;\n        }\n\n        let timer = null;\n\n        if (with_promise) {\n          // Only pass the current session id to the remote\n          // if we want to received the result\n          // I.e. the session id won't be passed for promises themselves\n          main_message[\"session\"] = local_session_id;\n          let method_name = `${target_id}:${method_id}`;\n          timer = new Timer(self._method_timeout, reject, [`Method call time out: ${method_name}`], method_name); // By default, hypha will clear the session after the method is called\n          // However, if the args contains _rintf === true, we will not clear the session\n\n          let clear_after_called = true;\n\n          for (let arg of args) {\n            if (typeof arg === \"object\" && arg._rintf === true) {\n              clear_after_called = false;\n              break;\n            }\n          }\n\n          extra_data[\"promise\"] = await self._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n        } // The message consists of two segments, the main message and extra data\n\n\n        let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n\n        if (extra_data) {\n          const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n          message_package = new Uint8Array([...message_package, ...extra]);\n        }\n\n        const total_size = message_package.length;\n\n        if (total_size <= CHUNK_SIZE + 1024) {\n          self._emit_message(message_package).then(function () {\n            if (timer) {\n              // console.log(`Start watchdog timer.`);\n              // Only start the timer after we send the message successfully\n              timer.start();\n            }\n          });\n        } else {\n          // send chunk by chunk\n          self._send_chunks(message_package, target_id, remote_parent).then(function () {\n            if (timer) {\n              // console.log(`Start watchdog timer.`);\n              // Only start the timer after we send the message successfully\n              timer.start();\n            }\n          });\n        }\n      });\n    } // Generate debugging information for the method\n\n\n    remote_method.__rpc_object__ = encoded_method;\n    const parts = method_id.split(\".\");\n    remote_method.__name__ = parts[parts.length - 1];\n    remote_method.__doc__ = encoded_method._rdoc;\n    remote_method.__sig__ = encoded_method._rsig;\n    return remote_method;\n  }\n\n  async _notify_service_update() {\n    if (this.manager_id) {\n      // try to get the root service\n      try {\n        await this.get_manager_service(30.0);\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n        await this._manager_service.update_client_info(this.get_client_info());\n      } catch (exp) {\n        // pylint: disable=broad-except\n        console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n      }\n    }\n  }\n\n  get_client_info() {\n    const services = [];\n\n    for (let service of Object.values(this._services)) {\n      services.push({\n        id: `${this._client_id}:${service[\"id\"]}`,\n        type: service[\"type\"],\n        name: service[\"name\"],\n        description: service[\"description\"] || \"\",\n        config: service[\"config\"]\n      });\n    }\n\n    return {\n      id: this._client_id,\n      services: services\n    };\n  }\n\n  async _handle_method(data) {\n    let reject = null;\n    let heartbeat_task = null;\n\n    try {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n      const method_name = data.from + \":\" + data.method;\n      const remote_workspace = data.from.split(\"/\")[0]; // Make sure the target id is an absolute id\n\n      data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n      data[\"ctx\"][\"to\"] = data[\"to\"];\n      const local_workspace = data.to.split(\"/\")[0];\n      const local_parent = data.parent;\n      let resolve, reject;\n\n      if (data.promise) {\n        // Decode the promise with the remote session id\n        // Such that the session id will be passed to the remote as a parent session id\n        const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n        resolve = promise.resolve;\n        reject = promise.reject;\n\n        if (promise.heartbeat && promise.interval) {\n          async function heartbeat() {\n            try {\n              // console.log(\"Reset heartbeat timer: \" + data.method);\n              await promise.heartbeat();\n            } catch (err) {\n              console.error(err);\n            }\n          }\n\n          heartbeat_task = setInterval(heartbeat, promise.interval * 1000);\n        }\n      }\n\n      let method;\n\n      try {\n        method = indexObject(this._object_store, data[\"method\"]);\n      } catch (e) {\n        console.debug(\"Failed to find method\", method_name, e);\n        throw new Error(`Method not found: ${method_name}`);\n      }\n\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name); // Check permission\n\n      if (this._method_annotations.has(method)) {\n        // For services, it should not be protected\n        if (this._method_annotations.get(method).visibility === \"protected\") {\n          if (local_workspace !== remote_workspace) {\n            throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n          }\n        }\n      } else {\n        // For sessions, the target_id should match exactly\n        let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n\n        if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n          session_target_id = local_workspace + \"/\" + session_target_id;\n        }\n\n        if (session_target_id !== data.from) {\n          throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n        }\n      } // Make sure the parent session is still open\n\n\n      if (local_parent) {\n        // The parent session should be a session that generate the current method call\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n      }\n\n      let args;\n\n      if (data.args) {\n        args = await this._decode(data.args, data.session, null, remote_workspace, null);\n      } else {\n        args = [];\n      }\n\n      if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n        args.push(data.ctx);\n      } // console.log(\"Executing method: \" + method_name);\n\n\n      if (data.promise) {\n        const result = method.apply(null, args);\n\n        if (result instanceof Promise) {\n          result.then(result => {\n            resolve(result);\n            clearInterval(heartbeat_task);\n          }).catch(err => {\n            reject(err);\n            clearInterval(heartbeat_task);\n          });\n        } else {\n          resolve(result);\n          clearInterval(heartbeat_task);\n        }\n      } else {\n        method.apply(null, args);\n        clearInterval(heartbeat_task);\n      }\n    } catch (err) {\n      if (reject) {\n        reject(err);\n        console.debug(\"Error during calling method: \", err);\n      } else {\n        console.error(\"Error during calling method: \", err);\n      } // make sure we clear the heartbeat timer\n\n\n      clearInterval(heartbeat_task);\n    }\n  }\n\n  encode(aObject, session_id) {\n    return this._encode(aObject, session_id);\n  }\n\n  _get_session_store(session_id, create) {\n    let store = this._object_store;\n    const levels = session_id.split(\".\");\n\n    if (create) {\n      const last_index = levels.length - 1;\n\n      for (let level of levels.slice(0, last_index)) {\n        if (!store[level]) {\n          return null;\n        }\n\n        store = store[level];\n      } // Create the last level\n\n\n      if (!store[levels[last_index]]) {\n        store[levels[last_index]] = {};\n      }\n\n      return store[levels[last_index]];\n    } else {\n      for (let level of levels) {\n        if (!store[level]) {\n          return null;\n        }\n\n        store = store[level];\n      }\n\n      return store;\n    }\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  async _encode(aObject, session_id, local_workspace) {\n    const aType = typeof aObject;\n\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof Uint8Array) {\n      return aObject;\n    }\n\n    if (aObject instanceof ArrayBuffer) {\n      return {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject)\n      };\n    } // Reuse the remote object\n\n\n    if (aObject.__rpc_object__) {\n      return aObject.__rpc_object__;\n    }\n\n    let bObject; // skip if already encoded\n\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      const temp = aObject._rtype;\n      delete aObject._rtype;\n      bObject = await this._encode(aObject, session_id, local_workspace);\n      bObject._rtype = temp;\n      return bObject;\n    }\n\n    if (typeof aObject === \"function\") {\n      if (this._method_annotations.has(aObject)) {\n        let annotation = this._method_annotations.get(aObject);\n\n        bObject = {\n          _rtype: \"method\",\n          _rtarget: this._client_id,\n          _rmethod: annotation.method_id,\n          _rpromise: true\n        };\n      } else {\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n        let object_id;\n\n        if (aObject.__name__) {\n          object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n        } else {\n          object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n        }\n\n        bObject = {\n          _rtype: \"method\",\n          _rtarget: this._client_id,\n          _rmethod: `${session_id}.${object_id}`,\n          _rpromise: true\n        };\n\n        let store = this._get_session_store(session_id, true);\n\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n        store[object_id] = aObject;\n      }\n\n      bObject._rdoc = aObject.__doc__;\n      bObject._rsig = aObject.__sig__;\n\n      if (!bObject._rdoc || !bObject._rsig) {\n        try {\n          const funcInfo = getFunctionInfo(aObject);\n\n          if (funcInfo && !bObject._rdoc) {\n            bObject._rdoc = `${funcInfo.doc}`;\n          }\n\n          if (funcInfo && !bObject._rsig) {\n            bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n          }\n        } catch (e) {\n          console.error(\"Failed to extract function docstring:\", aObject);\n        }\n      }\n\n      return bObject;\n    }\n\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\n\n        if (typeof encodedObj === \"object\") {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n          encodedObj._rtype = temp;\n        }\n\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n    /*global tf*/\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\n      const v_buffer = aObject.dataSync();\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(v_buffer.buffer),\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype\n      };\n    } else if (\n    /*global nj*/\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(aObject.selection.data.buffer),\n        _rshape: aObject.shape,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString(),\n        _rtrace: aObject.stack\n      };\n    } // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\n    } else if (aObject instanceof Blob) {\n      let _current_pos = 0;\n\n      async function read(length) {\n        let blob;\n\n        if (length) {\n          blob = aObject.slice(_current_pos, _current_pos + length);\n        } else {\n          blob = aObject.slice(_current_pos);\n        }\n\n        const ret = new Uint8Array(await blob.arrayBuffer());\n        _current_pos = _current_pos + ret.byteLength;\n        return ret;\n      }\n\n      function seek(pos) {\n        _current_pos = pos;\n      }\n\n      bObject = {\n        _rtype: \"iostream\",\n        _rnative: \"js:blob\",\n        type: aObject.type,\n        name: aObject.name,\n        size: aObject.size,\n        path: aObject._path || aObject.webkitRelativePath,\n        read: await this._encode(read, session_id, local_workspace),\n        seek: await this._encode(seek, session_id, local_workspace)\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: new Uint8Array(aObject.buffer),\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof DataView) {\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject.buffer)\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n      };\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n      bObject = isarray ? [] : {};\n      const keys = Object.keys(aObject);\n\n      for (let k of keys) {\n        bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n      }\n    } else {\n      throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n\n    return bObject;\n  }\n\n  async decode(aObject) {\n    return await this._decode(aObject);\n  }\n\n  async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (aObject._rtype) {\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n        aObject._rtype = temp;\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n      } else if (aObject._rtype === \"method\") {\n        bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n\n        const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n\n        bObject = new arraytype(buffer);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength); // ArrayBuffer\n      } else if (aObject._rtype === \"iostream\") {\n        if (aObject._rnative === \"js:blob\") {\n          const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n          const bytes = await read();\n          bObject = new Blob([bytes], {\n            type: aObject.type,\n            name: aObject.name\n          });\n        } else {\n          bObject = {};\n\n          for (let k of Object.keys(aObject)) {\n            if (!k.startsWith(\"_\")) {\n              bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n            }\n          }\n        }\n\n        bObject[\"__rpc_object__\"] = aObject;\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n      } else {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n        bObject._rtype = temp;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    }\n\n    return bObject;\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/hypha/utils.js\":\n/*!****************************!*\\\n  !*** ./src/hypha/utils.js ***!\n  \\****************************/\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_152121__) {\n\n\"use strict\";\n__nested_webpack_require_152121__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"assert\", function() { return assert; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"waitFor\", function() { return waitFor; });\n/* harmony export (binding) */ __nested_webpack_require_152121__.d(__nested_webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array\n};\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  } // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      var link_node;\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            await import(\n            /* webpackIgnore: true */\n            requirements[i]);\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nasync function loadRequirementsInWebworker(requirements) {\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n\n      for (var i = 0; i < requirements.length; i++) {\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n          throw \"unable to import css in a webworker\";\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nfunction loadRequirements(requirements) {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false; // remove functions\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\nconst typedArrayToDtypeKeys = [];\n\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n    await cacheUrlInServiceWorker(req).catch(e => {\n      console.error(e);\n    });\n  }\n}\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    baseUrl = baseUrl || \"/\";\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\n      // Registration was successful\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n    }, function (err) {\n      // registration failed :(\n      console.log(\"ServiceWorker registration failed: \", err);\n    });\n    targetOrigin = targetOrigin || \"*\";\n    cacheCallback = cacheCallback || cacheRequirements;\n\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\n      throw new Error(\"config.cache_requirements must be a function\");\n    }\n\n    window.addEventListener(\"message\", function (e) {\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n        const m = e.data;\n\n        if (m.type === \"cacheRequirements\") {\n          cacheCallback(m.requirements);\n        }\n      }\n    });\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nfunction waitFor(prom, time, error) {\n  let timer;\n  return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n    rej(error || \"Timeout Error\");\n  }, time * 1000))]).finally(() => clearTimeout(timer));\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/hypha/webrtc-client.js\":\n/*!************************************!*\\\n  !*** ./src/hypha/webrtc-client.js ***!\n  \\************************************/\n/*! exports provided: getRTCService, registerRTCService */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_164661__) {\n\n\"use strict\";\n__nested_webpack_require_164661__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_164661__.d(__nested_webpack_exports__, \"getRTCService\", function() { return getRTCService; });\n/* harmony export (binding) */ __nested_webpack_require_164661__.d(__nested_webpack_exports__, \"registerRTCService\", function() { return registerRTCService; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_164661__(/*! ./rpc.js */ \"./src/hypha/rpc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_164661__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n\n\n\nclass WebRTCConnection {\n  constructor(channel) {\n    this._data_channel = channel;\n    this._handle_message = null;\n    this._reconnection_token = null;\n\n    this._data_channel.onmessage = async event => {\n      let data = event.data;\n\n      if (data instanceof Blob) {\n        data = await data.arrayBuffer();\n      }\n\n      this._handle_message(data);\n    };\n\n    const self = this;\n\n    this._data_channel.onclose = function () {\n      console.log(\"websocket closed\");\n      self._data_channel = null;\n    };\n  }\n\n  set_reconnection_token(token) {\n    this._reconnection_token = token;\n  }\n\n  on_message(handler) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  async emit_message(data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n\n    try {\n      this._data_channel.send(data);\n    } catch (exp) {\n      //   data = msgpack_unpackb(data);\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  async disconnect(reason) {\n    this._data_channel = null;\n    console.info(`data channel connection disconnected (${reason})`);\n  }\n\n}\n\nasync function _setupRPC(config) {\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.channel, \"No channel provided\");\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.workspace, \"No workspace provided\");\n  const channel = config.channel;\n  const clientId = config.client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n  const connection = new WebRTCConnection(channel);\n  config.context = config.context || {};\n  config.context.connection_type = \"webrtc\";\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n    client_id: clientId,\n    manager_id: null,\n    default_context: config.context,\n    name: config.name,\n    method_timeout: config.method_timeout || 10.0,\n    workspace: config.workspace\n  });\n  return rpc;\n}\n\nasync function _createOffer(params, server, config, onInit, context) {\n  config = config || {};\n  let offer = new RTCSessionDescription({\n    sdp: params.sdp,\n    type: params.type\n  });\n  let pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [{\n      urls: [\"stun:stun.l.google.com:19302\"]\n    }],\n    sdpSemantics: \"unified-plan\"\n  });\n\n  if (server) {\n    pc.addEventListener(\"datachannel\", async event => {\n      const channel = event.channel;\n      let ctx = null;\n      if (context && context.user) ctx = {\n        user: context.user\n      };\n      const rpc = await _setupRPC({\n        channel: channel,\n        client_id: channel.label,\n        workspace: server.config.workspace,\n        context: ctx\n      }); // Map all the local services to the webrtc client\n\n      rpc._services = server.rpc._services;\n    });\n  }\n\n  if (onInit) {\n    await onInit(pc);\n  }\n\n  await pc.setRemoteDescription(offer);\n  let answer = await pc.createAnswer();\n  await pc.setLocalDescription(answer);\n  return {\n    sdp: pc.localDescription.sdp,\n    type: pc.localDescription.type,\n    workspace: server.config.workspace\n  };\n}\n\nasync function getRTCService(server, service_id, config) {\n  config = config || {};\n  config.peer_id = config.peer_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n  const pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [{\n      urls: [\"stun:stun.l.google.com:19302\"]\n    }],\n    sdpSemantics: \"unified-plan\"\n  });\n  return new Promise(async (resolve, reject) => {\n    try {\n      pc.addEventListener(\"connectionstatechange\", () => {\n        if (pc.connectionState === \"failed\") {\n          pc.close();\n          reject(new Error(\"Connection failed\"));\n        }\n      }, false);\n\n      if (config.on_init) {\n        await config.on_init(pc);\n        delete config.on_init;\n      }\n\n      let channel = pc.createDataChannel(config.peer_id, {\n        ordered: true\n      });\n      channel.binaryType = \"arraybuffer\";\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      const svc = await server.getService(service_id);\n      const answer = await svc.offer({\n        sdp: pc.localDescription.sdp,\n        type: pc.localDescription.type\n      });\n\n      channel.onopen = () => {\n        config.channel = channel;\n        config.workspace = answer.workspace; // Wait for the channel to be open before returning the rpc\n        // This is needed for safari to work\n\n        setTimeout(async () => {\n          const rpc = await _setupRPC(config);\n          pc.rpc = rpc;\n\n          async function getService(name) {\n            return await rpc.get_remote_service(config.peer_id + \":\" + name);\n          }\n\n          async function disconnect() {\n            await rpc.disconnect();\n            pc.close();\n          }\n\n          pc.get_service = getService;\n          pc.getService = getService;\n          pc.disconnect = disconnect;\n          pc.register_codec = rpc.register_codec;\n          pc.registerCodec = rpc.register_codec;\n          resolve(pc);\n        }, 500);\n      };\n\n      channel.onclose = () => reject(new Error(\"Data channel closed\"));\n\n      await pc.setRemoteDescription(new RTCSessionDescription({\n        sdp: answer.sdp,\n        type: answer.type\n      }));\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nasync function registerRTCService(server, service_id, config) {\n  config = config || {\n    visibility: \"protected\",\n    require_context: true\n  };\n  const onInit = config.on_init;\n  delete config.on_init;\n  await server.registerService({\n    id: service_id,\n    config,\n    offer: (params, context) => _createOffer(params, server, config, onInit, context)\n  });\n}\n\n\n\n/***/ }),\n\n/***/ \"./src/hypha/websocket-client.js\":\n/*!***************************************!*\\\n  !*** ./src/hypha/websocket-client.js ***!\n  \\***************************************/\n/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, getRTCService, registerRTCService, login, connectToServer, setupLocalClient */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_171376__) {\n\n\"use strict\";\n__nested_webpack_require_171376__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"login\", function() { return login; });\n/* harmony export (binding) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"connectToServer\", function() { return connectToServer; });\n/* harmony export (binding) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"setupLocalClient\", function() { return setupLocalClient; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_171376__(/*! ./rpc.js */ \"./src/hypha/rpc.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"API_VERSION\"]; });\n\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_171376__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"loadRequirements\"]; });\n\n/* harmony import */ var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_171376__(/*! ./webrtc-client.js */ \"./src/hypha/webrtc-client.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"getRTCService\", function() { return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"registerRTCService\", function() { return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_171376__(/*! ../../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /*#__PURE__*/__nested_webpack_require_171376__.t(/*! ../../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __nested_webpack_require_171376__.d(__nested_webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_3__[\"version\"]; });\n\n\n\n\n\n\n\n\nconst MAX_RETRY = 10000;\n\nclass WebsocketRPCConnection {\n  constructor(server_url, client_id, workspace, token, timeout = 60, WebSocketClass = null) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(server_url && client_id, \"server_url and client_id are required\");\n    server_url = server_url + \"?client_id=\" + client_id;\n\n    if (workspace) {\n      server_url += \"&workspace=\" + workspace;\n    }\n\n    if (token) {\n      server_url += \"&token=\" + token;\n    }\n\n    this._websocket = null;\n    this._handle_message = null;\n    this._reconnection_token = null;\n    this._server_url = server_url;\n    this._timeout = timeout * 1000; // converting to ms\n\n    this._opening = null;\n    this._retry_count = 0;\n    this._closing = false;\n    this._client_id = client_id;\n    this._workspace = workspace; // Allow to override the WebSocket class for mocking or testing\n\n    this._WebSocketClass = WebSocketClass;\n  }\n\n  set_reconnection_token(token) {\n    this._reconnection_token = token;\n  }\n\n  on_message(handler) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  async open() {\n    if (this._opening) {\n      return this._opening;\n    }\n\n    this._opening = new Promise((resolve, reject) => {\n      const server_url = this._reconnection_token ? `${this._server_url}&reconnection_token=${this._reconnection_token}` : this._server_url;\n      console.info(\"Creating a new connection to \", server_url.split(\"?\")[0]);\n      let websocket = null;\n\n      if (server_url.startsWith(\"wss://local-hypha-server:\")) {\n        if (this._WebSocketClass) {\n          websocket = new this._WebSocketClass(server_url);\n        } else {\n          console.log(\"Using local websocket\");\n          console.log(\"Connecting to local websocket \" + server_url);\n          websocket = new LocalWebSocket(server_url, this._client_id, this._workspace);\n        }\n      } else {\n        if (this._WebSocketClass) {\n          websocket = new this._WebSocketClass(server_url);\n        } else {\n          websocket = new WebSocket(server_url);\n        }\n      }\n\n      websocket.binaryType = \"arraybuffer\";\n\n      websocket.onmessage = event => {\n        const data = event.data;\n\n        this._handle_message(data);\n      };\n\n      websocket.onopen = () => {\n        this._websocket = websocket;\n        console.info(\"WebSocket connection established\");\n        this._retry_count = 0; // Reset retry count\n\n        resolve();\n      };\n\n      websocket.onclose = event => {\n        console.log(\"websocket closed\");\n\n        if (!this._closing) {\n          console.log(\"Websocket connection interrupted, retrying...\");\n          this._retry_count++;\n          setTimeout(() => this.open(), this._timeout);\n        }\n\n        this._websocket = null;\n      };\n\n      websocket.onerror = event => {\n        console.log(\"Error occurred in websocket connection: \", event);\n        reject(new Error(\"Websocket connection failed.\"));\n        this._websocket = null;\n      };\n    }).finally(() => {\n      this._opening = null;\n    });\n    return this._opening;\n  }\n\n  async emit_message(data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n\n    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n      await this.open();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this._websocket) {\n        reject(new Error(\"Websocket connection not available\"));\n      } else if (this._websocket.readyState === WebSocket.CONNECTING) {\n        const timeout = setTimeout(() => {\n          reject(new Error(\"WebSocket connection timed out\"));\n        }, this._timeout);\n\n        this._websocket.addEventListener(\"open\", () => {\n          clearTimeout(timeout);\n\n          try {\n            this._websocket.send(data);\n\n            resolve();\n          } catch (exp) {\n            console.error(`Failed to send data, error: ${exp}`);\n            reject(exp);\n          }\n        });\n      } else if (this._websocket.readyState === WebSocket.OPEN) {\n        try {\n          this._websocket.send(data);\n\n          resolve();\n        } catch (exp) {\n          console.error(`Failed to send data, error: ${exp}`);\n          reject(exp);\n        }\n      } else {\n        reject(new Error(\"WebSocket is not in the OPEN or CONNECTING state\"));\n      }\n    });\n  }\n\n  disconnect(reason) {\n    this._closing = true;\n    const ws = this._websocket;\n    this._websocket = null;\n\n    if (ws && ws.readyState === WebSocket.OPEN) {\n      ws.close(1000, reason);\n    }\n\n    console.info(`Websocket connection disconnected (${reason})`);\n  }\n\n}\n\nfunction normalizeServerUrl(server_url) {\n  if (!server_url) throw new Error(\"server_url is required\");\n\n  if (server_url.startsWith(\"http://\")) {\n    server_url = server_url.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n  } else if (server_url.startsWith(\"https://\")) {\n    server_url = server_url.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n  }\n\n  return server_url;\n}\n\nasync function login(config) {\n  const service_id = config.login_service_id || \"public/*:hypha-login\";\n  const timeout = config.login_timeout || 60;\n  const callback = config.login_callback;\n  const server = await connectToServer({\n    name: \"initial login client\",\n    server_url: config.server_url\n  });\n\n  try {\n    const svc = await server.get_service(service_id);\n    const context = await svc.start();\n\n    if (callback) {\n      await callback(context);\n    } else {\n      console.log(`Please open your browser and login at ${context.login_url}`);\n    }\n\n    return await svc.check(context.key, timeout);\n  } catch (error) {\n    throw error;\n  } finally {\n    await server.disconnect();\n  }\n}\nasync function connectToServer(config) {\n  if (config.server) {\n    config.server_url = config.server_url || config.server.url;\n    config.WebSocketClass = config.WebSocketClass || config.server.WebSocketClass;\n  }\n\n  let clientId = config.client_id;\n\n  if (!clientId) {\n    clientId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n    config.client_id = clientId;\n  }\n\n  let server_url = normalizeServerUrl(config.server_url);\n  let connection = new WebsocketRPCConnection(server_url, clientId, config.workspace, config.token, config.method_timeout || 60, config.WebSocketClass);\n  await connection.open();\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n    client_id: clientId,\n    manager_id: \"workspace-manager\",\n    default_context: {\n      connection_type: \"websocket\"\n    },\n    name: config.name,\n    method_timeout: config.method_timeout\n  });\n  const wm = await rpc.get_remote_service(\"workspace-manager:default\");\n  wm.rpc = rpc;\n\n  async function _export(api) {\n    api.id = \"default\";\n    api.name = config.name || api.id;\n    await rpc.register_service(api, true); // const svc = await rpc.get_remote_service(rpc._client_id + \":default\");\n    // if (svc.setup) {\n    //   await svc.setup();\n    // }\n  }\n\n  async function getPlugin(query) {\n    return await wm.get_service(query + \":default\");\n  }\n\n  async function disconnect() {\n    await rpc.disconnect();\n    await connection.disconnect();\n  }\n\n  wm.config[\"client_id\"] = clientId;\n  wm.export = _export;\n  wm.getPlugin = getPlugin;\n  wm.listPlugins = wm.listServices;\n  wm.disconnect = disconnect;\n  wm.registerCodec = rpc.register_codec.bind(rpc);\n\n  wm.emit = async function (message) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(message && typeof message === \"object\", \"message must be a dictionary\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(\"to\" in message, \"message must have a 'to' field\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(\"type\" in message, \"message must have a 'type' field\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(type !== \"method\", \"message type cannot be 'method'\");\n    return await rpc.emit(message);\n  };\n\n  wm.on = function (type, handler) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(type !== \"method\", \"message type cannot be 'method'\");\n    rpc.on(type, handler);\n  };\n\n  if (config.webrtc) {\n    await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"])(wm, clientId + \"-rtc\", config.webrtc_config);\n  }\n\n  if (wm.get_service || wm.getService) {\n    const _get_service = wm.get_service || wm.getService;\n\n    wm.get_service = async function (query, webrtc, webrtc_config) {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])([undefined, true, false, \"auto\"].includes(webrtc), \"webrtc must be true, false or 'auto'\");\n      const svc = await _get_service(query);\n\n      if (webrtc === true || webrtc === \"auto\") {\n        if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n          const client = svc.id.split(\":\")[0];\n\n          try {\n            // Assuming that the client registered a webrtc service with the client_id + \"-rtc\"\n            const peer = await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"])(wm, client + \":\" + client.split(\"/\")[1] + \"-rtc\", webrtc_config);\n            const rtcSvc = await peer.get_service(svc.id.split(\":\")[1]);\n            rtcSvc._webrtc = true;\n            rtcSvc._peer = peer;\n            rtcSvc._service = svc;\n            return rtcSvc;\n          } catch (e) {\n            console.warn(\"Failed to get webrtc service, using websocket connection\", e);\n          }\n        }\n\n        if (webrtc === true) {\n          throw new Error(\"Failed to get the service via webrtc\");\n        }\n      }\n\n      return svc;\n    };\n\n    wm.getService = wm.get_service;\n  }\n\n  return wm;\n}\n\nclass LocalWebSocket {\n  constructor(url, client_id, workspace) {\n    this.url = url;\n\n    this.onopen = () => {};\n\n    this.onmessage = () => {};\n\n    this.onclose = () => {};\n\n    this.onerror = () => {};\n\n    this.client_id = client_id;\n    this.workspace = workspace;\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n\n    this.postMessage = message => {\n      if (isWindow) {\n        window.parent.postMessage(message, \"*\");\n      } else {\n        self.postMessage(message);\n      }\n    };\n\n    this.readyState = WebSocket.CONNECTING;\n    context.addEventListener(\"message\", event => {\n      const {\n        type,\n        data,\n        to\n      } = event.data;\n\n      if (to !== this.client_id) {\n        console.debug(\"message not for me\", to, this.client_id);\n        return;\n      }\n\n      switch (type) {\n        case \"message\":\n          if (this.readyState === WebSocket.OPEN && this.onmessage) {\n            this.onmessage({\n              data: data\n            });\n          }\n\n          break;\n\n        case \"connected\":\n          this.readyState = WebSocket.OPEN;\n          this.onopen(event);\n          break;\n\n        case \"closed\":\n          this.readyState = WebSocket.CLOSED;\n          this.onclose(event);\n          break;\n\n        default:\n          break;\n      }\n    }, false);\n    if (!this.client_id) throw new Error(\"client_id is required\");\n    if (!this.workspace) throw new Error(\"workspace is required\");\n    this.postMessage({\n      type: \"connect\",\n      url: this.url,\n      from: this.client_id,\n      workspace: this.workspace\n    });\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.postMessage({\n        type: \"message\",\n        data: data,\n        from: this.client_id,\n        workspace: this.workspace\n      });\n    }\n  }\n\n  close() {\n    this.readyState = WebSocket.CLOSING;\n    this.postMessage({\n      type: \"close\",\n      from: this.client_id,\n      workspace: this.workspace\n    });\n    this.onclose();\n  }\n\n  addEventListener(type, listener) {\n    if (type === \"message\") {\n      this.onmessage = listener;\n    }\n\n    if (type === \"open\") {\n      this.onopen = listener;\n    }\n\n    if (type === \"close\") {\n      this.onclose = listener;\n    }\n\n    if (type === \"error\") {\n      this.onerror = listener;\n    }\n  }\n\n}\n\nfunction setupLocalClient({\n  enable_execution = false,\n  on_ready = null\n}) {\n  return new Promise((resolve, reject) => {\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    context.addEventListener(\"message\", event => {\n      const {\n        type,\n        server_url,\n        workspace,\n        client_id,\n        token,\n        method_timeout,\n        name,\n        config\n      } = event.data;\n\n      if (type === \"initializeHyphaClient\") {\n        if (!server_url || !workspace || !client_id) {\n          console.error(\"server_url, workspace, and client_id are required.\");\n          return;\n        }\n\n        if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n          console.error(\"server_url should start with https://local-hypha-server:\");\n          return;\n        }\n\n        connectToServer({\n          server_url,\n          workspace,\n          client_id,\n          token,\n          method_timeout,\n          name\n        }).then(async server => {\n          globalThis.api = server;\n\n          try {\n            // for iframe\n            if (isWindow && enable_execution) {\n              function loadScript(script) {\n                return new Promise((resolve, reject) => {\n                  const scriptElement = document.createElement(\"script\");\n                  scriptElement.innerHTML = script.content;\n                  scriptElement.lang = script.lang;\n\n                  scriptElement.onload = () => resolve();\n\n                  scriptElement.onerror = e => reject(e);\n\n                  document.head.appendChild(scriptElement);\n                });\n              }\n\n              if (config.styles && config.styles.length > 0) {\n                for (const style of config.styles) {\n                  const styleElement = document.createElement(\"style\");\n                  styleElement.innerHTML = style.content;\n                  styleElement.lang = style.lang;\n                  document.head.appendChild(styleElement);\n                }\n              }\n\n              if (config.links && config.links.length > 0) {\n                for (const link of config.links) {\n                  const linkElement = document.createElement(\"a\");\n                  linkElement.href = link.url;\n                  linkElement.innerText = link.text;\n                  document.body.appendChild(linkElement);\n                }\n              }\n\n              if (config.windows && config.windows.length > 0) {\n                for (const w of config.windows) {\n                  document.body.innerHTML = w.content;\n                  break;\n                }\n              }\n\n              if (config.scripts && config.scripts.length > 0) {\n                for (const script of config.scripts) {\n                  if (script.lang !== \"javascript\") throw new Error(\"Only javascript scripts are supported\");\n                  await loadScript(script); // Await the loading of each script\n                }\n              }\n            } // for web worker\n            else if (!isWindow && enable_execution && config.scripts && config.scripts.length > 0) {\n              for (const script of config.scripts) {\n                if (script.lang !== \"javascript\") throw new Error(\"Only javascript scripts are supported\");\n                eval(script.content);\n              }\n            }\n\n            if (on_ready) {\n              await on_ready(server, config);\n            }\n\n            resolve(server);\n          } catch (e) {\n            // If any script fails to load, send an error message\n            await server.update_client_info({\n              id: client_id,\n              error: e.message\n            });\n            reject(e);\n          }\n        });\n      }\n    }, false);\n\n    if (isWindow) {\n      window.parent.postMessage({\n        type: \"hyphaClientReady\"\n      }, \"*\");\n    } else {\n      self.postMessage({\n        type: \"hyphaClientReady\"\n      });\n    }\n  });\n}\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=hypha-rpc-websocket.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc.js":
/*!**************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc.js ***!
  \**************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_551__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_551__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_551__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_551__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_551__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_551__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_551__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_551__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_551__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_551__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_551__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_551__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_551__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_551__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_551__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_551__(__nested_webpack_require_551__.s = \"./src/hypha/rpc.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n  \\*************************************************************************/\n/*! exports provided: CachedKeyDecoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_4404__) {\n\n\"use strict\";\n__nested_webpack_require_4404__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_4404__.d(__nested_webpack_exports__, \"CachedKeyDecoder\", function() { return CachedKeyDecoder; });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4404__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n  \\********************************************************************/\n/*! exports provided: DecodeError */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_7930__) {\n\n\"use strict\";\n__nested_webpack_require_7930__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_7930__.d(__nested_webpack_exports__, \"DecodeError\", function() { return DecodeError; });\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n  \\****************************************************************/\n/*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_9926__) {\n\n\"use strict\";\n__nested_webpack_require_9926__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_9926__.d(__nested_webpack_exports__, \"DataViewIndexOutOfBoundsError\", function() { return DataViewIndexOutOfBoundsError; });\n/* harmony export (binding) */ __nested_webpack_require_9926__.d(__nested_webpack_exports__, \"Decoder\", function() { return Decoder; });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_9926__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_9926__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_9926__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_9926__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_9926__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_9926__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_9926__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nvar DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxBinLength === void 0) { maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxArrayLength === void 0) { maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxMapLength === void 0) { maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (maxExtLength === void 0) { maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"]; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n        this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n    };\n    /**\n     * @throws {DecodeError}\n     * @throws {RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n        }\n        this.stack.push({\n            type: 1 /* MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n        }\n        this.stack.push({\n            type: 0 /* ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n            object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n        }\n        else {\n            object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n  \\****************************************************************/\n/*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_43732__) {\n\n\"use strict\";\n__nested_webpack_require_43732__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_43732__.d(__nested_webpack_exports__, \"DEFAULT_MAX_DEPTH\", function() { return DEFAULT_MAX_DEPTH; });\n/* harmony export (binding) */ __nested_webpack_require_43732__.d(__nested_webpack_exports__, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() { return DEFAULT_INITIAL_BUFFER_SIZE; });\n/* harmony export (binding) */ __nested_webpack_require_43732__.d(__nested_webpack_exports__, \"Encoder\", function() { return Encoder; });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_43732__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_43732__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_43732__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_43732__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.getUint8Array = function () {\n        return this.bytes.subarray(0, this.pos);\n    };\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.getUint8Array();\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \" + depth);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n            var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \" + size);\n        }\n        var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \" + size);\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \" + size);\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \" + size);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n  \\****************************************************************/\n/*! exports provided: ExtData */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_59301__) {\n\n\"use strict\";\n__nested_webpack_require_59301__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_59301__.d(__nested_webpack_exports__, \"ExtData\", function() { return ExtData; });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n  \\***********************************************************************/\n/*! exports provided: ExtensionCodec */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_60209__) {\n\n\"use strict\";\n__nested_webpack_require_60209__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_60209__.d(__nested_webpack_exports__, \"ExtensionCodec\", function() { return ExtensionCodec; });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60209__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_60209__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n  \\***************************************************************/\n/*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_63785__) {\n\n\"use strict\";\n__nested_webpack_require_63785__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_63785__.d(__nested_webpack_exports__, \"defaultDecodeOptions\", function() { return defaultDecodeOptions; });\n/* harmony export (binding) */ __nested_webpack_require_63785__.d(__nested_webpack_exports__, \"decode\", function() { return decode; });\n/* harmony export (binding) */ __nested_webpack_require_63785__.d(__nested_webpack_exports__, \"decodeMulti\", function() { return decodeMulti; });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_63785__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n\nvar defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n */\nfunction decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n */\nfunction decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n  \\********************************************************************/\n/*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_66040__) {\n\n\"use strict\";\n__nested_webpack_require_66040__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_66040__.d(__nested_webpack_exports__, \"decodeAsync\", function() { return decodeAsync; });\n/* harmony export (binding) */ __nested_webpack_require_66040__.d(__nested_webpack_exports__, \"decodeArrayStream\", function() { return decodeArrayStream; });\n/* harmony export (binding) */ __nested_webpack_require_66040__.d(__nested_webpack_exports__, \"decodeMultiStream\", function() { return decodeMultiStream; });\n/* harmony export (binding) */ __nested_webpack_require_66040__.d(__nested_webpack_exports__, \"decodeStream\", function() { return decodeStream; });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_66040__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony import */ var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_66040__(/*! ./utils/stream.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\");\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_66040__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nfunction decodeAsync(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    return __awaiter(this, void 0, void 0, function () {\n        var stream, decoder;\n        return __generator(this, function (_a) {\n            stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return [2 /*return*/, decoder.decodeAsync(stream)];\n        });\n    });\n}\nfunction decodeArrayStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeArrayStream(stream);\n}\nfunction decodeMultiStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeStream(stream);\n}\n/**\n * @deprecated Use {@link decodeMultiStream()} instead.\n */\nfunction decodeStream(streamLike, options) {\n    if (options === void 0) { options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"]; }\n    return decodeMultiStream(streamLike, options);\n}\n//# sourceMappingURL=decodeAsync.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n  \\***************************************************************/\n/*! exports provided: encode */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_72154__) {\n\n\"use strict\";\n__nested_webpack_require_72154__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_72154__.d(__nested_webpack_exports__, \"encode\", function() { return encode; });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_72154__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encode(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n  \\**************************************************************/\n/*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_73944__) {\n\n\"use strict\";\n__nested_webpack_require_73944__.r(__nested_webpack_exports__);\n/* harmony import */ var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_73944__(/*! ./encode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"encode\", function() { return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"]; });\n\n/* harmony import */ var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_73944__(/*! ./decode.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decode\", function() { return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeMulti\", function() { return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"]; });\n\n/* harmony import */ var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_73944__(/*! ./decodeAsync.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeAsync\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeArrayStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeMultiStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeStream\", function() { return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"]; });\n\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_73944__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"Decoder\", function() { return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"DataViewIndexOutOfBoundsError\", function() { return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"]; });\n\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_73944__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"DecodeError\", function() { return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"]; });\n\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_73944__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"Encoder\", function() { return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"]; });\n\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_73944__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"ExtensionCodec\", function() { return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"]; });\n\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_73944__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"ExtData\", function() { return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"]; });\n\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_73944__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"EXT_TIMESTAMP\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"encodeDateToTimeSpec\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"encodeTimeSpecToTimestamp\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeTimestampToTimeSpec\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"encodeTimestampExtension\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_73944__.d(__nested_webpack_exports__, \"decodeTimestampExtension\", function() { return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"]; });\n\n// Main Functions:\n\n\n\n\n\n\n\n\n\n\n\n// Utilitiies for Extension Types:\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n  \\******************************************************************/\n/*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_79694__) {\n\n\"use strict\";\n__nested_webpack_require_79694__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"EXT_TIMESTAMP\", function() { return EXT_TIMESTAMP; });\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"encodeTimeSpecToTimestamp\", function() { return encodeTimeSpecToTimestamp; });\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"encodeDateToTimeSpec\", function() { return encodeDateToTimeSpec; });\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"encodeTimestampExtension\", function() { return encodeTimestampExtension; });\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"decodeTimestampToTimeSpec\", function() { return decodeTimestampToTimeSpec; });\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"decodeTimestampExtension\", function() { return decodeTimestampExtension; });\n/* harmony export (binding) */ __nested_webpack_require_79694__.d(__nested_webpack_exports__, \"timestampExtension\", function() { return timestampExtension; });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_79694__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_79694__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n  \\******************************************************************/\n/*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_85118__) {\n\n\"use strict\";\n__nested_webpack_require_85118__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_85118__.d(__nested_webpack_exports__, \"UINT32_MAX\", function() { return UINT32_MAX; });\n/* harmony export (binding) */ __nested_webpack_require_85118__.d(__nested_webpack_exports__, \"setUint64\", function() { return setUint64; });\n/* harmony export (binding) */ __nested_webpack_require_85118__.d(__nested_webpack_exports__, \"setInt64\", function() { return setInt64; });\n/* harmony export (binding) */ __nested_webpack_require_85118__.d(__nested_webpack_exports__, \"getInt64\", function() { return getInt64; });\n/* harmony export (binding) */ __nested_webpack_require_85118__.d(__nested_webpack_exports__, \"getUint64\", function() { return getUint64; });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n  \\*************************************************************************/\n/*! exports provided: prettyByte */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_87157__) {\n\n\"use strict\";\n__nested_webpack_require_87157__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_87157__.d(__nested_webpack_exports__, \"prettyByte\", function() { return prettyByte; });\nfunction prettyByte(byte) {\n    return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n  \\*********************************************************************/\n/*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_87972__) {\n\n\"use strict\";\n__nested_webpack_require_87972__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_87972__.d(__nested_webpack_exports__, \"isAsyncIterable\", function() { return isAsyncIterable; });\n/* harmony export (binding) */ __nested_webpack_require_87972__.d(__nested_webpack_exports__, \"asyncIterableFromStream\", function() { return asyncIterableFromStream; });\n/* harmony export (binding) */ __nested_webpack_require_87972__.d(__nested_webpack_exports__, \"ensureAsyncIterable\", function() { return ensureAsyncIterable; });\n// utility for whatwg streams\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nfunction isAsyncIterable(object) {\n    return object[Symbol.asyncIterator] != null;\n}\nfunction assertNonNull(value) {\n    if (value == null) {\n        throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n    }\n}\nfunction asyncIterableFromStream(stream) {\n    return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n        var reader, _a, done, value;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                case 2:\n                    if (false) {}\n                    return [4 /*yield*/, __await(reader.read())];\n                case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done) return [3 /*break*/, 5];\n                    return [4 /*yield*/, __await(void 0)];\n                case 4: return [2 /*return*/, _b.sent()];\n                case 5:\n                    assertNonNull(value);\n                    return [4 /*yield*/, __await(value)];\n                case 6: return [4 /*yield*/, _b.sent()];\n                case 7:\n                    _b.sent();\n                    return [3 /*break*/, 2];\n                case 8: return [3 /*break*/, 10];\n                case 9:\n                    reader.releaseLock();\n                    return [7 /*endfinally*/];\n                case 10: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction ensureAsyncIterable(streamLike) {\n    if (isAsyncIterable(streamLike)) {\n        return streamLike;\n    }\n    else {\n        return asyncIterableFromStream(streamLike);\n    }\n}\n//# sourceMappingURL=stream.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n  \\**************************************************************************/\n/*! exports provided: ensureUint8Array, createDataView */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_93673__) {\n\n\"use strict\";\n__nested_webpack_require_93673__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_93673__.d(__nested_webpack_exports__, \"ensureUint8Array\", function() { return ensureUint8Array; });\n/* harmony export (binding) */ __nested_webpack_require_93673__.d(__nested_webpack_exports__, \"createDataView\", function() { return createDataView; });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n  \\*******************************************************************/\n/*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_95233__) {\n\n\"use strict\";\n__nested_webpack_require_95233__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"utf8Count\", function() { return utf8Count; });\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"utf8EncodeJs\", function() { return utf8EncodeJs; });\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"TEXT_ENCODER_THRESHOLD\", function() { return TEXT_ENCODER_THRESHOLD; });\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"utf8EncodeTE\", function() { return utf8EncodeTE; });\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"utf8DecodeJs\", function() { return utf8DecodeJs; });\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"TEXT_DECODER_THRESHOLD\", function() { return TEXT_DECODER_THRESHOLD; });\n/* harmony export (binding) */ __nested_webpack_require_95233__.d(__nested_webpack_exports__, \"utf8DecodeTD\", function() { return utf8DecodeTD; });\n/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_95233__(/*! ./int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"]\n    : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"]\n    : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\"\n        ? 200\n        : 0;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map\n\n/***/ }),\n\n/***/ \"./src/hypha/rpc.js\":\n/*!**************************!*\\\n  !*** ./src/hypha/rpc.js ***!\n  \\**************************/\n/*! exports provided: API_VERSION, RPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_102278__) {\n\n\"use strict\";\n__nested_webpack_require_102278__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_102278__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __nested_webpack_require_102278__.d(__nested_webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_102278__(/*! ./utils.js */ \"./src/hypha/utils.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_102278__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\n\nconst API_VERSION = \"0.3.0\";\nconst CHUNK_SIZE = 1024 * 500;\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\n}\n\nfunction getFunctionInfo(func) {\n  const funcString = func.toString(); // Extract function name\n\n  const nameMatch = funcString.match(/function\\s*(\\w*)/);\n  const name = nameMatch && nameMatch[1] || \"\"; // Extract function parameters, excluding comments\n\n  const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n  let params = \"\";\n\n  if (paramsMatch) {\n    params = paramsMatch[1].split(\",\").map(p => p.replace(/\\/\\*.*?\\*\\//g, \"\") // Remove block comments\n    .replace(/\\/\\/.*$/g, \"\")) // Remove line comments\n    .filter(p => p.trim().length > 0) // Remove empty strings after removing comments\n    .map(p => p.trim()) // Trim remaining whitespace\n    .join(\", \");\n  } // Extract function docstring (block comment)\n\n\n  let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n  const docstringBlock = docMatch && docMatch[1].trim() || \"\"; // Extract function docstring (line comment)\n\n  docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n  const docstringLine = docMatch && docMatch[1].split(\"\\n\").map(s => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n  const docstring = docstringBlock || docstringLine;\n  return name && params.length > 0 && {\n    name: name,\n    sig: params,\n    doc: docstring\n  };\n}\n\nfunction concatArrayBuffers(buffers) {\n  var buffersLengths = buffers.map(function (b) {\n    return b.byteLength;\n  }),\n      totalBufferlength = buffersLengths.reduce(function (p, c) {\n    return p + c;\n  }, 0),\n      unit8Arr = new Uint8Array(totalBufferlength);\n  buffersLengths.reduce(function (p, c, i) {\n    unit8Arr.set(new Uint8Array(buffers[i]), p);\n    return p + c;\n  }, 0);\n  return unit8Arr.buffer;\n}\n\nclass Timer {\n  constructor(timeout, callback, args, label) {\n    this._timeout = timeout;\n    this._callback = callback;\n    this._args = args;\n    this._label = label || \"timer\";\n    this._task = null;\n    this.started = false;\n  }\n\n  start() {\n    if (this.started) {\n      this.reset();\n    } else {\n      this._task = setTimeout(() => {\n        this._callback.apply(this, this._args);\n      }, this._timeout * 1000);\n      this.started = true;\n    }\n  }\n\n  clear() {\n    if (this._task) {\n      clearTimeout(this._task);\n      this._task = null;\n      this.started = false;\n    } else {\n      console.warn(`Clearing a timer (${this._label}) which is not started`);\n    }\n  }\n\n  reset() {\n    if (this._task) {\n      clearTimeout(this._task);\n    }\n\n    this._task = setTimeout(() => {\n      this._callback.apply(this, this._args);\n    }, this._timeout * 1000);\n    this.started = true;\n  }\n\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, {\n    client_id = null,\n    manager_id = null,\n    default_context = null,\n    name = null,\n    codecs = null,\n    method_timeout = null,\n    max_message_buffer_size = 0,\n    debug = false,\n    workspace = null\n  }) {\n    super(debug);\n    this._codecs = codecs || {};\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n    this._client_id = client_id;\n    this._name = name;\n    this._connection_info = null;\n    this._workspace = null;\n    this._local_workspace = workspace;\n    this.manager_id = manager_id;\n    this.default_context = default_context || {};\n    this._method_annotations = new WeakMap();\n    this._manager_service = null;\n    this._max_message_buffer_size = max_message_buffer_size;\n    this._chunk_store = {};\n    this._method_timeout = method_timeout || 30; // make sure there is an execute function\n\n    this._services = {};\n    this._object_store = {\n      services: this._services\n    };\n\n    if (connection) {\n      this.add_service({\n        id: \"built-in\",\n        type: \"built-in\",\n        name: \"RPC built-in services\",\n        config: {\n          require_context: true,\n          visibility: \"public\"\n        },\n        ping: this._ping.bind(this),\n        get_service: this.get_local_service.bind(this),\n        register_service: this.register_service.bind(this),\n        message_cache: {\n          create: this._create_message.bind(this),\n          append: this._append_message.bind(this),\n          process: this._process_message.bind(this),\n          remove: this._remove_message.bind(this)\n        }\n      });\n      this.on(\"method\", this._handle_method.bind(this));\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n      this._emit_message = connection.emit_message.bind(connection);\n      connection.on_message(this._on_message.bind(this));\n      this._connection = connection; // Update the server and obtain client info\n\n      this._get_connection_info();\n    } else {\n      this._emit_message = function () {\n        console.log(\"No connection to emit message\");\n      };\n    }\n  }\n\n  async _get_connection_info() {\n    if (this.manager_id) {\n      // try to get the root service\n      try {\n        await this.get_manager_service(30.0);\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n        this._connection_info = await this._manager_service.get_connection_info();\n\n        if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n          this._local_workspace = this._connection_info.workspace;\n        }\n\n        if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n          this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n\n          const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8; // console.info(\n          //   `Reconnection token obtained: ${this._connection_info.reconnection_token}, will be refreshed in ${reconnection_expires_in} seconds`\n          // );\n\n          this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1000);\n        }\n      } catch (exp) {\n        console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n      }\n    }\n  }\n\n  register_codec(config) {\n    if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n      throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n    } else {\n      if (config.type) {\n        for (let k of Object.keys(this._codecs)) {\n          if (this._codecs[k].type === config.type || k === config.name) {\n            delete this._codecs[k];\n            console.warn(\"Remove duplicated codec: \" + k);\n          }\n        }\n      }\n\n      this._codecs[config[\"name\"]] = config;\n    }\n  }\n\n  async _ping(msg, context) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n    return \"pong\";\n  }\n\n  async ping(client_id, timeout) {\n    let method = this._generate_remote_method({\n      _rtarget: client_id,\n      _rmethod: \"services.built-in.ping\",\n      _rpromise: true,\n      _rdoc: \"Ping a remote client\",\n      _rsig: \"ping(msg)\"\n    });\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])((await method(\"ping\", timeout)) == \"pong\");\n  }\n\n  _create_message(key, heartbeat, overwrite, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    if (!this._object_store[\"message_cache\"]) {\n      this._object_store[\"message_cache\"] = {};\n    }\n\n    if (!overwrite && this._object_store[\"message_cache\"][key]) {\n      throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n    }\n\n    this._object_store[\"message_cache\"][key] = [];\n  }\n\n  _append_message(key, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    const cache = this._object_store[\"message_cache\"];\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n    cache[key].push(data);\n  }\n\n  _remove_message(key, context) {\n    const cache = this._object_store[\"message_cache\"];\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    delete cache[key];\n  }\n\n  _process_message(key, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    const cache = this._object_store[\"message_cache\"];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n\n    cache[key] = concatArrayBuffers(cache[key]);\n    console.debug(`Processing message ${key} (size=${cache[key].length})`);\n    let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n    const {\n      done,\n      value\n    } = unpacker.next();\n    const main = value; // Make sure the fields are from trusted source\n\n    Object.assign(main, {\n      from: context.from,\n      to: context.to,\n      user: context.user\n    });\n    main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n    Object.assign(main[\"ctx\"], this.default_context);\n\n    if (!done) {\n      let extra = unpacker.next();\n      Object.assign(main, extra.value);\n    }\n\n    this._fire(main[\"type\"], main);\n\n    delete cache[key];\n  }\n\n  _on_message(message) {\n    try {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n      let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n      const {\n        done,\n        value\n      } = unpacker.next();\n      const main = value; // Add trusted context to the method call\n\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n\n      if (!done) {\n        let extra = unpacker.next();\n        Object.assign(main, extra.value);\n      }\n\n      this._fire(main[\"type\"], main);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._services = {};\n  }\n\n  async disconnect() {\n    if (this._get_connection_info_task) {\n      clearTimeout(this._get_connection_info_task);\n      this._get_connection_info_task = null;\n    }\n\n    this._fire(\"disconnect\");\n  }\n\n  async get_manager_service(timeout) {\n    if (this.manager_id && !this._manager_service) {\n      this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n    }\n  }\n\n  get_all_local_services() {\n    return this._services;\n  }\n\n  get_local_service(service_id, context) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n    const [ws, client_id] = context[\"to\"].split(\"/\");\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n    const service = this._services[service_id];\n\n    if (!service) {\n      throw new Error(\"Service not found: \" + service_id);\n    } // allow access for the same workspace\n\n\n    if (service.config.visibility == \"public\") {\n      return service;\n    } // allow access for the same workspace\n\n\n    if (context[\"from\"].startsWith(ws + \"/\")) {\n      return service;\n    }\n\n    throw new Error(\"Permission denied for service: \" + service_id);\n  }\n\n  async get_remote_service(service_uri, timeout) {\n    timeout = timeout === undefined ? this._method_timeout : timeout;\n\n    if (!service_uri && this.manager_id) {\n      service_uri = this.manager_id;\n    } else if (!service_uri.includes(\":\")) {\n      service_uri = this._client_id + \":\" + service_uri;\n    }\n\n    const provider = service_uri.split(\":\")[0];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n\n    try {\n      const method = this._generate_remote_method({\n        _rtarget: provider,\n        _rmethod: \"services.built-in.get_service\",\n        _rpromise: true,\n        _rdoc: \"Get a remote service\",\n        _rsig: \"get_service(service_id)\"\n      });\n\n      const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n      svc.id = service_uri;\n      return svc;\n    } catch (e) {\n      console.error(\"Failed to get remote service: \" + service_uri, e);\n      throw e;\n    }\n  }\n\n  _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n    if (typeof aObject === \"function\") {\n      // mark the method as a remote method that requires context\n      let method_name = object_id.split(\".\")[1];\n\n      this._method_annotations.set(aObject, {\n        require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n        run_in_executor: run_in_executor,\n        method_id: \"services.\" + object_id,\n        visibility: visibility\n      });\n    } else if (aObject instanceof Array || aObject instanceof Object) {\n      for (let key of Object.keys(aObject)) {\n        let val = aObject[key];\n\n        if (typeof val === \"function\" && val.__rpc_object__) {\n          let client_id = val.__rpc_object__._rtarget;\n\n          if (client_id.includes(\"/\")) {\n            client_id = client_id.split(\"/\")[1];\n          }\n\n          if (this._client_id === client_id) {\n            if (aObject instanceof Array) {\n              aObject = aObject.slice();\n            } // recover local method\n\n\n            aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n            val = aObject[key]; // make sure it's annotated later\n          } else {\n            throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n          }\n        }\n\n        this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n      }\n    }\n  }\n\n  add_service(api, overwrite) {\n    if (!api || Array.isArray(api)) throw new Error(\"Invalid service object\");\n\n    if (api.constructor === Object) {\n      api = Object.assign({}, api);\n    } else {\n      const normApi = {};\n      const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n\n      for (let k of props) {\n        if (k !== \"constructor\") {\n          if (typeof api[k] === \"function\") normApi[k] = api[k].bind(api);else normApi[k] = api[k];\n        }\n      } // For class instance, we need set a default id\n\n\n      api.id = api.id || \"default\";\n      api = normApi;\n    }\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n\n    if (!api.name) {\n      api.name = api.id;\n    }\n\n    if (!api.config) {\n      api.config = {};\n    }\n\n    if (!api.type) {\n      api.type = \"generic\";\n    } // require_context only applies to the top-level functions\n\n\n    let require_context = false,\n        run_in_executor = false;\n    if (api.config.require_context) require_context = api.config.require_context;\n    if (api.config.run_in_executor) run_in_executor = true;\n    const visibility = api.config.visibility || \"protected\";\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n\n    this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n\n    if (this._services[api.id]) {\n      if (overwrite) {\n        delete this._services[api.id];\n      } else {\n        throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n      }\n    }\n\n    this._services[api.id] = api;\n    return api;\n  }\n\n  async register_service(api, overwrite, notify, context) {\n    if (notify === undefined) notify = true;\n\n    if (context) {\n      // If this function is called from remote, we need to make sure\n      const [workspace, client_id] = context[\"to\"].split(\"/\");\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n    }\n\n    const service = this.add_service(api, overwrite);\n\n    if (notify) {\n      this._fire(\"service-updated\", {\n        service_id: service[\"id\"],\n        api: service,\n        type: \"add\"\n      });\n\n      await this._notify_service_update();\n    }\n\n    return {\n      id: `${this._client_id}:${service[\"id\"]}`,\n      type: service[\"type\"],\n      name: service[\"name\"],\n      description: service[\"description\"] || \"\",\n      config: service[\"config\"]\n    };\n  }\n\n  async unregister_service(service, notify) {\n    if (service instanceof Object) {\n      service = service.id;\n    }\n\n    if (!this._services[service]) {\n      throw new Error(`Service not found: ${service}`);\n    }\n\n    const api = this._services[service];\n    delete this._services[service];\n\n    this._fire(\"service-updated\", {\n      service_id: service,\n      api: api,\n      type: \"remove\"\n    });\n\n    await this._notify_service_update();\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n\n  _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n    let method_id = `${session_id}.${name}`;\n    let encoded = {\n      _rtype: \"method\",\n      _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n      _rmethod: method_id,\n      _rpromise: false\n    };\n    const self = this;\n\n    let wrapped_callback = function () {\n      try {\n        callback.apply(null, Array.prototype.slice.call(arguments));\n      } catch (error) {\n        console.error(\"Error in callback:\", method_id, error);\n      } finally {\n        if (clear_after_called && self._object_store[session_id]) {\n          // console.log(\"Deleting session\", session_id, \"from\", self._client_id);\n          delete self._object_store[session_id];\n        }\n\n        if (timer && timer.started) {\n          timer.clear();\n        }\n      }\n    };\n\n    return [encoded, wrapped_callback];\n  }\n\n  async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n    let store = this._get_session_store(session_id, true);\n\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n    let encoded = {};\n\n    if (timer && reject && this._method_timeout) {\n      encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n      encoded.interval = this._method_timeout / 2;\n      store.timer = timer;\n    } else {\n      timer = null;\n    }\n\n    [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n    [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n    return encoded;\n  }\n\n  async _send_chunks(data, target_id, session_id) {\n    let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n    let message_cache = remote_services.message_cache;\n    let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n    await message_cache.create(message_id, !!session_id);\n    let total_size = data.length;\n    let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n\n    for (let idx = 0; idx < chunk_num; idx++) {\n      let start_byte = idx * CHUNK_SIZE;\n      await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id); // console.log(\n      //   `Sending chunk ${idx + 1}/${chunk_num} (${total_size} bytes)`\n      // );\n    } // console.log(`All chunks sent (${chunk_num})`);\n\n\n    await message_cache.process(message_id, !!session_id);\n  }\n\n  emit(main_message, extra_data) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n    let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n\n    if (extra_data) {\n      const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n      message_package = new Uint8Array([...message_package, ...extra]);\n    }\n\n    const total_size = message_package.length;\n\n    if (total_size <= CHUNK_SIZE + 1024) {\n      return this._emit_message(message_package);\n    } else {\n      throw new Error(\"Message is too large to send in one go.\");\n    }\n  }\n\n  _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n    let target_id = encoded_method._rtarget;\n\n    if (remote_workspace && !target_id.includes(\"/\")) {\n      if (remote_workspace !== target_id) {\n        target_id = remote_workspace + \"/\" + target_id;\n      } // Fix the target id to be an absolute id\n\n\n      encoded_method._rtarget = target_id;\n    }\n\n    let method_id = encoded_method._rmethod;\n    let with_promise = encoded_method._rpromise;\n    const self = this;\n\n    function remote_method() {\n      return new Promise(async (resolve, reject) => {\n        let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n        if (local_parent) {\n          // Store the children session under the parent\n          local_session_id = local_parent + \".\" + local_session_id;\n        }\n\n        let store = self._get_session_store(local_session_id, true);\n\n        if (!store) {\n          reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n          return;\n        }\n\n        store[\"target_id\"] = target_id;\n        const args = await self._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n        let main_message = {\n          type: \"method\",\n          from: self._local_workspace ? self._local_workspace + \"/\" + self._client_id : self._client_id,\n          to: target_id,\n          method: method_id\n        };\n        let extra_data = {};\n\n        if (args) {\n          extra_data[\"args\"] = args;\n        }\n\n        if (withKwargs) {\n          extra_data[\"with_kwargs\"] = withKwargs;\n        } // console.log(\n        //   `Calling remote method ${target_id}:${method_id}, session: ${local_session_id}`\n        // );\n\n\n        if (remote_parent) {\n          // Set the parent session\n          // Note: It's a session id for the remote, not the current client\n          main_message[\"parent\"] = remote_parent;\n        }\n\n        let timer = null;\n\n        if (with_promise) {\n          // Only pass the current session id to the remote\n          // if we want to received the result\n          // I.e. the session id won't be passed for promises themselves\n          main_message[\"session\"] = local_session_id;\n          let method_name = `${target_id}:${method_id}`;\n          timer = new Timer(self._method_timeout, reject, [`Method call time out: ${method_name}`], method_name); // By default, hypha will clear the session after the method is called\n          // However, if the args contains _rintf === true, we will not clear the session\n\n          let clear_after_called = true;\n\n          for (let arg of args) {\n            if (typeof arg === \"object\" && arg._rintf === true) {\n              clear_after_called = false;\n              break;\n            }\n          }\n\n          extra_data[\"promise\"] = await self._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n        } // The message consists of two segments, the main message and extra data\n\n\n        let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n\n        if (extra_data) {\n          const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n          message_package = new Uint8Array([...message_package, ...extra]);\n        }\n\n        const total_size = message_package.length;\n\n        if (total_size <= CHUNK_SIZE + 1024) {\n          self._emit_message(message_package).then(function () {\n            if (timer) {\n              // console.log(`Start watchdog timer.`);\n              // Only start the timer after we send the message successfully\n              timer.start();\n            }\n          });\n        } else {\n          // send chunk by chunk\n          self._send_chunks(message_package, target_id, remote_parent).then(function () {\n            if (timer) {\n              // console.log(`Start watchdog timer.`);\n              // Only start the timer after we send the message successfully\n              timer.start();\n            }\n          });\n        }\n      });\n    } // Generate debugging information for the method\n\n\n    remote_method.__rpc_object__ = encoded_method;\n    const parts = method_id.split(\".\");\n    remote_method.__name__ = parts[parts.length - 1];\n    remote_method.__doc__ = encoded_method._rdoc;\n    remote_method.__sig__ = encoded_method._rsig;\n    return remote_method;\n  }\n\n  async _notify_service_update() {\n    if (this.manager_id) {\n      // try to get the root service\n      try {\n        await this.get_manager_service(30.0);\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n        await this._manager_service.update_client_info(this.get_client_info());\n      } catch (exp) {\n        // pylint: disable=broad-except\n        console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n      }\n    }\n  }\n\n  get_client_info() {\n    const services = [];\n\n    for (let service of Object.values(this._services)) {\n      services.push({\n        id: `${this._client_id}:${service[\"id\"]}`,\n        type: service[\"type\"],\n        name: service[\"name\"],\n        description: service[\"description\"] || \"\",\n        config: service[\"config\"]\n      });\n    }\n\n    return {\n      id: this._client_id,\n      services: services\n    };\n  }\n\n  async _handle_method(data) {\n    let reject = null;\n    let heartbeat_task = null;\n\n    try {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n      const method_name = data.from + \":\" + data.method;\n      const remote_workspace = data.from.split(\"/\")[0]; // Make sure the target id is an absolute id\n\n      data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n      data[\"ctx\"][\"to\"] = data[\"to\"];\n      const local_workspace = data.to.split(\"/\")[0];\n      const local_parent = data.parent;\n      let resolve, reject;\n\n      if (data.promise) {\n        // Decode the promise with the remote session id\n        // Such that the session id will be passed to the remote as a parent session id\n        const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n        resolve = promise.resolve;\n        reject = promise.reject;\n\n        if (promise.heartbeat && promise.interval) {\n          async function heartbeat() {\n            try {\n              // console.log(\"Reset heartbeat timer: \" + data.method);\n              await promise.heartbeat();\n            } catch (err) {\n              console.error(err);\n            }\n          }\n\n          heartbeat_task = setInterval(heartbeat, promise.interval * 1000);\n        }\n      }\n\n      let method;\n\n      try {\n        method = indexObject(this._object_store, data[\"method\"]);\n      } catch (e) {\n        console.debug(\"Failed to find method\", method_name, e);\n        throw new Error(`Method not found: ${method_name}`);\n      }\n\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name); // Check permission\n\n      if (this._method_annotations.has(method)) {\n        // For services, it should not be protected\n        if (this._method_annotations.get(method).visibility === \"protected\") {\n          if (local_workspace !== remote_workspace) {\n            throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n          }\n        }\n      } else {\n        // For sessions, the target_id should match exactly\n        let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n\n        if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n          session_target_id = local_workspace + \"/\" + session_target_id;\n        }\n\n        if (session_target_id !== data.from) {\n          throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n        }\n      } // Make sure the parent session is still open\n\n\n      if (local_parent) {\n        // The parent session should be a session that generate the current method call\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n      }\n\n      let args;\n\n      if (data.args) {\n        args = await this._decode(data.args, data.session, null, remote_workspace, null);\n      } else {\n        args = [];\n      }\n\n      if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n        args.push(data.ctx);\n      } // console.log(\"Executing method: \" + method_name);\n\n\n      if (data.promise) {\n        const result = method.apply(null, args);\n\n        if (result instanceof Promise) {\n          result.then(result => {\n            resolve(result);\n            clearInterval(heartbeat_task);\n          }).catch(err => {\n            reject(err);\n            clearInterval(heartbeat_task);\n          });\n        } else {\n          resolve(result);\n          clearInterval(heartbeat_task);\n        }\n      } else {\n        method.apply(null, args);\n        clearInterval(heartbeat_task);\n      }\n    } catch (err) {\n      if (reject) {\n        reject(err);\n        console.debug(\"Error during calling method: \", err);\n      } else {\n        console.error(\"Error during calling method: \", err);\n      } // make sure we clear the heartbeat timer\n\n\n      clearInterval(heartbeat_task);\n    }\n  }\n\n  encode(aObject, session_id) {\n    return this._encode(aObject, session_id);\n  }\n\n  _get_session_store(session_id, create) {\n    let store = this._object_store;\n    const levels = session_id.split(\".\");\n\n    if (create) {\n      const last_index = levels.length - 1;\n\n      for (let level of levels.slice(0, last_index)) {\n        if (!store[level]) {\n          return null;\n        }\n\n        store = store[level];\n      } // Create the last level\n\n\n      if (!store[levels[last_index]]) {\n        store[levels[last_index]] = {};\n      }\n\n      return store[levels[last_index]];\n    } else {\n      for (let level of levels) {\n        if (!store[level]) {\n          return null;\n        }\n\n        store = store[level];\n      }\n\n      return store;\n    }\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  async _encode(aObject, session_id, local_workspace) {\n    const aType = typeof aObject;\n\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof Uint8Array) {\n      return aObject;\n    }\n\n    if (aObject instanceof ArrayBuffer) {\n      return {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject)\n      };\n    } // Reuse the remote object\n\n\n    if (aObject.__rpc_object__) {\n      return aObject.__rpc_object__;\n    }\n\n    let bObject; // skip if already encoded\n\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      const temp = aObject._rtype;\n      delete aObject._rtype;\n      bObject = await this._encode(aObject, session_id, local_workspace);\n      bObject._rtype = temp;\n      return bObject;\n    }\n\n    if (typeof aObject === \"function\") {\n      if (this._method_annotations.has(aObject)) {\n        let annotation = this._method_annotations.get(aObject);\n\n        bObject = {\n          _rtype: \"method\",\n          _rtarget: this._client_id,\n          _rmethod: annotation.method_id,\n          _rpromise: true\n        };\n      } else {\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n        let object_id;\n\n        if (aObject.__name__) {\n          object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n        } else {\n          object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n        }\n\n        bObject = {\n          _rtype: \"method\",\n          _rtarget: this._client_id,\n          _rmethod: `${session_id}.${object_id}`,\n          _rpromise: true\n        };\n\n        let store = this._get_session_store(session_id, true);\n\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n        store[object_id] = aObject;\n      }\n\n      bObject._rdoc = aObject.__doc__;\n      bObject._rsig = aObject.__sig__;\n\n      if (!bObject._rdoc || !bObject._rsig) {\n        try {\n          const funcInfo = getFunctionInfo(aObject);\n\n          if (funcInfo && !bObject._rdoc) {\n            bObject._rdoc = `${funcInfo.doc}`;\n          }\n\n          if (funcInfo && !bObject._rsig) {\n            bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n          }\n        } catch (e) {\n          console.error(\"Failed to extract function docstring:\", aObject);\n        }\n      }\n\n      return bObject;\n    }\n\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\n\n        if (typeof encodedObj === \"object\") {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n          encodedObj._rtype = temp;\n        }\n\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n    /*global tf*/\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\n      const v_buffer = aObject.dataSync();\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(v_buffer.buffer),\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype\n      };\n    } else if (\n    /*global nj*/\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(aObject.selection.data.buffer),\n        _rshape: aObject.shape,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString(),\n        _rtrace: aObject.stack\n      };\n    } // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\n    } else if (aObject instanceof Blob) {\n      let _current_pos = 0;\n\n      async function read(length) {\n        let blob;\n\n        if (length) {\n          blob = aObject.slice(_current_pos, _current_pos + length);\n        } else {\n          blob = aObject.slice(_current_pos);\n        }\n\n        const ret = new Uint8Array(await blob.arrayBuffer());\n        _current_pos = _current_pos + ret.byteLength;\n        return ret;\n      }\n\n      function seek(pos) {\n        _current_pos = pos;\n      }\n\n      bObject = {\n        _rtype: \"iostream\",\n        _rnative: \"js:blob\",\n        type: aObject.type,\n        name: aObject.name,\n        size: aObject.size,\n        path: aObject._path || aObject.webkitRelativePath,\n        read: await this._encode(read, session_id, local_workspace),\n        seek: await this._encode(seek, session_id, local_workspace)\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: new Uint8Array(aObject.buffer),\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof DataView) {\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject.buffer)\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n      };\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n      bObject = isarray ? [] : {};\n      const keys = Object.keys(aObject);\n\n      for (let k of keys) {\n        bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n      }\n    } else {\n      throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n\n    return bObject;\n  }\n\n  async decode(aObject) {\n    return await this._decode(aObject);\n  }\n\n  async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (aObject._rtype) {\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n        aObject._rtype = temp;\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n      } else if (aObject._rtype === \"method\") {\n        bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n\n        const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n\n        bObject = new arraytype(buffer);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength); // ArrayBuffer\n      } else if (aObject._rtype === \"iostream\") {\n        if (aObject._rnative === \"js:blob\") {\n          const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n          const bytes = await read();\n          bObject = new Blob([bytes], {\n            type: aObject.type,\n            name: aObject.name\n          });\n        } else {\n          bObject = {};\n\n          for (let k of Object.keys(aObject)) {\n            if (!k.startsWith(\"_\")) {\n              bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n            }\n          }\n        }\n\n        bObject[\"__rpc_object__\"] = aObject;\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n      } else {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n        bObject._rtype = temp;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    }\n\n    return bObject;\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/hypha/utils.js\":\n/*!****************************!*\\\n  !*** ./src/hypha/utils.js ***!\n  \\****************************/\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_148577__) {\n\n\"use strict\";\n__nested_webpack_require_148577__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"assert\", function() { return assert; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"waitFor\", function() { return waitFor; });\n/* harmony export (binding) */ __nested_webpack_require_148577__.d(__nested_webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array\n};\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  } // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      var link_node;\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            await import(\n            /* webpackIgnore: true */\n            requirements[i]);\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nasync function loadRequirementsInWebworker(requirements) {\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n\n      for (var i = 0; i < requirements.length; i++) {\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n          throw \"unable to import css in a webworker\";\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nfunction loadRequirements(requirements) {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false; // remove functions\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\nconst typedArrayToDtypeKeys = [];\n\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n    await cacheUrlInServiceWorker(req).catch(e => {\n      console.error(e);\n    });\n  }\n}\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    baseUrl = baseUrl || \"/\";\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\n      // Registration was successful\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n    }, function (err) {\n      // registration failed :(\n      console.log(\"ServiceWorker registration failed: \", err);\n    });\n    targetOrigin = targetOrigin || \"*\";\n    cacheCallback = cacheCallback || cacheRequirements;\n\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\n      throw new Error(\"config.cache_requirements must be a function\");\n    }\n\n    window.addEventListener(\"message\", function (e) {\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n        const m = e.data;\n\n        if (m.type === \"cacheRequirements\") {\n          cacheCallback(m.requirements);\n        }\n      }\n    });\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nfunction waitFor(prom, time, error) {\n  let timer;\n  return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n    rej(error || \"Timeout Error\");\n  }, time * 1000))]).finally(() => clearTimeout(timer));\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=hypha-rpc.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/imjoy-rpc/dist/hypha-rpc.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js":
/*!***********************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js ***!
  \***********************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_575__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_575__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_575__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_575__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_575__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_575__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_575__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_575__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_575__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_575__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_575__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_575__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_575__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_575__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_575__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_575__(__nested_webpack_require_575__.s = \"./src/socketIOMain.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js\":\n/*!***********************************************************************************!*\\\n  !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!\n  \\***********************************************************************************/\n/*! exports provided: decode, encode */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_4457__) {\n\n\"use strict\";\n__nested_webpack_require_4457__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_4457__.d(__nested_webpack_exports__, \"decode\", function() { return decode; });\n/* harmony export (binding) */ __nested_webpack_require_4457__.d(__nested_webpack_exports__, \"encode\", function() { return encode; });\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\n\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/@socket.io/component-emitter/index.mjs\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/@socket.io/component-emitter/index.mjs ***!\n  \\*************************************************************/\n/*! exports provided: Emitter */\n/***/ (function(__webpack_module__, __nested_webpack_exports__, __nested_webpack_require_7106__) {\n\n\"use strict\";\n__nested_webpack_require_7106__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_7106__.d(__nested_webpack_exports__, \"Emitter\", function() { return Emitter; });\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/base64-js/index.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/base64-js/index.js ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/buffer/index.js\":\n/*!**************************************!*\\\n  !*** ./node_modules/buffer/index.js ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_15076__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __nested_webpack_require_15076__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __nested_webpack_require_15076__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __nested_webpack_require_15076__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_15076__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/contrib/has-cors.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/contrib/has-cors.js ***!\n  \\*********************************************************************/\n/*! exports provided: hasCORS */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_64423__) {\n\n\"use strict\";\n__nested_webpack_require_64423__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_64423__.d(__nested_webpack_exports__, \"hasCORS\", function() { return hasCORS; });\n// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nconst hasCORS = value;\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/contrib/parseqs.js ***!\n  \\********************************************************************/\n/*! exports provided: encode, decode */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_65329__) {\n\n\"use strict\";\n__nested_webpack_require_65329__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_65329__.d(__nested_webpack_exports__, \"encode\", function() { return encode; });\n/* harmony export (binding) */ __nested_webpack_require_65329__.d(__nested_webpack_exports__, \"decode\", function() { return decode; });\n// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nfunction encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nfunction decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/contrib/parseuri.js ***!\n  \\*********************************************************************/\n/*! exports provided: parse */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_66824__) {\n\n\"use strict\";\n__nested_webpack_require_66824__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_66824__.d(__nested_webpack_exports__, \"parse\", function() { return parse; });\n// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nfunction parse(str) {\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/contrib/yeast.js ***!\n  \\******************************************************************/\n/*! exports provided: encode, decode, yeast */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_69847__) {\n\n\"use strict\";\n__nested_webpack_require_69847__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_69847__.d(__nested_webpack_exports__, \"encode\", function() { return encode; });\n/* harmony export (binding) */ __nested_webpack_require_69847__.d(__nested_webpack_exports__, \"decode\", function() { return decode; });\n/* harmony export (binding) */ __nested_webpack_require_69847__.d(__nested_webpack_exports__, \"yeast\", function() { return yeast; });\n// imported from https://github.com/unshiftio/yeast\n\nconst alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n    let encoded = '';\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return seed = 0, prev = now;\n    return now + '.' + encode(seed++);\n}\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/globalThis.browser.js ***!\n  \\***********************************************************************/\n/*! exports provided: globalThisShim */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_71965__) {\n\n\"use strict\";\n__nested_webpack_require_71965__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_71965__.d(__nested_webpack_exports__, \"globalThisShim\", function() { return globalThisShim; });\nconst globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/index.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/index.js ***!\n  \\**********************************************************/\n/*! exports provided: Socket, protocol, Transport, transports, installTimerFunctions, parse, nextTick */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_72831__) {\n\n\"use strict\";\n__nested_webpack_require_72831__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"protocol\", function() { return protocol; });\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_72831__(/*! ./socket.js */ \"./node_modules/engine.io-client/build/esm/socket.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"Socket\", function() { return _socket_js__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"]; });\n\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_72831__(/*! ./transport.js */ \"./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"Transport\", function() { return _transport_js__WEBPACK_IMPORTED_MODULE_1__[\"Transport\"]; });\n\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_72831__(/*! ./transports/index.js */ \"./node_modules/engine.io-client/build/esm/transports/index.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"transports\", function() { return _transports_index_js__WEBPACK_IMPORTED_MODULE_2__[\"transports\"]; });\n\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_72831__(/*! ./util.js */ \"./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"installTimerFunctions\", function() { return _util_js__WEBPACK_IMPORTED_MODULE_3__[\"installTimerFunctions\"]; });\n\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_72831__(/*! ./contrib/parseuri.js */ \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"parse\", function() { return _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__[\"parse\"]; });\n\n/* harmony import */ var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_72831__(/*! ./transports/websocket-constructor.js */ \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_72831__.d(__nested_webpack_exports__, \"nextTick\", function() { return _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__[\"nextTick\"]; });\n\n\n\nconst protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"].protocol;\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/socket.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/socket.js ***!\n  \\***********************************************************/\n/*! exports provided: Socket */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_75630__) {\n\n\"use strict\";\n__nested_webpack_require_75630__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_75630__.d(__nested_webpack_exports__, \"Socket\", function() { return Socket; });\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_75630__(/*! ./transports/index.js */ \"./node_modules/engine.io-client/build/esm/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_75630__(/*! ./util.js */ \"./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_75630__(/*! ./contrib/parseqs.js */ \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_75630__(/*! ./contrib/parseuri.js */ \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_75630__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_75630__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/esm/index.js\");\n\n\n\n\n\n\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__[\"Emitter\"] {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts = {}) {\n        super();\n        this.writeBuffer = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = Object(_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = Object(_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(opts.host).host;\n        }\n        Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"installTimerFunctions\"])(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__[\"decode\"])(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"protocol\"];\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        });\n        return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__[\"transports\"][name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this.getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    getWritablePackets() {\n        const shouldCheckPayloadSize = this.maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"byteLength\"])(data);\n            }\n            if (i > 0 && payloadSize > this.maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    onError(err) {\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nSocket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"protocol\"];\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/transport.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/transport.js ***!\n  \\**************************************************************/\n/*! exports provided: Transport */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_96794__) {\n\n\"use strict\";\n__nested_webpack_require_96794__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_96794__.d(__nested_webpack_exports__, \"Transport\", function() { return Transport; });\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_96794__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_96794__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_96794__(/*! ./util.js */ \"./node_modules/engine.io-client/build/esm/util.js\");\n\n\n\nclass TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nclass Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__[\"Emitter\"] {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"installTimerFunctions\"])(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"decodePacket\"])(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/transports/index.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/transports/index.js ***!\n  \\*********************************************************************/\n/*! exports provided: transports */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_100613__) {\n\n\"use strict\";\n__nested_webpack_require_100613__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_100613__.d(__nested_webpack_exports__, \"transports\", function() { return transports; });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_100613__(/*! ./polling.js */ \"./node_modules/engine.io-client/build/esm/transports/polling.js\");\n/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_100613__(/*! ./websocket.js */ \"./node_modules/engine.io-client/build/esm/transports/websocket.js\");\n\n\nconst transports = {\n    websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__[\"WS\"],\n    polling: _polling_js__WEBPACK_IMPORTED_MODULE_0__[\"Polling\"],\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/transports/polling.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/transports/polling.js ***!\n  \\***********************************************************************/\n/*! exports provided: Polling, Request */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_101737__) {\n\n\"use strict\";\n__nested_webpack_require_101737__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_101737__.d(__nested_webpack_exports__, \"Polling\", function() { return Polling; });\n/* harmony export (binding) */ __nested_webpack_require_101737__.d(__nested_webpack_exports__, \"Request\", function() { return Request; });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_101737__(/*! ../transport.js */ \"./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_101737__(/*! ../contrib/yeast.js */ \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_101737__(/*! ../contrib/parseqs.js */ \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_101737__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_101737__(/*! ./xmlhttprequest.js */ \"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_101737__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_101737__(/*! ../util.js */ \"./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_101737__(/*! ../globalThis.js */ \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n\n\n\n\n\n\n\n\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__[\"XHR\"]({\n        xdomain: false,\n    });\n    return null != xhr.responseType;\n})();\nclass Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__[\"Transport\"] {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        this.polling = false;\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"decodePayload\"])(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"encodePayload\"])(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = Object(_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__[\"yeast\"])();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__[\"encode\"])(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nclass Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__[\"Emitter\"] {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(uri, opts) {\n        super();\n        Object(_util_js__WEBPACK_IMPORTED_MODULE_6__[\"installTimerFunctions\"])(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    create() {\n        const opts = Object(_util_js__WEBPACK_IMPORTED_MODULE_6__[\"pick\"])(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__[\"XHR\"](opts));\n        try {\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    onError(err) {\n        this.emitReserved(\"error\", err, this.xhr);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this.cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in _globalThis_js__WEBPACK_IMPORTED_MODULE_7__[\"globalThisShim\"] ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\":\n/*!*********************************************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js ***!\n  \\*********************************************************************************************/\n/*! exports provided: nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_115902__) {\n\n\"use strict\";\n__nested_webpack_require_115902__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_115902__.d(__nested_webpack_exports__, \"nextTick\", function() { return nextTick; });\n/* harmony export (binding) */ __nested_webpack_require_115902__.d(__nested_webpack_exports__, \"WebSocket\", function() { return WebSocket; });\n/* harmony export (binding) */ __nested_webpack_require_115902__.d(__nested_webpack_exports__, \"usingBrowserWebSocket\", function() { return usingBrowserWebSocket; });\n/* harmony export (binding) */ __nested_webpack_require_115902__.d(__nested_webpack_exports__, \"defaultBinaryType\", function() { return defaultBinaryType; });\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_115902__(/*! ../globalThis.js */ \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n\nconst nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nconst WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].MozWebSocket;\nconst usingBrowserWebSocket = true;\nconst defaultBinaryType = \"arraybuffer\";\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/transports/websocket.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/transports/websocket.js ***!\n  \\*************************************************************************/\n/*! exports provided: WS */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_117634__) {\n\n\"use strict\";\n__nested_webpack_require_117634__.r(__nested_webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __nested_webpack_require_117634__.d(__nested_webpack_exports__, \"WS\", function() { return WS; });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_117634__(/*! ../transport.js */ \"./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_117634__(/*! ../contrib/parseqs.js */ \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_117634__(/*! ../contrib/yeast.js */ \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_117634__(/*! ../util.js */ \"./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_117634__(/*! ./websocket-constructor.js */ \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_117634__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/build/esm/index.js\");\n\n\n\n\n\n\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__[\"Transport\"] {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : Object(_util_js__WEBPACK_IMPORTED_MODULE_3__[\"pick\"])(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"] && !isReactNative\n                    ? protocols\n                        ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri, protocols)\n                        : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri)\n                    : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"defaultBinaryType\"];\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"encodePacket\"])(packet, this.supportsBinary, (data) => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"]) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \n                        // @ts-ignore\n                        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"]) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    Object(_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"nextTick\"])(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = Object(_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__[\"yeast\"])();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @private\n     */\n    check() {\n        return !!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"];\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_117634__(/*! ./../../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\":\n/*!**************************************************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js ***!\n  \\**************************************************************************************/\n/*! exports provided: XHR */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_126013__) {\n\n\"use strict\";\n__nested_webpack_require_126013__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_126013__.d(__nested_webpack_exports__, \"XHR\", function() { return XHR; });\n/* harmony import */ var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_126013__(/*! ../contrib/has-cors.js */ \"./node_modules/engine.io-client/build/esm/contrib/has-cors.js\");\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_126013__(/*! ../globalThis.js */ \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n// browser shim for xmlhttprequest module\n\n\nfunction XHR(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__[\"hasCORS\"])) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__[\"globalThisShim\"][[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-client/build/esm/util.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/engine.io-client/build/esm/util.js ***!\n  \\*********************************************************/\n/*! exports provided: pick, installTimerFunctions, byteLength */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_127530__) {\n\n\"use strict\";\n__nested_webpack_require_127530__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_127530__.d(__nested_webpack_exports__, \"pick\", function() { return pick; });\n/* harmony export (binding) */ __nested_webpack_require_127530__.d(__nested_webpack_exports__, \"installTimerFunctions\", function() { return installTimerFunctions; });\n/* harmony export (binding) */ __nested_webpack_require_127530__.d(__nested_webpack_exports__, \"byteLength\", function() { return byteLength; });\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_127530__(/*! ./globalThis.js */ \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n    }\n    else {\n        obj.setTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n        obj.clearTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nfunction byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-parser/build/esm/commons.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/engine.io-parser/build/esm/commons.js ***!\n  \\************************************************************/\n/*! exports provided: PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_130544__) {\n\n\"use strict\";\n__nested_webpack_require_130544__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_130544__.d(__nested_webpack_exports__, \"PACKET_TYPES\", function() { return PACKET_TYPES; });\n/* harmony export (binding) */ __nested_webpack_require_130544__.d(__nested_webpack_exports__, \"PACKET_TYPES_REVERSE\", function() { return PACKET_TYPES_REVERSE; });\n/* harmony export (binding) */ __nested_webpack_require_130544__.d(__nested_webpack_exports__, \"ERROR_PACKET\", function() { return ERROR_PACKET; });\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!\n  \\*************************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_131908__) {\n\n\"use strict\";\n__nested_webpack_require_131908__.r(__nested_webpack_exports__);\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_131908__(/*! ./commons.js */ \"./node_modules/engine.io-parser/build/esm/commons.js\");\n/* harmony import */ var _socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_131908__(/*! @socket.io/base64-arraybuffer */ \"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js\");\n\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type];\n    if (!packetType) {\n        return _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"ERROR_PACKET\"];\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = Object(_socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\n/* harmony default export */ __nested_webpack_exports__[\"default\"] = (decodePacket);\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!\n  \\*************************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_134475__) {\n\n\"use strict\";\n__nested_webpack_require_134475__.r(__nested_webpack_exports__);\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_134475__(/*! ./commons.js */ \"./node_modules/engine.io-parser/build/esm/commons.js\");\n\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES\"][type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + content);\n    };\n    return fileReader.readAsDataURL(data);\n};\n/* harmony default export */ __nested_webpack_exports__[\"default\"] = (encodePacket);\n\n\n/***/ }),\n\n/***/ \"./node_modules/engine.io-parser/build/esm/index.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/engine.io-parser/build/esm/index.js ***!\n  \\**********************************************************/\n/*! exports provided: protocol, encodePacket, encodePayload, decodePacket, decodePayload */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_136593__) {\n\n\"use strict\";\n__nested_webpack_require_136593__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_136593__.d(__nested_webpack_exports__, \"protocol\", function() { return protocol; });\n/* harmony export (binding) */ __nested_webpack_require_136593__.d(__nested_webpack_exports__, \"encodePayload\", function() { return encodePayload; });\n/* harmony export (binding) */ __nested_webpack_require_136593__.d(__nested_webpack_exports__, \"decodePayload\", function() { return decodePayload; });\n/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_136593__(/*! ./encodePacket.js */ \"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_136593__.d(__nested_webpack_exports__, \"encodePacket\", function() { return _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_136593__(/*! ./decodePacket.js */ \"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_136593__.d(__nested_webpack_exports__, \"decodePacket\", function() { return _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n\n\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        Object(_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = Object(_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nconst protocol = 4;\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/ieee754/index.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/ieee754/index.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/isarray/index.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/isarray/index.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-client/build/esm/contrib/backo2.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/socket.io-client/build/esm/contrib/backo2.js ***!\n  \\*******************************************************************/\n/*! exports provided: Backoff */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_142166__) {\n\n\"use strict\";\n__nested_webpack_require_142166__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_142166__.d(__nested_webpack_exports__, \"Backoff\", function() { return Backoff; });\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nfunction Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-client/build/esm/index.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/socket.io-client/build/esm/index.js ***!\n  \\**********************************************************/\n/*! exports provided: protocol, Manager, Socket, io, connect, default */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_144125__) {\n\n\"use strict\";\n__nested_webpack_require_144125__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_144125__.d(__nested_webpack_exports__, \"io\", function() { return lookup; });\n/* harmony export (binding) */ __nested_webpack_require_144125__.d(__nested_webpack_exports__, \"connect\", function() { return lookup; });\n/* harmony export (binding) */ __nested_webpack_require_144125__.d(__nested_webpack_exports__, \"default\", function() { return lookup; });\n/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_144125__(/*! ./url.js */ \"./node_modules/socket.io-client/build/esm/url.js\");\n/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_144125__(/*! ./manager.js */ \"./node_modules/socket.io-client/build/esm/manager.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_144125__.d(__nested_webpack_exports__, \"Manager\", function() { return _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"]; });\n\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_144125__(/*! ./socket.js */ \"./node_modules/socket.io-client/build/esm/socket.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_144125__.d(__nested_webpack_exports__, \"Socket\", function() { return _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"]; });\n\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_144125__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_144125__.d(__nested_webpack_exports__, \"protocol\", function() { return socket_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"protocol\"]; });\n\n\n\n\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = Object(_url_js__WEBPACK_IMPORTED_MODULE_0__[\"url\"])(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"](source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"](source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"],\n    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"],\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\n\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-client/build/esm/manager.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/socket.io-client/build/esm/manager.js ***!\n  \\************************************************************/\n/*! exports provided: Manager */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_147507__) {\n\n\"use strict\";\n__nested_webpack_require_147507__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_147507__.d(__nested_webpack_exports__, \"Manager\", function() { return Manager; });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_147507__(/*! engine.io-client */ \"./node_modules/engine.io-client/build/esm/index.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_147507__(/*! ./socket.js */ \"./node_modules/socket.io-client/build/esm/socket.js\");\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_147507__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_147507__(/*! ./on.js */ \"./node_modules/socket.io-client/build/esm/on.js\");\n/* harmony import */ var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_147507__(/*! ./contrib/backo2.js */ \"./node_modules/socket.io-client/build/esm/contrib/backo2.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_147507__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\n\n\n\n\n\n\nclass Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__[\"Emitter\"] {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"installTimerFunctions\"])(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__[\"Backoff\"]({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"](this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"error\", (err) => {\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"ping\", this.onping.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"data\", this.ondata.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"error\", this.onerror.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"close\", this.onclose.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"nextTick\"])(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__[\"Socket\"](this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-client/build/esm/on.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/socket.io-client/build/esm/on.js ***!\n  \\*******************************************************/\n/*! exports provided: on */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_159906__) {\n\n\"use strict\";\n__nested_webpack_require_159906__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_159906__.d(__nested_webpack_exports__, \"on\", function() { return on; });\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-client/build/esm/socket.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/socket.io-client/build/esm/socket.js ***!\n  \\***********************************************************/\n/*! exports provided: Socket */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_160557__) {\n\n\"use strict\";\n__nested_webpack_require_160557__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_160557__.d(__nested_webpack_exports__, \"Socket\", function() { return Socket; });\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_160557__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_160557__(/*! ./on.js */ \"./node_modules/socket.io-client/build/esm/on.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_160557__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\n\n\n\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__[\"Emitter\"] {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"open\", this.onopen.bind(this)),\n            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"packet\", this.onpacket.bind(this)),\n            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"error\", this.onerror.bind(this)),\n            Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n        }\n        else if (this.connected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks[id] = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, [null, ...args]);\n        };\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].EVENT:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].ACK:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-client/build/esm/url.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/socket.io-client/build/esm/url.js ***!\n  \\********************************************************/\n/*! exports provided: url */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_186106__) {\n\n\"use strict\";\n__nested_webpack_require_186106__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_186106__.d(__nested_webpack_exports__, \"url\", function() { return url; });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_186106__(/*! engine.io-client */ \"./node_modules/engine.io-client/build/esm/index.js\");\n\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"parse\"])(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-parser/build/esm/binary.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/socket.io-parser/build/esm/binary.js ***!\n  \\***********************************************************/\n/*! exports provided: deconstructPacket, reconstructPacket */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_188576__) {\n\n\"use strict\";\n__nested_webpack_require_188576__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_188576__.d(__nested_webpack_exports__, \"deconstructPacket\", function() { return deconstructPacket; });\n/* harmony export (binding) */ __nested_webpack_require_188576__.d(__nested_webpack_exports__, \"reconstructPacket\", function() { return reconstructPacket; });\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_188576__(/*! ./is-binary.js */ \"./node_modules/socket.io-parser/build/esm/is-binary.js\");\n\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_0__[\"isBinary\"])(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-parser/build/esm/index.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/socket.io-parser/build/esm/index.js ***!\n  \\**********************************************************/\n/*! exports provided: protocol, PacketType, Encoder, Decoder */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_192219__) {\n\n\"use strict\";\n__nested_webpack_require_192219__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_192219__.d(__nested_webpack_exports__, \"protocol\", function() { return protocol; });\n/* harmony export (binding) */ __nested_webpack_require_192219__.d(__nested_webpack_exports__, \"PacketType\", function() { return PacketType; });\n/* harmony export (binding) */ __nested_webpack_require_192219__.d(__nested_webpack_exports__, \"Encoder\", function() { return Encoder; });\n/* harmony export (binding) */ __nested_webpack_require_192219__.d(__nested_webpack_exports__, \"Decoder\", function() { return Decoder; });\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_192219__(/*! @socket.io/component-emitter */ \"./node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_192219__(/*! ./binary.js */ \"./node_modules/socket.io-parser/build/esm/binary.js\");\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_192219__(/*! ./is-binary.js */ \"./node_modules/socket.io-parser/build/esm/is-binary.js\");\n\n\n\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nconst protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__[\"hasBinary\"])(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__[\"deconstructPacket\"])(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__[\"Emitter\"] {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__[\"isBinary\"])(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__[\"reconstructPacket\"])(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/socket.io-parser/build/esm/is-binary.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/socket.io-parser/build/esm/is-binary.js ***!\n  \\**************************************************************/\n/*! exports provided: isBinary, hasBinary */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_203729__) {\n\n\"use strict\";\n__nested_webpack_require_203729__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_203729__.d(__nested_webpack_exports__, \"isBinary\", function() { return isBinary; });\n/* harmony export (binding) */ __nested_webpack_require_203729__.d(__nested_webpack_exports__, \"hasBinary\", function() { return hasBinary; });\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};\n\n/***/ }),\n\n/***/ \"./package.json\":\n/*!**********************!*\\\n  !*** ./package.json ***!\n  \\**********************/\n/*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.5.59\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"types\\\":\\\"index.d.ts\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\\",\\\"watch\\\":\\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\\",\\\"publish-npm\\\":\\\"npm install && npm run build && npm publish\\\",\\\"serve\\\":\\\"webpack-dev-server\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\",\\\"test-watch\\\":\\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{\\\"@msgpack/msgpack\\\":\\\"^2.7.1\\\",\\\"socket.io-client\\\":\\\"^4.6.2\\\"},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.16.12\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.8.3\\\",\\\"@babel/polyfill\\\":\\\"^7.12.1\\\",\\\"@babel/preset-env\\\":\\\"^7.16.11\\\",\\\"@types/requirejs\\\":\\\"^2.1.34\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"^8.2.3\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.3.6\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.1.2\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^6.3.12\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^2.0.1\\\",\\\"karma-sourcemap-loader\\\":\\\"^0.3.8\\\",\\\"karma-spec-reporter\\\":\\\"0.0.32\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^6.0.3\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^10.1.0\\\",\\\"postcss\\\":\\\"^7.0.36\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"ts-loader\\\":\\\"^9.4.3\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.46.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^4.7.0\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\",\\\"webpack-dev-server\\\":\\\"^3.11.3\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"workbox-webpack-plugin\\\":\\\"^4.3.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");\n\n/***/ }),\n\n/***/ \"./src/main.js\":\n/*!*********************!*\\\n  !*** ./src/main.js ***!\n  \\*********************/\n/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_211378__) {\n\n\"use strict\";\n__nested_webpack_require_211378__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_211378__.d(__nested_webpack_exports__, \"waitForInitialization\", function() { return waitForInitialization; });\n/* harmony export (binding) */ __nested_webpack_require_211378__.d(__nested_webpack_exports__, \"setupRPC\", function() { return setupRPC; });\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_211378__(/*! ./plugin.webworker.js */ \"./src/plugin.webworker.js\");\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_211378__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_211378__(/*! ./pluginIframe.js */ \"./src/pluginIframe.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_211378__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_211378__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirements\"]; });\n\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_211378__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_211378__.d(__nested_webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_211378__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"API_VERSION\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_211378__(/*! ../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__nested_webpack_require_211378__.t(/*! ../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __nested_webpack_require_211378__.d(__nested_webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_4__[\"version\"]; });\n\n/**\n * Contains the code executed in the sandboxed frame under web-browser\n *\n * Tries to create a Web-Worker inside the frame and set up the\n * communication between the worker and the parent window. Some\n * browsers restrict creating a worker inside a sandboxed iframe - if\n * this happens, the plugin initialized right inside the frame (in the\n * same thread)\n */\n\n\n\n\n\n\n\nfunction _inIframe() {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction _inWebWorker() {\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}\n/**\n * Initializes the plugin inside a web worker. May throw an exception\n * in case this was not permitted by the browser.\n */\n\n\nfunction setupWebWorker(config) {\n  if (!config.allow_execution) throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n  let broadcastChannel = null;\n\n  if (config.broadcastChannel) {\n    broadcastChannel = new BroadcastChannel(config.broadcastChannel);\n  }\n\n  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker\n  // initialization without exception, handling this with timeout\n\n  const fallbackTimeout = setTimeout(function () {\n    worker.terminate();\n    console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n  }, 2000);\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])(); // forwarding messages between the worker and parent window\n\n  worker.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.type === \"worker-ready\") {\n      // send config to the worker\n      worker.postMessage({\n        type: \"connectRPC\",\n        config: config\n      });\n      clearTimeout(fallbackTimeout);\n      return;\n    } else if (m.type === \"initialized\") {\n      // complete the missing fields\n      m.config = Object.assign({}, config, m.config);\n      m.origin = globalThis.location.origin;\n      m.peer_id = peer_id;\n    } else if (m.type === \"imjoy_remote_api_ready\") {\n      // if it's a webworker, there will be no api object returned\n      globalThis.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: null\n      }));\n    } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n      cache_requirements(m.requirements);\n    } else if (m.type === \"disconnect\") {\n      worker.terminate();\n    } else {\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n    }\n\n    if (broadcastChannel) broadcastChannel.postMessage(m);else parent.postMessage(m, config.target_origin || \"*\", transferables);\n  });\n  (broadcastChannel || window).addEventListener(\"message\", function (e) {\n    if (e.type === \"message\" && (broadcastChannel || config.target_origin === \"*\" || e.origin === config.target_origin)) {\n      let transferables = undefined;\n      const m = e.data;\n\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n\n      if (m.peer_id === peer_id) {\n        worker.postMessage(m, transferables);\n      } else if (config.debug) {\n        console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n      }\n    }\n  });\n}\n\nfunction waitForInitialization(config) {\n  if (_inWebWorker()) {\n    globalThis.parent = self;\n  }\n\n  config = config || {};\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n    config.enable_service_worker = false;\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  }\n\n  const targetOrigin = config.target_origin || \"*\";\n\n  if (config.credential_required && typeof config.verify_credential !== \"function\") {\n    throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n  }\n\n  if (config.credential_required && targetOrigin === \"*\") {\n    throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n  }\n\n  const done = () => {\n    globalThis.removeEventListener(\"message\", handleEvent);\n  };\n\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n\n  const handleEvent = e => {\n    if (e.type === \"message\" && (!e.origin || targetOrigin === \"*\" || e.origin === targetOrigin)) {\n      if (e.data.type === \"initialize\") {\n        done();\n\n        if (e.data.peer_id !== peer_id) {\n          // TODO: throw an error when we are sure all the peers will send the peer_id\n          console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n        }\n\n        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client\n        // otherwise take the setting from the core\n\n        if (targetOrigin !== \"*\") {\n          cfg.target_origin = targetOrigin;\n        }\n\n        if (config.credential_required) {\n          config.verify_credential(cfg.credential).then(result => {\n            if (result && result.auth && !result.error) {\n              // pass the authentication information with tokens\n              cfg.auth = result.auth;\n              setupRPC(cfg).then(() => {\n                console.log(\"ImJoy RPC loaded successfully!\");\n              });\n            } else {\n              throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n            }\n          });\n        } else {\n          setupRPC(cfg).then(() => {\n            console.log(\"ImJoy RPC loaded successfully!\");\n          });\n        }\n      } else {\n        throw new Error(`unrecognized message: ${e.data}`);\n      }\n    }\n  };\n\n  globalThis.addEventListener(\"message\", handleEvent);\n\n  if (_inWebWorker()) {\n    parent.postMessage({\n      type: \"imjoyRPCReady\",\n      config: config,\n      peer_id: peer_id\n    });\n  } else {\n    parent.postMessage({\n      type: \"imjoyRPCReady\",\n      config: config,\n      peer_id: peer_id\n    }, \"*\");\n  }\n}\nfunction setupRPC(config) {\n  config = config || {};\n  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"normalizeConfig\"])(config);\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  }\n\n  return new Promise((resolve, reject) => {\n    const handleEvent = e => {\n      const api = e.detail;\n\n      if (config.expose_api_globally) {\n        globalThis.api = api;\n      } // imjoy plugin api\n\n\n      resolve(api);\n      globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n    };\n\n    if (_inIframe()) {\n      if (config.type === \"web-worker\") {\n        try {\n          setupWebWorker(config);\n        } catch (e) {\n          // fallback to iframe\n          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        }\n      } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n      } else {\n        console.error(\"Unsupported plugin type: \" + config.type);\n        reject(\"Unsupported plugin type: \" + config.type);\n        return;\n      }\n\n      globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n    } else if (_inWebWorker()) {\n      // inside a webworker\n      Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n    } else {\n      reject(new Error(\"imjoy-rpc should only run inside an iframe or a webworker.\"));\n    }\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/plugin.webworker.js\":\n/*!*********************************!*\\\n  !*** ./src/plugin.webworker.js ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_221702__) {\n\nmodule.exports = function() {\n  return __nested_webpack_require_221702__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/plugin.webworker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/plugin.webworker.js\\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\\"./src/pluginCore.js\\\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\\"./src/rpc.js\\\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\\"./src/utils.js\\\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \\\"undefined\\\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\\\"This script can only loaded in a webworker\\\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \\\"data:text/javascript;charset=utf-8,\\\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\\"MessageEmitter\\\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\\\"message\\\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \\\"initialized\\\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\\\"beforeDisconnect\\\");\\n    self.close();\\n    this._fire(\\\"disconnected\\\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \\\"requirements\\\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\\\"loadRequirementsInWebworker\\\"])(code.requirements);\\n    } else if (code.type === \\\"script\\\") {\\n      try {\\n        if (code.attrs.type === \\\"module\\\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \\\"unsupported code type.\\\";\\n    }\\n    if (code.type === \\\"requirements\\\") {\\n      self.postMessage({\\n        type: \\\"cacheRequirements\\\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \\\"web-worker\\\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \\\"javascript\\\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\\"API_VERSION\\\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\\\"connectRPC\\\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\\"connectRPC\\\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \\\"worker-ready\\\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/pluginCore.js\\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"connectRPC\\\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\\"./src/rpc.js\\\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\\"RPC\\\"](connection, config, codecs);\\n  rpc.on(\\\"getInterface\\\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\\\"remoteReady\\\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\\\"name\\\"] || !config[\\\"encoder\\\"] && !config[\\\"decoder\\\"]) {\\n        throw new Error(\\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\\\"Remove duplicated codec: \\\" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\\\"name\\\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \\\"undefined\\\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \\\"imjoy_remote_api_ready\\\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\\\"imjoy_remote_api_ready\\\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\\\"imjoy_remote_api_ready\\\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \\\"function\\\") {\\n      const msg = \\\"A function may only be subsribed to the event, \\\" + type + \\\" was provided instead\\\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \\\"./src/rpc.js\\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"API_VERSION\\\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RPC\\\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\\"./src/utils.js\\\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \\\"0.2.3\\\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\\\"undefined index\\\");\\n  if (typeof is === \\\"string\\\") return indexObject(obj, is.split(\\\".\\\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"MessageEmitter\\\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(`connection.execute not implemented (in \\\"${name}\\\")`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\\\"remoteIdle\\\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\\\"remoteBusy\\\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \\\"initialized\\\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\\\"interfaceAvailable\\\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\\\"interfaceSetAsRemote\\\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\\\"interface is not set.\\\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \\\"setInterface\\\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(`Object (id=${objectId}) not found.`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\\\"disposed\\\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \\\"disposeObject\\\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\\\"Invalid object\\\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\\\"init\\\", this.init);\\n\\n    this._connection.on(\\\"execute\\\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \\\"executed\\\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\\"executed\\\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\\\"method\\\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\\\".\\\")) {\\n          const tmp = data.name.split(\\\".\\\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\\\".\\\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\"AsyncFunction\\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\\"callback\\\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\"AsyncFunction\\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\\"disposeObject\\\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \\\"disposed\\\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\\"disposed\\\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\\"setInterface\\\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\\\"getInterface\\\", () => {\\n      this._fire(\\\"getInterface\\\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\\\"interfaceAvailable\\\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\\"interfaceSetAsRemote\\\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\\\"interfaceSetAsRemote\\\");\\n    });\\n\\n    this._connection.on(\\\"disconnect\\\", () => {\\n      this._fire(\\\"beforeDisconnect\\\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\\\"disconnected\\\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \\\"getInterface\\\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"typedArrayToDtype\\\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \\\"dtype doesn't match the type of the array: \\\" + _dtype + \\\" != \\\" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \\\"ndarray\\\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\\\"remoteReady\\\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \\\"/\\\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\\"object\\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \\\"register\\\" || name === \\\"registerService\\\" || name === \\\"register_service\\\" || name === \\\"export\\\" || name === \\\"on\\\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \\\"method\\\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \\\"interfaceSetAsRemote\\\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \\\"number\\\" || aType === \\\"string\\\" || aType === \\\"boolean\\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \\\"function\\\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\\\"objectId is not specified.\\\");\\n        bObject = {\\n          _rtype: \\\"interface\\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \\\"callback\\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \\\"undefined\\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\\"ndarray\\\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \\\"undefined\\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"typedArrayToDtype\\\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\\"ndarray\\\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \\\"error\\\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \\\"undefined\\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\\"file\\\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\\"undefined\\\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \\\"undefined\\\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \\\"undefined\\\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \\\"undefined\\\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \\\"undefined\\\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \\\"undefined\\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\\"file\\\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \\\"blob\\\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"typedArrayToDtype\\\"])(aObject);\\n      bObject = {\\n        _rtype: \\\"typedarray\\\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\\"memoryview\\\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \\\"set\\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \\\"orderedmap\\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\\\"Please instantiate the class before exportting it.\\\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\\\"Unsupported interface type\\\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \\\"string\\\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"randId\\\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \\\"constructor\\\") continue;\\n\\n          if (k.startsWith(\\\"_\\\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \\\"string\\\" ? asInterface + \\\".\\\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \\\"function\\\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \\\"function\\\") {\\n          aObject.on(\\\"close\\\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\\\"hasOwnProperty\\\", \\\"constructor\\\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \\\"object\\\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"randId\\\"])();\\n\\n      for (let k of keys) {\\n        if ([\\\"hasOwnProperty\\\", \\\"constructor\\\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \\\"imjoy-rpc: Unsupported data type:\\\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\\\"Failed to encode object\\\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\\\"_rtype\\\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \\\"callback\\\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \\\"interface\\\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \\\"ndarray\\\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \\\"undefined\\\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \\\"undefined\\\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"dtypeToTypedArray\\\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \\\"error\\\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \\\"file\\\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \\\"typedarray\\\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"dtypeToTypedArray\\\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\\\"unsupported dtype: \\\" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \\\"memoryview\\\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \\\"blob\\\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \\\"orderedmap\\\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \\\"set\\\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\\\"Failed to decode object\\\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\\"object\\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \\\"callback\\\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\\"object\\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \\\"callback\\\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \\\"disconnect\\\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \\\"./src/utils.js\\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"randId\\\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"dtypeToTypedArray\\\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"loadRequirementsInWindow\\\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"loadRequirementsInWebworker\\\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"loadRequirements\\\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"normalizeConfig\\\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"typedArrayToDtypeMapping\\\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"typedArrayToDtype\\\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"cacheRequirements\\\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"setupServiceWorker\\\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"urlJoin\\\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MessageEmitter\\\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\\\"script\\\");\\n      scriptTag.src = url;\\n      scriptTag.type = \\\"text/javascript\\\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \\\"loaded\\\" || this.readyState === \\\"complete\\\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\\"string\\\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \\\"string\\\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\\\".css\\\") || requirements[i].startsWith(\\\"css:\\\")) {\\n            if (requirements[i].startsWith(\\\"css:\\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\\\"link\\\");\\n            link_node.rel = \\\"stylesheet\\\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\\\".mjs\\\") || requirements[i].startsWith(\\\"mjs:\\\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\\\"mjs:\\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\\\".js\\\") || requirements[i].startsWith(\\\"js:\\\")) {\\n            if (requirements[i].startsWith(\\\"js:\\\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\\"http\\\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\\"cache:\\\")) {//ignore cache\\n          } else {\\n            console.log(\\\"Unprocessed requirements url: \\\" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \\\"unsupported requirements definition\\\";\\n      }\\n    } catch (e) {\\n      throw \\\"failed to import required scripts: \\\" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\\"string\\\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\\\".css\\\") || requirements[i].startsWith(\\\"css:\\\")) {\\n          throw \\\"unable to import css in a webworker\\\";\\n        } else if (requirements[i].toLowerCase().endsWith(\\\".js\\\") || requirements[i].startsWith(\\\"js:\\\")) {\\n          if (requirements[i].startsWith(\\\"js:\\\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\\"http\\\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\\"cache:\\\")) {//ignore cache\\n        } else {\\n          console.log(\\\"Unprocessed requirements url: \\\" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \\\"failed to import required scripts: \\\" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \\\"undefined\\\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \\\"0.1.0\\\";\\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\\n  config.type = config.type || \\\"rpc-window\\\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \\\"*\\\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \\\"function\\\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \\\"int8\\\",\\n  Int16Array: \\\"int16\\\",\\n  Int32Array: \\\"int32\\\",\\n  Uint8Array: \\\"uint8\\\",\\n  Uint16Array: \\\"uint16\\\",\\n  Uint32Array: \\\"uint32\\\",\\n  Float32Array: \\\"float32\\\",\\n  Float64Array: \\\"float64\\\",\\n  Array: \\\"array\\\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \\\"add\\\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\\\"Service worker is not supported.\\\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\\\"Service worker controller is not available\\\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\\\"js:\\\")) req = req.slice(3);\\n    if (req.startsWith(\\\"css:\\\")) req = req.slice(4);\\n    if (req.startsWith(\\\"cache:\\\")) req = req.slice(6);\\n    if (!req.startsWith(\\\"http\\\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\\\"serviceWorker\\\" in navigator) {\\n    baseUrl = baseUrl || \\\"/\\\";\\n    navigator.serviceWorker.register(baseUrl + \\\"plugin-service-worker.js\\\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\\\"ServiceWorker registration successful with scope: \\\", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\\\"ServiceWorker registration failed: \\\", err);\\n    });\\n    targetOrigin = targetOrigin || \\\"*\\\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \\\"function\\\") {\\n      throw new Error(\\\"config.cache_requirements must be a function\\\");\\n    }\\n\\n    window.addEventListener(\\\"message\\\", function (e) {\\n      if (targetOrigin === \\\"*\\\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \\\"cacheRequirements\\\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\\\"/\\\").replace(/[\\\\/]+/g, \\\"/\\\").replace(/^(.+):\\\\//, \\\"$1://\\\").replace(/^file:/, \\\"file:/\\\").replace(/\\\\/(\\\\?|&|#[^!])/g, \\\"$1\\\").replace(/\\\\?/g, \\\"&\\\").replace(\\\"&\\\", \\\"?\\\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\\\"emit is not implemented\\\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\\\"unhandled event\\\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map\", null);\n};\n\n/***/ }),\n\n/***/ \"./src/pluginCore.js\":\n/*!***************************!*\\\n  !*** ./src/pluginCore.js ***!\n  \\***************************/\n/*! exports provided: connectRPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_281678__) {\n\n\"use strict\";\n__nested_webpack_require_281678__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_281678__.d(__nested_webpack_exports__, \"connectRPC\", function() { return connectRPC; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_281678__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Core plugin script loaded into the plugin process/thread.\n *\n * Initializes the plugin-site API global methods.\n */\n\nfunction connectRPC(connection, config) {\n  config = config || {};\n  const codecs = {};\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n  rpc.on(\"getInterface\", function () {\n    launchConnected();\n  });\n  rpc.on(\"remoteReady\", function () {\n    const api = rpc.getRemote() || {};\n\n    api.registerCodec = function (config) {\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n      } else {\n        if (config.type) {\n          for (let k of Object.keys(codecs)) {\n            if (codecs[k].type === config.type || k === config.name) {\n              delete codecs[k];\n              console.warn(\"Remove duplicated codec: \" + k);\n            }\n          }\n        }\n\n        codecs[config[\"name\"]] = config;\n      }\n    };\n\n    api.init = function (config) {\n      // register a minimal plugin api\n      rpc.setInterface({\n        setup() {}\n\n      }, config);\n    };\n\n    api.disposeObject = function (obj) {\n      rpc.disposeObject(obj);\n    };\n\n    api.export = function (_interface, config) {\n      rpc.setInterface(_interface, config);\n    };\n\n    api.onLoad = function (handler) {\n      handler = checkHandler(handler);\n\n      if (connected) {\n        handler();\n      } else {\n        connectedHandlers.push(handler);\n      }\n    };\n\n    api.dispose = function (_interface) {\n      rpc.disconnect();\n    };\n\n    api._rpc = rpc;\n\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n      self.api = api;\n      self.postMessage({\n        type: \"imjoy_remote_api_ready\"\n      });\n      self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    } else if (typeof window) {\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    }\n  });\n  let connected = false;\n  const connectedHandlers = [];\n\n  const launchConnected = function () {\n    if (!connected) {\n      connected = true;\n      let handler;\n\n      while (handler = connectedHandlers.pop()) {\n        handler();\n      }\n    }\n  };\n\n  const checkHandler = function (handler) {\n    const type = typeof handler;\n\n    if (type !== \"function\") {\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n      throw new Error(msg);\n    }\n\n    return handler;\n  };\n\n  return rpc;\n}\n\n/***/ }),\n\n/***/ \"./src/pluginIframe.js\":\n/*!*****************************!*\\\n  !*** ./src/pluginIframe.js ***!\n  \\*****************************/\n/*! exports provided: Connection, default */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_284849__) {\n\n\"use strict\";\n__nested_webpack_require_284849__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_284849__.d(__nested_webpack_exports__, \"Connection\", function() { return Connection; });\n/* harmony export (binding) */ __nested_webpack_require_284849__.d(__nested_webpack_exports__, \"default\", function() { return setupIframe; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_284849__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_284849__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_284849__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n // Create a new, plain <span> element\n\nfunction _htmlToElement(html) {\n  var template = document.createElement(\"template\");\n  html = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nconst _inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n\nasync function executeEsModule(content) {\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\n  await import(\n  /* webpackIgnore: true */\n  dataUri);\n}\n\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n  constructor(config) {\n    super(config && config.debug);\n    this.config = config || {};\n    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  }\n\n  connect() {\n    this.config.target_origin = this.config.target_origin || \"*\"; // this will call handleEvent function\n\n    if (this.config.broadcastChannel) {\n      this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);\n    } else {\n      this.broadcastChannel = null;\n    }\n\n    if (this.broadcastChannel) this.broadcastChannel.addEventListener(\"message\", this);else globalThis.addEventListener(\"message\", this);\n    this.emit({\n      type: \"initialized\",\n      config: this.config,\n      origin: globalThis.location.origin,\n      peer_id: this.peer_id\n    });\n\n    this._fire(\"connected\");\n  }\n\n  handleEvent(e) {\n    if (e.type === \"message\" && (this.broadcastChannel || this.config.target_origin === \"*\" || !e.origin || e.origin === this.config.target_origin)) {\n      if (e.data.peer_id === this.peer_id) {\n        this._fire(e.data.type, e.data);\n      } else if (this.config.debug) {\n        console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n      }\n    }\n  }\n\n  disconnect() {\n    this._fire(\"beforeDisconnect\");\n\n    globalThis.removeEventListener(\"message\", this);\n\n    this._fire(\"disconnected\");\n  }\n\n  emit(data) {\n    let transferables;\n    if (this.broadcastChannel) this.broadcastChannel.postMessage(data);else {\n      if (data.__transferables__) {\n        transferables = data.__transferables__;\n        delete data.__transferables__;\n      } else if (_inWebWorker) self.postMessage(data, transferables);else parent.postMessage(data, this.config.target_origin, transferables);\n    }\n  }\n\n  async execute(code) {\n    try {\n      if (code.type === \"requirements\") {\n        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWindow\"])(code.requirements);\n      } else if (code.type === \"script\") {\n        if (code.src) {\n          var script_node = document.createElement(\"script\");\n          script_node.setAttribute(\"type\", code.attrs.type);\n          script_node.setAttribute(\"src\", code.src);\n          document.head.appendChild(script_node);\n        } else {\n          if (code.content && code.attrs.lang === \"javascript\") {\n            // document.addEventListener(\"DOMContentLoaded\", function(){\n            if (code.attrs.type === \"module\") {\n              await executeEsModule(code.content);\n            } else {\n              eval(code.content);\n            } // });\n\n          } else {\n            var node = document.createElement(\"script\");\n\n            for (let k in code.attrs) {\n              node.setAttribute(k, code.attrs[k]);\n            }\n\n            node.appendChild(document.createTextNode(code.content));\n            document.body.appendChild(node);\n          }\n        }\n      } else if (code.type === \"style\") {\n        const style_node = document.createElement(\"style\");\n\n        if (code.src) {\n          style_node.src = code.src;\n        }\n\n        style_node.innerHTML = code.content;\n        document.head.appendChild(style_node);\n      } else if (code.type === \"link\") {\n        const link_node_ = document.createElement(\"link\");\n\n        if (code.rel) {\n          link_node_.rel = code.rel;\n        }\n\n        if (code.href) {\n          link_node_.href = code.href;\n        }\n\n        if (code.attrs && code.attrs.type) {\n          link_node_.type = code.attrs.type;\n        }\n\n        document.head.appendChild(link_node_);\n      } else if (code.type === \"html\") {\n        document.body.appendChild(_htmlToElement(code.content));\n      } else {\n        throw \"unsupported code type.\";\n      }\n\n      if (_inWebWorker) self.postMessage({\n        type: \"executed\"\n      });else parent.postMessage({\n        type: \"executed\"\n      }, this.config.target_origin);\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      if (_inWebWorker) self.postMessage({\n        type: \"executed\",\n        error: e.stack || String(e)\n      });else parent.postMessage({\n        type: \"executed\",\n        error: e.stack || String(e)\n      }, this.config.target_origin);\n    }\n  }\n\n}\nfunction setupIframe(config) {\n  config = config || {};\n  config.dedicated_thread = false;\n  config.lang = \"javascript\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n  const conn = new Connection(config);\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n  conn.connect();\n}\n\n/***/ }),\n\n/***/ \"./src/rpc.js\":\n/*!********************!*\\\n  !*** ./src/rpc.js ***!\n  \\********************/\n/*! exports provided: API_VERSION, RPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_291169__) {\n\n\"use strict\";\n__nested_webpack_require_291169__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_291169__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __nested_webpack_require_291169__.d(__nested_webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_291169__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\nconst API_VERSION = \"0.2.3\";\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, config, codecs) {\n    super(config && config.debug);\n    this._connection = connection;\n    this.config = config || {};\n    this._codecs = codecs || {};\n    this._object_store = {};\n    this._method_weakmap = new WeakMap();\n    this._object_weakmap = new WeakMap();\n    this._local_api = null;\n    this._remote_set = false; // make sure there is an execute function\n\n    const name = this.config.name;\n\n    this._connection.execute = this._connection.execute || function () {\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\n    };\n\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n\n    this._method_refs.onReady(() => {\n      this._fire(\"remoteIdle\");\n    });\n\n    this._method_refs.onBusy(() => {\n      this._fire(\"remoteBusy\");\n    });\n\n    this._setupMessageHanlders();\n  }\n\n  init() {\n    this._connection.emit({\n      type: \"initialized\",\n      config: this.config,\n      peer_id: this._connection.peer_id\n    });\n  }\n\n  setConfig(config) {\n    if (config) for (const k of Object.keys(config)) {\n      this.config[k] = config[k];\n    }\n  }\n  /**\n   * Set a handler to be called when received a responce from the\n   * remote site reporting that the previously provided interface\n   * has been successfully set as remote for that site\n   *\n   * @param {Function} handler\n   */\n\n\n  getRemoteCallStack() {\n    return this._method_refs.getStack();\n  }\n  /**\n   * @returns {Object} set of remote interface methods\n   */\n\n\n  getRemote() {\n    return this._remote_interface;\n  }\n  /**\n   * Sets the interface of this site making it available to the\n   * remote site by sending a message with a set of methods names\n   *\n   * @param {Object} _interface to set\n   */\n\n\n  setInterface(_interface, config) {\n    config = config || {};\n    this.config.name = config.name || this.config.name;\n    this.config.description = config.description || this.config.description;\n\n    if (this.config.forwarding_functions) {\n      for (let func_name of this.config.forwarding_functions) {\n        const _remote = this._remote_interface;\n\n        if (_remote[func_name]) {\n          if (_interface.constructor === Object) {\n            if (!_interface[func_name]) {\n              _interface[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          } else if (_interface.constructor.constructor === Function) {\n            if (!_interface.constructor.prototype[func_name]) {\n              _interface.constructor.prototype[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          }\n        }\n      }\n    }\n\n    this._local_api = _interface;\n    if (!this._remote_set) this._fire(\"interfaceAvailable\");else this.sendInterface();\n    return new Promise(resolve => {\n      this.once(\"interfaceSetAsRemote\", resolve);\n    });\n  }\n  /**\n   * Sends the actual interface to the remote site upon it was\n   * updated or by a special request of the remote site\n   */\n\n\n  sendInterface() {\n    if (!this._local_api) {\n      throw new Error(\"interface is not set.\");\n    }\n\n    this._encode(this._local_api, true).then(api => {\n      this._connection.emit({\n        type: \"setInterface\",\n        api: api\n      });\n    });\n  }\n\n  _disposeObject(objectId) {\n    if (this._object_store[objectId]) {\n      delete this._object_store[objectId];\n    } else {\n      throw new Error(`Object (id=${objectId}) not found.`);\n    }\n  }\n\n  disposeObject(obj) {\n    return new Promise((resolve, reject) => {\n      if (this._object_weakmap.has(obj)) {\n        const objectId = this._object_weakmap.get(obj);\n\n        this._connection.once(\"disposed\", data => {\n          if (data.error) reject(new Error(data.error));else resolve();\n        });\n\n        this._connection.emit({\n          type: \"disposeObject\",\n          object_id: objectId\n        });\n      } else {\n        throw new Error(\"Invalid object\");\n      }\n    });\n  }\n  /**\n   * Handles a message from the remote site\n   */\n\n\n  _setupMessageHanlders() {\n    this._connection.on(\"init\", this.init);\n\n    this._connection.on(\"execute\", data => {\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\n        this._connection.emit({\n          type: \"executed\"\n        });\n      }).catch(e => {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"executed\",\n          error: String(e)\n        });\n      });\n    });\n\n    this._connection.on(\"method\", async data => {\n      let resolve, reject, method, method_this, args, result;\n\n      try {\n        if (data.promise) {\n          [resolve, reject] = await this._unwrap(data.promise, false);\n        }\n\n        const _interface = this._object_store[data.object_id];\n        method = indexObject(_interface, data.name);\n\n        if (data.name.includes(\".\")) {\n          const tmp = data.name.split(\".\");\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\n          method_this = indexObject(_interface, intf_index);\n        } else {\n          method_this = _interface;\n        }\n\n        args = await this._unwrap(data.args, true);\n\n        if (data.promise) {\n          result = method.apply(method_this, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } else {\n          method.apply(method_this, args);\n        }\n      } catch (err) {\n        console.error(this.config.name, err);\n\n        if (reject) {\n          reject(err);\n        }\n      }\n    });\n\n    this._connection.on(\"callback\", async data => {\n      let resolve, reject, method, args, result;\n\n      try {\n        if (data.promise) {\n          [resolve, reject] = await this._unwrap(data.promise, false);\n        }\n\n        if (data.promise) {\n          method = this._store.fetch(data.id);\n          args = await this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          result = method.apply(null, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } else {\n          method = this._store.fetch(data.id);\n          args = await this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          method.apply(null, args);\n        }\n      } catch (err) {\n        console.error(this.config.name, err);\n\n        if (reject) {\n          reject(err);\n        }\n      }\n    });\n\n    this._connection.on(\"disposeObject\", data => {\n      try {\n        this._disposeObject(data.object_id);\n\n        this._connection.emit({\n          type: \"disposed\"\n        });\n      } catch (e) {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"disposed\",\n          error: String(e)\n        });\n      }\n    });\n\n    this._connection.on(\"setInterface\", data => {\n      this._setRemoteInterface(data.api);\n    });\n\n    this._connection.on(\"getInterface\", () => {\n      this._fire(\"getInterface\");\n\n      if (this._local_api) {\n        this.sendInterface();\n      } else {\n        this.once(\"interfaceAvailable\", () => {\n          this.sendInterface();\n        });\n      }\n    });\n\n    this._connection.on(\"interfaceSetAsRemote\", () => {\n      this._remote_set = true;\n\n      this._fire(\"interfaceSetAsRemote\");\n    });\n\n    this._connection.on(\"disconnect\", () => {\n      this._fire(\"beforeDisconnect\");\n\n      this._connection.disconnect();\n\n      this._fire(\"disconnected\");\n    });\n  }\n  /**\n   * Sends a requests to the remote site asking it to provide its\n   * current interface\n   */\n\n\n  requestRemote() {\n    this._connection.emit({\n      type: \"getInterface\"\n    });\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n  /**\n   * Sets the new remote interface provided by the other site\n   *\n   * @param {Array} names list of function names\n   */\n\n\n  _setRemoteInterface(api) {\n    this._decode(api).then(intf => {\n      // update existing interface instead of recreating it\n      // this will preserve the object reference\n      if (this._remote_interface) {\n        // clear the interface\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\n\n\n        Object.assign(this._remote_interface, intf);\n      } else this._remote_interface = intf;\n\n      this._fire(\"remoteReady\");\n\n      this._reportRemoteSet();\n    });\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * method. When the generated function is called, it will send the\n   * corresponding message to the remote site asking it to execute\n   * the particular method of its interface\n   *\n   * @param {String} name of the remote method\n   *\n   * @returns {Function} wrapped remote method\n   */\n\n\n  _genRemoteMethod(targetId, name, objectId) {\n    const me = this;\n\n    const remoteMethod = function () {\n      return new Promise(async (resolve, reject) => {\n        let id = null;\n\n        try {\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n\n          const wrapped_resolve = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return resolve.apply(this, arguments);\n          };\n\n          const wrapped_reject = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return reject.apply(this, arguments);\n          };\n\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\n\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n          let args = Array.prototype.slice.call(arguments);\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\n\n          if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\n            args = await me._wrap(args, true);\n          } else {\n            args = await me._wrap(args);\n          }\n\n          const transferables = args.__transferables__;\n          if (transferables) delete args.__transferables__;\n\n          me._connection.emit({\n            type: \"method\",\n            target_id: targetId,\n            name: name,\n            object_id: objectId,\n            args: args,\n            promise: encodedPromise,\n            with_kwargs: withKwargs\n          }, transferables);\n        } catch (e) {\n          if (id) me._method_refs.fetch(id);\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n        }\n      });\n    };\n\n    remoteMethod.__remote_method = true;\n    return remoteMethod;\n  }\n  /**\n   * Sends a responce reporting that interface just provided by the\n   * remote site was successfully set by this site as remote\n   */\n\n\n  _reportRemoteSet() {\n    this._connection.emit({\n      type: \"interfaceSetAsRemote\"\n    });\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  async _encode(aObject, asInterface, objectId) {\n    const aType = typeof aObject;\n\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (typeof aObject === \"function\") {\n      if (asInterface) {\n        if (!objectId) throw new Error(\"objectId is not specified.\");\n        bObject = {\n          _rtype: \"interface\",\n          _rtarget_id: this._connection.peer_id,\n          _rintf: objectId,\n          _rvalue: asInterface\n        };\n\n        this._method_weakmap.set(aObject, bObject);\n      } else if (this._method_weakmap.has(aObject)) {\n        bObject = this._method_weakmap.get(aObject);\n      } else {\n        const cid = this._store.put(aObject);\n\n        bObject = {\n          _rtype: \"callback\",\n          _rtarget_id: this._connection.peer_id,\n          _rname: aObject.constructor && aObject.constructor.name || cid,\n          _rvalue: cid\n        };\n      }\n\n      return bObject;\n    } // skip if already encoded\n\n\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      if (aObject._rintf) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._encode(aObject, asInterface, objectId);\n        bObject._rtype = temp;\n      } else {\n        bObject = aObject;\n      }\n\n      return bObject;\n    }\n\n    const transferables = [];\n    const _transfer = aObject._transfer;\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\n\n        if (encodedObj && encodedObj._rintf) {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\n          encodedObj._rtype = temp;\n        }\n\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n    /*global tf*/\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\n      const v_buffer = aObject.dataSync();\n\n      if (aObject._transfer || _transfer) {\n        transferables.push(v_buffer.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: v_buffer.buffer,\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype\n      };\n    } else if (\n    /*global nj*/\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.selection.data.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: aObject.selection.data.buffer,\n        _rshape: aObject.shape,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString()\n      };\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n      bObject = {\n        _rtype: \"file\",\n        _rvalue: aObject,\n        _rpath: aObject._path || aObject.webkitRelativePath\n      };\n    } // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n      bObject = {\n        _rtype: \"file\",\n        _rname: aObject.name,\n        _rmime: aObject.type,\n        _rvalue: aObject,\n        _rpath: aObject._path || aObject.webkitRelativePath\n      };\n    } else if (aObject instanceof Blob) {\n      bObject = {\n        _rtype: \"blob\",\n        _rvalue: aObject\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.buffer);\n        delete aObject._transfer;\n      }\n\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: aObject.buffer,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof DataView) {\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: aObject.buffer\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\n      };\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n      bObject = isarray ? [] : {};\n      let keys; // an object/array\n\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\n        keys = Object.keys(aObject);\n      } // a class\n      else if (aObject.constructor === Function) {\n        throw new Error(\"Please instantiate the class before exportting it.\");\n      } // instance of a class\n      else if (aObject.constructor.constructor === Function) {\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\n        // always encode class instance as interface\n\n        asInterface = true;\n      } else {\n        throw Error(\"Unsupported interface type\");\n      }\n\n      let hasFunction = false; // encode interfaces\n\n      if (aObject._rintf || asInterface) {\n        if (!objectId) {\n          if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\n            objectId = aObject._rintf; // enable custom object id\n          } else {\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n          } // Note: object with the same id will be overwritten\n\n\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\n          this._object_store[objectId] = aObject;\n        }\n\n        for (let k of keys) {\n          if (k === \"constructor\") continue;\n\n          if (k.startsWith(\"_\")) {\n            continue;\n          }\n\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n\n          if (typeof aObject[k] === \"function\") {\n            hasFunction = true;\n          }\n        } // object id for dispose the object remotely\n\n\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\n\n        if (aObject.on && typeof aObject.on === \"function\") {\n          aObject.on(\"close\", () => {\n            delete this._object_store[objectId];\n          });\n        }\n      } else {\n        for (let k of keys) {\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\n          bObject[k] = await this._encode(aObject[k]);\n        }\n      } // for example, browserFS object\n\n    } else if (typeof aObject === \"object\") {\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n      for (let k of keys) {\n        if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\n\n        bObject[k] = await this._encode(aObject[k], k, bObject);\n      } // object id, used for dispose the object\n\n\n      bObject._rintf = objectId;\n    } else {\n      throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n    }\n\n    if (transferables.length > 0) {\n      bObject.__transferables__ = transferables;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n\n    return bObject;\n  }\n\n  async _decode(aObject, withPromise) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (aObject[\"_rtype\"]) {\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n        if (aObject._rintf) {\n          const temp = aObject._rtype;\n          delete aObject._rtype;\n          aObject = await this._decode(aObject, withPromise);\n          aObject._rtype = temp;\n        }\n\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n      } else if (aObject._rtype === \"callback\") {\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n      } else if (aObject._rtype === \"interface\") {\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(aObject._rvalue);\n      } else if (aObject._rtype === \"file\") {\n        if (aObject._rvalue instanceof File) {\n          bObject = aObject._rvalue; //patch _path\n\n          bObject._path = aObject._rpath;\n        } else {\n          bObject = new File([aObject._rvalue], aObject._rname, {\n            type: aObject._rmime\n          });\n          bObject._path = aObject._rpath;\n        }\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n        bObject = new arraytype(aObject._rvalue);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = new DataView(aObject._rvalue);\n      } else if (aObject._rtype === \"blob\") {\n        if (aObject._rvalue instanceof Blob) {\n          bObject = aObject._rvalue;\n        } else {\n          bObject = new Blob([aObject._rvalue], {\n            type: aObject._rmime\n          });\n        }\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\n      } else {\n        // make sure all the interface functions are decoded\n        if (aObject._rintf) {\n          const temp = aObject._rtype;\n          delete aObject._rtype;\n          bObject = await this._decode(aObject, withPromise);\n          bObject._rtype = temp;\n        } else bObject = aObject;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(v, withPromise);\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    } // store the object id for dispose\n\n\n    if (aObject._rintf) {\n      this._object_weakmap.set(bObject, aObject._rintf);\n    }\n\n    return bObject;\n  }\n\n  async _wrap(args, asInterface) {\n    return await this._encode(args, asInterface);\n  }\n  /**\n   * Unwraps the set of arguments delivered from the remote site,\n   * replaces all callback identifiers with a function which will\n   * initiate sending that callback identifier back to other site\n   *\n   * @param {Object} args to unwrap\n   *\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Array} unwrapped args\n   */\n\n\n  async _unwrap(args, withPromise) {\n    return await this._decode(args, withPromise);\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * callback. When the generated function is called, it will send\n   * the corresponding message to the remote site asking it to\n   * execute the particular callback previously saved during a call\n   * by the remote site a method from the interface of this site\n   *\n   * @param {Number} id of the remote callback to execute\n   * @param {Number} argNum argument index of the callback\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Function} wrapped remote callback\n   */\n\n\n  _genRemoteCallback(targetId, cid, withPromise) {\n    const me = this;\n    let remoteCallback;\n\n    if (withPromise) {\n      remoteCallback = function () {\n        return new Promise(async (resolve, reject) => {\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\n          const transferables = args.__transferables__;\n          if (transferables) delete args.__transferables__;\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\n\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\n          reject.__promise_pair = encodedPromise[0]._rvalue;\n\n          try {\n            me._connection.emit({\n              type: \"callback\",\n              target_id: targetId,\n              id: cid,\n              args: args,\n              promise: encodedPromise,\n              with_kwargs: withKwargs\n            }, transferables);\n          } catch (e) {\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\n          }\n        });\n      };\n\n      return remoteCallback;\n    } else {\n      remoteCallback = async function () {\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n        const transferables = args.__transferables__;\n        if (transferables) delete args.__transferables__;\n        return me._connection.emit({\n          type: \"callback\",\n          target_id: targetId,\n          id: cid,\n          args: args,\n          with_kwargs: withKwargs\n        }, transferables);\n      };\n\n      return remoteCallback;\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._remote_interface = null;\n    this._object_store = {};\n    this._method_weakmap = new WeakMap();\n    this._object_weakmap = new WeakMap();\n    this._local_api = null;\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n  }\n  /**\n   * Sends the notification message and breaks the connection\n   */\n\n\n  disconnect() {\n    this._connection.emit({\n      type: \"disconnect\"\n    });\n\n    this.reset();\n    setTimeout(() => {\n      this._connection.disconnect();\n    }, 2000);\n  }\n\n}\n/**\n * ReferenceStore is a special object which stores other objects\n * and provides the references (number) instead. This reference\n * may then be sent over a json-based communication channel (IPC\n * to another Node.js process or a message to the Worker). Other\n * site may then provide the reference in the responce message\n * implying the given object should be activated.\n *\n * Primary usage for the ReferenceStore is a storage for the\n * callbacks, which therefore makes it possible to initiate a\n * callback execution by the opposite site (which normally cannot\n * directly execute functions over the communication channel).\n *\n * Each stored object can only be fetched once and is not\n * available for the second time. Each stored object must be\n * fetched, since otherwise it will remain stored forever and\n * consume memory.\n *\n * Stored object indeces are simply the numbers, which are however\n * released along with the objects, and are later reused again (in\n * order to postpone the overflow, which should not likely happen,\n * but anyway).\n */\n\nclass ReferenceStore {\n  constructor() {\n    this._store = {}; // stored object\n\n    this._indices = [0]; // smallest available indices\n\n    this._readyHandler = function () {};\n\n    this._busyHandler = function () {};\n\n    this._readyHandler();\n  }\n  /**\n   * call handler when the store is empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onReady(readyHandler) {\n    this._readyHandler = readyHandler || function () {};\n  }\n  /**\n   * call handler when the store is not empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onBusy(busyHandler) {\n    this._busyHandler = busyHandler || function () {};\n  }\n  /**\n   * get the length of the store\n   *\n   */\n\n\n  getStack() {\n    return Object.keys(this._store).length;\n  }\n  /**\n   * @function _genId() generates the new reference id\n   *\n   * @returns {Number} smallest available id and reserves it\n   */\n\n\n  _genId() {\n    let id;\n\n    if (this._indices.length === 1) {\n      id = this._indices[0]++;\n    } else {\n      id = this._indices.shift();\n    }\n\n    return id;\n  }\n  /**\n   * Releases the given reference id so that it will be available by\n   * another object stored\n   *\n   * @param {Number} id to release\n   */\n\n\n  _releaseId(id) {\n    for (let i = 0; i < this._indices.length; i++) {\n      if (id < this._indices[i]) {\n        this._indices.splice(i, 0, id);\n\n        break;\n      }\n    } // cleaning-up the sequence tail\n\n\n    for (let i = this._indices.length - 1; i >= 0; i--) {\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\n        this._indices.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Stores the given object and returns the refernce id instead\n   *\n   * @param {Object} obj to store\n   *\n   * @returns {Number} reference id of the stored object\n   */\n\n\n  put(obj) {\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\n      this._busyHandler();\n    }\n\n    const id = this._genId();\n\n    this._store[id] = obj;\n    return id;\n  }\n  /**\n   * Retrieves previously stored object and releases its reference\n   *\n   * @param {Number} id of an object to retrieve\n   */\n\n\n  fetch(id) {\n    const obj = this._store[id];\n\n    if (obj && !obj.__remote_method) {\n      delete this._store[id];\n\n      this._releaseId(id);\n\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\n        this._readyHandler();\n      }\n    }\n\n    if (obj && obj.__promise_pair) {\n      this.fetch(obj.__promise_pair);\n    }\n\n    return obj;\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/socketIOMain.js\":\n/*!*****************************!*\\\n  !*** ./src/socketIOMain.js ***!\n  \\*****************************/\n/*! exports provided: setupRPC, waitForInitialization, VERSION, RPC, API_VERSION, loadRequirements, Connection, connectToServer */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_326091__) {\n\n\"use strict\";\n__nested_webpack_require_326091__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"Connection\", function() { return Connection; });\n/* harmony export (binding) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"connectToServer\", function() { return connectToServer; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_326091__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_326091__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]; });\n\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_326091__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirements\"]; });\n\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_326091__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_326091__(/*! ./main.js */ \"./src/main.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"setupRPC\", function() { return _main_js__WEBPACK_IMPORTED_MODULE_4__[\"setupRPC\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"waitForInitialization\", function() { return _main_js__WEBPACK_IMPORTED_MODULE_4__[\"waitForInitialization\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_326091__(/*! ../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /*#__PURE__*/__nested_webpack_require_326091__.t(/*! ../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __nested_webpack_require_326091__.d(__nested_webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"]; });\n\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n\n\n\n\n\n\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n  constructor(config) {\n    super(config && config.debug);\n    this.config = config || {};\n    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  }\n\n  init() {\n    return new Promise((resolve, reject) => {\n      const config = this.config;\n      const url = config.server_url;\n      const extraHeaders = {};\n\n      if (config.token) {\n        extraHeaders.Authorization = \"Bearer \" + config.token;\n      }\n\n      const basePath = new URL(url).pathname; // Note: extraHeaders only works for polling transport (the default)\n      // If we switch to websocket only, the headers won't be respected\n\n      const socket = Object(socket_io_client__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(url, {\n        withCredentials: true,\n        extraHeaders,\n        path: (basePath.endsWith(\"/\") ? basePath.slice(0, -1) : basePath) + \"/socket.io\"\n      });\n      let connected = false;\n      socket.on(\"connect\", () => {\n        if (connected) {\n          console.warn(\"Skipping reconnect to the server\");\n          return;\n        }\n\n        socket.emit(\"register_plugin\", config, result => {\n          if (!result.success) {\n            console.error(result.detail);\n            reject(result.detail);\n            return;\n          }\n\n          connected = true;\n          this.plugin_id = result.plugin_id;\n          socket.on(\"plugin_message\", data => {\n            if (data.peer_id === this.peer_id) {\n              this._fire(data.type, data);\n            } else if (this.config.debug) {\n              console.log(`connection peer id mismatch ${data.peer_id} !== ${this.peer_id}`);\n            }\n          });\n          this.once(\"initialize\", () => {\n            if (!this.rpc) {\n              this.rpc = Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(this, config);\n            } else {\n              this.rpc.once(\"remoteReady\", () => {\n                this.rpc.sendInterface();\n              });\n            }\n\n            this.connect();\n            resolve();\n          });\n          this.emit({\n            type: \"imjoyRPCReady\",\n            config: config,\n            peer_id: this.peer_id\n          });\n        });\n        this._disconnected = false;\n      });\n      socket.on(\"connect_error\", () => {\n        reject(\"connection error\");\n\n        this._fire(\"connectFailure\");\n      });\n      socket.on(\"disconnect\", () => {\n        reject(\"disconnected\");\n        this.disconnect();\n\n        this._fire(\"disconnected\");\n      });\n      this.socket = socket;\n    });\n  }\n\n  connect() {\n    this.emit({\n      type: \"initialized\",\n      config: this.config,\n      origin: globalThis.location.origin,\n      peer_id: this.peer_id\n    });\n\n    this._fire(\"connected\");\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._once_handlers = {};\n  }\n\n  execute() {\n    throw new Error(\"Execution is not allowed for socketio connection\");\n  }\n\n  disconnect() {\n    this._fire(\"beforeDisconnect\");\n\n    this.socket.disconnect();\n    this.init();\n\n    this._fire(\"disconnected\");\n  }\n\n  emit(data) {\n    data.plugin_id = this.plugin_id;\n    this.socket.emit(\"plugin_message\", data, result => {\n      if (!result.success) this._fire(\"error\", data.detail);\n    });\n  }\n\n}\nfunction connectToServer(config) {\n  config = config || {};\n  if (!config.server_url) throw new Error(\"Server URL is not specified.\");\n  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"normalizeConfig\"])(config);\n  return new Promise((resolve, reject) => {\n    const handleEvent = e => {\n      const api = e.detail;\n\n      if (config.expose_api_globally) {\n        globalThis.api = api;\n      } // imjoy plugin api\n\n\n      resolve(api);\n      globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n    };\n\n    globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n    config = config || {};\n    config.dedicated_thread = false;\n    config.lang = \"javascript\";\n    config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n    const conn = new Connection(config);\n    conn.init().catch(reject);\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/utils.js\":\n/*!**********************!*\\\n  !*** ./src/utils.js ***!\n  \\**********************/\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_333274__) {\n\n\"use strict\";\n__nested_webpack_require_333274__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __nested_webpack_require_333274__.d(__nested_webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array\n};\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  } // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      var link_node;\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            await import(\n            /* webpackIgnore: true */\n            requirements[i]);\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nasync function loadRequirementsInWebworker(requirements) {\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n\n      for (var i = 0; i < requirements.length; i++) {\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n          throw \"unable to import css in a webworker\";\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nfunction loadRequirements(requirements) {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false; // remove functions\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\nconst typedArrayToDtypeKeys = [];\n\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n    await cacheUrlInServiceWorker(req).catch(e => {\n      console.error(e);\n    });\n  }\n}\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    baseUrl = baseUrl || \"/\";\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\n      // Registration was successful\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n    }, function (err) {\n      // registration failed :(\n      console.log(\"ServiceWorker registration failed: \", err);\n    });\n    targetOrigin = targetOrigin || \"*\";\n    cacheCallback = cacheCallback || cacheRequirements;\n\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\n      throw new Error(\"config.cache_requirements must be a function\");\n    }\n\n    window.addEventListener(\"message\", function (e) {\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n        const m = e.data;\n\n        if (m.type === \"cacheRequirements\") {\n          cacheCallback(m.requirements);\n        }\n      }\n    });\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=imjoy-rpc-socketio.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/imjoy-rpc.js":
/*!**************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/imjoy-rpc.js ***!
  \**************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_551__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_551__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_551__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_551__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_551__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_551__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_551__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_551__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_551__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_551__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_551__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_551__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_551__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_551__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_551__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_551__(__nested_webpack_require_551__.s = \"./src/main.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};\n\n/***/ }),\n\n/***/ \"./package.json\":\n/*!**********************!*\\\n  !*** ./package.json ***!\n  \\**********************/\n/*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"name\\\":\\\"imjoy-rpc\\\",\\\"version\\\":\\\"0.5.59\\\",\\\"description\\\":\\\"Remote procedure calls for ImJoy.\\\",\\\"module\\\":\\\"index.js\\\",\\\"types\\\":\\\"index.d.ts\\\",\\\"scripts\\\":{\\\"build\\\":\\\"rm -rf dist && npm run build-umd\\\",\\\"build-umd\\\":\\\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \\\",\\\"watch\\\":\\\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\\\",\\\"publish-npm\\\":\\\"npm install && npm run build && npm publish\\\",\\\"serve\\\":\\\"webpack-dev-server\\\",\\\"stats\\\":\\\"webpack --profile --json > stats.json\\\",\\\"stats-prod\\\":\\\"webpack --profile --json --mode production > stats-prod.json\\\",\\\"analyze\\\":\\\"webpack-bundle-analyzer -p 9999 stats.json\\\",\\\"analyze-prod\\\":\\\"webpack-bundle-analyzer -p 9999 stats-prod.json\\\",\\\"clean\\\":\\\"rimraf dist/*\\\",\\\"deploy\\\":\\\"npm run build && node deploy-site.js\\\",\\\"format\\\":\\\"prettier --write \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"check-format\\\":\\\"prettier --check \\\\\\\"{src,tests}/**/**\\\\\\\"\\\",\\\"test\\\":\\\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\\\",\\\"test-watch\\\":\\\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/imjoy-team/imjoy-rpc.git\\\"},\\\"keywords\\\":[\\\"imjoy\\\",\\\"rpc\\\"],\\\"author\\\":\\\"imjoy-team <imjoy.team@gmail.com>\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/imjoy-team/imjoy-rpc/issues\\\"},\\\"homepage\\\":\\\"https://github.com/imjoy-team/imjoy-rpc\\\",\\\"dependencies\\\":{\\\"@msgpack/msgpack\\\":\\\"^2.7.1\\\",\\\"socket.io-client\\\":\\\"^4.6.2\\\"},\\\"devDependencies\\\":{\\\"@babel/core\\\":\\\"^7.16.12\\\",\\\"@babel/plugin-syntax-dynamic-import\\\":\\\"^7.8.3\\\",\\\"@babel/polyfill\\\":\\\"^7.12.1\\\",\\\"@babel/preset-env\\\":\\\"^7.16.11\\\",\\\"@types/requirejs\\\":\\\"^2.1.34\\\",\\\"babel-core\\\":\\\"^6.26.0\\\",\\\"babel-eslint\\\":\\\"^10.1.0\\\",\\\"babel-loader\\\":\\\"^8.2.3\\\",\\\"babel-runtime\\\":\\\"^6.26.0\\\",\\\"chai\\\":\\\"^4.3.6\\\",\\\"clean-webpack-plugin\\\":\\\"^0.1.19\\\",\\\"copy-webpack-plugin\\\":\\\"^5.1.2\\\",\\\"eslint\\\":\\\"^6.8.0\\\",\\\"eslint-config-prettier\\\":\\\"^4.2.0\\\",\\\"eslint-loader\\\":\\\"^4.0.2\\\",\\\"file-loader\\\":\\\"^0.11.2\\\",\\\"fs-extra\\\":\\\"^0.30.0\\\",\\\"gh-pages\\\":\\\"^2.0.1\\\",\\\"html-loader\\\":\\\"^0.5.5\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"json-loader\\\":\\\"^0.5.4\\\",\\\"karma\\\":\\\"^6.3.12\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^1.3.0\\\",\\\"karma-mocha\\\":\\\"^2.0.1\\\",\\\"karma-sourcemap-loader\\\":\\\"^0.3.8\\\",\\\"karma-spec-reporter\\\":\\\"0.0.32\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"lerna\\\":\\\"^6.0.3\\\",\\\"lodash.debounce\\\":\\\"^4.0.8\\\",\\\"mocha\\\":\\\"^10.1.0\\\",\\\"postcss\\\":\\\"^7.0.36\\\",\\\"prettier\\\":\\\"^1.6.1\\\",\\\"rimraf\\\":\\\"^2.6.2\\\",\\\"schema-utils\\\":\\\"^0.4.3\\\",\\\"style-loader\\\":\\\"^0.18.1\\\",\\\"ts-loader\\\":\\\"^9.4.3\\\",\\\"url-loader\\\":\\\"^0.5.9\\\",\\\"webpack\\\":\\\"^4.46.0\\\",\\\"webpack-bundle-analyzer\\\":\\\"^4.7.0\\\",\\\"webpack-cli\\\":\\\"^3.3.12\\\",\\\"webpack-dev-server\\\":\\\"^3.11.3\\\",\\\"webpack-merge\\\":\\\"^4.1.1\\\",\\\"workbox-webpack-plugin\\\":\\\"^4.3.1\\\",\\\"worker-loader\\\":\\\"^2.0.0\\\",\\\"write-file-webpack-plugin\\\":\\\"^4.5.1\\\"},\\\"eslintConfig\\\":{\\\"globals\\\":{\\\"document\\\":true,\\\"window\\\":true}}}\");\n\n/***/ }),\n\n/***/ \"./src/main.js\":\n/*!*********************!*\\\n  !*** ./src/main.js ***!\n  \\*********************/\n/*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_9015__) {\n\n\"use strict\";\n__nested_webpack_require_9015__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_9015__.d(__nested_webpack_exports__, \"waitForInitialization\", function() { return waitForInitialization; });\n/* harmony export (binding) */ __nested_webpack_require_9015__.d(__nested_webpack_exports__, \"setupRPC\", function() { return setupRPC; });\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_9015__(/*! ./plugin.webworker.js */ \"./src/plugin.webworker.js\");\n/* harmony import */ var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_9015__.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_9015__(/*! ./pluginIframe.js */ \"./src/pluginIframe.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_9015__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_9015__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirements\"]; });\n\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_9015__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony reexport (safe) */ __nested_webpack_require_9015__.d(__nested_webpack_exports__, \"RPC\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"RPC\"]; });\n\n/* harmony reexport (safe) */ __nested_webpack_require_9015__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"API_VERSION\"]; });\n\n/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_9015__(/*! ../package.json */ \"./package.json\");\nvar _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /*#__PURE__*/__nested_webpack_require_9015__.t(/*! ../package.json */ \"./package.json\", 1);\n/* harmony reexport (safe) */ __nested_webpack_require_9015__.d(__nested_webpack_exports__, \"VERSION\", function() { return _package_json__WEBPACK_IMPORTED_MODULE_4__[\"version\"]; });\n\n/**\n * Contains the code executed in the sandboxed frame under web-browser\n *\n * Tries to create a Web-Worker inside the frame and set up the\n * communication between the worker and the parent window. Some\n * browsers restrict creating a worker inside a sandboxed iframe - if\n * this happens, the plugin initialized right inside the frame (in the\n * same thread)\n */\n\n\n\n\n\n\n\nfunction _inIframe() {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n}\n\nfunction _inWebWorker() {\n  return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n}\n/**\n * Initializes the plugin inside a web worker. May throw an exception\n * in case this was not permitted by the browser.\n */\n\n\nfunction setupWebWorker(config) {\n  if (!config.allow_execution) throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n  let broadcastChannel = null;\n\n  if (config.broadcastChannel) {\n    broadcastChannel = new BroadcastChannel(config.broadcastChannel);\n  }\n\n  const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a(); // mixed content warning in Chrome silently skips worker\n  // initialization without exception, handling this with timeout\n\n  const fallbackTimeout = setTimeout(function () {\n    worker.terminate();\n    console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n  }, 2000);\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])(); // forwarding messages between the worker and parent window\n\n  worker.addEventListener(\"message\", function (e) {\n    let transferables = undefined;\n    const m = e.data;\n\n    if (m.type === \"worker-ready\") {\n      // send config to the worker\n      worker.postMessage({\n        type: \"connectRPC\",\n        config: config\n      });\n      clearTimeout(fallbackTimeout);\n      return;\n    } else if (m.type === \"initialized\") {\n      // complete the missing fields\n      m.config = Object.assign({}, config, m.config);\n      m.origin = globalThis.location.origin;\n      m.peer_id = peer_id;\n    } else if (m.type === \"imjoy_remote_api_ready\") {\n      // if it's a webworker, there will be no api object returned\n      globalThis.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: null\n      }));\n    } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n      cache_requirements(m.requirements);\n    } else if (m.type === \"disconnect\") {\n      worker.terminate();\n    } else {\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n    }\n\n    if (broadcastChannel) broadcastChannel.postMessage(m);else parent.postMessage(m, config.target_origin || \"*\", transferables);\n  });\n  (broadcastChannel || window).addEventListener(\"message\", function (e) {\n    if (e.type === \"message\" && (broadcastChannel || config.target_origin === \"*\" || e.origin === config.target_origin)) {\n      let transferables = undefined;\n      const m = e.data;\n\n      if (m.__transferables__) {\n        transferables = m.__transferables__;\n        delete m.__transferables__;\n      }\n\n      if (m.peer_id === peer_id) {\n        worker.postMessage(m, transferables);\n      } else if (config.debug) {\n        console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n      }\n    }\n  });\n}\n\nfunction waitForInitialization(config) {\n  if (_inWebWorker()) {\n    globalThis.parent = self;\n  }\n\n  config = config || {};\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n    config.enable_service_worker = false;\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  }\n\n  const targetOrigin = config.target_origin || \"*\";\n\n  if (config.credential_required && typeof config.verify_credential !== \"function\") {\n    throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n  }\n\n  if (config.credential_required && targetOrigin === \"*\") {\n    throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n  }\n\n  const done = () => {\n    globalThis.removeEventListener(\"message\", handleEvent);\n  };\n\n  const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n\n  const handleEvent = e => {\n    if (e.type === \"message\" && (!e.origin || targetOrigin === \"*\" || e.origin === targetOrigin)) {\n      if (e.data.type === \"initialize\") {\n        done();\n\n        if (e.data.peer_id !== peer_id) {\n          // TODO: throw an error when we are sure all the peers will send the peer_id\n          console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n        }\n\n        const cfg = e.data.config; // override the target_origin setting if it's configured by the rpc client\n        // otherwise take the setting from the core\n\n        if (targetOrigin !== \"*\") {\n          cfg.target_origin = targetOrigin;\n        }\n\n        if (config.credential_required) {\n          config.verify_credential(cfg.credential).then(result => {\n            if (result && result.auth && !result.error) {\n              // pass the authentication information with tokens\n              cfg.auth = result.auth;\n              setupRPC(cfg).then(() => {\n                console.log(\"ImJoy RPC loaded successfully!\");\n              });\n            } else {\n              throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n            }\n          });\n        } else {\n          setupRPC(cfg).then(() => {\n            console.log(\"ImJoy RPC loaded successfully!\");\n          });\n        }\n      } else {\n        throw new Error(`unrecognized message: ${e.data}`);\n      }\n    }\n  };\n\n  globalThis.addEventListener(\"message\", handleEvent);\n\n  if (_inWebWorker()) {\n    parent.postMessage({\n      type: \"imjoyRPCReady\",\n      config: config,\n      peer_id: peer_id\n    });\n  } else {\n    parent.postMessage({\n      type: \"imjoyRPCReady\",\n      config: config,\n      peer_id: peer_id\n    }, \"*\");\n  }\n}\nfunction setupRPC(config) {\n  config = config || {};\n  config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"normalizeConfig\"])(config);\n\n  if (config.enable_service_worker) {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n  }\n\n  if (config.cache_requirements) {\n    delete config.cache_requirements;\n  }\n\n  return new Promise((resolve, reject) => {\n    const handleEvent = e => {\n      const api = e.detail;\n\n      if (config.expose_api_globally) {\n        globalThis.api = api;\n      } // imjoy plugin api\n\n\n      resolve(api);\n      globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n    };\n\n    if (_inIframe()) {\n      if (config.type === \"web-worker\") {\n        try {\n          setupWebWorker(config);\n        } catch (e) {\n          // fallback to iframe\n          Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n        }\n      } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n        Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n      } else {\n        console.error(\"Unsupported plugin type: \" + config.type);\n        reject(\"Unsupported plugin type: \" + config.type);\n        return;\n      }\n\n      globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n    } else if (_inWebWorker()) {\n      // inside a webworker\n      Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n    } else {\n      reject(new Error(\"imjoy-rpc should only run inside an iframe or a webworker.\"));\n    }\n  });\n}\n\n/***/ }),\n\n/***/ \"./src/plugin.webworker.js\":\n/*!*********************************!*\\\n  !*** ./src/plugin.webworker.js ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __nested_webpack_require_19339__) {\n\nmodule.exports = function() {\n  return __nested_webpack_require_19339__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/plugin.webworker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/plugin.webworker.js\\\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \\\"./src/pluginCore.js\\\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \\\"./src/rpc.js\\\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \\\"./src/utils.js\\\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \\\"undefined\\\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\\\"This script can only loaded in a webworker\\\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \\\"data:text/javascript;charset=utf-8,\\\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\\\"MessageEmitter\\\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\\\"message\\\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \\\"initialized\\\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\\\"beforeDisconnect\\\");\\n    self.close();\\n    this._fire(\\\"disconnected\\\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \\\"requirements\\\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\\\"loadRequirementsInWebworker\\\"])(code.requirements);\\n    } else if (code.type === \\\"script\\\") {\\n      try {\\n        if (code.attrs.type === \\\"module\\\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \\\"unsupported code type.\\\";\\n    }\\n    if (code.type === \\\"requirements\\\") {\\n      self.postMessage({\\n        type: \\\"cacheRequirements\\\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \\\"web-worker\\\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \\\"javascript\\\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\\\"API_VERSION\\\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\\\"connectRPC\\\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\\\"connectRPC\\\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \\\"worker-ready\\\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \\\"./src/pluginCore.js\\\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"connectRPC\\\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \\\"./src/rpc.js\\\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\\\"RPC\\\"](connection, config, codecs);\\n  rpc.on(\\\"getInterface\\\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\\\"remoteReady\\\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\\\"name\\\"] || !config[\\\"encoder\\\"] && !config[\\\"decoder\\\"]) {\\n        throw new Error(\\\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\\\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\\\"Remove duplicated codec: \\\" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\\\"name\\\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \\\"undefined\\\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \\\"imjoy_remote_api_ready\\\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\\\"imjoy_remote_api_ready\\\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\\\"imjoy_remote_api_ready\\\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \\\"function\\\") {\\n      const msg = \\\"A function may only be subsribed to the event, \\\" + type + \\\" was provided instead\\\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \\\"./src/rpc.js\\\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"API_VERSION\\\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"RPC\\\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \\\"./src/utils.js\\\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \\\"0.2.3\\\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\\\"undefined index\\\");\\n  if (typeof is === \\\"string\\\") return indexObject(obj, is.split(\\\".\\\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"MessageEmitter\\\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(`connection.execute not implemented (in \\\"${name}\\\")`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\\\"remoteIdle\\\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\\\"remoteBusy\\\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \\\"initialized\\\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\\\"interfaceAvailable\\\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\\\"interfaceSetAsRemote\\\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\\\"interface is not set.\\\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \\\"setInterface\\\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(`Object (id=${objectId}) not found.`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\\\"disposed\\\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \\\"disposeObject\\\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\\\"Invalid object\\\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\\\"init\\\", this.init);\\n\\n    this._connection.on(\\\"execute\\\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \\\"executed\\\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\\"executed\\\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\\\"method\\\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\\\".\\\")) {\\n          const tmp = data.name.split(\\\".\\\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\\\".\\\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\"AsyncFunction\\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\\"callback\\\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \\\"AsyncFunction\\\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\\\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\\\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\\\"disposeObject\\\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \\\"disposed\\\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \\\"disposed\\\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\\"setInterface\\\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\\\"getInterface\\\", () => {\\n      this._fire(\\\"getInterface\\\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\\\"interfaceAvailable\\\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\\\"interfaceSetAsRemote\\\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\\\"interfaceSetAsRemote\\\");\\n    });\\n\\n    this._connection.on(\\\"disconnect\\\", () => {\\n      this._fire(\\\"beforeDisconnect\\\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\\\"disconnected\\\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \\\"getInterface\\\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"typedArrayToDtype\\\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \\\"dtype doesn't match the type of the array: \\\" + _dtype + \\\" != \\\" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \\\"ndarray\\\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\\\"remoteReady\\\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \\\"/\\\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\\"object\\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \\\"register\\\" || name === \\\"registerService\\\" || name === \\\"register_service\\\" || name === \\\"export\\\" || name === \\\"on\\\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \\\"method\\\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \\\"interfaceSetAsRemote\\\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \\\"number\\\" || aType === \\\"string\\\" || aType === \\\"boolean\\\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \\\"function\\\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\\\"objectId is not specified.\\\");\\n        bObject = {\\n          _rtype: \\\"interface\\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \\\"callback\\\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \\\"undefined\\\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\\"ndarray\\\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \\\"undefined\\\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"typedArrayToDtype\\\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\\"ndarray\\\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \\\"error\\\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \\\"undefined\\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\\"file\\\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \\\"undefined\\\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \\\"undefined\\\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \\\"undefined\\\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \\\"undefined\\\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \\\"undefined\\\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \\\"undefined\\\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \\\"file\\\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \\\"blob\\\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"typedArrayToDtype\\\"])(aObject);\\n      bObject = {\\n        _rtype: \\\"typedarray\\\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \\\"memoryview\\\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \\\"set\\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \\\"orderedmap\\\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\\\"Please instantiate the class before exportting it.\\\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\\\"Unsupported interface type\\\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \\\"string\\\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"randId\\\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \\\"constructor\\\") continue;\\n\\n          if (k.startsWith(\\\"_\\\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \\\"string\\\" ? asInterface + \\\".\\\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \\\"function\\\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \\\"function\\\") {\\n          aObject.on(\\\"close\\\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\\\"hasOwnProperty\\\", \\\"constructor\\\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \\\"object\\\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"randId\\\"])();\\n\\n      for (let k of keys) {\\n        if ([\\\"hasOwnProperty\\\", \\\"constructor\\\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \\\"imjoy-rpc: Unsupported data type:\\\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\\\"Failed to encode object\\\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\\\"_rtype\\\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \\\"callback\\\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \\\"interface\\\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \\\"ndarray\\\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \\\"undefined\\\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \\\"undefined\\\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"dtypeToTypedArray\\\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \\\"error\\\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \\\"file\\\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \\\"typedarray\\\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\\\"dtypeToTypedArray\\\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\\\"unsupported dtype: \\\" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \\\"memoryview\\\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \\\"blob\\\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \\\"orderedmap\\\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \\\"set\\\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\\\"Failed to decode object\\\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\\"object\\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \\\"callback\\\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \\\"object\\\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \\\"callback\\\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \\\"disconnect\\\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \\\"./src/utils.js\\\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"randId\\\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"dtypeToTypedArray\\\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"loadRequirementsInWindow\\\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"loadRequirementsInWebworker\\\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"loadRequirements\\\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"normalizeConfig\\\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"typedArrayToDtypeMapping\\\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"typedArrayToDtype\\\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"cacheRequirements\\\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"setupServiceWorker\\\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"urlJoin\\\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"MessageEmitter\\\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\\\"script\\\");\\n      scriptTag.src = url;\\n      scriptTag.type = \\\"text/javascript\\\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \\\"loaded\\\" || this.readyState === \\\"complete\\\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\\"string\\\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \\\"string\\\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\\\".css\\\") || requirements[i].startsWith(\\\"css:\\\")) {\\n            if (requirements[i].startsWith(\\\"css:\\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\\\"link\\\");\\n            link_node.rel = \\\"stylesheet\\\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\\\".mjs\\\") || requirements[i].startsWith(\\\"mjs:\\\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\\\"mjs:\\\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\\\".js\\\") || requirements[i].startsWith(\\\"js:\\\")) {\\n            if (requirements[i].startsWith(\\\"js:\\\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\\"http\\\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\\\"cache:\\\")) {//ignore cache\\n          } else {\\n            console.log(\\\"Unprocessed requirements url: \\\" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \\\"unsupported requirements definition\\\";\\n      }\\n    } catch (e) {\\n      throw \\\"failed to import required scripts: \\\" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \\\"string\\\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\\\".css\\\") || requirements[i].startsWith(\\\"css:\\\")) {\\n          throw \\\"unable to import css in a webworker\\\";\\n        } else if (requirements[i].toLowerCase().endsWith(\\\".js\\\") || requirements[i].startsWith(\\\"js:\\\")) {\\n          if (requirements[i].startsWith(\\\"js:\\\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\\"http\\\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\\\"cache:\\\")) {//ignore cache\\n        } else {\\n          console.log(\\\"Unprocessed requirements url: \\\" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \\\"failed to import required scripts: \\\" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \\\"undefined\\\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \\\"0.1.0\\\";\\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\\n  config.type = config.type || \\\"rpc-window\\\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \\\"*\\\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \\\"function\\\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \\\"int8\\\",\\n  Int16Array: \\\"int16\\\",\\n  Int32Array: \\\"int32\\\",\\n  Uint8Array: \\\"uint8\\\",\\n  Uint16Array: \\\"uint16\\\",\\n  Uint32Array: \\\"uint32\\\",\\n  Float32Array: \\\"float32\\\",\\n  Float64Array: \\\"float64\\\",\\n  Array: \\\"array\\\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \\\"add\\\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\\\"Service worker is not supported.\\\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\\\"Service worker controller is not available\\\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\\\"js:\\\")) req = req.slice(3);\\n    if (req.startsWith(\\\"css:\\\")) req = req.slice(4);\\n    if (req.startsWith(\\\"cache:\\\")) req = req.slice(6);\\n    if (!req.startsWith(\\\"http\\\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\\\"serviceWorker\\\" in navigator) {\\n    baseUrl = baseUrl || \\\"/\\\";\\n    navigator.serviceWorker.register(baseUrl + \\\"plugin-service-worker.js\\\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\\\"ServiceWorker registration successful with scope: \\\", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\\\"ServiceWorker registration failed: \\\", err);\\n    });\\n    targetOrigin = targetOrigin || \\\"*\\\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \\\"function\\\") {\\n      throw new Error(\\\"config.cache_requirements must be a function\\\");\\n    }\\n\\n    window.addEventListener(\\\"message\\\", function (e) {\\n      if (targetOrigin === \\\"*\\\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \\\"cacheRequirements\\\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\\\"/\\\").replace(/[\\\\/]+/g, \\\"/\\\").replace(/^(.+):\\\\//, \\\"$1://\\\").replace(/^file:/, \\\"file:/\\\").replace(/\\\\/(\\\\?|&|#[^!])/g, \\\"$1\\\").replace(/\\\\?/g, \\\"&\\\").replace(\\\"&\\\", \\\"?\\\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\\\"emit is not implemented\\\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\\\"unhandled event\\\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map\", null);\n};\n\n/***/ }),\n\n/***/ \"./src/pluginCore.js\":\n/*!***************************!*\\\n  !*** ./src/pluginCore.js ***!\n  \\***************************/\n/*! exports provided: connectRPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_79315__) {\n\n\"use strict\";\n__nested_webpack_require_79315__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_79315__.d(__nested_webpack_exports__, \"connectRPC\", function() { return connectRPC; });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_79315__(/*! ./rpc.js */ \"./src/rpc.js\");\n/**\n * Core plugin script loaded into the plugin process/thread.\n *\n * Initializes the plugin-site API global methods.\n */\n\nfunction connectRPC(connection, config) {\n  config = config || {};\n  const codecs = {};\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n  rpc.on(\"getInterface\", function () {\n    launchConnected();\n  });\n  rpc.on(\"remoteReady\", function () {\n    const api = rpc.getRemote() || {};\n\n    api.registerCodec = function (config) {\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n      } else {\n        if (config.type) {\n          for (let k of Object.keys(codecs)) {\n            if (codecs[k].type === config.type || k === config.name) {\n              delete codecs[k];\n              console.warn(\"Remove duplicated codec: \" + k);\n            }\n          }\n        }\n\n        codecs[config[\"name\"]] = config;\n      }\n    };\n\n    api.init = function (config) {\n      // register a minimal plugin api\n      rpc.setInterface({\n        setup() {}\n\n      }, config);\n    };\n\n    api.disposeObject = function (obj) {\n      rpc.disposeObject(obj);\n    };\n\n    api.export = function (_interface, config) {\n      rpc.setInterface(_interface, config);\n    };\n\n    api.onLoad = function (handler) {\n      handler = checkHandler(handler);\n\n      if (connected) {\n        handler();\n      } else {\n        connectedHandlers.push(handler);\n      }\n    };\n\n    api.dispose = function (_interface) {\n      rpc.disconnect();\n    };\n\n    api._rpc = rpc;\n\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n      self.api = api;\n      self.postMessage({\n        type: \"imjoy_remote_api_ready\"\n      });\n      self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    } else if (typeof window) {\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n        detail: api\n      }));\n    }\n  });\n  let connected = false;\n  const connectedHandlers = [];\n\n  const launchConnected = function () {\n    if (!connected) {\n      connected = true;\n      let handler;\n\n      while (handler = connectedHandlers.pop()) {\n        handler();\n      }\n    }\n  };\n\n  const checkHandler = function (handler) {\n    const type = typeof handler;\n\n    if (type !== \"function\") {\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n      throw new Error(msg);\n    }\n\n    return handler;\n  };\n\n  return rpc;\n}\n\n/***/ }),\n\n/***/ \"./src/pluginIframe.js\":\n/*!*****************************!*\\\n  !*** ./src/pluginIframe.js ***!\n  \\*****************************/\n/*! exports provided: Connection, default */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_82486__) {\n\n\"use strict\";\n__nested_webpack_require_82486__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_82486__.d(__nested_webpack_exports__, \"Connection\", function() { return Connection; });\n/* harmony export (binding) */ __nested_webpack_require_82486__.d(__nested_webpack_exports__, \"default\", function() { return setupIframe; });\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_82486__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_82486__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_82486__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the routines loaded by the plugin iframe under web-browser\n * in case when worker failed to initialize\n *\n * Initializes the web environment version of the platform-dependent\n * connection object for the plugin site\n */\n\n\n // Create a new, plain <span> element\n\nfunction _htmlToElement(html) {\n  var template = document.createElement(\"template\");\n  html = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = html;\n  return template.content.firstChild;\n}\n\nconst _inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n\nasync function executeEsModule(content) {\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\n  await import(\n  /* webpackIgnore: true */\n  dataUri);\n}\n\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n  constructor(config) {\n    super(config && config.debug);\n    this.config = config || {};\n    this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n  }\n\n  connect() {\n    this.config.target_origin = this.config.target_origin || \"*\"; // this will call handleEvent function\n\n    if (this.config.broadcastChannel) {\n      this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);\n    } else {\n      this.broadcastChannel = null;\n    }\n\n    if (this.broadcastChannel) this.broadcastChannel.addEventListener(\"message\", this);else globalThis.addEventListener(\"message\", this);\n    this.emit({\n      type: \"initialized\",\n      config: this.config,\n      origin: globalThis.location.origin,\n      peer_id: this.peer_id\n    });\n\n    this._fire(\"connected\");\n  }\n\n  handleEvent(e) {\n    if (e.type === \"message\" && (this.broadcastChannel || this.config.target_origin === \"*\" || !e.origin || e.origin === this.config.target_origin)) {\n      if (e.data.peer_id === this.peer_id) {\n        this._fire(e.data.type, e.data);\n      } else if (this.config.debug) {\n        console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n      }\n    }\n  }\n\n  disconnect() {\n    this._fire(\"beforeDisconnect\");\n\n    globalThis.removeEventListener(\"message\", this);\n\n    this._fire(\"disconnected\");\n  }\n\n  emit(data) {\n    let transferables;\n    if (this.broadcastChannel) this.broadcastChannel.postMessage(data);else {\n      if (data.__transferables__) {\n        transferables = data.__transferables__;\n        delete data.__transferables__;\n      } else if (_inWebWorker) self.postMessage(data, transferables);else parent.postMessage(data, this.config.target_origin, transferables);\n    }\n  }\n\n  async execute(code) {\n    try {\n      if (code.type === \"requirements\") {\n        await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWindow\"])(code.requirements);\n      } else if (code.type === \"script\") {\n        if (code.src) {\n          var script_node = document.createElement(\"script\");\n          script_node.setAttribute(\"type\", code.attrs.type);\n          script_node.setAttribute(\"src\", code.src);\n          document.head.appendChild(script_node);\n        } else {\n          if (code.content && code.attrs.lang === \"javascript\") {\n            // document.addEventListener(\"DOMContentLoaded\", function(){\n            if (code.attrs.type === \"module\") {\n              await executeEsModule(code.content);\n            } else {\n              eval(code.content);\n            } // });\n\n          } else {\n            var node = document.createElement(\"script\");\n\n            for (let k in code.attrs) {\n              node.setAttribute(k, code.attrs[k]);\n            }\n\n            node.appendChild(document.createTextNode(code.content));\n            document.body.appendChild(node);\n          }\n        }\n      } else if (code.type === \"style\") {\n        const style_node = document.createElement(\"style\");\n\n        if (code.src) {\n          style_node.src = code.src;\n        }\n\n        style_node.innerHTML = code.content;\n        document.head.appendChild(style_node);\n      } else if (code.type === \"link\") {\n        const link_node_ = document.createElement(\"link\");\n\n        if (code.rel) {\n          link_node_.rel = code.rel;\n        }\n\n        if (code.href) {\n          link_node_.href = code.href;\n        }\n\n        if (code.attrs && code.attrs.type) {\n          link_node_.type = code.attrs.type;\n        }\n\n        document.head.appendChild(link_node_);\n      } else if (code.type === \"html\") {\n        document.body.appendChild(_htmlToElement(code.content));\n      } else {\n        throw \"unsupported code type.\";\n      }\n\n      if (_inWebWorker) self.postMessage({\n        type: \"executed\"\n      });else parent.postMessage({\n        type: \"executed\"\n      }, this.config.target_origin);\n    } catch (e) {\n      console.error(\"failed to execute scripts: \", code, e);\n      if (_inWebWorker) self.postMessage({\n        type: \"executed\",\n        error: e.stack || String(e)\n      });else parent.postMessage({\n        type: \"executed\",\n        error: e.stack || String(e)\n      }, this.config.target_origin);\n    }\n  }\n\n}\nfunction setupIframe(config) {\n  config = config || {};\n  config.dedicated_thread = false;\n  config.lang = \"javascript\";\n  config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n  const conn = new Connection(config);\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n  conn.connect();\n}\n\n/***/ }),\n\n/***/ \"./src/rpc.js\":\n/*!********************!*\\\n  !*** ./src/rpc.js ***!\n  \\********************/\n/*! exports provided: API_VERSION, RPC */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_88806__) {\n\n\"use strict\";\n__nested_webpack_require_88806__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_88806__.d(__nested_webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\n/* harmony export (binding) */ __nested_webpack_require_88806__.d(__nested_webpack_exports__, \"RPC\", function() { return RPC; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_88806__(/*! ./utils.js */ \"./src/utils.js\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\nconst API_VERSION = \"0.2.3\";\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\n}\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\n\n\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n  constructor(connection, config, codecs) {\n    super(config && config.debug);\n    this._connection = connection;\n    this.config = config || {};\n    this._codecs = codecs || {};\n    this._object_store = {};\n    this._method_weakmap = new WeakMap();\n    this._object_weakmap = new WeakMap();\n    this._local_api = null;\n    this._remote_set = false; // make sure there is an execute function\n\n    const name = this.config.name;\n\n    this._connection.execute = this._connection.execute || function () {\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\n    };\n\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n\n    this._method_refs.onReady(() => {\n      this._fire(\"remoteIdle\");\n    });\n\n    this._method_refs.onBusy(() => {\n      this._fire(\"remoteBusy\");\n    });\n\n    this._setupMessageHanlders();\n  }\n\n  init() {\n    this._connection.emit({\n      type: \"initialized\",\n      config: this.config,\n      peer_id: this._connection.peer_id\n    });\n  }\n\n  setConfig(config) {\n    if (config) for (const k of Object.keys(config)) {\n      this.config[k] = config[k];\n    }\n  }\n  /**\n   * Set a handler to be called when received a responce from the\n   * remote site reporting that the previously provided interface\n   * has been successfully set as remote for that site\n   *\n   * @param {Function} handler\n   */\n\n\n  getRemoteCallStack() {\n    return this._method_refs.getStack();\n  }\n  /**\n   * @returns {Object} set of remote interface methods\n   */\n\n\n  getRemote() {\n    return this._remote_interface;\n  }\n  /**\n   * Sets the interface of this site making it available to the\n   * remote site by sending a message with a set of methods names\n   *\n   * @param {Object} _interface to set\n   */\n\n\n  setInterface(_interface, config) {\n    config = config || {};\n    this.config.name = config.name || this.config.name;\n    this.config.description = config.description || this.config.description;\n\n    if (this.config.forwarding_functions) {\n      for (let func_name of this.config.forwarding_functions) {\n        const _remote = this._remote_interface;\n\n        if (_remote[func_name]) {\n          if (_interface.constructor === Object) {\n            if (!_interface[func_name]) {\n              _interface[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          } else if (_interface.constructor.constructor === Function) {\n            if (!_interface.constructor.prototype[func_name]) {\n              _interface.constructor.prototype[func_name] = (...args) => {\n                _remote[func_name](...args);\n              };\n            }\n          }\n        }\n      }\n    }\n\n    this._local_api = _interface;\n    if (!this._remote_set) this._fire(\"interfaceAvailable\");else this.sendInterface();\n    return new Promise(resolve => {\n      this.once(\"interfaceSetAsRemote\", resolve);\n    });\n  }\n  /**\n   * Sends the actual interface to the remote site upon it was\n   * updated or by a special request of the remote site\n   */\n\n\n  sendInterface() {\n    if (!this._local_api) {\n      throw new Error(\"interface is not set.\");\n    }\n\n    this._encode(this._local_api, true).then(api => {\n      this._connection.emit({\n        type: \"setInterface\",\n        api: api\n      });\n    });\n  }\n\n  _disposeObject(objectId) {\n    if (this._object_store[objectId]) {\n      delete this._object_store[objectId];\n    } else {\n      throw new Error(`Object (id=${objectId}) not found.`);\n    }\n  }\n\n  disposeObject(obj) {\n    return new Promise((resolve, reject) => {\n      if (this._object_weakmap.has(obj)) {\n        const objectId = this._object_weakmap.get(obj);\n\n        this._connection.once(\"disposed\", data => {\n          if (data.error) reject(new Error(data.error));else resolve();\n        });\n\n        this._connection.emit({\n          type: \"disposeObject\",\n          object_id: objectId\n        });\n      } else {\n        throw new Error(\"Invalid object\");\n      }\n    });\n  }\n  /**\n   * Handles a message from the remote site\n   */\n\n\n  _setupMessageHanlders() {\n    this._connection.on(\"init\", this.init);\n\n    this._connection.on(\"execute\", data => {\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\n        this._connection.emit({\n          type: \"executed\"\n        });\n      }).catch(e => {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"executed\",\n          error: String(e)\n        });\n      });\n    });\n\n    this._connection.on(\"method\", async data => {\n      let resolve, reject, method, method_this, args, result;\n\n      try {\n        if (data.promise) {\n          [resolve, reject] = await this._unwrap(data.promise, false);\n        }\n\n        const _interface = this._object_store[data.object_id];\n        method = indexObject(_interface, data.name);\n\n        if (data.name.includes(\".\")) {\n          const tmp = data.name.split(\".\");\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\n          method_this = indexObject(_interface, intf_index);\n        } else {\n          method_this = _interface;\n        }\n\n        args = await this._unwrap(data.args, true);\n\n        if (data.promise) {\n          result = method.apply(method_this, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } else {\n          method.apply(method_this, args);\n        }\n      } catch (err) {\n        console.error(this.config.name, err);\n\n        if (reject) {\n          reject(err);\n        }\n      }\n    });\n\n    this._connection.on(\"callback\", async data => {\n      let resolve, reject, method, args, result;\n\n      try {\n        if (data.promise) {\n          [resolve, reject] = await this._unwrap(data.promise, false);\n        }\n\n        if (data.promise) {\n          method = this._store.fetch(data.id);\n          args = await this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          result = method.apply(null, args);\n\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n            result.then(resolve).catch(reject);\n          } else {\n            resolve(result);\n          }\n        } else {\n          method = this._store.fetch(data.id);\n          args = await this._unwrap(data.args, true);\n\n          if (!method) {\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n          }\n\n          method.apply(null, args);\n        }\n      } catch (err) {\n        console.error(this.config.name, err);\n\n        if (reject) {\n          reject(err);\n        }\n      }\n    });\n\n    this._connection.on(\"disposeObject\", data => {\n      try {\n        this._disposeObject(data.object_id);\n\n        this._connection.emit({\n          type: \"disposed\"\n        });\n      } catch (e) {\n        console.error(e);\n\n        this._connection.emit({\n          type: \"disposed\",\n          error: String(e)\n        });\n      }\n    });\n\n    this._connection.on(\"setInterface\", data => {\n      this._setRemoteInterface(data.api);\n    });\n\n    this._connection.on(\"getInterface\", () => {\n      this._fire(\"getInterface\");\n\n      if (this._local_api) {\n        this.sendInterface();\n      } else {\n        this.once(\"interfaceAvailable\", () => {\n          this.sendInterface();\n        });\n      }\n    });\n\n    this._connection.on(\"interfaceSetAsRemote\", () => {\n      this._remote_set = true;\n\n      this._fire(\"interfaceSetAsRemote\");\n    });\n\n    this._connection.on(\"disconnect\", () => {\n      this._fire(\"beforeDisconnect\");\n\n      this._connection.disconnect();\n\n      this._fire(\"disconnected\");\n    });\n  }\n  /**\n   * Sends a requests to the remote site asking it to provide its\n   * current interface\n   */\n\n\n  requestRemote() {\n    this._connection.emit({\n      type: \"getInterface\"\n    });\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n\n    if (dtype && dtype !== _dtype) {\n      throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n    }\n\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype\n    };\n  }\n  /**\n   * Sets the new remote interface provided by the other site\n   *\n   * @param {Array} names list of function names\n   */\n\n\n  _setRemoteInterface(api) {\n    this._decode(api).then(intf => {\n      // update existing interface instead of recreating it\n      // this will preserve the object reference\n      if (this._remote_interface) {\n        // clear the interface\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\n\n\n        Object.assign(this._remote_interface, intf);\n      } else this._remote_interface = intf;\n\n      this._fire(\"remoteReady\");\n\n      this._reportRemoteSet();\n    });\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * method. When the generated function is called, it will send the\n   * corresponding message to the remote site asking it to execute\n   * the particular method of its interface\n   *\n   * @param {String} name of the remote method\n   *\n   * @returns {Function} wrapped remote method\n   */\n\n\n  _genRemoteMethod(targetId, name, objectId) {\n    const me = this;\n\n    const remoteMethod = function () {\n      return new Promise(async (resolve, reject) => {\n        let id = null;\n\n        try {\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n\n          const wrapped_resolve = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return resolve.apply(this, arguments);\n          };\n\n          const wrapped_reject = function () {\n            if (id !== null) me._method_refs.fetch(id);\n            return reject.apply(this, arguments);\n          };\n\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\n\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n          let args = Array.prototype.slice.call(arguments);\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\n\n          if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\n            args = await me._wrap(args, true);\n          } else {\n            args = await me._wrap(args);\n          }\n\n          const transferables = args.__transferables__;\n          if (transferables) delete args.__transferables__;\n\n          me._connection.emit({\n            type: \"method\",\n            target_id: targetId,\n            name: name,\n            object_id: objectId,\n            args: args,\n            promise: encodedPromise,\n            with_kwargs: withKwargs\n          }, transferables);\n        } catch (e) {\n          if (id) me._method_refs.fetch(id);\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n        }\n      });\n    };\n\n    remoteMethod.__remote_method = true;\n    return remoteMethod;\n  }\n  /**\n   * Sends a responce reporting that interface just provided by the\n   * remote site was successfully set by this site as remote\n   */\n\n\n  _reportRemoteSet() {\n    this._connection.emit({\n      type: \"interfaceSetAsRemote\"\n    });\n  }\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n\n\n  async _encode(aObject, asInterface, objectId) {\n    const aType = typeof aObject;\n\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (typeof aObject === \"function\") {\n      if (asInterface) {\n        if (!objectId) throw new Error(\"objectId is not specified.\");\n        bObject = {\n          _rtype: \"interface\",\n          _rtarget_id: this._connection.peer_id,\n          _rintf: objectId,\n          _rvalue: asInterface\n        };\n\n        this._method_weakmap.set(aObject, bObject);\n      } else if (this._method_weakmap.has(aObject)) {\n        bObject = this._method_weakmap.get(aObject);\n      } else {\n        const cid = this._store.put(aObject);\n\n        bObject = {\n          _rtype: \"callback\",\n          _rtarget_id: this._connection.peer_id,\n          _rname: aObject.constructor && aObject.constructor.name || cid,\n          _rvalue: cid\n        };\n      }\n\n      return bObject;\n    } // skip if already encoded\n\n\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      if (aObject._rintf) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._encode(aObject, asInterface, objectId);\n        bObject._rtype = temp;\n      } else {\n        bObject = aObject;\n      }\n\n      return bObject;\n    }\n\n    const transferables = [];\n    const _transfer = aObject._transfer;\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\n\n        if (encodedObj && encodedObj._rintf) {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\n          encodedObj._rtype = temp;\n        }\n\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n    /*global tf*/\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\n      const v_buffer = aObject.dataSync();\n\n      if (aObject._transfer || _transfer) {\n        transferables.push(v_buffer.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: v_buffer.buffer,\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype\n      };\n    } else if (\n    /*global nj*/\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.selection.data.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: aObject.selection.data.buffer,\n        _rshape: aObject.shape,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString()\n      };\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n      bObject = {\n        _rtype: \"file\",\n        _rvalue: aObject,\n        _rpath: aObject._path || aObject.webkitRelativePath\n      };\n    } // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n      bObject = {\n        _rtype: \"file\",\n        _rname: aObject.name,\n        _rmime: aObject.type,\n        _rvalue: aObject,\n        _rpath: aObject._path || aObject.webkitRelativePath\n      };\n    } else if (aObject instanceof Blob) {\n      bObject = {\n        _rtype: \"blob\",\n        _rvalue: aObject\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.buffer);\n        delete aObject._transfer;\n      }\n\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: aObject.buffer,\n        _rdtype: dtype\n      };\n    } else if (aObject instanceof DataView) {\n      if (aObject._transfer || _transfer) {\n        transferables.push(aObject.buffer);\n        delete aObject._transfer;\n      }\n\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: aObject.buffer\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\n      };\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n      bObject = isarray ? [] : {};\n      let keys; // an object/array\n\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\n        keys = Object.keys(aObject);\n      } // a class\n      else if (aObject.constructor === Function) {\n        throw new Error(\"Please instantiate the class before exportting it.\");\n      } // instance of a class\n      else if (aObject.constructor.constructor === Function) {\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\n        // always encode class instance as interface\n\n        asInterface = true;\n      } else {\n        throw Error(\"Unsupported interface type\");\n      }\n\n      let hasFunction = false; // encode interfaces\n\n      if (aObject._rintf || asInterface) {\n        if (!objectId) {\n          if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\n            objectId = aObject._rintf; // enable custom object id\n          } else {\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n          } // Note: object with the same id will be overwritten\n\n\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\n          this._object_store[objectId] = aObject;\n        }\n\n        for (let k of keys) {\n          if (k === \"constructor\") continue;\n\n          if (k.startsWith(\"_\")) {\n            continue;\n          }\n\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n\n          if (typeof aObject[k] === \"function\") {\n            hasFunction = true;\n          }\n        } // object id for dispose the object remotely\n\n\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\n\n        if (aObject.on && typeof aObject.on === \"function\") {\n          aObject.on(\"close\", () => {\n            delete this._object_store[objectId];\n          });\n        }\n      } else {\n        for (let k of keys) {\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\n          bObject[k] = await this._encode(aObject[k]);\n        }\n      } // for example, browserFS object\n\n    } else if (typeof aObject === \"object\") {\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n\n      for (let k of keys) {\n        if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\n\n        bObject[k] = await this._encode(aObject[k], k, bObject);\n      } // object id, used for dispose the object\n\n\n      bObject._rintf = objectId;\n    } else {\n      throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n    }\n\n    if (transferables.length > 0) {\n      bObject.__transferables__ = transferables;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n\n    return bObject;\n  }\n\n  async _decode(aObject, withPromise) {\n    if (!aObject) {\n      return aObject;\n    }\n\n    let bObject;\n\n    if (aObject[\"_rtype\"]) {\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n        if (aObject._rintf) {\n          const temp = aObject._rtype;\n          delete aObject._rtype;\n          aObject = await this._decode(aObject, withPromise);\n          aObject._rtype = temp;\n        }\n\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n      } else if (aObject._rtype === \"callback\") {\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n      } else if (aObject._rtype === \"interface\") {\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(aObject._rvalue);\n      } else if (aObject._rtype === \"file\") {\n        if (aObject._rvalue instanceof File) {\n          bObject = aObject._rvalue; //patch _path\n\n          bObject._path = aObject._rpath;\n        } else {\n          bObject = new File([aObject._rvalue], aObject._rname, {\n            type: aObject._rmime\n          });\n          bObject._path = aObject._rpath;\n        }\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n        bObject = new arraytype(aObject._rvalue);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = new DataView(aObject._rvalue);\n      } else if (aObject._rtype === \"blob\") {\n        if (aObject._rvalue instanceof Blob) {\n          bObject = aObject._rvalue;\n        } else {\n          bObject = new Blob([aObject._rvalue], {\n            type: aObject._rmime\n          });\n        }\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\n      } else {\n        // make sure all the interface functions are decoded\n        if (aObject._rintf) {\n          const temp = aObject._rtype;\n          delete aObject._rtype;\n          bObject = await this._decode(aObject, withPromise);\n          bObject._rtype = temp;\n        } else bObject = aObject;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(v, withPromise);\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    } // store the object id for dispose\n\n\n    if (aObject._rintf) {\n      this._object_weakmap.set(bObject, aObject._rintf);\n    }\n\n    return bObject;\n  }\n\n  async _wrap(args, asInterface) {\n    return await this._encode(args, asInterface);\n  }\n  /**\n   * Unwraps the set of arguments delivered from the remote site,\n   * replaces all callback identifiers with a function which will\n   * initiate sending that callback identifier back to other site\n   *\n   * @param {Object} args to unwrap\n   *\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Array} unwrapped args\n   */\n\n\n  async _unwrap(args, withPromise) {\n    return await this._decode(args, withPromise);\n  }\n  /**\n   * Generates the wrapped function corresponding to a single remote\n   * callback. When the generated function is called, it will send\n   * the corresponding message to the remote site asking it to\n   * execute the particular callback previously saved during a call\n   * by the remote site a method from the interface of this site\n   *\n   * @param {Number} id of the remote callback to execute\n   * @param {Number} argNum argument index of the callback\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\n   *\n   * @returns {Function} wrapped remote callback\n   */\n\n\n  _genRemoteCallback(targetId, cid, withPromise) {\n    const me = this;\n    let remoteCallback;\n\n    if (withPromise) {\n      remoteCallback = function () {\n        return new Promise(async (resolve, reject) => {\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\n          const transferables = args.__transferables__;\n          if (transferables) delete args.__transferables__;\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\n\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\n          reject.__promise_pair = encodedPromise[0]._rvalue;\n\n          try {\n            me._connection.emit({\n              type: \"callback\",\n              target_id: targetId,\n              id: cid,\n              args: args,\n              promise: encodedPromise,\n              with_kwargs: withKwargs\n            }, transferables);\n          } catch (e) {\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\n          }\n        });\n      };\n\n      return remoteCallback;\n    } else {\n      remoteCallback = async function () {\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\n\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n        const transferables = args.__transferables__;\n        if (transferables) delete args.__transferables__;\n        return me._connection.emit({\n          type: \"callback\",\n          target_id: targetId,\n          id: cid,\n          args: args,\n          with_kwargs: withKwargs\n        }, transferables);\n      };\n\n      return remoteCallback;\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._remote_interface = null;\n    this._object_store = {};\n    this._method_weakmap = new WeakMap();\n    this._object_weakmap = new WeakMap();\n    this._local_api = null;\n    this._store = new ReferenceStore();\n    this._method_refs = new ReferenceStore();\n  }\n  /**\n   * Sends the notification message and breaks the connection\n   */\n\n\n  disconnect() {\n    this._connection.emit({\n      type: \"disconnect\"\n    });\n\n    this.reset();\n    setTimeout(() => {\n      this._connection.disconnect();\n    }, 2000);\n  }\n\n}\n/**\n * ReferenceStore is a special object which stores other objects\n * and provides the references (number) instead. This reference\n * may then be sent over a json-based communication channel (IPC\n * to another Node.js process or a message to the Worker). Other\n * site may then provide the reference in the responce message\n * implying the given object should be activated.\n *\n * Primary usage for the ReferenceStore is a storage for the\n * callbacks, which therefore makes it possible to initiate a\n * callback execution by the opposite site (which normally cannot\n * directly execute functions over the communication channel).\n *\n * Each stored object can only be fetched once and is not\n * available for the second time. Each stored object must be\n * fetched, since otherwise it will remain stored forever and\n * consume memory.\n *\n * Stored object indeces are simply the numbers, which are however\n * released along with the objects, and are later reused again (in\n * order to postpone the overflow, which should not likely happen,\n * but anyway).\n */\n\nclass ReferenceStore {\n  constructor() {\n    this._store = {}; // stored object\n\n    this._indices = [0]; // smallest available indices\n\n    this._readyHandler = function () {};\n\n    this._busyHandler = function () {};\n\n    this._readyHandler();\n  }\n  /**\n   * call handler when the store is empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onReady(readyHandler) {\n    this._readyHandler = readyHandler || function () {};\n  }\n  /**\n   * call handler when the store is not empty\n   *\n   * @param {FUNCTION} id of a handler\n   */\n\n\n  onBusy(busyHandler) {\n    this._busyHandler = busyHandler || function () {};\n  }\n  /**\n   * get the length of the store\n   *\n   */\n\n\n  getStack() {\n    return Object.keys(this._store).length;\n  }\n  /**\n   * @function _genId() generates the new reference id\n   *\n   * @returns {Number} smallest available id and reserves it\n   */\n\n\n  _genId() {\n    let id;\n\n    if (this._indices.length === 1) {\n      id = this._indices[0]++;\n    } else {\n      id = this._indices.shift();\n    }\n\n    return id;\n  }\n  /**\n   * Releases the given reference id so that it will be available by\n   * another object stored\n   *\n   * @param {Number} id to release\n   */\n\n\n  _releaseId(id) {\n    for (let i = 0; i < this._indices.length; i++) {\n      if (id < this._indices[i]) {\n        this._indices.splice(i, 0, id);\n\n        break;\n      }\n    } // cleaning-up the sequence tail\n\n\n    for (let i = this._indices.length - 1; i >= 0; i--) {\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\n        this._indices.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Stores the given object and returns the refernce id instead\n   *\n   * @param {Object} obj to store\n   *\n   * @returns {Number} reference id of the stored object\n   */\n\n\n  put(obj) {\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\n      this._busyHandler();\n    }\n\n    const id = this._genId();\n\n    this._store[id] = obj;\n    return id;\n  }\n  /**\n   * Retrieves previously stored object and releases its reference\n   *\n   * @param {Number} id of an object to retrieve\n   */\n\n\n  fetch(id) {\n    const obj = this._store[id];\n\n    if (obj && !obj.__remote_method) {\n      delete this._store[id];\n\n      this._releaseId(id);\n\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\n        this._readyHandler();\n      }\n    }\n\n    if (obj && obj.__promise_pair) {\n      this.fetch(obj.__promise_pair);\n    }\n\n    return obj;\n  }\n\n}\n\n/***/ }),\n\n/***/ \"./src/utils.js\":\n/*!**********************!*\\\n  !*** ./src/utils.js ***!\n  \\**********************/\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_123819__) {\n\n\"use strict\";\n__nested_webpack_require_123819__.r(__nested_webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"randId\", function() { return randId; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"urlJoin\", function() { return urlJoin; });\n/* harmony export (binding) */ __nested_webpack_require_123819__.d(__nested_webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array\n};\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  } // support importScripts outside web worker\n\n\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n        len = args.length,\n        i = 0;\n\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      var link_node;\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n\n            await import(\n            /* webpackIgnore: true */\n            requirements[i]);\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nasync function loadRequirementsInWebworker(requirements) {\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n\n      for (var i = 0; i < requirements.length; i++) {\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n          throw \"unable to import css in a webworker\";\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\nfunction loadRequirements(requirements) {\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false; // remove functions\n\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\"\n};\nconst typedArrayToDtypeKeys = [];\n\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url\n    };\n\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n\n    const messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n    await cacheUrlInServiceWorker(req).catch(e => {\n      console.error(e);\n    });\n  }\n}\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n  // register service worker for offline access\n  if (\"serviceWorker\" in navigator) {\n    baseUrl = baseUrl || \"/\";\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\n      // Registration was successful\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n    }, function (err) {\n      // registration failed :(\n      console.log(\"ServiceWorker registration failed: \", err);\n    });\n    targetOrigin = targetOrigin || \"*\";\n    cacheCallback = cacheCallback || cacheRequirements;\n\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\n      throw new Error(\"config.cache_requirements must be a function\");\n    }\n\n    window.addEventListener(\"message\", function (e) {\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n        const m = e.data;\n\n        if (m.type === \"cacheRequirements\") {\n          cacheCallback(m.requirements);\n        }\n      }\n    });\n  }\n} //#Source https://bit.ly/2neWfJ2\n\nfunction urlJoin(...args) {\n  return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n\n    this._event_handlers[event].push(handler);\n  }\n\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n}\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=imjoy-rpc.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/imjoy-rpc/dist/imjoy-rpc.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/imjoy-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { imjoyRPC: __webpack_require__(/*! ./dist/imjoy-rpc.js */ \"./node_modules/imjoy-rpc/dist/imjoy-rpc.js\"), imjoyRPCSocketIO: __webpack_require__(/*! ./dist/imjoy-rpc-socketio.js */ \"./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js\"), hyphaRPC: __webpack_require__(/*! ./dist/hypha-rpc.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc.js\"), hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js\"), hyphaSSEClient: __webpack_require__(/*! ./dist/hypha-rpc-sse.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js\") };\n\n//# sourceURL=webpack://HyphaCore/./node_modules/imjoy-rpc/index.js?");

/***/ }),

/***/ "./node_modules/mock-socket/dist/mock-socket.js":
/*!******************************************************!*\
  !*** ./node_modules/mock-socket/dist/mock-socket.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nvar requiresPort = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) { return false; }\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\nvar has = Object.prototype.hasOwnProperty;\nvar undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) { continue; }\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) { prefix = '?'; }\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) { continue; }\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nvar stringify = querystringify;\nvar parse = querystring;\n\nvar querystringify_1 = {\n\tstringify: stringify,\n\tparse: parse\n};\n\nvar CRHTLF = /[\\n\\r\\t]/g;\nvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\nvar protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i;\nvar windowsDriveLetter = /^[a-zA-Z]:/;\nvar whitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(whitespace, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') { globalVar = window; }\n  else if (typeof commonjsGlobal !== 'undefined') { globalVar = commonjsGlobal; }\n  else if (typeof self !== 'undefined') { globalVar = self; }\n  else { globalVar = {}; }\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) { delete finaldestination[key]; }\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) { continue; }\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4];\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') { return base; }\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) { unshift = true; }\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) { path.unshift(''); }\n  if (last === '.' || last === '..') { path.push(''); }\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) { parser = querystringify_1.parse; }\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@'\n        ? address.lastIndexOf(parse)\n        : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) { url[key] = url[key].toLowerCase(); }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) { url.query = parser(url.query); }\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!requiresPort(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password));\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username +':'+ url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || querystringify_1.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!requiresPort(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) { value += ':'+ url.port; }\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) { url[ins[1]] = url[ins[1]].toLowerCase(); }\n  }\n\n  url.auth = url.password ? url.username +':'+ url.password : url.username;\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) { stringify = querystringify_1.stringify; }\n\n  var query\n    , url = this\n    , host = url.host\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') { protocol += ':'; }\n\n  var result =\n    protocol +\n    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) { result += ':'+ url.password; }\n    result += '@';\n  } else if (url.password) {\n    result += ':'+ url.password;\n    result += '@';\n  } else if (\n    url.protocol !== 'file:' &&\n    isSpecial(url.protocol) &&\n    !host &&\n    url.pathname !== '/'\n  ) {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  }\n\n  //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n  if (host[host.length - 1] === ':') { host += ':'; }\n  result += host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) { result += '?' !== query.charAt(0) ? '?'+ query : query; }\n\n  if (url.hash) { result += url.hash; }\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = querystringify_1;\n\nvar urlParse = Url;\n\n/*\n * This delay allows the thread to finish assigning its on* methods\n * before invoking the delay callback. This is purely a timing hack.\n * http://geekabyte.blogspot.com/2014/01/javascript-effect-of-setting-settimeout.html\n *\n * @param {callback: function} the callback which will be invoked after the timeout\n * @parma {context: object} the context in which to invoke the function\n */\nfunction delay(callback, context) {\n  setTimeout(function (timeoutContext) { return callback.call(timeoutContext); }, 4, context);\n}\n\nfunction log(method, message) {\n  /* eslint-disable no-console */\n  if (typeof process !== 'undefined' && \"development\" !== 'test') {\n    console[method].call(null, message);\n  }\n  /* eslint-enable no-console */\n}\n\nfunction reject(array, callback) {\n  if ( array === void 0 ) array = [];\n\n  var results = [];\n  array.forEach(function (itemInArray) {\n    if (!callback(itemInArray)) {\n      results.push(itemInArray);\n    }\n  });\n\n  return results;\n}\n\nfunction filter(array, callback) {\n  if ( array === void 0 ) array = [];\n\n  var results = [];\n  array.forEach(function (itemInArray) {\n    if (callback(itemInArray)) {\n      results.push(itemInArray);\n    }\n  });\n\n  return results;\n}\n\n/*\n * EventTarget is an interface implemented by objects that can\n * receive events and may have listeners for them.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n */\nvar EventTarget = function EventTarget() {\n  this.listeners = {};\n};\n\n/*\n * Ties a listener function to an event type which can later be invoked via the\n * dispatchEvent method.\n *\n * @param {string} type - the type of event (ie: 'open', 'message', etc.)\n * @param {function} listener - callback function to invoke when an event is dispatched matching the type\n * @param {boolean} useCapture - N/A TODO: implement useCapture functionality\n */\nEventTarget.prototype.addEventListener = function addEventListener (type, listener /* , useCapture */) {\n  if (typeof listener === 'function') {\n    if (!Array.isArray(this.listeners[type])) {\n      this.listeners[type] = [];\n    }\n\n    // Only add the same function once\n    if (filter(this.listeners[type], function (item) { return item === listener; }).length === 0) {\n      this.listeners[type].push(listener);\n    }\n  }\n};\n\n/*\n * Removes the listener so it will no longer be invoked via the dispatchEvent method.\n *\n * @param {string} type - the type of event (ie: 'open', 'message', etc.)\n * @param {function} listener - callback function to invoke when an event is dispatched matching the type\n * @param {boolean} useCapture - N/A TODO: implement useCapture functionality\n */\nEventTarget.prototype.removeEventListener = function removeEventListener (type, removingListener /* , useCapture */) {\n  var arrayOfListeners = this.listeners[type];\n  this.listeners[type] = reject(arrayOfListeners, function (listener) { return listener === removingListener; });\n};\n\n/*\n * Invokes all listener functions that are listening to the given event.type property. Each\n * listener will be passed the event as the first argument.\n *\n * @param {object} event - event object which will be passed to all listeners of the event.type property\n */\nEventTarget.prototype.dispatchEvent = function dispatchEvent (event) {\n    var this$1 = this;\n    var customArguments = [], len = arguments.length - 1;\n    while ( len-- > 0 ) customArguments[ len ] = arguments[ len + 1 ];\n\n  var eventName = event.type;\n  var listeners = this.listeners[eventName];\n\n  if (!Array.isArray(listeners)) {\n    return false;\n  }\n\n  listeners.forEach(function (listener) {\n    if (customArguments.length > 0) {\n      listener.apply(this$1, customArguments);\n    } else {\n      listener.call(this$1, event);\n    }\n  });\n\n  return true;\n};\n\nfunction trimQueryPartFromURL(url) {\n  var queryIndex = url.indexOf('?');\n  return queryIndex >= 0 ? url.slice(0, queryIndex) : url;\n}\n\n/*\n * The network bridge is a way for the mock websocket object to 'communicate' with\n * all available servers. This is a singleton object so it is important that you\n * clean up urlMap whenever you are finished.\n */\nvar NetworkBridge = function NetworkBridge() {\n  this.urlMap = {};\n};\n\n/*\n * Attaches a websocket object to the urlMap hash so that it can find the server\n * it is connected to and the server in turn can find it.\n *\n * @param {object} websocket - websocket object to add to the urlMap hash\n * @param {string} url\n */\nNetworkBridge.prototype.attachWebSocket = function attachWebSocket (websocket, url) {\n  var serverURL = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverURL];\n\n  if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) === -1) {\n    connectionLookup.websockets.push(websocket);\n    return connectionLookup.server;\n  }\n};\n\n/*\n * Attaches a websocket to a room\n */\nNetworkBridge.prototype.addMembershipToRoom = function addMembershipToRoom (websocket, room) {\n  var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n\n  if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) !== -1) {\n    if (!connectionLookup.roomMemberships[room]) {\n      connectionLookup.roomMemberships[room] = [];\n    }\n\n    connectionLookup.roomMemberships[room].push(websocket);\n  }\n};\n\n/*\n * Attaches a server object to the urlMap hash so that it can find a websockets\n * which are connected to it and so that websockets can in turn can find it.\n *\n * @param {object} server - server object to add to the urlMap hash\n * @param {string} url\n */\nNetworkBridge.prototype.attachServer = function attachServer (server, url) {\n  var serverUrl = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverUrl];\n\n  if (!connectionLookup) {\n    this.urlMap[serverUrl] = {\n      server: server,\n      websockets: [],\n      roomMemberships: {}\n    };\n\n    return server;\n  }\n};\n\n/*\n * Finds the server which is 'running' on the given url.\n *\n * @param {string} url - the url to use to find which server is running on it\n */\nNetworkBridge.prototype.serverLookup = function serverLookup (url) {\n  var serverURL = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverURL];\n\n  if (connectionLookup) {\n    return connectionLookup.server;\n  }\n};\n\n/*\n * Finds all websockets which is 'listening' on the given url.\n *\n * @param {string} url - the url to use to find all websockets which are associated with it\n * @param {string} room - if a room is provided, will only return sockets in this room\n * @param {class} broadcaster - socket that is broadcasting and is to be excluded from the lookup\n */\nNetworkBridge.prototype.websocketsLookup = function websocketsLookup (url, room, broadcaster) {\n  var serverURL = trimQueryPartFromURL(url);\n  var websockets;\n  var connectionLookup = this.urlMap[serverURL];\n\n  websockets = connectionLookup ? connectionLookup.websockets : [];\n\n  if (room) {\n    var members = connectionLookup.roomMemberships[room];\n    websockets = members || [];\n  }\n\n  return broadcaster ? websockets.filter(function (websocket) { return websocket !== broadcaster; }) : websockets;\n};\n\n/*\n * Removes the entry associated with the url.\n *\n * @param {string} url\n */\nNetworkBridge.prototype.removeServer = function removeServer (url) {\n  delete this.urlMap[trimQueryPartFromURL(url)];\n};\n\n/*\n * Removes the individual websocket from the map of associated websockets.\n *\n * @param {object} websocket - websocket object to remove from the url map\n * @param {string} url\n */\nNetworkBridge.prototype.removeWebSocket = function removeWebSocket (websocket, url) {\n  var serverURL = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverURL];\n\n  if (connectionLookup) {\n    connectionLookup.websockets = reject(connectionLookup.websockets, function (socket) { return socket === websocket; });\n  }\n};\n\n/*\n * Removes a websocket from a room\n */\nNetworkBridge.prototype.removeMembershipFromRoom = function removeMembershipFromRoom (websocket, room) {\n  var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n  var memberships = connectionLookup.roomMemberships[room];\n\n  if (connectionLookup && memberships !== null) {\n    connectionLookup.roomMemberships[room] = reject(memberships, function (socket) { return socket === websocket; });\n  }\n};\n\nvar networkBridge = new NetworkBridge(); // Note: this is a singleton\n\n/*\n * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n */\nvar CLOSE_CODES = {\n  CLOSE_NORMAL: 1000,\n  CLOSE_GOING_AWAY: 1001,\n  CLOSE_PROTOCOL_ERROR: 1002,\n  CLOSE_UNSUPPORTED: 1003,\n  CLOSE_NO_STATUS: 1005,\n  CLOSE_ABNORMAL: 1006,\n  UNSUPPORTED_DATA: 1007,\n  POLICY_VIOLATION: 1008,\n  CLOSE_TOO_LARGE: 1009,\n  MISSING_EXTENSION: 1010,\n  INTERNAL_ERROR: 1011,\n  SERVICE_RESTART: 1012,\n  TRY_AGAIN_LATER: 1013,\n  TLS_HANDSHAKE: 1015\n};\n\nvar ERROR_PREFIX = {\n  CONSTRUCTOR_ERROR: \"Failed to construct 'WebSocket':\",\n  CLOSE_ERROR: \"Failed to execute 'close' on 'WebSocket':\",\n  EVENT: {\n    CONSTRUCT: \"Failed to construct 'Event':\",\n    MESSAGE: \"Failed to construct 'MessageEvent':\",\n    CLOSE: \"Failed to construct 'CloseEvent':\"\n  }\n};\n\nvar EventPrototype = function EventPrototype () {};\n\nEventPrototype.prototype.stopPropagation = function stopPropagation () {};\nEventPrototype.prototype.stopImmediatePropagation = function stopImmediatePropagation () {};\n\n// if no arguments are passed then the type is set to \"undefined\" on\n// chrome and safari.\nEventPrototype.prototype.initEvent = function initEvent (type, bubbles, cancelable) {\n    if ( type === void 0 ) type = 'undefined';\n    if ( bubbles === void 0 ) bubbles = false;\n    if ( cancelable === void 0 ) cancelable = false;\n\n  this.type = \"\" + type;\n  this.bubbles = Boolean(bubbles);\n  this.cancelable = Boolean(cancelable);\n};\n\nvar Event = (function (EventPrototype$$1) {\n  function Event(type, eventInitConfig) {\n    if ( eventInitConfig === void 0 ) eventInitConfig = {};\n\n    EventPrototype$$1.call(this);\n\n    if (!type) {\n      throw new TypeError(((ERROR_PREFIX.EVENT_ERROR) + \" 1 argument required, but only 0 present.\"));\n    }\n\n    if (typeof eventInitConfig !== 'object') {\n      throw new TypeError(((ERROR_PREFIX.EVENT_ERROR) + \" parameter 2 ('eventInitDict') is not an object.\"));\n    }\n\n    var bubbles = eventInitConfig.bubbles;\n    var cancelable = eventInitConfig.cancelable;\n\n    this.type = \"\" + type;\n    this.timeStamp = Date.now();\n    this.target = null;\n    this.srcElement = null;\n    this.returnValue = true;\n    this.isTrusted = false;\n    this.eventPhase = 0;\n    this.defaultPrevented = false;\n    this.currentTarget = null;\n    this.cancelable = cancelable ? Boolean(cancelable) : false;\n    this.cancelBubble = false;\n    this.bubbles = bubbles ? Boolean(bubbles) : false;\n  }\n\n  if ( EventPrototype$$1 ) Event.__proto__ = EventPrototype$$1;\n  Event.prototype = Object.create( EventPrototype$$1 && EventPrototype$$1.prototype );\n  Event.prototype.constructor = Event;\n\n  return Event;\n}(EventPrototype));\n\nvar MessageEvent = (function (EventPrototype$$1) {\n  function MessageEvent(type, eventInitConfig) {\n    if ( eventInitConfig === void 0 ) eventInitConfig = {};\n\n    EventPrototype$$1.call(this);\n\n    if (!type) {\n      throw new TypeError(((ERROR_PREFIX.EVENT.MESSAGE) + \" 1 argument required, but only 0 present.\"));\n    }\n\n    if (typeof eventInitConfig !== 'object') {\n      throw new TypeError(((ERROR_PREFIX.EVENT.MESSAGE) + \" parameter 2 ('eventInitDict') is not an object\"));\n    }\n\n    var bubbles = eventInitConfig.bubbles;\n    var cancelable = eventInitConfig.cancelable;\n    var data = eventInitConfig.data;\n    var origin = eventInitConfig.origin;\n    var lastEventId = eventInitConfig.lastEventId;\n    var ports = eventInitConfig.ports;\n\n    this.type = \"\" + type;\n    this.timeStamp = Date.now();\n    this.target = null;\n    this.srcElement = null;\n    this.returnValue = true;\n    this.isTrusted = false;\n    this.eventPhase = 0;\n    this.defaultPrevented = false;\n    this.currentTarget = null;\n    this.cancelable = cancelable ? Boolean(cancelable) : false;\n    this.canncelBubble = false;\n    this.bubbles = bubbles ? Boolean(bubbles) : false;\n    this.origin = \"\" + origin;\n    this.ports = typeof ports === 'undefined' ? null : ports;\n    this.data = typeof data === 'undefined' ? null : data;\n    this.lastEventId = \"\" + (lastEventId || '');\n  }\n\n  if ( EventPrototype$$1 ) MessageEvent.__proto__ = EventPrototype$$1;\n  MessageEvent.prototype = Object.create( EventPrototype$$1 && EventPrototype$$1.prototype );\n  MessageEvent.prototype.constructor = MessageEvent;\n\n  return MessageEvent;\n}(EventPrototype));\n\nvar CloseEvent = (function (EventPrototype$$1) {\n  function CloseEvent(type, eventInitConfig) {\n    if ( eventInitConfig === void 0 ) eventInitConfig = {};\n\n    EventPrototype$$1.call(this);\n\n    if (!type) {\n      throw new TypeError(((ERROR_PREFIX.EVENT.CLOSE) + \" 1 argument required, but only 0 present.\"));\n    }\n\n    if (typeof eventInitConfig !== 'object') {\n      throw new TypeError(((ERROR_PREFIX.EVENT.CLOSE) + \" parameter 2 ('eventInitDict') is not an object\"));\n    }\n\n    var bubbles = eventInitConfig.bubbles;\n    var cancelable = eventInitConfig.cancelable;\n    var code = eventInitConfig.code;\n    var reason = eventInitConfig.reason;\n    var wasClean = eventInitConfig.wasClean;\n\n    this.type = \"\" + type;\n    this.timeStamp = Date.now();\n    this.target = null;\n    this.srcElement = null;\n    this.returnValue = true;\n    this.isTrusted = false;\n    this.eventPhase = 0;\n    this.defaultPrevented = false;\n    this.currentTarget = null;\n    this.cancelable = cancelable ? Boolean(cancelable) : false;\n    this.cancelBubble = false;\n    this.bubbles = bubbles ? Boolean(bubbles) : false;\n    this.code = typeof code === 'number' ? parseInt(code, 10) : 0;\n    this.reason = \"\" + (reason || '');\n    this.wasClean = wasClean ? Boolean(wasClean) : false;\n  }\n\n  if ( EventPrototype$$1 ) CloseEvent.__proto__ = EventPrototype$$1;\n  CloseEvent.prototype = Object.create( EventPrototype$$1 && EventPrototype$$1.prototype );\n  CloseEvent.prototype.constructor = CloseEvent;\n\n  return CloseEvent;\n}(EventPrototype));\n\n/*\n * Creates an Event object and extends it to allow full modification of\n * its properties.\n *\n * @param {object} config - within config you will need to pass type and optionally target\n */\nfunction createEvent(config) {\n  var type = config.type;\n  var target = config.target;\n  var eventObject = new Event(type);\n\n  if (target) {\n    eventObject.target = target;\n    eventObject.srcElement = target;\n    eventObject.currentTarget = target;\n  }\n\n  return eventObject;\n}\n\n/*\n * Creates a MessageEvent object and extends it to allow full modification of\n * its properties.\n *\n * @param {object} config - within config: type, origin, data and optionally target\n */\nfunction createMessageEvent(config) {\n  var type = config.type;\n  var origin = config.origin;\n  var data = config.data;\n  var target = config.target;\n  var messageEvent = new MessageEvent(type, {\n    data: data,\n    origin: origin\n  });\n\n  if (target) {\n    messageEvent.target = target;\n    messageEvent.srcElement = target;\n    messageEvent.currentTarget = target;\n  }\n\n  return messageEvent;\n}\n\n/*\n * Creates a CloseEvent object and extends it to allow full modification of\n * its properties.\n *\n * @param {object} config - within config: type and optionally target, code, and reason\n */\nfunction createCloseEvent(config) {\n  var code = config.code;\n  var reason = config.reason;\n  var type = config.type;\n  var target = config.target;\n  var wasClean = config.wasClean;\n\n  if (!wasClean) {\n    wasClean = code === CLOSE_CODES.CLOSE_NORMAL || code === CLOSE_CODES.CLOSE_NO_STATUS;\n  }\n\n  var closeEvent = new CloseEvent(type, {\n    code: code,\n    reason: reason,\n    wasClean: wasClean\n  });\n\n  if (target) {\n    closeEvent.target = target;\n    closeEvent.srcElement = target;\n    closeEvent.currentTarget = target;\n  }\n\n  return closeEvent;\n}\n\nfunction closeWebSocketConnection(context, code, reason) {\n  context.readyState = WebSocket$1.CLOSING;\n\n  var server = networkBridge.serverLookup(context.url);\n  var closeEvent = createCloseEvent({\n    type: 'close',\n    target: context.target,\n    code: code,\n    reason: reason\n  });\n\n  delay(function () {\n    networkBridge.removeWebSocket(context, context.url);\n\n    context.readyState = WebSocket$1.CLOSED;\n    context.dispatchEvent(closeEvent);\n\n    if (server) {\n      server.dispatchEvent(closeEvent, server);\n    }\n  }, context);\n}\n\nfunction failWebSocketConnection(context, code, reason) {\n  context.readyState = WebSocket$1.CLOSING;\n\n  var server = networkBridge.serverLookup(context.url);\n  var closeEvent = createCloseEvent({\n    type: 'close',\n    target: context.target,\n    code: code,\n    reason: reason,\n    wasClean: false\n  });\n\n  var errorEvent = createEvent({\n    type: 'error',\n    target: context.target\n  });\n\n  delay(function () {\n    networkBridge.removeWebSocket(context, context.url);\n\n    context.readyState = WebSocket$1.CLOSED;\n    context.dispatchEvent(errorEvent);\n    context.dispatchEvent(closeEvent);\n\n    if (server) {\n      server.dispatchEvent(closeEvent, server);\n    }\n  }, context);\n}\n\nfunction normalizeSendData(data) {\n  if (Object.prototype.toString.call(data) !== '[object Blob]' && !(data instanceof ArrayBuffer)) {\n    data = String(data);\n  }\n\n  return data;\n}\n\nvar proxies = new WeakMap();\n\nfunction proxyFactory(target) {\n  if (proxies.has(target)) {\n    return proxies.get(target);\n  }\n\n  var proxy = new Proxy(target, {\n    get: function get(obj, prop) {\n      if (prop === 'close') {\n        return function close(options) {\n          if ( options === void 0 ) options = {};\n\n          var code = options.code || CLOSE_CODES.CLOSE_NORMAL;\n          var reason = options.reason || '';\n\n          closeWebSocketConnection(proxy, code, reason);\n        };\n      }\n\n      if (prop === 'send') {\n        return function send(data) {\n          data = normalizeSendData(data);\n\n          target.dispatchEvent(\n            createMessageEvent({\n              type: 'message',\n              data: data,\n              origin: this.url,\n              target: target\n            })\n          );\n        };\n      }\n\n      var toSocketName = function (type) { return (type === 'message' ? (\"server::\" + type) : type); };\n      if (prop === 'on') {\n        return function onWrapper(type, cb) {\n          target.addEventListener(toSocketName(type), cb);\n        };\n      }\n      if (prop === 'off') {\n        return function offWrapper(type, cb) {\n          target.removeEventListener(toSocketName(type), cb);\n        };\n      }\n\n      if (prop === 'target') {\n        return target;\n      }\n\n      return obj[prop];\n    }\n  });\n  proxies.set(target, proxy);\n\n  return proxy;\n}\n\nfunction lengthInUtf8Bytes(str) {\n  // Matches only the 10.. bytes that are non-initial characters in a multi-byte sequence.\n  var m = encodeURIComponent(str).match(/%[89ABab]/g);\n  return str.length + (m ? m.length : 0);\n}\n\nfunction urlVerification(url) {\n  var urlRecord = new urlParse(url);\n  var pathname = urlRecord.pathname;\n  var protocol = urlRecord.protocol;\n  var hash = urlRecord.hash;\n\n  if (!url) {\n    throw new TypeError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" 1 argument required, but only 0 present.\"));\n  }\n\n  if (!pathname) {\n    urlRecord.pathname = '/';\n  }\n\n  if (protocol === '') {\n    throw new SyntaxError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The URL '\" + (urlRecord.toString()) + \"' is invalid.\"));\n  }\n\n  if (protocol !== 'ws:' && protocol !== 'wss:') {\n    throw new SyntaxError(\n      ((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The URL's scheme must be either 'ws' or 'wss'. '\" + protocol + \"' is not allowed.\")\n    );\n  }\n\n  if (hash !== '') {\n    /* eslint-disable max-len */\n    throw new SyntaxError(\n      ((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The URL contains a fragment identifier ('\" + hash + \"'). Fragment identifiers are not allowed in WebSocket URLs.\")\n    );\n    /* eslint-enable max-len */\n  }\n\n  return urlRecord.toString();\n}\n\nfunction protocolVerification(protocols) {\n  if ( protocols === void 0 ) protocols = [];\n\n  if (!Array.isArray(protocols) && typeof protocols !== 'string') {\n    throw new SyntaxError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The subprotocol '\" + (protocols.toString()) + \"' is invalid.\"));\n  }\n\n  if (typeof protocols === 'string') {\n    protocols = [protocols];\n  }\n\n  var uniq = protocols\n    .map(function (p) { return ({ count: 1, protocol: p }); })\n    .reduce(function (a, b) {\n      a[b.protocol] = (a[b.protocol] || 0) + b.count;\n      return a;\n    }, {});\n\n  var duplicates = Object.keys(uniq).filter(function (a) { return uniq[a] > 1; });\n\n  if (duplicates.length > 0) {\n    throw new SyntaxError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The subprotocol '\" + (duplicates[0]) + \"' is duplicated.\"));\n  }\n\n  return protocols;\n}\n\n/*\n * The main websocket class which is designed to mimick the native WebSocket class as close\n * as possible.\n *\n * https://html.spec.whatwg.org/multipage/web-sockets.html\n */\nvar WebSocket$1 = (function (EventTarget$$1) {\n  function WebSocket(url, protocols) {\n    EventTarget$$1.call(this);\n\n    this._onopen = null;\n    this._onmessage = null;\n    this._onerror = null;\n    this._onclose = null;\n\n    this.url = urlVerification(url);\n    protocols = protocolVerification(protocols);\n    this.protocol = protocols[0] || '';\n\n    this.binaryType = 'blob';\n    this.readyState = WebSocket.CONNECTING;\n\n    var client = proxyFactory(this);\n    var server = networkBridge.attachWebSocket(client, this.url);\n\n    /*\n     * This delay is needed so that we dont trigger an event before the callbacks have been\n     * setup. For example:\n     *\n     * var socket = new WebSocket('ws://localhost');\n     *\n     * If we dont have the delay then the event would be triggered right here and this is\n     * before the onopen had a chance to register itself.\n     *\n     * socket.onopen = () => { // this would never be called };\n     *\n     * and with the delay the event gets triggered here after all of the callbacks have been\n     * registered :-)\n     */\n    delay(function delayCallback() {\n      if (this.readyState !== WebSocket.CONNECTING) {\n        return;\n      }\n      if (server) {\n        if (\n          server.options.verifyClient &&\n          typeof server.options.verifyClient === 'function' &&\n          !server.options.verifyClient()\n        ) {\n          this.readyState = WebSocket.CLOSED;\n\n          log(\n            'error',\n            (\"WebSocket connection to '\" + (this.url) + \"' failed: HTTP Authentication failed; no valid credentials available\")\n          );\n\n          networkBridge.removeWebSocket(client, this.url);\n          this.dispatchEvent(createEvent({ type: 'error', target: this }));\n          this.dispatchEvent(createCloseEvent({ type: 'close', target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n        } else {\n          if (server.options.selectProtocol && typeof server.options.selectProtocol === 'function') {\n            var selectedProtocol = server.options.selectProtocol(protocols);\n            var isFilled = selectedProtocol !== '';\n            var isRequested = protocols.indexOf(selectedProtocol) !== -1;\n            if (isFilled && !isRequested) {\n              this.readyState = WebSocket.CLOSED;\n\n              log('error', (\"WebSocket connection to '\" + (this.url) + \"' failed: Invalid Sub-Protocol\"));\n\n              networkBridge.removeWebSocket(client, this.url);\n              this.dispatchEvent(createEvent({ type: 'error', target: this }));\n              this.dispatchEvent(createCloseEvent({ type: 'close', target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n              return;\n            }\n            this.protocol = selectedProtocol;\n          }\n          this.readyState = WebSocket.OPEN;\n          this.dispatchEvent(createEvent({ type: 'open', target: this }));\n          server.dispatchEvent(createEvent({ type: 'connection' }), client);\n        }\n      } else {\n        this.readyState = WebSocket.CLOSED;\n        this.dispatchEvent(createEvent({ type: 'error', target: this }));\n        this.dispatchEvent(createCloseEvent({ type: 'close', target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n\n        log('error', (\"WebSocket connection to '\" + (this.url) + \"' failed\"));\n      }\n    }, this);\n  }\n\n  if ( EventTarget$$1 ) WebSocket.__proto__ = EventTarget$$1;\n  WebSocket.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );\n  WebSocket.prototype.constructor = WebSocket;\n\n  var prototypeAccessors = { onopen: {},onmessage: {},onclose: {},onerror: {} };\n\n  prototypeAccessors.onopen.get = function () {\n    return this._onopen;\n  };\n\n  prototypeAccessors.onmessage.get = function () {\n    return this._onmessage;\n  };\n\n  prototypeAccessors.onclose.get = function () {\n    return this._onclose;\n  };\n\n  prototypeAccessors.onerror.get = function () {\n    return this._onerror;\n  };\n\n  prototypeAccessors.onopen.set = function (listener) {\n    this.removeEventListener('open', this._onopen);\n    this._onopen = listener;\n    this.addEventListener('open', listener);\n  };\n\n  prototypeAccessors.onmessage.set = function (listener) {\n    this.removeEventListener('message', this._onmessage);\n    this._onmessage = listener;\n    this.addEventListener('message', listener);\n  };\n\n  prototypeAccessors.onclose.set = function (listener) {\n    this.removeEventListener('close', this._onclose);\n    this._onclose = listener;\n    this.addEventListener('close', listener);\n  };\n\n  prototypeAccessors.onerror.set = function (listener) {\n    this.removeEventListener('error', this._onerror);\n    this._onerror = listener;\n    this.addEventListener('error', listener);\n  };\n\n  WebSocket.prototype.send = function send (data) {\n    var this$1 = this;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      // TODO: node>=17 replace with DOMException\n      throw new Error(\"Failed to execute 'send' on 'WebSocket': Still in CONNECTING state\");\n    }\n\n    // TODO: handle bufferedAmount\n\n    var messageEvent = createMessageEvent({\n      type: 'server::message',\n      origin: this.url,\n      data: normalizeSendData(data)\n    });\n\n    var server = networkBridge.serverLookup(this.url);\n\n    if (server) {\n      delay(function () {\n        this$1.dispatchEvent(messageEvent, data);\n      }, server);\n    }\n  };\n\n  WebSocket.prototype.close = function close (code, reason) {\n    if (code !== undefined) {\n      if (typeof code !== 'number' || (code !== 1000 && (code < 3000 || code > 4999))) {\n        throw new TypeError(\n          ((ERROR_PREFIX.CLOSE_ERROR) + \" The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\")\n        );\n      }\n    }\n\n    if (reason !== undefined) {\n      var length = lengthInUtf8Bytes(reason);\n\n      if (length > 123) {\n        throw new SyntaxError(((ERROR_PREFIX.CLOSE_ERROR) + \" The message must not be greater than 123 bytes.\"));\n      }\n    }\n\n    if (this.readyState === WebSocket.CLOSING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n\n    var client = proxyFactory(this);\n    if (this.readyState === WebSocket.CONNECTING) {\n      failWebSocketConnection(client, code || CLOSE_CODES.CLOSE_ABNORMAL, reason);\n    } else {\n      closeWebSocketConnection(client, code || CLOSE_CODES.CLOSE_NO_STATUS, reason);\n    }\n  };\n\n  Object.defineProperties( WebSocket.prototype, prototypeAccessors );\n\n  return WebSocket;\n}(EventTarget));\n\nWebSocket$1.CONNECTING = 0;\nWebSocket$1.prototype.CONNECTING = WebSocket$1.CONNECTING;\nWebSocket$1.OPEN = 1;\nWebSocket$1.prototype.OPEN = WebSocket$1.OPEN;\nWebSocket$1.CLOSING = 2;\nWebSocket$1.prototype.CLOSING = WebSocket$1.CLOSING;\nWebSocket$1.CLOSED = 3;\nWebSocket$1.prototype.CLOSED = WebSocket$1.CLOSED;\n\n/*\n * The socket-io class is designed to mimick the real API as closely as possible.\n *\n * http://socket.io/docs/\n */\nvar SocketIO$1 = (function (EventTarget$$1) {\n  function SocketIO(url, protocol) {\n    var this$1 = this;\n    if ( url === void 0 ) url = 'socket.io';\n    if ( protocol === void 0 ) protocol = '';\n\n    EventTarget$$1.call(this);\n\n    this.binaryType = 'blob';\n    var urlRecord = new urlParse(url);\n\n    if (!urlRecord.pathname) {\n      urlRecord.pathname = '/';\n    }\n\n    this.url = urlRecord.toString();\n    this.readyState = SocketIO.CONNECTING;\n    this.protocol = '';\n    this.target = this;\n\n    if (typeof protocol === 'string' || (typeof protocol === 'object' && protocol !== null)) {\n      this.protocol = protocol;\n    } else if (Array.isArray(protocol) && protocol.length > 0) {\n      this.protocol = protocol[0];\n    }\n\n    var server = networkBridge.attachWebSocket(this, this.url);\n\n    /*\n     * Delay triggering the connection events so they can be defined in time.\n     */\n    delay(function delayCallback() {\n      if (server) {\n        this.readyState = SocketIO.OPEN;\n        server.dispatchEvent(createEvent({ type: 'connection' }), server, this);\n        server.dispatchEvent(createEvent({ type: 'connect' }), server, this); // alias\n        this.dispatchEvent(createEvent({ type: 'connect', target: this }));\n      } else {\n        this.readyState = SocketIO.CLOSED;\n        this.dispatchEvent(createEvent({ type: 'error', target: this }));\n        this.dispatchEvent(\n          createCloseEvent({\n            type: 'close',\n            target: this,\n            code: CLOSE_CODES.CLOSE_NORMAL\n          })\n        );\n\n        log('error', (\"Socket.io connection to '\" + (this.url) + \"' failed\"));\n      }\n    }, this);\n\n    /**\n      Add an aliased event listener for close / disconnect\n     */\n    this.addEventListener('close', function (event) {\n      this$1.dispatchEvent(\n        createCloseEvent({\n          type: 'disconnect',\n          target: event.target,\n          code: event.code\n        })\n      );\n    });\n  }\n\n  if ( EventTarget$$1 ) SocketIO.__proto__ = EventTarget$$1;\n  SocketIO.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );\n  SocketIO.prototype.constructor = SocketIO;\n\n  var prototypeAccessors = { broadcast: {} };\n\n  /*\n   * Closes the SocketIO connection or connection attempt, if any.\n   * If the connection is already CLOSED, this method does nothing.\n   */\n  SocketIO.prototype.close = function close () {\n    if (this.readyState !== SocketIO.OPEN) {\n      return undefined;\n    }\n\n    var server = networkBridge.serverLookup(this.url);\n    networkBridge.removeWebSocket(this, this.url);\n\n    this.readyState = SocketIO.CLOSED;\n    this.dispatchEvent(\n      createCloseEvent({\n        type: 'close',\n        target: this,\n        code: CLOSE_CODES.CLOSE_NORMAL\n      })\n    );\n\n    if (server) {\n      server.dispatchEvent(\n        createCloseEvent({\n          type: 'disconnect',\n          target: this,\n          code: CLOSE_CODES.CLOSE_NORMAL\n        }),\n        server\n      );\n    }\n\n    return this;\n  };\n\n  /*\n   * Alias for Socket#close\n   *\n   * https://github.com/socketio/socket.io-client/blob/master/lib/socket.js#L383\n   */\n  SocketIO.prototype.disconnect = function disconnect () {\n    return this.close();\n  };\n\n  /*\n   * Submits an event to the server with a payload\n   */\n  SocketIO.prototype.emit = function emit (event) {\n    var data = [], len = arguments.length - 1;\n    while ( len-- > 0 ) data[ len ] = arguments[ len + 1 ];\n\n    if (this.readyState !== SocketIO.OPEN) {\n      throw new Error('SocketIO is already in CLOSING or CLOSED state');\n    }\n\n    var messageEvent = createMessageEvent({\n      type: event,\n      origin: this.url,\n      data: data\n    });\n\n    var server = networkBridge.serverLookup(this.url);\n\n    if (server) {\n      server.dispatchEvent.apply(server, [ messageEvent ].concat( data ));\n    }\n\n    return this;\n  };\n\n  /*\n   * Submits a 'message' event to the server.\n   *\n   * Should behave exactly like WebSocket#send\n   *\n   * https://github.com/socketio/socket.io-client/blob/master/lib/socket.js#L113\n   */\n  SocketIO.prototype.send = function send (data) {\n    this.emit('message', data);\n    return this;\n  };\n\n  /*\n   * For broadcasting events to other connected sockets.\n   *\n   * e.g. socket.broadcast.emit('hi!');\n   * e.g. socket.broadcast.to('my-room').emit('hi!');\n   */\n  prototypeAccessors.broadcast.get = function () {\n    if (this.readyState !== SocketIO.OPEN) {\n      throw new Error('SocketIO is already in CLOSING or CLOSED state');\n    }\n\n    var self = this;\n    var server = networkBridge.serverLookup(this.url);\n    if (!server) {\n      throw new Error((\"SocketIO can not find a server at the specified URL (\" + (this.url) + \")\"));\n    }\n\n    return {\n      emit: function emit(event, data) {\n        server.emit(event, data, { websockets: networkBridge.websocketsLookup(self.url, null, self) });\n        return self;\n      },\n      to: function to(room) {\n        return server.to(room, self);\n      },\n      in: function in$1(room) {\n        return server.in(room, self);\n      }\n    };\n  };\n\n  /*\n   * For registering events to be received from the server\n   */\n  SocketIO.prototype.on = function on (type, callback) {\n    this.addEventListener(type, callback);\n    return this;\n  };\n\n  /*\n   * Remove event listener\n   *\n   * https://github.com/component/emitter#emitteroffevent-fn\n   */\n  SocketIO.prototype.off = function off (type, callback) {\n    this.removeEventListener(type, callback);\n  };\n\n  /*\n   * Check if listeners have already been added for an event\n   *\n   * https://github.com/component/emitter#emitterhaslistenersevent\n   */\n  SocketIO.prototype.hasListeners = function hasListeners (type) {\n    var listeners = this.listeners[type];\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n    return !!listeners.length;\n  };\n\n  /*\n   * Join a room on a server\n   *\n   * http://socket.io/docs/rooms-and-namespaces/#joining-and-leaving\n   */\n  SocketIO.prototype.join = function join (room) {\n    networkBridge.addMembershipToRoom(this, room);\n  };\n\n  /*\n   * Get the websocket to leave the room\n   *\n   * http://socket.io/docs/rooms-and-namespaces/#joining-and-leaving\n   */\n  SocketIO.prototype.leave = function leave (room) {\n    networkBridge.removeMembershipFromRoom(this, room);\n  };\n\n  SocketIO.prototype.to = function to (room) {\n    return this.broadcast.to(room);\n  };\n\n  SocketIO.prototype.in = function in$1 () {\n    return this.to.apply(null, arguments);\n  };\n\n  /*\n   * Invokes all listener functions that are listening to the given event.type property. Each\n   * listener will be passed the event as the first argument.\n   *\n   * @param {object} event - event object which will be passed to all listeners of the event.type property\n   */\n  SocketIO.prototype.dispatchEvent = function dispatchEvent (event) {\n    var this$1 = this;\n    var customArguments = [], len = arguments.length - 1;\n    while ( len-- > 0 ) customArguments[ len ] = arguments[ len + 1 ];\n\n    var eventName = event.type;\n    var listeners = this.listeners[eventName];\n\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n\n    listeners.forEach(function (listener) {\n      if (customArguments.length > 0) {\n        listener.apply(this$1, customArguments);\n      } else {\n        // Regular WebSockets expect a MessageEvent but Socketio.io just wants raw data\n        //  payload instanceof MessageEvent works, but you can't isntance of NodeEvent\n        //  for now we detect if the output has data defined on it\n        listener.call(this$1, event.data ? event.data : event);\n      }\n    });\n  };\n\n  Object.defineProperties( SocketIO.prototype, prototypeAccessors );\n\n  return SocketIO;\n}(EventTarget));\n\nSocketIO$1.CONNECTING = 0;\nSocketIO$1.OPEN = 1;\nSocketIO$1.CLOSING = 2;\nSocketIO$1.CLOSED = 3;\n\n/*\n * Static constructor methods for the IO Socket\n */\nvar IO = function ioConstructor(url, protocol) {\n  return new SocketIO$1(url, protocol);\n};\n\n/*\n * Alias the raw IO() constructor\n */\nIO.connect = function ioConnect(url, protocol) {\n  /* eslint-disable new-cap */\n  return IO(url, protocol);\n  /* eslint-enable new-cap */\n};\n\nvar dedupe = function (arr) { return arr.reduce(function (deduped, b) {\n    if (deduped.indexOf(b) > -1) { return deduped; }\n    return deduped.concat(b);\n  }, []); };\n\nfunction retrieveGlobalObject() {\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  return typeof process === 'object' && \"function\" === 'function' && typeof __webpack_require__.g === 'object' ? __webpack_require__.g : this;\n}\n\nvar defaultOptions = {\n  mock: true,\n  verifyClient: null,\n  selectProtocol: null\n};\n\nvar Server$1 = (function (EventTarget$$1) {\n  function Server(url, options) {\n    if ( options === void 0 ) options = defaultOptions;\n\n    EventTarget$$1.call(this);\n    var urlRecord = new urlParse(url);\n\n    if (!urlRecord.pathname) {\n      urlRecord.pathname = '/';\n    }\n\n    this.url = urlRecord.toString();\n\n    this.originalWebSocket = null;\n    var server = networkBridge.attachServer(this, this.url);\n\n    if (!server) {\n      this.dispatchEvent(createEvent({ type: 'error' }));\n      throw new Error('A mock server is already listening on this url');\n    }\n\n    this.options = Object.assign({}, defaultOptions, options);\n\n    if (this.options.mock) {\n      this.mockWebsocket();\n    }\n  }\n\n  if ( EventTarget$$1 ) Server.__proto__ = EventTarget$$1;\n  Server.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );\n  Server.prototype.constructor = Server;\n\n  /*\n   * Attaches the mock websocket object to the global object\n   */\n  Server.prototype.mockWebsocket = function mockWebsocket () {\n    var globalObj = retrieveGlobalObject();\n\n    this.originalWebSocket = globalObj.WebSocket;\n    globalObj.WebSocket = WebSocket$1;\n  };\n\n  /*\n   * Removes the mock websocket object from the global object\n   */\n  Server.prototype.restoreWebsocket = function restoreWebsocket () {\n    var globalObj = retrieveGlobalObject();\n\n    if (this.originalWebSocket !== null) {\n      globalObj.WebSocket = this.originalWebSocket;\n    }\n\n    this.originalWebSocket = null;\n  };\n\n  /**\n   * Removes itself from the urlMap so another server could add itself to the url.\n   * @param {function} callback - The callback is called when the server is stopped\n   */\n  Server.prototype.stop = function stop (callback) {\n    if ( callback === void 0 ) callback = function () {};\n\n    if (this.options.mock) {\n      this.restoreWebsocket();\n    }\n\n    networkBridge.removeServer(this.url);\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n\n  /*\n   * This is the main function for the mock server to subscribe to the on events.\n   *\n   * ie: mockServer.on('connection', function() { console.log('a mock client connected'); });\n   *\n   * @param {string} type - The event key to subscribe to. Valid keys are: connection, message, and close.\n   * @param {function} callback - The callback which should be called when a certain event is fired.\n   */\n  Server.prototype.on = function on (type, callback) {\n    this.addEventListener(type, callback);\n  };\n\n  /*\n   * Remove event listener\n   */\n  Server.prototype.off = function off (type, callback) {\n    this.removeEventListener(type, callback);\n  };\n\n  /*\n   * Closes the connection and triggers the onclose method of all listening\n   * websockets. After that it removes itself from the urlMap so another server\n   * could add itself to the url.\n   *\n   * @param {object} options\n   */\n  Server.prototype.close = function close (options) {\n    if ( options === void 0 ) options = {};\n\n    var code = options.code;\n    var reason = options.reason;\n    var wasClean = options.wasClean;\n    var listeners = networkBridge.websocketsLookup(this.url);\n\n    // Remove server before notifications to prevent immediate reconnects from\n    // socket onclose handlers\n    networkBridge.removeServer(this.url);\n\n    listeners.forEach(function (socket) {\n      socket.readyState = WebSocket$1.CLOSED;\n      socket.dispatchEvent(\n        createCloseEvent({\n          type: 'close',\n          target: socket.target,\n          code: code || CLOSE_CODES.CLOSE_NORMAL,\n          reason: reason || '',\n          wasClean: wasClean\n        })\n      );\n    });\n\n    this.dispatchEvent(createCloseEvent({ type: 'close' }), this);\n  };\n\n  /*\n   * Sends a generic message event to all mock clients.\n   */\n  Server.prototype.emit = function emit (event, data, options) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n    var websockets = options.websockets;\n\n    if (!websockets) {\n      websockets = networkBridge.websocketsLookup(this.url);\n    }\n\n    var normalizedData;\n    if (typeof options !== 'object' || arguments.length > 3) {\n      data = Array.prototype.slice.call(arguments, 1, arguments.length);\n      normalizedData = data.map(function (item) { return normalizeSendData(item); });\n    } else {\n      normalizedData = normalizeSendData(data);\n    }\n\n    websockets.forEach(function (socket) {\n      var messageData = socket instanceof SocketIO$1 ? data : normalizedData;\n      if (Array.isArray(messageData)) {\n        socket.dispatchEvent.apply(\n          socket, [ createMessageEvent({\n            type: event,\n            data: messageData,\n            origin: this$1.url,\n            target: socket.target\n          }) ].concat( messageData )\n        );\n      } else {\n        socket.dispatchEvent(\n          createMessageEvent({\n            type: event,\n            data: messageData,\n            origin: this$1.url,\n            target: socket.target\n          })\n        );\n      }\n    });\n  };\n\n  /*\n   * Returns an array of websockets which are listening to this server\n   * TOOD: this should return a set and not be a method\n   */\n  Server.prototype.clients = function clients () {\n    return networkBridge.websocketsLookup(this.url);\n  };\n\n  /*\n   * Prepares a method to submit an event to members of the room\n   *\n   * e.g. server.to('my-room').emit('hi!');\n   */\n  Server.prototype.to = function to (room, broadcaster, broadcastList) {\n    var this$1 = this;\n    if ( broadcastList === void 0 ) broadcastList = [];\n\n    var self = this;\n    var websockets = dedupe(broadcastList.concat(networkBridge.websocketsLookup(this.url, room, broadcaster)));\n\n    return {\n      to: function (chainedRoom, chainedBroadcaster) { return this$1.to.call(this$1, chainedRoom, chainedBroadcaster, websockets); },\n      emit: function emit(event, data) {\n        self.emit(event, data, { websockets: websockets });\n      }\n    };\n  };\n\n  /*\n   * Alias for Server.to\n   */\n  Server.prototype.in = function in$1 () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return this.to.apply(null, args);\n  };\n\n  /*\n   * Simulate an event from the server to the clients. Useful for\n   * simulating errors.\n   */\n  Server.prototype.simulate = function simulate (event) {\n    var listeners = networkBridge.websocketsLookup(this.url);\n\n    if (event === 'error') {\n      listeners.forEach(function (socket) {\n        socket.readyState = WebSocket$1.CLOSED;\n        socket.dispatchEvent(createEvent({ type: 'error', target: socket.target }));\n      });\n    }\n  };\n\n  return Server;\n}(EventTarget));\n\n/*\n * Alternative constructor to support namespaces in socket.io\n *\n * http://socket.io/docs/rooms-and-namespaces/#custom-namespaces\n */\nServer$1.of = function of(url) {\n  return new Server$1(url);\n};\n\nvar Server = Server$1;\nvar WebSocket = WebSocket$1;\nvar SocketIO$$1 = IO;\n\nexports.Server = Server;\nexports.WebSocket = WebSocket;\nexports.SocketIO = SocketIO$$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack://HyphaCore/./node_modules/mock-socket/dist/mock-socket.js?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataViewIndexOutOfBoundsError: () => (/* binding */ DataViewIndexOutOfBoundsError),\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar STATE_ARRAY = \"array\";\nvar STATE_MAP_KEY = \"map_key\";\nvar STATE_MAP_VALUE = \"map_value\";\nvar isValidMapKeyType = function (key) {\n    return typeof key === \"string\" || typeof key === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n}\ncatch (e) {\n    if (!(e instanceof RangeError)) {\n        throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n    }\n}\nvar DataViewIndexOutOfBoundsError = RangeError;\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(options) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n        this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;\n        this.maxStrLength = (_c = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _c !== void 0 ? _c : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxBinLength = (_d = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _d !== void 0 ? _d : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxArrayLength = (_e = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _e !== void 0 ? _e : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxMapLength = (_f = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _f !== void 0 ? _f : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxExtLength = (_g = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _g !== void 0 ? _g : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.keyDecoder = ((options === null || options === void 0 ? void 0 : options.keyDecoder) !== undefined) ? options.keyDecoder : sharedCachedKeyDecoder;\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n        this.view = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var _a, stream_1, stream_1_1;\n        var _b, e_1, _c, _d;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        decoded = false;\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 6, 7, 12]);\n                        _a = true, stream_1 = __asyncValues(stream);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3 /*break*/, 5];\n                        _d = stream_1_1.value;\n                        _a = false;\n                        try {\n                            buffer = _d;\n                            if (decoded) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            this.appendBuffer(buffer);\n                            try {\n                                object = this.doDecodeSync();\n                                decoded = true;\n                            }\n                            catch (e) {\n                                if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                    throw e; // rethrow\n                                }\n                                // fallthrough\n                            }\n                            this.totalPos += this.pos;\n                        }\n                        finally {\n                            _a = true;\n                        }\n                        _f.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _f.trys.push([7, , 10, 11]);\n                        if (!(!_a && !_b && (_c = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _c.call(stream_1)];\n                    case 8:\n                        _f.sent();\n                        _f.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var _b, e_3, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _e.label = 1;\n                    case 1:\n                        _e.trys.push([1, 15, 16, 21]);\n                        _a = true, stream_2 = __asyncValues(stream);\n                        _e.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3 /*break*/, 14];\n                        _d = stream_2_1.value;\n                        _a = false;\n                        _e.label = 4;\n                    case 4:\n                        _e.trys.push([4, , 12, 13]);\n                        buffer = _d;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _e.label = 5;\n                    case 5:\n                        _e.trys.push([5, 10, , 11]);\n                        _e.label = 6;\n                    case 6:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 7: return [4 /*yield*/, _e.sent()];\n                    case 8:\n                        _e.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 9];\n                        }\n                        return [3 /*break*/, 6];\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        e_2 = _e.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 11];\n                    case 11:\n                        this.totalPos += this.pos;\n                        return [3 /*break*/, 13];\n                    case 12:\n                        _a = true;\n                        return [7 /*endfinally*/];\n                    case 13: return [3 /*break*/, 2];\n                    case 14: return [3 /*break*/, 21];\n                    case 15:\n                        e_3_1 = _e.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 21];\n                    case 16:\n                        _e.trys.push([16, , 19, 20]);\n                        if (!(!_a && !_b && (_c = stream_2.return))) return [3 /*break*/, 18];\n                        return [4 /*yield*/, __await(_c.call(stream_2))];\n                    case 17:\n                        _e.sent();\n                        _e.label = 18;\n                    case 18: return [3 /*break*/, 20];\n                    case 19:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 20: return [7 /*endfinally*/];\n                    case 21: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                if (this.useBigInt64) {\n                    object = this.readU64AsBigInt();\n                }\n                else {\n                    object = this.readU64();\n                }\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                if (this.useBigInt64) {\n                    object = this.readI64AsBigInt();\n                }\n                else {\n                    object = this.readI64();\n                }\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === STATE_ARRAY) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === STATE_MAP_KEY) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = STATE_MAP_VALUE;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = STATE_MAP_KEY;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: STATE_MAP_KEY,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: STATE_ARRAY,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8Decode)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === STATE_MAP_KEY;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readU64AsBigInt = function () {\n        var value = this.view.getBigUint64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64AsBigInt = function () {\n        var value = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;\n        this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;\n        this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;\n        this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;\n        this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;\n        this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;\n        this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;\n        this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            if (!this.forceIntegerToFloat) {\n                this.encodeNumber(object);\n            }\n            else {\n                this.encodeNumberAsFloat(object);\n            }\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else if (this.useBigInt64 && typeof object === \"bigint\") {\n            this.encodeBigInt64(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n        }\n        else {\n            this.encodeNumberAsFloat(object);\n        }\n    };\n    Encoder.prototype.encodeNumberAsFloat = function (object) {\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        }\n        else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    };\n    Encoder.prototype.encodeBigInt64 = function (object) {\n        if (object >= BigInt(0)) {\n            // uint 64\n            this.writeU8(0xcf);\n            this.writeBigUint64(object);\n        }\n        else {\n            // int 64\n            this.writeU8(0xd3);\n            this.writeBigInt64(object);\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n        this.writeStringHeader(byteLength);\n        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Encode)(object, this.bytes, this.pos);\n        this.pos += byteLength;\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeBigUint64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigUint64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeBigInt64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultEncodeOptions: () => (/* binding */ defaultEncodeOptions),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\n/**\n * @deprecated No longer supported.\n */\nvar defaultEncodeOptions = undefined;\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDataView: () => (/* binding */ createDataView),\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nvar sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nvar TEXT_ENCODER_THRESHOLD = 50;\nfunction utf8EncodeTE(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nfunction utf8Encode(str, output, outputOffset) {\n    if (str.length > TEXT_ENCODER_THRESHOLD) {\n        utf8EncodeTE(str, output, outputOffset);\n    }\n    else {\n        utf8EncodeJs(str, output, outputOffset);\n    }\n}\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nvar TEXT_DECODER_THRESHOLD = 200;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\nfunction utf8Decode(bytes, inputOffset, byteLength) {\n    if (byteLength > TEXT_DECODER_THRESHOLD) {\n        return utf8DecodeTD(bytes, inputOffset, byteLength);\n    }\n    else {\n        return utf8DecodeJs(bytes, inputOffset, byteLength);\n    }\n}\n//# sourceMappingURL=utf8.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/hypha-core.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});