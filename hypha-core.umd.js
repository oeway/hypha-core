/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["HyphaCore"] = factory();
	else
		root["HyphaCore"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/hypha-core.js":
/*!***************************!*\
  !*** ./src/hypha-core.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HyphaCore: () => (/* binding */ HyphaCore),\n/* harmony export */   WebSocket: () => (/* reexport safe */ mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket),\n/* harmony export */   WebsocketRPCConnection: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.WebsocketRPCConnection),\n/* harmony export */   Workspace: () => (/* reexport safe */ _workspace_js__WEBPACK_IMPORTED_MODULE_3__.Workspace),\n/* harmony export */   connectToServer: () => (/* binding */ connectToServer),\n/* harmony export */   hyphaWebsocketClient: () => (/* reexport safe */ hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient),\n/* harmony export */   imjoyRPC: () => (/* binding */ getImjoyRPC)\n/* harmony export */ });\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mock-socket */ \"./node_modules/mock-socket/dist/mock-socket.js\");\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mock_socket__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/index.js */ \"./src/utils/index.js\");\n/* harmony import */ var _workspace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workspace.js */ \"./src/workspace.js\");\n/* harmony import */ var _utils_redis_mock_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/redis-mock.js */ \"./src/utils/redis-mock.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\n\n\n\n\nconst connectToServer = hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.connectToServer;\nconst AUTH0_NAMESPACE = \"https://api.imjoy.io/\";\nfunction base64UrlEncode(data) {\n  if (typeof btoa !== \"undefined\") {\n    const base64 = btoa(\n      typeof data === \"string\" ? data : String.fromCharCode(...new Uint8Array(data))\n    );\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  } else if (typeof Buffer !== \"undefined\") {\n    const buffer = typeof data === \"string\" ? Buffer.from(data) : Buffer.from(data);\n    const base64 = buffer.toString(\"base64\");\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  } else {\n    throw new Error(\"Base64 encoding not available in current environment\");\n  }\n}\nfunction base64UrlDecode(base64Url) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  if (typeof atob !== \"undefined\") {\n    return atob(base64);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(base64, \"base64\").toString(\"binary\");\n  } else {\n    throw new Error(\"Base64 decoding not available in current environment\");\n  }\n}\nasync function hmacSha256(key, data) {\n  if (typeof crypto !== \"undefined\" && crypto.subtle) {\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(key);\n    const msgData = encoder.encode(data);\n    const cryptoKey = await crypto.subtle.importKey(\n      \"raw\",\n      keyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\"]\n    );\n    const signature = await crypto.subtle.sign(\"HMAC\", cryptoKey, msgData);\n    return new Uint8Array(signature);\n  } else {\n    throw new Error(\"JWT HS256 signing requires Web Crypto API (browser) or crypto module (Node.js/Deno)\");\n  }\n}\nasync function verifyJWT(token, secret) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  const [encodedHeader, encodedPayload, encodedSignature] = parts;\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  try {\n    const header = JSON.parse(base64UrlDecode(encodedHeader));\n    if (header.alg !== \"HS256\") {\n      throw new Error(\"Unsupported algorithm\");\n    }\n    const expectedSignature = await hmacSha256(secret, unsigned);\n    const actualSignature = new Uint8Array(\n      Array.from(base64UrlDecode(encodedSignature)).map((c) => c.charCodeAt(0))\n    );\n    if (expectedSignature.length !== actualSignature.length) {\n      throw new Error(\"Invalid signature\");\n    }\n    for (let i = 0; i < expectedSignature.length; i++) {\n      if (expectedSignature[i] !== actualSignature[i]) {\n        throw new Error(\"Invalid signature\");\n      }\n    }\n    const payload = JSON.parse(base64UrlDecode(encodedPayload));\n    if (payload.exp && Date.now() / 1e3 > payload.exp) {\n      throw new Error(\"Token expired\");\n    }\n    return payload;\n  } catch (error) {\n    throw new Error(`JWT verification failed: ${error.message}`);\n  }\n}\nasync function generateJWT(payload, secret) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await hmacSha256(secret, unsigned);\n  const encodedSignature = base64UrlEncode(signature);\n  return `${unsigned}.${encodedSignature}`;\n}\nconst _HyphaCore = class extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.MessageEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.redis = _utils_redis_mock_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n    this.port = config.port || 8080;\n    if (config.host) {\n      this.host = config.host;\n    } else if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n      this.host = \"local-hypha-server\";\n    } else {\n      this.host = \"localhost\";\n    }\n    this.baseUrl = config.base_url || _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.getSafeBaseUrl();\n    if (!this.baseUrl.endsWith(\"/\")) {\n      this.baseUrl += \"/\";\n    }\n    if (config.url && config.port) {\n      throw new Error(\"Please provide either url or port, not both.\");\n    }\n    this.ServerClass = config.ServerClass || mock_socket__WEBPACK_IMPORTED_MODULE_0__.Server;\n    this.WebSocketClass = config.WebSocketClass || mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket;\n    if (config.url && (config.url.startsWith(\"wss://\") || config.url.startsWith(\"ws://\"))) {\n      if (!config.url.endsWith(\"/ws\")) {\n        throw new Error(\"Please provide a valid wss url ending with /ws\");\n      }\n      this.url = config.url.replace(\"wss://\", \"https://\").replace(\"ws://\", \"http://\").slice(0, -3);\n      this.wsUrl = config.url;\n    } else {\n      this.url = config.url || `https://${this.host}:${this.port}`;\n      this.wsUrl = this.url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\") + \"/ws\";\n    }\n    this.api = null;\n    this.server = null;\n    this.workspaceManagerId = \"workspace-manager\";\n    this.connections = {};\n    this.defaultServices = config.default_service || {};\n    this.imjoyPluginWindows = /* @__PURE__ */ new Map();\n    this.jwtSecret = config.jwtSecret || \"hypha-core-default-secret-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n    this.environment = _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.getEnvironment();\n    this.on(\"add_window\", (config2) => {\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n        console.log(\"Creating window: \", config2);\n      } else {\n        console.warn(`Window creation requested but not supported in ${this.environment} environment:`, config2);\n      }\n    });\n  }\n  async emit(event, data) {\n    this._fire(event, data);\n  }\n  async _handleImJoyPlugin(event) {\n    if (!_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n      console.warn(\"ImJoy plugin handling is only supported in browser environments\");\n      return;\n    }\n    let imjoyRPC;\n    try {\n      const imjoyModule = await __webpack_require__.e(/*! import() */ \"vendors-node_modules_imjoy-rpc_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! imjoy-rpc */ \"./node_modules/imjoy-rpc/index.js\", 23));\n      imjoyRPC = imjoyModule.imjoyRPC;\n    } catch (error) {\n      console.error(\"Failed to load imjoy-rpc:\", error);\n      return;\n    }\n    const contentWindow = event.source;\n    const data = event.data;\n    let cid = null;\n    for (const [key, value] of Object.entries(this.connections)) {\n      if (value.source === contentWindow) {\n        cid = key;\n        break;\n      }\n    }\n    if (!cid) {\n      console.error(\"Client id not found for the plugin: \", data);\n      return;\n    }\n    const defaultService = this.workspaceManager.getDefaultService();\n    const coreInterface = {};\n    for (const key in defaultService) {\n      const camelKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toCamelCase)(key);\n      if (typeof defaultService[key] === \"function\") {\n        coreInterface[camelKey] = async (...args) => {\n          const context = {\n            ws: this.connections[cid].workspace,\n            from: `${cid}`,\n            to: `${this.connections[cid].workspace}/${this.workspaceManagerId}`,\n            user: this.connections[cid].user || {\n              id: \"anonymous\",\n              is_anonymous: true,\n              email: \"anonymous@imjoy.io\",\n              roles: [],\n              scopes: []\n            }\n          };\n          return await defaultService[key](...args, context);\n        };\n      } else {\n        coreInterface[camelKey] = defaultService[key];\n      }\n    }\n    const coreConnection = {\n      peer_id: data.peer_id,\n      fire(m) {\n        if (coreConnection._messageHandler[m.type]) {\n          coreConnection._messageHandler[m.type](m);\n        }\n      },\n      disconnect: function() {\n      },\n      emit: (msg) => {\n        msg.peer_id = coreConnection.peer_id;\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.safePostMessage(contentWindow, msg, \"*\");\n      },\n      on: function(event2, handler) {\n        coreConnection._messageHandler[event2] = handler;\n      },\n      _messageHandler: {},\n      async execute(code) {\n        coreConnection.emit({ type: \"execute\", code });\n      }\n    };\n    const pluginConfig = data.config;\n    if (data.error) {\n      console.error(\"Failed to initialize the plugin\", data.error);\n      return;\n    }\n    if (!data.peer_id) {\n      throw \"Please provide a peer_id for the connection.\";\n    }\n    this.imjoyPluginWindows.set(\n      event.source,\n      {\n        coreConnection,\n        cid\n      }\n    );\n    console.log(\"plugin initialized:\", pluginConfig);\n    const core = new imjoyRPC.RPC(coreConnection, { name: \"core\" });\n    core.setInterface(coreInterface);\n    core.on(\"interfaceSetAsRemote\", () => {\n      core.on(\"remoteReady\", async () => {\n        const api = core.getRemote();\n        api.id = `${cid}:default`;\n        api.type = \"imjoy\";\n        await this.workspaceManager.eventBus.emit(\"service_added\", api);\n      });\n      core.requestRemote();\n    });\n    core.sendInterface();\n  }\n  _handleClientMessage(event) {\n    if (event.data && event.data.type === \"hyphaClientReady\") {\n      const sourceToMatch = event.source || event.currentTarget;\n      let found = false;\n      for (const key in this.connections) {\n        const conn = this.connections[key];\n        if (conn.source === sourceToMatch) {\n          console.log(`\\u2705 [DEBUG] Found matching connection: ${key}`);\n          this.emit(\"connection_ready\", conn);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        console.error(\"\\u274C [DEBUG] No matching connection found for hyphaClientReady message!\");\n      }\n    }\n    const workspace = event.data.workspace;\n    if (!workspace) {\n      if (event.data.type === \"initialized\") {\n        this._handleImJoyPlugin(event).catch((error) => {\n          console.error(\"Error handling ImJoy plugin:\", error);\n        });\n      } else if (this.imjoyPluginWindows.has(event.source)) {\n        const coreConnection = this.imjoyPluginWindows.get(event.source).coreConnection;\n        coreConnection.fire(event.data);\n      }\n      return;\n    }\n    const clientId = event.data.from;\n    if (!clientId || !this.connections[workspace + \"/\" + clientId]) {\n      console.warn(\"Connection not found for client: \", clientId);\n      return;\n    }\n    const connection = this.connections[workspace + \"/\" + clientId];\n    const ws = connection.websocket;\n    if (event.data.type === \"message\") {\n      ws.send(event.data.data);\n    } else if (event.data.type === \"close\") {\n      ws.close();\n    } else if (event.data.type === \"connect\") {\n      const ws2 = new this.WebSocketClass(event.data.url);\n      ws2.onmessage = (evt) => {\n        connection.postMessage({ type: \"message\", data: evt.data, to: clientId });\n      };\n      ws2.onopen = () => {\n        connection.postMessage({ type: \"connected\", to: clientId });\n      };\n      ws2.onclose = () => {\n        connection.postMessage({ type: \"closed\", to: clientId });\n      };\n      connection.websocket = ws2;\n    }\n  }\n  async start(config) {\n    if (_HyphaCore.servers[this.url]) {\n      throw new Error(`Server already running at ${this.url}`);\n    } else {\n      const serverOptions = {\n        mock: false,\n        hyphaCore: this\n        // Enable HTTP service proxy functionality\n      };\n      this.server = new this.ServerClass(this.wsUrl, serverOptions);\n      _HyphaCore.servers[this.url] = this.server;\n      this.messageHandler = this._handleClientMessage.bind(this);\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.safeAddEventListener(window, \"message\", this.messageHandler);\n      } else {\n        console.log(`Running in ${this.environment} environment - window message handling disabled`);\n      }\n    }\n    this.server.on(\"connection\", async (websocket) => {\n      await this._handleWebsocketConnection(websocket);\n    });\n    config = config || {};\n    config.server = this;\n    config.WebSocketClass = this.WebSocketClass;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(config.workspace === void 0, \"workspace is not allowed to be set in the config\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(config.client_id === void 0, \"client_id is not allowed to be set in the config\");\n    this.workspaceManager = new _workspace_js__WEBPACK_IMPORTED_MODULE_3__.Workspace(this);\n    await this.workspaceManager.setup({\n      client_id: this.workspaceManagerId,\n      method_timeout: 60,\n      default_service: this.defaultServices\n    });\n    const api = this._createDirectAPIWrapper();\n    this.api = api;\n    return api;\n  }\n  async _handleWebsocketConnection(websocket) {\n    let authConfig = {};\n    let userInfo;\n    let workspace;\n    let clientId;\n    try {\n      const authData = await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error(\"Authentication timeout\"));\n        }, 3e4);\n        websocket.on(\"message\", (data) => {\n          clearTimeout(timeout);\n          resolve(data);\n        });\n        websocket.on(\"error\", (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n        websocket.on(\"close\", () => {\n          clearTimeout(timeout);\n          reject(new Error(\"Connection closed during authentication\"));\n        });\n      });\n      try {\n        authConfig = JSON.parse(authData);\n      } catch (parseError) {\n        await this._disconnectWebsocket(websocket, \"Failed to decode authentication information\", 1003);\n        return;\n      }\n      if (authConfig.workspace === void 0 && authConfig.client_id === void 0 && authConfig.token === void 0) {\n        throw new Error(\"Authentication required: workspace, client_id, or token must be provided\");\n      }\n      const authResult = await this._authenticateUser(authConfig);\n      userInfo = authResult.userInfo;\n      workspace = authResult.workspace;\n      clientId = authConfig.client_id;\n      if (!workspace) {\n        workspace = \"workspace-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n      }\n      if (!clientId) {\n        clientId = \"client-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n      }\n      await this._checkClientPermissions(clientId, workspace, userInfo);\n      await this._establishWebsocketCommunication(websocket, workspace, clientId, userInfo);\n    } catch (error) {\n      console.error(\"WebSocket connection failed:\", error.message);\n      await this._disconnectWebsocket(websocket, `Failed to establish connection: ${error.message}`, 1001);\n    }\n  }\n  async _authenticateUser(authConfig) {\n    let userInfo;\n    let workspace = authConfig.workspace;\n    if (authConfig.token) {\n      try {\n        const payload = await verifyJWT(authConfig.token, this.jwtSecret);\n        userInfo = {\n          id: payload.sub || payload.user_id || \"anonymous\",\n          is_anonymous: !payload.email,\n          email: payload.email || \"\",\n          roles: payload.roles || [],\n          scopes: payload.scope ? payload.scope.split(\" \") : [],\n          expires_at: payload.exp\n        };\n        workspace = payload.workspace || authConfig.workspace || \"default\";\n      } catch (jwtError) {\n        try {\n          const info = parseJwt(authConfig.token);\n          const expiresAt = info[\"exp\"];\n          userInfo = {\n            id: info[\"sub\"],\n            is_anonymous: !info[AUTH0_NAMESPACE + \"email\"],\n            email: info[AUTH0_NAMESPACE + \"email\"],\n            roles: info[AUTH0_NAMESPACE + \"roles\"],\n            scopes: info[\"scope\"],\n            expires_at: expiresAt\n          };\n          workspace = info.workspace || authConfig.workspace || userInfo.id;\n        } catch (parseError) {\n          throw new Error(`Token verification failed: ${jwtError.message}`);\n        }\n      }\n    } else if (authConfig.reconnection_token) {\n      try {\n        const payload = await verifyJWT(authConfig.reconnection_token, this.jwtSecret);\n        userInfo = {\n          id: payload.sub || \"anonymous\",\n          is_anonymous: !payload.email,\n          email: payload.email || \"\",\n          roles: payload.roles || [],\n          scopes: payload.scope ? payload.scope.split(\" \") : [],\n          expires_at: payload.exp\n        };\n        workspace = payload.workspace || authConfig.workspace;\n        if (payload.client_id && authConfig.client_id && payload.client_id !== authConfig.client_id) {\n          throw new Error(\"Client ID mismatch during reconnection\");\n        }\n      } catch (error) {\n        throw new Error(`Reconnection token verification failed: ${error.message}`);\n      }\n    } else {\n      const anonymousUserId = \"anonymous-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n      userInfo = {\n        id: anonymousUserId,\n        is_anonymous: true,\n        email: \"anonymous@imjoy.io\",\n        roles: [],\n        scopes: []\n      };\n      const requestedWorkspace = authConfig.workspace;\n      if (!requestedWorkspace) {\n        workspace = anonymousUserId;\n      } else {\n        if (requestedWorkspace !== \"public\" && requestedWorkspace !== anonymousUserId) {\n          throw new Error(`Anonymous client attempted to access protected workspace: ${requestedWorkspace}`);\n        }\n        workspace = requestedWorkspace;\n      }\n    }\n    return { userInfo, workspace };\n  }\n  async _checkClientPermissions(clientId, workspace, userInfo) {\n    if (workspace === \"public\") {\n      return;\n    }\n    if (userInfo.is_anonymous && !workspace.startsWith(\"anonymous-\")) {\n      throw new Error(`Permission denied for workspace: ${workspace}`);\n    }\n  }\n  async _establishWebsocketCommunication(websocket, workspace, clientId, userInfo) {\n    const connectionKey = `${workspace}/${clientId}`;\n    if (!this._websockets) {\n      this._websockets = {};\n    }\n    this._websockets[connectionKey] = websocket;\n    try {\n      const conn = new _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.RedisRPCConnection(this, workspace, clientId, userInfo, this.workspaceManagerId);\n      conn.on_message((data) => {\n        if (websocket.readyState === websocket.OPEN) {\n          websocket.send(data);\n        }\n      });\n      const reconnectionToken = await this._generateReconnectionToken(userInfo, workspace, clientId);\n      const baseUrl = this.url.endsWith(\"/\") ? this.url.slice(0, -1) : this.url;\n      const connectionInfo = {\n        \"type\": \"connection_info\",\n        \"hypha_version\": \"0.1.0\",\n        \"public_base_url\": baseUrl,\n        \"local_base_url\": baseUrl,\n        \"manager_id\": this.workspaceManagerId,\n        \"workspace\": workspace,\n        \"client_id\": clientId,\n        \"user\": userInfo,\n        \"reconnection_token\": reconnectionToken,\n        \"reconnection_token_life_time\": 3600\n        // 1 hour\n      };\n      websocket.send(JSON.stringify(connectionInfo));\n      websocket.on(\"message\", async (data) => {\n        try {\n          if (typeof data === \"string\") {\n            if (data.length > 1e3) {\n              console.warn(`Ignoring long text message: ${data.substring(0, 1e3)}...`);\n              return;\n            }\n            const message = JSON.parse(data);\n            if (message.type === \"ping\") {\n              websocket.send(JSON.stringify({ type: \"pong\" }));\n            } else if (message.type === \"refresh_token\") {\n              const newReconnectionToken = await this._generateReconnectionToken(userInfo, workspace, clientId);\n              websocket.send(JSON.stringify({\n                type: \"reconnection_token\",\n                reconnection_token: newReconnectionToken\n              }));\n            } else {\n              console.info(\"Unknown message type:\", message.type);\n            }\n          } else {\n            await conn.emit_message(data);\n          }\n        } catch (error) {\n          console.error(\"Error processing websocket message:\", error);\n        }\n      });\n      websocket.on(\"close\", async () => {\n        await this._handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn);\n      });\n      websocket.on(\"error\", async (error) => {\n        console.error(`WebSocket error for ${connectionKey}:`, error);\n        await this._handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn);\n      });\n    } catch (error) {\n      if (this._websockets && this._websockets[connectionKey]) {\n        delete this._websockets[connectionKey];\n      }\n      throw error;\n    }\n  }\n  async _generateReconnectionToken(userInfo, workspace, clientId) {\n    const payload = {\n      sub: userInfo.id,\n      workspace,\n      client_id: clientId,\n      email: userInfo.email,\n      roles: userInfo.roles || [],\n      scope: Array.isArray(userInfo.scopes) ? userInfo.scopes.join(\" \") : \"\",\n      iat: Math.floor(Date.now() / 1e3),\n      exp: Math.floor(Date.now() / 1e3) + 3600,\n      // 1 hour\n      iss: \"hypha-core\",\n      aud: \"hypha-reconnection\"\n    };\n    return await generateJWT(payload, this.jwtSecret);\n  }\n  async _handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn) {\n    const connectionKey = `${workspace}/${clientId}`;\n    try {\n      if (conn) {\n        await conn.disconnect(\"disconnected\");\n      }\n      console.info(`Client disconnected: ${connectionKey}`);\n    } catch (error) {\n      console.error(`Error handling disconnection for ${connectionKey}:`, error);\n    } finally {\n      if (this._websockets && this._websockets[connectionKey]) {\n        delete this._websockets[connectionKey];\n      }\n    }\n  }\n  async _disconnectWebsocket(websocket, reason, code = 1e3) {\n    console.error(\"Disconnecting websocket, reason:\", reason, \"code:\", code);\n    try {\n      if (websocket.readyState === websocket.OPEN) {\n        websocket.send(JSON.stringify({ type: \"error\", message: reason }));\n      }\n    } catch (error) {\n      console.error(\"Error sending disconnect message:\", error);\n    }\n    try {\n      if (websocket.readyState === websocket.OPEN || websocket.readyState === websocket.CONNECTING) {\n        websocket.close(code, reason);\n      }\n    } catch (error) {\n      console.error(\"Error closing websocket:\", error);\n    }\n  }\n  getWebsockets() {\n    return this._websockets || {};\n  }\n  async forceDisconnect(workspace, clientId, code, reason) {\n    const connectionKey = `${workspace}/${clientId}`;\n    const websocket = this._websockets && this._websockets[connectionKey];\n    if (!websocket) {\n      throw new Error(`Client not connected: ${connectionKey}`);\n    }\n    await this._disconnectWebsocket(websocket, reason, code);\n  }\n  async connect(config) {\n    config = config || {};\n    config.server = this;\n    config.WebSocketClass = this.WebSocketClass;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(config.client_id !== \"root\", \"client_id cannot be 'root'\");\n    config.client_id = config.client_id || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n    const rawApi = await connectToServer(config);\n    return this._createCamelCaseWrapper(rawApi);\n  }\n  _createCamelCaseWrapper(rawApi) {\n    const wrappedApi = {};\n    for (const key in rawApi) {\n      const camelKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toCamelCase)(key);\n      if (typeof rawApi[key] === \"function\") {\n        wrappedApi[camelKey] = rawApi[key].bind(rawApi);\n      } else {\n        wrappedApi[camelKey] = rawApi[key];\n      }\n    }\n    return wrappedApi;\n  }\n  async reset() {\n    this.close();\n    await this.start();\n  }\n  close() {\n    if (this.messageHandler) {\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.safeRemoveEventListener(window, \"message\", this.messageHandler);\n      }\n    }\n    if (this.server) {\n      this.server.close();\n      delete _HyphaCore.servers[this.url];\n    }\n  }\n  _createDirectAPIWrapper() {\n    const context = {\n      ws: \"default\",\n      from: \"default/root\",\n      user: {\n        id: \"root\",\n        is_anonymous: false,\n        email: \"root@localhost\",\n        roles: [\"admin\"],\n        scopes: []\n      }\n    };\n    const api = {\n      // API properties that tests expect\n      id: context.from.split(\"/\")[1],\n      // Extract client ID from \"workspace/clientId\"\n      config: {\n        workspace: context.ws,\n        server_url: this.url\n      },\n      // Workspace management functions\n      registerService: async (service) => {\n        return await this.workspaceManager.registerService(service, context);\n      },\n      unregisterService: async (serviceId) => {\n        return await this.workspaceManager.unregisterService(serviceId, context);\n      },\n      listServices: async (query = {}) => {\n        return await this.workspaceManager.listServices(query, context);\n      },\n      getService: async (serviceId, options = {}) => {\n        return await this.workspaceManager.getService(serviceId, options, context);\n      },\n      close: () => {\n        this.close();\n      },\n      // Event methods\n      emit: async (type, data) => {\n        await this.workspaceManager.eventBus.emit(type, data);\n      },\n      on: (event, handler) => {\n        this.workspaceManager.eventBus.on(event, handler);\n      },\n      off: (event, handler) => {\n        this.workspaceManager.eventBus.off(event, handler);\n      },\n      // Utility methods\n      echo: (msg) => {\n        return msg;\n      },\n      alert: (msg) => {\n        alert(msg);\n      },\n      confirm: (msg) => {\n        return confirm(msg);\n      },\n      prompt: (msg, default_value) => {\n        return prompt(msg, default_value);\n      },\n      showProgress: (progress) => {\n        console.log(\"showProgress\", progress);\n      },\n      showMessage: (msg) => {\n        console.log(msg);\n      },\n      log: (msg) => {\n        console.log(msg);\n      },\n      info: (msg) => {\n        console.info(msg);\n      },\n      error: (msg) => {\n        console.error(msg);\n      },\n      warning: (msg) => {\n        console.warn(msg);\n      },\n      critical: (msg) => {\n        console.error(msg);\n      },\n      // Token generation\n      generateToken: async (tokenConfig) => {\n        if (!tokenConfig) {\n          tokenConfig = {};\n        }\n        const currentWorkspace = context.ws;\n        const currentClientId = context.from?.split(\"/\")[1];\n        let targetWorkspace = tokenConfig.workspace || currentWorkspace;\n        if (targetWorkspace !== currentWorkspace) {\n          if (currentWorkspace !== \"default\" || currentClientId !== \"root\") {\n            throw new Error(`Access denied: Cannot generate token for workspace '${targetWorkspace}' from workspace '${currentWorkspace}' with client '${currentClientId}'. Only root client in default workspace can generate cross-workspace tokens.`);\n          }\n        }\n        const payload = {\n          sub: tokenConfig.user_id || context.user?.id || \"anonymous\",\n          workspace: targetWorkspace,\n          client_id: tokenConfig.client_id || context.from?.split(\"/\")[1] || \"anonymous-\" + Date.now().toString(),\n          email: tokenConfig.email || context.user?.email || \"\",\n          roles: tokenConfig.roles || context.user?.roles || [],\n          scope: Array.isArray(tokenConfig.scopes) ? tokenConfig.scopes.join(\" \") : tokenConfig.scope || \"\",\n          iat: Math.floor(Date.now() / 1e3),\n          exp: tokenConfig.expires_in ? Math.floor(Date.now() / 1e3) + tokenConfig.expires_in : Math.floor(Date.now() / 1e3) + 24 * 60 * 60,\n          // Default 24 hours\n          iss: \"hypha-core\",\n          aud: \"hypha-api\"\n        };\n        const jwtSecret = this.jwtSecret;\n        if (!jwtSecret) {\n          throw new Error(\"JWT secret not configured on server\");\n        }\n        return await generateJWT(payload, jwtSecret);\n      },\n      // App and window management methods\n      loadApp: async (config, extra_config) => {\n        return await this.workspaceManager.loadApp(config, extra_config, context);\n      },\n      createWindow: async (config, extra_config) => {\n        return await this.workspaceManager.createWindow(config, extra_config, context);\n      },\n      getWindow: async (config) => {\n        return await this.workspaceManager.getWindow(config, context);\n      },\n      getApp: async (config, extra_config) => {\n        return await this.workspaceManager.getApp(config, extra_config, context);\n      }\n    };\n    api.getPlugin = api.getApp;\n    api.loadPlugin = api.loadApp;\n    this.workspaceManager.registerService({\n      id: \"default\",\n      name: \"Default workspace management service\",\n      description: \"Services for managing workspace.\",\n      config: {\n        visibility: \"public\"\n      },\n      ...this.workspaceManager.getDefaultService()\n    }, context).catch((err) => {\n      console.warn(\"Could not register default service:\", err.message);\n    });\n    return this._createCamelCaseWrapper(api);\n  }\n};\nlet HyphaCore = _HyphaCore;\n__publicField(HyphaCore, \"servers\", {});\nfunction parseJwt(token) {\n  var base64Url = token.split(\".\")[1];\n  var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  var jsonPayload = decodeURIComponent(atob(base64).split(\"\").map(function(c) {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"));\n  return JSON.parse(jsonPayload);\n}\nlet _imjoyRPC = null;\nasync function getImjoyRPC() {\n  if (!_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n    throw new Error(\"imjoyRPC is only available in browser environments\");\n  }\n  if (!_imjoyRPC) {\n    const imjoyModule = await __webpack_require__.e(/*! import() */ \"vendors-node_modules_imjoy-rpc_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! imjoy-rpc */ \"./node_modules/imjoy-rpc/index.js\", 23));\n    _imjoyRPC = imjoyModule.imjoyRPC;\n  }\n  return _imjoyRPC;\n}\n\n\n\n//# sourceURL=webpack://HyphaCore/./src/hypha-core.js?");

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   MessageEmitter: () => (/* binding */ MessageEmitter),\n/* harmony export */   RedisRPCConnection: () => (/* binding */ RedisRPCConnection),\n/* harmony export */   WebsocketRPCConnection: () => (/* binding */ WebsocketRPCConnection),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   parsePluginCode: () => (/* binding */ parsePluginCode),\n/* harmony export */   randId: () => (/* binding */ randId),\n/* harmony export */   toCamelCase: () => (/* binding */ toCamelCase)\n/* harmony export */ });\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginParser.js */ \"./src/utils/pluginParser.js\");\n\n\nfunction toCamelCase(str) {\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      if (this._event_handlers[event])\n        this._event_handlers[event] = [];\n    } else {\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout);\n    });\n  }\n}\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nclass WebsocketRPCConnection {\n  constructor(eventBus, clients, clientId, workspace, managerId, timeout = 60) {\n    this._clients = clients;\n    this._clientId = clientId;\n    this._handle_message = null;\n    this._handle_connected = null;\n    this._handle_disconnected = null;\n    this._reconnection_token = null;\n    this._timeout = timeout * 1e3;\n    this.workspace = workspace;\n    this.connection_info = null;\n    this.manager_id = managerId;\n    this.eventBus = eventBus;\n  }\n  mount(config) {\n    assert(config.id && config.workspace && config.websocket && config.user_info, \"Invalid client config\");\n    config.websocket.on(\"message\", (data) => {\n      const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n      const unpacker = decoder.decodeMulti(data);\n      const { value: message } = unpacker.next();\n      const targetId = message.to.includes(\"/\") ? message.to.split(\"/\")[1] : message.to;\n      if (targetId === this._clientId) {\n        this._handle_message(data.buffer);\n      } else {\n        this.emit_message(data);\n      }\n    });\n  }\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n  async emit_message(data) {\n    assert(this._handle_message, \"No handler for message\");\n    const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n    const unpacker = decoder.decodeMulti(data);\n    const { value: message } = unpacker.next();\n    let targetId = message.to;\n    if (!targetId.includes(\"/\")) {\n      targetId = `${this.workspace}/${targetId}`;\n    }\n    if (!this._clients[targetId]) {\n      console.error(\"No client found for targetId:\", targetId);\n      return;\n    }\n    const client = this._clients[targetId];\n    const websocket = client.websocket;\n    if (!message.from.includes(\"/\")) {\n      message.from = `${this.workspace}/${message.from}`;\n    }\n    const updatedMessage = {\n      ...message,\n      ws: this.workspace,\n      to: targetId,\n      from: message.from,\n      user: client.userInfo\n    };\n    const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(updatedMessage);\n    const pos = decoder.pos;\n    const remainingData = data.slice(pos);\n    const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n    finalData.set(encodedUpdatedMessage, 0);\n    finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n    if (!websocket || !websocket.send) {\n      console.error(\"No websocket found for targetId:\", targetId);\n      return;\n    }\n    websocket.send(finalData.buffer);\n  }\n  disconnect(reason) {\n    console.info(`Websocket connection disconnected (${reason})`);\n  }\n}\nclass RedisRPCConnection {\n  /**\n   * Represent a Redis connection for handling RPC-like messaging.\n   * @param {EventBus} eventBus - Event bus for messaging.\n   * @param {string} workspace - Workspace identifier.\n   * @param {string} clientId - Client identifier.\n   * @param {UserInfo} userInfo - User information.\n   * @param {string} managerId - Manager identifier.\n   */\n  constructor(eventBus, workspace, clientId, userInfo, managerId) {\n    if (!workspace || clientId.includes(\"/\")) {\n      throw new Error(\"Invalid workspace or client ID\");\n    }\n    this._workspace = workspace;\n    this._clientId = clientId;\n    this._userInfo = userInfo;\n    this._stop = false;\n    this._eventBus = eventBus;\n    this._handleConnected = null;\n    this._handleDisconnected = null;\n    this._handleMessage = null;\n    this.manager_id = managerId;\n  }\n  /**\n   * Register a disconnection event handler.\n   * @param {function} handler - Disconnection handler.\n   */\n  on_disconnected(handler) {\n    this._handleDisconnected = handler;\n  }\n  /**\n   * Register a connection open event handler.\n   * @param {function} handler - Connection handler.\n   */\n  on_connected(handler) {\n    this._handleConnected = handler;\n  }\n  /**\n   * Set message handler.\n   * @param {function} handler - Message handler.\n   */\n  on_message(handler) {\n    this._handleMessage = handler;\n    this._eventBus.on(`${this._workspace}/${this._clientId}:msg`, handler);\n    this._eventBus.on(`${this._workspace}/*:msg`, handler);\n    if (this._handleConnected) {\n      this._handleConnected(this);\n    }\n  }\n  /**\n   * Send message after packing additional info.\n   * @param {Object|Uint8Array} data - Data to send.\n   */\n  async emit_message(data) {\n    if (this._stop) {\n      throw new Error(`Connection has already been closed (client: ${this._workspace}/${this._clientId})`);\n    }\n    if (!(data instanceof Uint8Array)) {\n      console.log(\"Skipping text message\", data);\n      return;\n    }\n    const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n    const unpacker = decoder.decodeMulti(data);\n    const { value: message } = unpacker.next();\n    const pos = decoder.pos;\n    let targetId = message.to;\n    if (!targetId.includes(\"/\")) {\n      if (targetId.includes(\"/workspace-manager-\")) {\n        throw new Error(`Invalid target ID: ${targetId}, it appears that the target is a workspace manager (target_id should starts with */)`);\n      }\n      targetId = `${this._workspace}/${targetId}`;\n    }\n    const sourceId = `${this._workspace}/${this._clientId}`;\n    message.ws = this._workspace === \"*\" ? targetId.split(\"/\")[0] : this._workspace;\n    message.to = targetId;\n    message.from = sourceId;\n    message.user = this._userInfo;\n    const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(message);\n    const remainingData = data.slice(pos);\n    const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n    finalData.set(encodedUpdatedMessage, 0);\n    finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n    this._eventBus.emit(`${targetId}:msg`, finalData.buffer);\n  }\n  /**\n   * Handle disconnection.\n   * @param {string} [reason] - Reason for disconnection.\n   */\n  async disconnect(reason) {\n    this._stop = true;\n    if (this._handleMessage) {\n      this._eventBus.off(`${this._workspace}/${this._clientId}:msg`, this._handleMessage);\n      this._eventBus.off(`${this._workspace}/*:msg`, this._handleMessage);\n    }\n    this._handleMessage = null;\n    console.info(`Redis Connection Disconnected: ${reason}`);\n    if (this._handleDisconnected) {\n      await this._handleDisconnected(reason);\n    }\n  }\n}\nconst CONFIGURABLE_FIELDS = [\n  \"env\",\n  \"requirements\",\n  \"dependencies\",\n  \"icon\",\n  \"ui\",\n  \"type\",\n  \"flags\",\n  \"labels\",\n  \"cover\",\n  \"base_frame\",\n  \"base_worker\",\n  \"passive\"\n];\nfunction parsePluginCode(code, overwrite_config) {\n  overwrite_config = overwrite_config || {};\n  try {\n    const pluginComp = (0,_pluginParser_js__WEBPACK_IMPORTED_MODULE_0__.parseComponent)(code);\n    let config;\n    if (pluginComp.config[0].attrs.lang === \"yaml\") {\n      throw new Error(\"YAML not supported\");\n    } else if (pluginComp.config[0].attrs.lang === \"json\") {\n      config = JSON.parse(pluginComp.config[0].content);\n    } else {\n      config = JSON.parse(pluginComp.config[0].content);\n      if (compareVersions(config.api_version, \">\", \"0.1.5\")) {\n        throw `Unsupported config language ${pluginComp.config[0].attrs.lang}, please set lang=\"json\" or lang=\"yaml\"`;\n      }\n    }\n    config.tag = overwrite_config.tag || config.tags && config.tags[0];\n    config.hot_reloading = overwrite_config.hot_reloading, config.scripts = [];\n    for (let i = 0; i < pluginComp.script.length; i++) {\n      if (pluginComp.script[i].attrs.tag === config.tag) {\n        config.script = pluginComp.script[i].content;\n      }\n      if (!pluginComp.script[i].attrs.tag || pluginComp.script[i].attrs.tag === config.tag) {\n        config.scripts.push(pluginComp.script[i]);\n      }\n    }\n    if (!config.script && pluginComp.script.length > 0) {\n      config.script = pluginComp.script[0].content;\n      config.lang = pluginComp.script[0].attrs.lang;\n    }\n    config.links = pluginComp.link || null;\n    config.windows = pluginComp.window || null;\n    config.styles = pluginComp.style || null;\n    config.docs = pluginComp.docs && pluginComp.docs[0] || config.docs;\n    config.attachments = pluginComp.attachment || null;\n    config._id = overwrite_config._id || config.name.replace(/ /g, \"_\");\n    config.uri = overwrite_config.uri;\n    config.origin = overwrite_config.origin;\n    config.namespace = overwrite_config.namespace;\n    config.code = code;\n    config.id = config.name.trim().replace(/ /g, \"_\") + \"_\" + randId();\n    config.runnable = config.runnable === false ? false : true;\n    config.requirements = config.requirements || [];\n    for (let i = 0; i < CONFIGURABLE_FIELDS.length; i++) {\n      const obj = config[CONFIGURABLE_FIELDS[i]];\n      if (obj && typeof obj === \"object\" && !(obj instanceof Array)) {\n        if (config.tag) {\n          config[CONFIGURABLE_FIELDS[i]] = obj[config.tag];\n          if (!Object.prototype.hasOwnProperty.call(obj, config.tag)) {\n            console.log(\n              \"WARNING: \" + CONFIGURABLE_FIELDS[i] + \" do not contain a tag named: \" + config.tag\n            );\n          }\n        } else {\n          throw \"You must use 'tags' with configurable fields.\";\n        }\n      }\n    }\n    config.lang = config.lang || \"javascript\";\n    return config;\n  } catch (e) {\n    console.error(e);\n    throw `Failed to parse the plugin file, error: ${e}`;\n  }\n}\nconst Environment = {\n  /**\n   * Check if we're running in a browser environment\n   */\n  isBrowser() {\n    return typeof window !== \"undefined\" && typeof document !== \"undefined\" && typeof navigator !== \"undefined\";\n  },\n  /**\n   * Check if we're running in Node.js\n   */\n  isNode() {\n    return typeof process !== \"undefined\" && process.versions && process.versions.node;\n  },\n  /**\n   * Check if we're running in Deno\n   */\n  isDeno() {\n    return typeof Deno !== \"undefined\";\n  },\n  /**\n   * Check if we're running in a server environment (Node.js or Deno)\n   */\n  isServer() {\n    return this.isNode() || this.isDeno();\n  },\n  /**\n   * Get environment name for debugging\n   */\n  getEnvironment() {\n    if (this.isBrowser())\n      return \"browser\";\n    if (this.isDeno())\n      return \"deno\";\n    if (this.isNode())\n      return \"node\";\n    return \"unknown\";\n  },\n  /**\n   * Require browser environment or throw error\n   */\n  requireBrowser(feature) {\n    if (!this.isBrowser()) {\n      throw new Error(`${feature} requires browser environment. Currently running in: ${this.getEnvironment()}`);\n    }\n  },\n  /**\n   * Get safe base URL for different environments\n   */\n  getSafeBaseUrl() {\n    if (this.isBrowser() && typeof document !== \"undefined\" && document.location) {\n      return new URL(\"./\", document.location.href).href;\n    }\n    return \"http://localhost:8080/\";\n  },\n  /**\n   * Safe postMessage wrapper\n   */\n  safePostMessage(target, message, origin = \"*\") {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.postMessage === \"function\") {\n      target.postMessage(message, origin);\n    } else {\n      console.warn(\"postMessage not available in current environment:\", this.getEnvironment());\n    }\n  },\n  /**\n   * Safe event listener management\n   */\n  safeAddEventListener(target, event, handler) {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.addEventListener === \"function\") {\n      target.addEventListener(event, handler);\n      return true;\n    }\n    return false;\n  },\n  safeRemoveEventListener(target, event, handler) {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.removeEventListener === \"function\") {\n      target.removeEventListener(event, handler);\n      return true;\n    }\n    return false;\n  }\n};\n\n\n//# sourceURL=webpack://HyphaCore/./src/utils/index.js?");

/***/ }),

/***/ "./src/utils/pluginParser.js":
/*!***********************************!*\
  !*** ./src/utils/pluginParser.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseComponent: () => (/* binding */ parseComponent)\n/* harmony export */ });\nvar splitRE = /\\r?\\n/g;\nvar emptyRE = /^\\s*$/;\nvar needFixRE = /^(\\r?\\n)*[\\t\\s]/;\nvar deIndent = function deindent(str) {\n  if (!needFixRE.test(str)) {\n    return str;\n  }\n  var lines = str.split(splitRE);\n  var min = Infinity;\n  var type, cur, c;\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    if (!emptyRE.test(line)) {\n      if (!type) {\n        c = line.charAt(0);\n        if (c === \" \" || c === \"\t\") {\n          type = c;\n          cur = count(line, type);\n          if (cur < min) {\n            min = cur;\n          }\n        } else {\n          return str;\n        }\n      } else {\n        cur = count(line, type);\n        if (cur < min) {\n          min = cur;\n        }\n      }\n    }\n  }\n  return lines.map(function(line2) {\n    return line2.slice(min);\n  }).join(\"\\n\");\n};\nfunction count(line, type) {\n  var i = 0;\n  while (line.charAt(i) === type) {\n    i++;\n  }\n  return i;\n}\nvar emptyObject = Object.freeze({});\nfunction isUndef(v) {\n  return v === void 0 || v === null;\n}\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || // $flow-disable-line\n  typeof value === \"symbol\" || typeof value === \"boolean\";\n}\nfunction isObject(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\nvar _toString = Object.prototype.toString;\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === \"[object Object]\";\n}\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction makeMap(str, expectsLowerCase) {\n  var map = /* @__PURE__ */ Object.create(null);\n  var list = str.split(\",\");\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function(val) {\n    return map[val.toLowerCase()];\n  } : function(val) {\n    return map[val];\n  };\n}\nvar isBuiltInTag = makeMap(\"slot,component\", true);\nvar isReservedAttribute = makeMap(\"key,ref,slot,slot-scope,is\");\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\nfunction cached(fn) {\n  var cache = /* @__PURE__ */ Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function(str) {\n  return str.replace(camelizeRE, function(_, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n});\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  boundFn._length = fn.length;\n  return boundFn;\n}\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\nfunction noop(a, b, c) {\n}\nvar no = function(a, b, c) {\n  return false;\n};\nvar identity = function(_) {\n  return _;\n};\nfunction genStaticKeys(modules) {\n  return modules.reduce(function(keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(\",\");\n}\nvar isUnaryTag = makeMap(\n  \"area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr\"\n);\nvar canBeLeftOpenTag = makeMap(\n  \"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source\"\n);\nvar isNonPhrasingTag = makeMap(\n  \"address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track\"\n);\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\w\\\\-\\\\.]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\nvar IS_REGEX_CAPTURING_BROKEN = false;\n\"x\".replace(/x(.)?/g, function(m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === \"\";\n});\nvar isPlainTextElement = makeMap(\"script,style,textarea\", true);\nvar reCache = {};\nvar decodingMap = {\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&amp;\": \"&\",\n  \"&#10;\": \"\\n\",\n  \"&#9;\": \"\t\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\nvar isIgnoreNewlineTag = makeMap(\"pre,textarea\", true);\nvar shouldIgnoreFirstNewline = function(tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === \"\\n\";\n};\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function(match) {\n    return decodingMap[match];\n  });\n}\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf(\"<\");\n      if (textEnd === 0) {\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf(\"-->\");\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(\"]>\");\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue;\n        }\n      }\n      var text = void 0, rest = void 0, next = void 0;\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          next = rest.indexOf(\"<\", 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n      if (textEnd < 0) {\n        text = html;\n        html = \"\";\n      }\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(\n        \"([\\\\s\\\\S]*?)(</\" + stackedTag + \"[^>]*>)\",\n        \"i\"\n      ));\n      var rest$1 = html.replace(reStackedTag, function(all, text2, endTag2) {\n        endTagLength = endTag2.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== \"noscript\") {\n          text2 = text2.replace(/<!\\--([\\s\\S]*?)-->/g, \"$1\").replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1\");\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text2)) {\n          text2 = text2.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text2);\n        }\n        return \"\";\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (!stack.length && options.warn) {\n        options.warn('Mal-formatted tag at end of template: \"' + html + '\"');\n      }\n      break;\n    }\n  }\n  parseEndTag();\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n    if (expectHTML) {\n      if (lastTag === \"p\" && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === \"\") {\n          delete args[3];\n        }\n        if (args[4] === \"\") {\n          delete args[4];\n        }\n        if (args[5] === \"\") {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || \"\";\n      var shouldDecodeNewlines = tagName === \"a\" && args[1] === \"href\" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs\n      });\n      lastTag = tagName;\n    }\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      pos = 0;\n    }\n    if (pos >= 0) {\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ((i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === \"br\") {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === \"p\") {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\nvar splitRE$1 = /\\r?\\n/g;\nvar replaceRE = /./g;\nvar isSpecialTag = makeMap(\"script,style,template\", true);\nfunction parseComponent(content, options) {\n  if (options === void 0)\n    options = {};\n  var sfc = {\n    script: [],\n    style: [],\n    config: [],\n    window: [],\n    docs: [],\n    attachment: [],\n    link: [],\n    others: []\n  };\n  var depth = 0;\n  var currentBlock = null;\n  function start(tag, attrs, unary, start2, end2) {\n    if (depth === 0) {\n      currentBlock = {\n        type: tag,\n        content: \"\",\n        start: end2,\n        attrs: attrs.reduce(function(cumulated, ref) {\n          var name = ref.name;\n          var value = ref.value;\n          cumulated[name] = value || true;\n          return cumulated;\n        }, {})\n      };\n      if (sfc[tag]) {\n        checkAttrs(currentBlock, attrs);\n        sfc[tag].push(currentBlock);\n      } else {\n        sfc.others.push(currentBlock);\n      }\n    }\n    if (!unary) {\n      depth++;\n    }\n  }\n  function checkAttrs(block, attrs) {\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (attr.name === \"lang\") {\n        block.lang = attr.value;\n      }\n      if (attr.name === \"scoped\") {\n        block.scoped = true;\n      }\n      if (attr.name === \"module\") {\n        block.module = attr.value || true;\n      }\n      if (attr.name === \"src\") {\n        block.src = attr.value;\n      }\n    }\n  }\n  function end(tag, start2, end2) {\n    if (depth === 1 && currentBlock) {\n      currentBlock.end = start2;\n      var text = deIndent(content.slice(currentBlock.start, currentBlock.end));\n      if (currentBlock.type !== \"template\" && options.pad) {\n        text = padContent(currentBlock, options.pad) + text;\n      }\n      currentBlock.content = text;\n      currentBlock = null;\n    }\n    depth--;\n  }\n  function padContent(block, pad) {\n    if (pad === \"space\") {\n      return content.slice(0, block.start).replace(replaceRE, \" \");\n    } else {\n      var offset = content.slice(0, block.start).split(splitRE$1).length;\n      var padChar = block.type === \"script\" && !block.lang ? \"//\\n\" : \"\\n\";\n      return Array(offset).join(padChar);\n    }\n  }\n  parseHTML(content, {\n    start,\n    end\n  });\n  return sfc;\n}\n\n\n//# sourceURL=webpack://HyphaCore/./src/utils/pluginParser.js?");

/***/ }),

/***/ "./src/utils/redis-mock.js":
/*!*********************************!*\
  !*** ./src/utils/redis-mock.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function() {\n  \"use strict\";\n  var root = this || globalThis;\n  var redismock2 = {};\n  function exists(v) {\n    return typeof v !== \"undefined\" && v !== null;\n  }\n  if (typeof exports !== \"undefined\") {\n    if ( true && module.exports) {\n      exports = module.exports = redismock2;\n    }\n    exports.redismock = redismock2;\n  } else {\n    root.redismock = redismock2;\n  }\n  if (typeof setImmediate === \"undefined\" || typeof setImmediate !== \"function\") {\n    var setImmediate = function(f) {\n      setTimeout(f, 0);\n    };\n  }\n  redismock2.Array = Array;\n  function SortedSet() {\n    this.scores = [];\n    this.set = {};\n    this.invset = {};\n    this.indices = {};\n    this.lengths = {};\n    this.card = 0;\n    return this;\n  }\n  SortedSet.prototype.add = function(score, member) {\n    var ret = 1;\n    if (exists(this.invset[member])) {\n      this.rem(member);\n      ret = 0;\n    }\n    if (!exists(this.set[score])) {\n      this.scores.push(score);\n      this.set[score] = [];\n      this.lengths[score] = 0;\n    }\n    this.set[score].push(member);\n    this.invset[member] = score;\n    this.indices[member] = this.set[score].length - 1;\n    this.lengths[score] += 1;\n    this.card += 1;\n    return ret;\n  };\n  SortedSet.prototype.rem = function(member) {\n    var score;\n    if (!exists(this.invset[member])) {\n      return 0;\n    }\n    score = this.invset[member];\n    this.set[score].splice(this.set[score].indexOf(member), 1);\n    this.lengths[score] -= 1;\n    if (this.lengths[score] === 0) {\n      this.set[score] = void 0;\n      this.scores.splice(this.scores.indexOf(score), 1);\n    }\n    this.invset[member] = void 0;\n    this.indices[member] = void 0;\n    this.card -= 1;\n    return 1;\n  };\n  SortedSet.prototype.sortScores = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(a, 10) - parseInt(b, 10);\n    });\n    return this;\n  };\n  SortedSet.prototype.sortScoresRev = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(b, 10) - parseInt(a, 10);\n    });\n    return this;\n  };\n  redismock2.SortedSet = function() {\n    return new SortedSet();\n  };\n  var cache = {};\n  var timeouts = {};\n  var subscribers = [];\n  var watchers = {};\n  var sets = \"sets-\" + Math.random();\n  var zsets = \"zsets-\" + Math.random();\n  var hashes = \"hashes-\" + Math.random();\n  cache[sets] = {};\n  cache[zsets] = {};\n  cache[hashes] = {};\n  String.prototype.escape = function() {\n    var escapable = /[.\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    var meta;\n    meta = {\n      // table of character substitutions\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      \".\": \"\\\\.\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    };\n    function escapechar(a) {\n      var c = meta[a];\n      return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n    }\n    return this.replace(escapable, escapechar);\n  };\n  function translate(pat) {\n    var i = 0, j, n = pat.length || 0, res, c, stuff;\n    res = \"^\";\n    while (i < n) {\n      c = pat[i];\n      i = i + 1;\n      if (c === \"*\") {\n        res = res + \".*\";\n      } else if (c === \"?\") {\n        res = res + \".\";\n      } else if (c === \"[\") {\n        j = i;\n        if (j < n && pat[j] === \"!\") {\n          j = j + 1;\n        }\n        if (j < n && pat[j] === \"]\") {\n          j = j + 1;\n        }\n        while (j < n && pat[j] !== \"]\") {\n          j = j + 1;\n        }\n        if (j >= n) {\n          res = res + \"\\\\[\";\n        } else {\n          stuff = pat.slice(i, j).replace(\"\\\\\", \"\\\\\\\\\");\n          i = j + 1;\n          if (stuff[0] === \"!\") {\n            stuff = \"^\" + stuff.slice(1);\n          } else if (stuff[0] === \"^\") {\n            stuff = \"\\\\\" + stuff;\n          }\n          res = res + \"[\" + stuff + \"]\";\n        }\n      } else {\n        res = res + c.escape();\n      }\n    }\n    return res + \"$\";\n  }\n  var cb = function(callback, context) {\n    return function() {\n      var args = arguments;\n      if (callback && typeof callback === \"function\") {\n        setImmediate(function() {\n          callback.apply(context, args);\n        });\n      }\n      if (args[0] instanceof Error) {\n        return args[0];\n      }\n      return args[1];\n    };\n  };\n  var gather = function() {\n    return function() {\n      var idx, len = arguments.length;\n      var callback;\n      var list = [];\n      for (idx = len - 1; idx >= 0; idx -= 1) {\n        if (!callback && typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        } else if (exists(arguments[idx])) {\n          list.unshift(arguments[idx]);\n        }\n      }\n      return {\n        callback,\n        list\n      };\n    };\n  };\n  var wrongType = function(callback) {\n    return cb(callback)(new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n  };\n  redismock2.ifType = function(key2, type, callback) {\n    var that = this;\n    return {\n      thenex: function(f) {\n        this._ifex = f;\n        return this;\n      },\n      thennx: function(f) {\n        this._ifnx = f;\n        return this;\n      },\n      then: function(f) {\n        this._then = f;\n        return this;\n      },\n      end: function() {\n        var ret;\n        if (that.exists(key2)) {\n          if (that.type(key2) !== type) {\n            return wrongType(callback);\n          }\n          if (typeof this._ifex === \"function\") {\n            ret = this._ifex.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        } else {\n          if (typeof this._ifnx === \"function\") {\n            ret = this._ifnx.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        }\n        if (typeof this._then === \"function\") {\n          ret = this._then.call(that);\n          if (ret && ret instanceof Error) {\n            return cb(callback)(ret);\n          }\n        }\n        return cb(callback)(null, ret);\n      }\n    };\n  };\n  redismock2.del = function(key2, callback) {\n    var that = this;\n    var count = 0;\n    var g = gather(this.del).apply(this, arguments);\n    callback = g.callback;\n    var deleter = function(k) {\n      if (that.exists(k)) {\n        if (k in cache) {\n          cache[k] = void 0;\n        } else if (k in cache[sets]) {\n          cache[sets][k] = void 0;\n        } else if (k in cache[zsets]) {\n          cache[zsets][k] = void 0;\n        } else if (k in cache[hashes]) {\n          cache[hashes][k] = void 0;\n        }\n        return 1;\n      }\n      return 0;\n    };\n    var toDelete = g.list;\n    if (typeof g.list[0] === \"object\") {\n      toDelete = g.list[0];\n    }\n    toDelete.forEach(function(k) {\n      count += deleter(k);\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.dump = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.exists = function(key2, callback) {\n    return cb(callback)(null, exists(cache[key2]) || exists(cache[sets][key2]) || exists(cache[zsets][key2]) || exists(cache[hashes][key2]) ? 1 : 0);\n  };\n  redismock2.expire = function(key2, seconds, callback) {\n    return this.pexpire(key2, seconds * 1e3, callback);\n  };\n  redismock2.expireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp * 1e3 - now.getTime(), callback);\n  };\n  redismock2.keys = function(pattern, callback) {\n    var keys = [], key2;\n    var regex = new RegExp(translate(pattern));\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    return cb(callback)(null, keys);\n  };\n  redismock2.migrate = function(host, port, key2, destination_db, timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.move = function(key2, db, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.object = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.persist = function(key2, callback) {\n    if (this.exists(key2) && timeouts[key2]) {\n      clearTimeout(timeouts[key2].timeout);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.pexpire = function(key2, milliseconds, callback) {\n    var that = this;\n    if (this.exists(key2)) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n      if (milliseconds <= 0) {\n        this.del(key2);\n      } else {\n        timeouts[key2] = {};\n        timeouts[key2].start = /* @__PURE__ */ new Date();\n        timeouts[key2].end = new Date(timeouts[key2].start.getTime() + milliseconds);\n        timeouts[key2].timeout = setTimeout(function() {\n          timeouts[key2] = void 0;\n          that.del(key2);\n        }, milliseconds);\n      }\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.pexpireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp - now.getTime(), callback);\n  };\n  redismock2.pttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, timeouts[key2].end.getTime() - now.getTime());\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock2.randomkey = function(callback) {\n    var rando = null;\n    function loop_through(count, looper) {\n      var key2;\n      for (key2 in looper) {\n        if (key2 === sets) {\n          count = loop_through(count, cache[sets]);\n          continue;\n        } else if (key2 === zsets) {\n          count = loop_through(count, cache[zsets]);\n          continue;\n        } else if (key2 === hashes) {\n          count = loop_through(count, cache[hashes]);\n          continue;\n        } else if (Math.random() < 1 / count) {\n          rando = key2;\n        }\n        count += 1;\n      }\n      return count;\n    }\n    loop_through(1, cache);\n    return cb(callback)(null, rando);\n  };\n  redismock2.rename = function(key2, newkey, callback) {\n    var type;\n    if (!this.exists(key2)) {\n      return cb(callback)(new Error(\"ERR no such key\"));\n    }\n    if (key2 === newkey) {\n      return cb(callback)(null, \"OK\");\n    }\n    type = this.type(key2);\n    if (type === \"string\" || type === \"list\") {\n      cache[newkey] = cache[key2];\n    } else if (type === \"set\") {\n      cache[sets][newkey] = cache[sets][key2];\n    } else if (type === \"zset\") {\n      cache[zsets][newkey] = cache[zsets][key2];\n    } else if (type === \"hash\") {\n      cache[hashes][newkey] = cache[hashes][key2];\n    }\n    this.del(key2);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.renamenx = function(key2, newkey, callback) {\n    var r;\n    if (this.exists(newkey)) {\n      return cb(callback)(null, 0);\n    }\n    r = this.rename(key2, newkey);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, 1);\n  };\n  redismock2.restore = function(key2, ttl, serialized_value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.sort = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.ttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, (timeouts[key2].end.getTime() - now.getTime()) / 1e3);\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock2.type = function(key2, callback) {\n    if (this.exists(key2)) {\n      var type = typeof cache[key2];\n      if (type === \"object\") {\n        if (cache[key2] instanceof Array) {\n          type = \"list\";\n        }\n      } else if (type === \"undefined\") {\n        if (key2 in cache[sets] && cache[sets][key2]) {\n          type = \"set\";\n        } else if (key2 in cache[zsets] && cache[zsets][key2]) {\n          type = \"zset\";\n        } else if (key2 in cache[hashes] && cache[hashes][key2]) {\n          type = \"hash\";\n        }\n      }\n      return cb(callback)(null, type);\n    }\n    return cb(callback)(null, \"none\");\n  };\n  redismock2.scan = function(cursor, callback) {\n    var g = gather(this.scan).apply(null, arguments);\n    var idx = 0;\n    var key2;\n    var reply = [];\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    for (key2 in cache) {\n      if (cache.hasOwnProperty(key2)) {\n        if (key2 === sets || key2 === zsets || key2 === hashes) {\n          continue;\n        }\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    if (!reply.length) {\n      idx = 0;\n    }\n    return cb(callback)(null, [idx, reply]);\n  };\n  redismock2.append = function(key2, value, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      cache[key2] += value;\n      return null;\n    }).thennx(function() {\n      return this.set(key2, value);\n    }).then(function() {\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.bitcount = function(key2, callback) {\n    var g = gather(this.bitcount).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length === 3) {\n      start = g.list[1];\n      end = g.list[2];\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var idx, n, count;\n      if (!exists(start)) {\n        start = 0;\n      }\n      if (!exists(end)) {\n        end = cache[key2].length - 1;\n      }\n      if (end >= cache[key2].length) {\n        end = cache[key2].length - 1;\n      }\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return 0;\n      }\n      count = 0;\n      for (idx = start; idx <= end; idx += 1) {\n        n = cache[key2].charCodeAt(idx);\n        while (n) {\n          count += n & 1;\n          n >>= 1;\n        }\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.bitop = function(operation, destkey, key2, callback) {\n    var that = this;\n    var g = gather(this.bitop).apply(this, arguments);\n    var longest, strings, string, r;\n    operation = typeof operation === \"string\" ? operation.toLowerCase() : \"\";\n    if (operation !== \"and\" && operation !== \"or\" && operation !== \"xor\" && operation !== \"not\") {\n      return cb(callback)(new Error(\"ERR syntax error\"));\n    }\n    callback = g.callback;\n    strings = g.list.slice(2).map(function(k) {\n      if (that.exists(k) && that.type(k) !== \"string\") {\n        return null;\n      }\n      return that.exists(k) ? cache[k] : \"\";\n    });\n    if (strings.some(function(str) {\n      return str === null;\n    })) {\n      return wrongType(callback);\n    }\n    longest = strings.reduce(function(length, str) {\n      return str.length > length ? str.length : length;\n    }, 0);\n    strings = strings.map(function(str) {\n      while (str.length < longest) {\n        str += \"\\0\";\n      }\n      return str;\n    });\n    string = strings.reduce(function(cur, str, index) {\n      var idx, n, s;\n      s = \"\";\n      for (idx = 0; idx < longest; idx += 1) {\n        if (operation === \"and\") {\n          n = cur.charCodeAt(idx) & str.charCodeAt(idx);\n        } else if (operation === \"or\") {\n          n = cur.charCodeAt(idx) | str.charCodeAt(idx);\n        } else if (operation === \"xor\") {\n          if (index > 0) {\n            n = cur.charCodeAt(idx) ^ str.charCodeAt(idx);\n          } else {\n            n = cur.charCodeAt(idx);\n          }\n        } else if (operation === \"not\") {\n          n = ~cur.charCodeAt(idx);\n        }\n        s += String.fromCharCode(n);\n      }\n      return s;\n    }, strings[0]);\n    r = this.set(destkey, string);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, string.length);\n  };\n  redismock2.bitpos = function(key2, bit, callback) {\n    var g = gather(this.bitpos).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length > 2) {\n      start = g.list[2];\n      end = g.list[3];\n    }\n    if (typeof start === \"undefined\") {\n      start = 0;\n    }\n    if (bit !== 0 && bit !== 1) {\n      return cb(callback)(new Error(\"ERR The bit argument must be 1 or 0.\"));\n    }\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      if (bit === 0) {\n        return 0;\n      }\n      return -1;\n    }).thenex(function() {\n      var idx, ch, cnt, noend = false;\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (typeof end === \"undefined\") {\n        noend = true;\n        end = cache[key2].length - 1;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return -1;\n      }\n      for (idx = start; idx <= end; idx += 1) {\n        ch = cache[key2].charCodeAt(idx);\n        cnt = 0;\n        while (cnt < 8) {\n          if (bit === 0 && (ch & 128) !== 128) {\n            return idx * 8 + cnt;\n          }\n          if (bit === 1 && (ch & 128) === 128) {\n            return idx * 8 + cnt;\n          }\n          ch <<= 1;\n          cnt += 1;\n        }\n      }\n      if (bit === 1) {\n        return -1;\n      }\n      if (bit === 0 && noend) {\n        return idx * 8;\n      }\n      return -1;\n    }).end();\n  };\n  redismock2.decr = function(key2, callback) {\n    return this.decrby(key2, 1, callback);\n  };\n  redismock2.decrby = function(key2, decrement, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt - decrement);\n      return asInt - decrement;\n    }).end();\n  };\n  redismock2.get = function(key2, callback) {\n    if (this.type(key2) === \"string\") {\n      return cb(callback)(null, cache[key2]);\n    }\n    return cb(callback)(null, null);\n  };\n  redismock2.getbit = function(key2, offset, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var n, pos;\n      if (offset >= cache[key2].length * 8) {\n        return 0;\n      }\n      n = cache[key2].charCodeAt(Math.floor(offset / 8));\n      pos = offset % 8;\n      return n >> pos & 1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.getrange = function(key2, start, end, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var len = 0;\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start < 0) {\n        len = end - (cache[key2].length + start) + 1;\n      } else {\n        len = end - start + 1;\n      }\n      return cache[key2].substr(start, len);\n    }).thennx(function() {\n      return \"\";\n    }).end();\n  };\n  redismock2.getset = function(key2, value, callback) {\n    var prev = this.get(key2);\n    this.set(key2, value);\n    return cb(callback)(null, prev);\n  };\n  redismock2.incr = function(key2, callback) {\n    return this.incrby(key2, 1, callback);\n  };\n  redismock2.incrby = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return asInt + increment;\n    }).end();\n  };\n  redismock2.incrbyfloat = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseFloat(this.get(key2));\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return this.get(key2);\n    }).end();\n  };\n  redismock2.mget = function(key2, callback) {\n    var g = gather(this.mget).apply(this, arguments);\n    callback = g.callback;\n    var data = typeof g.list[0] === \"object\" ? g.list[0] : g.list;\n    return cb(callback)(null, data.map(function(k) {\n      return cache[k] || null;\n    }));\n  };\n  redismock2.mset = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.mset).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.msetnx = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.msetnx).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    if (kvs.some(function(kv) {\n      return that.exists(kv[0]);\n    })) {\n      return cb(callback)(null, 0);\n    }\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, 1);\n  };\n  redismock2.psetex = function(key2, milliseconds, value, callback) {\n    this.set(key2, value);\n    this.pexpire(key2, milliseconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.set = function(key2, value, callback) {\n    var nx = false, xx = false, ex = -1, px = -1;\n    var g = gather(this.set).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (opt === \"nx\" || opt === \"NX\") {\n        nx = true;\n      } else if (opt === \"xx\" || opt === \"XX\") {\n        xx = true;\n      } else if (opt === \"ex\" || opt === \"EX\") {\n        ex = g.list[index + 1];\n      } else if (opt === \"px\" || opt === \"PX\") {\n        px = g.list[index + 1];\n      }\n    });\n    if (nx) {\n      if (this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    if (xx) {\n      if (!this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    cache[key2] = exists(value) ? value.toString() : \"\";\n    if (px !== -1) {\n      redismock2.pexpire(key2, px);\n    }\n    if (ex !== -1) {\n      redismock2.expire(key2, ex);\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.setbit = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var byteIdx = Math.floor(offset / 8);\n      var bitIdx = offset % 8;\n      var idx, bit, mask;\n      var code;\n      if (value !== 0 && value !== 1) {\n        return new Error(\"ERR bit is not an integer or out of range\");\n      }\n      while (cache[key2].length < byteIdx + 1) {\n        cache[key2] += \"\\0\";\n      }\n      code = cache[key2].charCodeAt(byteIdx);\n      idx = 0;\n      mask = 128;\n      while (idx < bitIdx) {\n        mask >>= 1;\n        idx += 1;\n      }\n      bit = (code & mask) === 0 ? 0 : 1;\n      if (value === 0) {\n        code = code & ~mask;\n      } else {\n        code = code | mask;\n      }\n      cache[key2] = cache[key2].substr(0, byteIdx) + String.fromCharCode(code) + cache[key2].substr(byteIdx + 1);\n      return bit;\n    }).end();\n  };\n  redismock2.setex = function(key2, seconds, value, callback) {\n    this.set(key2, value);\n    this.expire(key2, seconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.setnx = function(key2, value, callback) {\n    if (!this.exists(key2)) {\n      this.set(key2, value);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.setrange = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var idx, newValue;\n      if (cache[key2].length < offset + value.length - 1) {\n        for (idx = cache[key2].length; idx < offset + value.length; idx += 1) {\n          cache[key2] += \"\\0\";\n        }\n      }\n      newValue = cache[key2].substr(0, offset);\n      for (idx = offset; idx < offset + value.length; idx += 1) {\n        newValue += value[idx - offset];\n      }\n      newValue += cache[key2].substr(offset + value.length);\n      cache[key2] = newValue;\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.strlen = function(key2, callback) {\n    if (!this.exists(key2)) {\n      return cb(callback)(null, 0);\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.blpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.blpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    var f, timedout = false;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.lpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.brpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.brpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    var f, timedout = false;\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.rpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.brpoplpush = function(source, destination, timeout, callback) {\n    var that = this;\n    var f, timedout = false;\n    f = function() {\n      var len;\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      len = that.llen(source);\n      if (len instanceof Error) {\n        return cb(callback)(len);\n      }\n      if (len > 0) {\n        that.rpoplpush(source, destination, callback);\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.lindex = function(key2, i, callback) {\n    var elem = null;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (i >= 0 && i < cache[key2].length) {\n        elem = cache[key2][i];\n      } else if (i < 0 && cache[key2].length + 1 >= 0) {\n        elem = cache[key2][cache[key2].length + i];\n      }\n    }).then(function() {\n      return elem;\n    }).end();\n  };\n  redismock2.linsert = function(key2, beforeafter, pivot, value, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx = cache[key2].indexOf(pivot);\n      if (idx !== -1) {\n        if (beforeafter === \"before\") {\n          cache[key2].splice(idx, 0, value);\n        } else if (beforeafter === \"after\") {\n          cache[key2].splice(idx + 1, 0, value);\n        }\n        return cache[key2].length;\n      }\n      return -1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.llen = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.lpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].shift();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.lpush = function(key2, element, callback) {\n    var g = gather(this.lpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock2.Array();\n    }).then(function() {\n      g.list.slice(1).forEach(function(elem) {\n        cache[key2].unshift(elem);\n      });\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.lpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].unshift(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.lrange = function(key2, start, end, callback) {\n    var l = [];\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (start > cache[key2].length - 1) {\n        l = [];\n      } else {\n        if (start < 0) {\n          start = cache[key2].length + start;\n        }\n        if (end < 0) {\n          end = cache[key2].length + end;\n        }\n        if (start > end) {\n          l = [];\n        } else {\n          l = cache[key2].slice(start, end + 1);\n        }\n      }\n    }).then(function() {\n      return l;\n    }).end();\n  };\n  redismock2.lrem = function(key2, count, element, callback) {\n    var cnt = 0;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx;\n      while (true) {\n        idx = cache[key2].indexOf(element);\n        if (idx === -1) {\n          break;\n        }\n        cache[key2].splice(idx, 1);\n        cnt += 1;\n        if (count > 0 && cnt === count) {\n          break;\n        }\n      }\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return cnt;\n    }).end();\n  };\n  redismock2.lset = function(key2, index, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (index >= cache[key2].length) {\n        return new Error(\"ERR index out of range\");\n      }\n      cache[key2][index] = element;\n      return \"OK\";\n    }).thennx(function() {\n      return new Error(\"ERR no such key\");\n    }).end();\n  };\n  redismock2.ltrim = function(key2, start, end, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var tmpS, tmpE;\n      if (start > cache[key2].length - 1 || start > end) {\n        cache[key2] = new redismock2.Array();\n      } else {\n        if (start < 0 && end < 0) {\n          tmpE = cache[key2].length + end;\n          tmpS = cache[key2].length + start;\n          if (tmpS < 0) {\n            tmpS = 0;\n          }\n          start = tmpS;\n          end = tmpE;\n        }\n        if (end > cache[key2].length - 1) {\n          end = cache[key2].length - 1;\n        }\n        cache[key2] = cache[key2].slice(start, end + 1);\n      }\n    }).then(function() {\n      if (this.exists(key2) && !cache[key2].length) {\n        this.del(key2);\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock2.rpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].pop();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.rpoplpush = function(source, dest, callback) {\n    var element = null, reply;\n    if (this.exists(source) && this.type(source) !== \"list\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"list\") {\n      return wrongType(callback);\n    }\n    element = this.rpop(source);\n    if (element instanceof Error) {\n      return cb(callback)(element);\n    }\n    if (element) {\n      reply = this.lpush(dest, element);\n      if (reply instanceof Error) {\n        return cb(callback)(reply);\n      }\n    }\n    return cb(callback)(null, element);\n  };\n  redismock2.rpush = function(key2, element, callback) {\n    var g = gather(this.rpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock2.Array();\n    }).then(function() {\n      cache[key2] = cache[key2].concat(g.list.slice(1));\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.rpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].push(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.sadd = function(key2, member, callback) {\n    var g = gather(this.sadd).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      cache[sets][key2] = {};\n    }).then(function() {\n      g.list.slice(1).forEach(function(m) {\n        m = m ? m.toString() : \"\";\n        if (m.length === 0) {\n          return;\n        }\n        if (!(m in cache[sets][key2])) {\n          cache[sets][key2][m] = \"\";\n          count += 1;\n        }\n      });\n      return count;\n    }).end();\n  };\n  redismock2.scard = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]).length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.sdiff = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sdiff).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(diff, k) {\n        return diff.filter(function(d) {\n          return !(d in cache[sets][k]);\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock2.sdiffstore = function(destination, key2, callback) {\n    var g = gather(this.sdiffstore).apply(this, arguments);\n    var diff = this.sdiff.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (diff instanceof Error) {\n      return cb(callback)(diff);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    this.sadd.apply(this, [destination].concat(diff));\n    return cb(callback)(null, diff.length);\n  };\n  redismock2.sinter = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sinter).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(inter, k) {\n        return inter.filter(function(i) {\n          return i in cache[sets][k];\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock2.sinterstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sinterstore).apply(this, arguments);\n    var inter = this.sinter.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (inter instanceof Error) {\n      return cb(callback)(inter);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    inter.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, inter.length);\n  };\n  redismock2.sismember = function(key2, member, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return member in cache[sets][key2] ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.smembers = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]);\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.smove = function(source, dest, member, callback) {\n    var r, e;\n    if (this.exists(source) && this.type(source) !== \"set\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"set\") {\n      return wrongType(callback);\n    }\n    r = redismock2.srem(source, member);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    if (r === 1) {\n      e = redismock2.sadd(dest, member);\n      if (e instanceof Error) {\n        return cb(callback)(e);\n      }\n    }\n    return cb(callback)(null, r);\n  };\n  redismock2.spop = function(key2, callback) {\n    var r;\n    var rando = this.srandmember(key2);\n    if (rando instanceof Error) {\n      return cb(callback)(rando);\n    }\n    r = this.srem(key2, rando);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, rando);\n  };\n  redismock2.srandmember = function(key2, callback) {\n    var that = this;\n    var count;\n    if (arguments.length === 2 && typeof callback !== \"function\") {\n      count = callback;\n      callback = null;\n    }\n    if (arguments.length === 3) {\n      count = callback;\n      callback = arguments[2];\n    }\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      var k = Object.keys(cache[sets][key2]);\n      var randos, rando;\n      var len = that.scard(key2);\n      if (count === 0) {\n        return null;\n      }\n      if (count) {\n        randos = [];\n        while (randos.length < Math.abs(count)) {\n          rando = k[Math.floor(Math.random() * k.length)];\n          if (count < 0) {\n            randos.push(rando);\n          } else {\n            if (randos.indexOf(rando) === -1) {\n              randos.push(rando);\n              if (randos.length === len) {\n                break;\n              }\n            }\n          }\n        }\n        return randos;\n      }\n      return k[Math.floor(Math.random() * k.length)];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.srem = function(key2, member, callback) {\n    var g = gather(this.srem).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      g.list.slice(1).forEach(function(m) {\n        var k = m ? m.toString() : \"\";\n        if (k in cache[sets][key2]) {\n          delete cache[sets][key2][k];\n          count += 1;\n        }\n      });\n      if (!Object.keys(cache[sets][key2]).length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock2.sunion = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sunion).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return Object.keys(g.list.reduce(function(set, k) {\n        Object.keys(cache[sets][k]).filter(function(u) {\n          return !(u in set);\n        }).forEach(function(u) {\n          set[u] = \"\";\n        });\n        return set;\n      }, {}));\n    }).end();\n  };\n  redismock2.sunionstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sunionstore).apply(this, arguments);\n    var union = this.sunion.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (union instanceof Error) {\n      return cb(callback)(union);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    union.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, union.length);\n  };\n  redismock2.sscan = function(key2, cursor, callback) {\n    var g = gather(this.sscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).then(function() {\n      var arr = [];\n      this.smembers(key2).slice(cursor).some(function(member) {\n        if (typeof match === \"undefined\" || member.match(match)) {\n          arr.push(member);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.zadd = function(key2, score, member, callback) {\n    var g = gather(this.zadd).apply(this, arguments);\n    callback = g.callback;\n    g.list = g.list.slice(1);\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock2.SortedSet();\n    }).then(function() {\n      var count = g.list.map(function(elem, index) {\n        if (index % 2 === 0) {\n          return [parseFloat(g.list[index]), g.list[index + 1]];\n        }\n        return null;\n      }).filter(function(elem) {\n        return elem !== null;\n      }).map(function(sm) {\n        return cache[zsets][key2].add(sm[0], sm[1].toString());\n      }).reduce(function(cnt, ret) {\n        return cnt + ret;\n      }, 0);\n      return count;\n    }).end();\n  };\n  redismock2.zcard = function(key2, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      return cache[zsets][key2].card;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zcount = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = cache[zsets][key2].scores.filter(function(score) {\n        return min <= score && score <= max;\n      }).reduce(function(cnt, score) {\n        return cnt + cache[zsets][key2].lengths[score];\n      }, 0);\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zincrby = function(key2, increment, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock2.SortedSet();\n    }).then(function() {\n      var newScore, score;\n      if (!exists(cache[zsets][key2].invset[member])) {\n        this.zadd(key2, increment, member);\n        return increment;\n      }\n      score = cache[zsets][key2].invset[member];\n      newScore = score + increment;\n      this.zadd(key2, newScore, member);\n      return newScore;\n    }).end();\n  };\n  redismock2.zinterstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zinterstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(inter, k) {\n      var arr = [];\n      var idx, len = inter.length;\n      var score, ms;\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        score = cache[zsets][k].invset[inter[idx]];\n        if (!exists(score)) {\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        ms = [inter[idx + 1], inter[idx]];\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, inter) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, inter[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.zlexcount = function(key2, min, max, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock2.zrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = Math.max(this.zcard(key2) + start, 0);\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].lengths[score] > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].lengths[score];\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        while (from < to) {\n          if (exists(cache[zsets][key2].set[score][from])) {\n            arr.push(cache[zsets][key2].set[score][from]);\n          }\n          from += 1;\n        }\n        arr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrangebylex = function(key2, min, max, callback) {\n    function verify(r) {\n      return typeof r === \"string\" && (r.charAt(0) === \"(\" || r.charAt(0) === \"[\" || r.charAt(0) === \"-\" || r.charAt(0) === \"+\");\n    }\n    if (!verify(min) || !verify(max)) {\n      return cb(callback)(new Error(\"ERR min or max not valid string range item\"));\n    }\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      var minStr = min.substr(1), maxStr = max.substr(1);\n      var minInclusive = min.charAt(0) === \"[\", maxInclusive = max.charAt(0) === \"[\";\n      var maxAll = max.charAt(0) === \"+\";\n      var range = [];\n      if (min.charAt(0) === \"+\") {\n        return [];\n      }\n      if (max.charAt(0) === \"-\") {\n        return [];\n      }\n      cache[zsets][key2].scores.forEach(function(score) {\n        cache[zsets][key2].set[score].forEach(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if (member > minStr && (member < maxStr || maxAll)) {\n            range.push(member);\n          } else if (member === minStr && minInclusive) {\n            range.push(member);\n          } else if (member === maxStr && maxInclusive) {\n            range.push(member);\n          }\n        });\n      });\n      range.sort(function(a, b) {\n        return a.localeCompare(b);\n      });\n      return range;\n    }).end();\n  };\n  redismock2.zrevrangebylex = function(key2, max, min, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.reverse());\n  };\n  redismock2.zrangebyscore = function(key2, min, max, callback) {\n    var withscores = false;\n    var limitOffset = -1, limitCount = -1;\n    var idx, len;\n    var arr = [], offset, count;\n    var minInclusive = true, maxInclusive = true;\n    if (typeof callback !== \"function\") {\n      len = arguments.length;\n      for (idx = 3; idx < len; idx += 1) {\n        if (arguments[idx] === \"withscores\") {\n          withscores = true;\n        }\n        if (typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        }\n        if (arguments[idx] === \"limit\") {\n          limitOffset = arguments[idx + 1];\n          limitCount = arguments[idx + 2];\n        }\n      }\n    }\n    if (min === \"-inf\") {\n      min = Number.NEGATIVE_INFINITY;\n    }\n    if (min === \"+inf\") {\n      min = Number.POSITIVE_INFINITY;\n    }\n    if (max === \"-inf\") {\n      max = Number.NEGATIVE_INFINITY;\n    }\n    if (max === \"+inf\") {\n      max = Number.POSITIVE_INFINITY;\n    }\n    if (min.toString().charAt(0) === \"(\") {\n      minInclusive = false;\n      min = parseFloat(min.toString().substr(1));\n    }\n    if (max.toString().charAt(0) === \"(\") {\n      maxInclusive = false;\n      max = parseFloat(max.toString().substr(1));\n    }\n    offset = 0;\n    count = 0;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        var memberArr = [], scoreArr = [], concatArr = [];\n        cache[zsets][key2].set[score].some(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if ((minInclusive && min <= score || !minInclusive && min < score) && (maxInclusive && score <= max || !maxInclusive && score < max)) {\n            if (limitOffset !== -1 && offset >= limitOffset) {\n              if (limitCount !== -1) {\n                if (count + memberArr.length < limitCount) {\n                  memberArr.push(member);\n                  if (withscores) {\n                    scoreArr.push(score);\n                  }\n                } else {\n                  return true;\n                }\n              }\n            } else if (limitOffset === -1) {\n              memberArr.push(member);\n              if (withscores) {\n                scoreArr.push(score);\n              }\n            }\n          }\n          offset += 1;\n          return false;\n        });\n        count += memberArr.length;\n        memberArr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          memberArr.forEach(function(m, idx2) {\n            concatArr.push(m, scoreArr[idx2]);\n          });\n        } else {\n          concatArr = memberArr;\n        }\n        arr = arr.concat(concatArr);\n        if (limitCount !== -1 && count === limitCount) {\n          return true;\n        }\n        return false;\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx = 0;\n      var found;\n      cache[zsets][key2].sortScores();\n      found = cache[zsets][key2].scores.some(function(score) {\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return true;\n        }\n        idx += 1;\n        return false;\n      });\n      if (!found) {\n        return null;\n      }\n      return idx;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zrem = function(key2, member, callback) {\n    var g = gather(this.zrem).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = g.list.reduce(function(cnt, m) {\n        return cnt + cache[zsets][key2].rem(m);\n      }, 0);\n      if (cache[zsets][key2].scores.length === 0) {\n        this.del(key2);\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zremrangebylex = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebylex(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock2.zremrangebyrank = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var that = this;\n      var idx, len = cache[zsets][key2].scores.length, jdx, nel;\n      var cnt;\n      var score;\n      var toRem = [];\n      var card = this.zcard(key2);\n      if (min < 0) {\n        min = card + min;\n      }\n      if (max < 0) {\n        max = card + max;\n      }\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = 0; idx < len; idx += 1) {\n        score = cache[zsets][key2].scores[idx];\n        nel = cache[zsets][key2].set[score].length;\n        for (jdx = 0; jdx < nel; jdx += 1, cnt += 1) {\n          if (min <= cnt && cnt <= max) {\n            toRem.push(cache[zsets][key2].set[score][jdx]);\n          }\n          if (cnt > max) {\n            break;\n          }\n        }\n        if (cnt > max) {\n          break;\n        }\n      }\n      toRem.forEach(function(r) {\n        that.zrem(key2, r);\n      });\n      return toRem.length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zremrangebyscore = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebyscore(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock2.zrevrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = this.zcard(key2) + start;\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScoresRev().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].set[score].length > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].set[score].length;\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        arr = cache[zsets][key2].set[score].slice(from, to);\n        arr.sort(function(a, b) {\n          return b.localeCompare(a);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrevrangebyscore = function(key2, max, min, callback) {\n    var g = gather(this.zrevrangebyscore).apply(this, arguments);\n    var r, tmpM;\n    callback = g.callback;\n    tmpM = g.list[1];\n    g.list[1] = g.list[2];\n    g.list[2] = tmpM;\n    r = this.zrangebyscore.apply(this, g.list);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    r.reverse();\n    if (g.list.some(function(arg) {\n      return arg === \"withscores\";\n    })) {\n      r = r.map(function(e, idx) {\n        if (idx % 2 === 0) {\n          return r[idx + 1];\n        }\n        return r[idx - 1];\n      });\n    }\n    return cb(callback)(null, r);\n  };\n  redismock2.zrevrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx, len = cache[zsets][key2].scores.length, cnt;\n      var score;\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = len - 1; idx >= 0; idx -= 1, cnt += 1) {\n        score = cache[zsets][key2].scores[idx];\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return cnt;\n        }\n      }\n      return null;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zscore = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var score = null;\n      if (exists(cache[zsets][key2].invset[member])) {\n        score = cache[zsets][key2].invset[member];\n      }\n      return score;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zunionstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zunionstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2, 2 + numkeys).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(union, k) {\n      var arr = [];\n      var idx, len = union.length;\n      var score, ms;\n      var hashk = cache[zsets][k].invset;\n      var hashu = {};\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        ms = [union[idx + 1], union[idx]];\n        score = cache[zsets][k].invset[union[idx]];\n        hashu[ms[1]] = ms[0];\n        if (!exists(score)) {\n          arr.push(ms[1], ms[0]);\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      Object.keys(hashk).forEach(function(member) {\n        if (!exists(hashk[member])) {\n          return;\n        }\n        if (!(member in hashu)) {\n          score = hashk[member];\n          if (k in weights) {\n            score *= weights[k];\n          }\n          arr.push(member, score);\n        }\n      });\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, union) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, union[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.zscan = function(key2, cursor, callback) {\n    var g = gather(this.zscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).then(function() {\n      var arr = [];\n      var cnt = 0;\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        cache[zsets][key2].set[score].some(function(member) {\n          if (cursor <= cnt) {\n            if (typeof match === \"undefined\" || member.match(match)) {\n              arr.push([member, score]);\n            }\n            cursor += 1;\n          }\n          if (arr.length >= count) {\n            return true;\n          }\n          cnt += 1;\n          return false;\n        });\n        if (arr.length >= count) {\n          return true;\n        }\n        return false;\n      });\n      arr = arr.reduce(function(unnested, ms) {\n        return unnested.concat(ms);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.hdel = function(key2, field, callback) {\n    var count = 0;\n    var g = gather(this.hdel).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list.forEach(function(field2) {\n        if (field2 in cache[hashes][key2]) {\n          cache[hashes][key2][field2] = void 0;\n          count += 1;\n        }\n      });\n      if (Object.keys(cache[hashes][key2]).length === 0) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock2.hexists = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field] !== void 0 ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.hget = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.hgetall = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var obj = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        prev[fv[0]] = fv[1];\n        return prev;\n      }, {});\n      return obj;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.hgetall_array = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var arr = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hincrby = function(key2, field, increment, callback) {\n    increment = parseInt(increment, 10);\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseInt(this.hget(key2, field), 10);\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not an integer\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock2.hincrbyfloat = function(key2, field, increment, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseFloat(this.hget(key2, field));\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not a valid float\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock2.hkeys = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return Object.keys(cache[hashes][key2]).filter(function(f) {\n        return cache[hashes][key2][f] !== void 0;\n      });\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hlen = function(key2, callback) {\n    var r = this.hkeys(key2);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock2.hmget = function(key2, field, callback) {\n    var g = gather(this.hmget).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list = g.list.slice(1);\n      var arr = g.list.map(function(f) {\n        return cache[hashes][key2][f];\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hmset = function(key2, field, callback) {\n    var g = gather(this.hmset).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var that = this;\n      var first = g.list[1];\n      if (g.list.length === 2 && typeof first === \"object\" && !(first instanceof Array)) {\n        Object.keys(first).forEach(function(fv) {\n          that.hset(key2, fv, first[fv]);\n        });\n      } else {\n        g.list = g.list.slice(1);\n        g.list.map(function(fv, index) {\n          if (index % 2 === 0) {\n            return [fv, g.list[index + 1]];\n          }\n          return null;\n        }).filter(function(fv) {\n          return fv !== null;\n        }).forEach(function(fv) {\n          that.hset(key2, fv[0], fv[1]);\n        });\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock2.hset = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n      } else {\n        ret = 1;\n      }\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      cache[hashes][key2][field] = value;\n      return ret;\n    }).end();\n  };\n  redismock2.hsetnx = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n        return;\n      }\n      ret = 1;\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      if (ret === 1) {\n        cache[hashes][key2][field] = value;\n      }\n      return ret;\n    }).end();\n  };\n  redismock2.hstrlen = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      return 0;\n    }).thenex(function() {\n      if (!exists(cache[hashes][key2][field])) {\n        return 0;\n      }\n      return cache[hashes][key2][field].toString().length;\n    }).end();\n  };\n  redismock2.hvals = function(key2, callback) {\n    var vals = [];\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      vals = Object.keys(cache[hashes][key2]).filter(function(field) {\n        return cache[hashes][key2][field] !== void 0;\n      }).map(function(field) {\n        return cache[hashes][key2][field];\n      });\n    }).then(function() {\n      return vals;\n    }).end();\n  };\n  redismock2.hscan = function(key2, cursor, callback) {\n    var g = gather(this.hscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).then(function() {\n      var arr = [];\n      this.hgetall_array(key2).slice(cursor * 2).some(function(forv, index, hgetall) {\n        if (index % 2 !== 0) {\n          return false;\n        }\n        if (typeof match === \"undefined\" || forv.match(match)) {\n          arr.push([forv, hgetall[index + 1]]);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      arr = arr.reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.on = function(event, callback) {\n    if (!exists(this.listeners)) {\n      this.listeners = {};\n    }\n    if (!exists(this.listeners[event])) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n    return this;\n  };\n  function emit(rm, event) {\n    var g = gather(emit).apply(null, arguments);\n    if (exists(rm.listeners) && exists(rm.listeners[event])) {\n      rm.listeners[event].forEach(function(cb2) {\n        setImmediate(function() {\n          cb2.apply(rm, g.list.slice(2));\n        });\n      });\n    }\n  }\n  function Subscriber(rm) {\n    this.rm = rm;\n    return this;\n  }\n  Subscriber.prototype.subscribe = function(channel) {\n    this.channel = channel;\n    emit(this.rm, \"subscribe\", channel, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.psubscribe = function(pattern) {\n    this.originalPattern = pattern;\n    this.pattern = new RegExp(translate(pattern));\n    emit(this.rm, \"psubscribe\", pattern, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.matches = function(channel) {\n    if (exists(this.channel) && this.channel === channel) {\n      return true;\n    }\n    if (exists(this.pattern) && channel.match(this.pattern)) {\n      return true;\n    }\n    return false;\n  };\n  Subscriber.prototype.message = function(channel, message) {\n    if (this.matches(channel)) {\n      if (exists(this.channel)) {\n        emit(this.rm, \"message\", channel, message);\n        return true;\n      } else if (exists(this.pattern)) {\n        emit(this.rm, \"pmessage\", this.originalPattern, channel, message);\n        return true;\n      }\n    }\n    return false;\n  };\n  Subscriber.prototype.unsubscribe = function(count) {\n    if (exists(this.channel)) {\n      emit(this.rm, \"unsubscribe\", this.channel, count);\n    }\n    if (exists(this.pattern)) {\n      emit(this.rm, \"punsubscribe\", this.originalPattern, count);\n    }\n    return this;\n  };\n  redismock2.psubscribe = function(pattern, callback) {\n    var that = this;\n    var g = gather(this.psubscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(pat) {\n      subscribers.push(new Subscriber(that).psubscribe(pat));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.pubsub = function(subcommand, callback) {\n    var g = gather(this.pubsub).apply(this, arguments);\n    var ret = null, pat;\n    if (subcommand === \"channels\") {\n      if (g.list[1]) {\n        pat = new RegExp(translate(g.list[1]));\n      }\n      ret = subscribers.map(function(subscriber) {\n        if (exists(subscriber.channel) && (!pat || subscriber.channel.match(pat))) {\n          return subscriber.channel;\n        }\n        return null;\n      }).filter(function(channel) {\n        return channel !== null;\n      });\n    } else if (subcommand === \"numsub\") {\n      ret = g.list.slice(1).map(function(channel) {\n        return subscribers.reduce(function(count, subscriber) {\n          if (subscriber.channel === channel) {\n            return count + 1;\n          }\n          return count;\n        }, 0);\n      }).reduce(function(flattened, cc) {\n        return flattened.concat(cc);\n      }, []);\n    } else if (subcommand === \"numpat\") {\n      ret = subscribers.reduce(function(count, subscriber) {\n        if (exists(subscriber.pattern)) {\n          return count + 1;\n        }\n        return count;\n      }, 0);\n    }\n    callback = g.callback;\n    return cb(callback)(null, ret);\n  };\n  redismock2.publish = function(channel, message, callback) {\n    var count = subscribers.reduce(function(cnt, subscriber) {\n      if (subscriber.message(channel.toString(), message.toString())) {\n        return cnt + 1;\n      }\n      return cnt;\n    }, 0);\n    return cb(callback)(null, count);\n  };\n  redismock2.punsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.punsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.pattern)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.pattern);\n      });\n    } else {\n      g.list.forEach(function(pattern) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.originalPattern === pattern) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.subscribe = function(channel, callback) {\n    var that = this;\n    var g = gather(this.subscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(chan) {\n      subscribers.push(new Subscriber(that).subscribe(chan));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.unsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.unsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.channel)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.channel);\n      });\n    } else {\n      g.list.forEach(function(chan) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.channel === chan) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n          }\n          return subscriber.channel !== chan;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.discard = function(callback) {\n    return cb(callback)(new Error(\"ERR DISCARD without MULTI\"));\n  };\n  redismock2.multi = function(commands) {\n    var rc = {};\n    var that = this;\n    var toApply = [], replies = [];\n    if (exists(commands)) {\n      toApply = toApply.concat(commands.map(function(command) {\n        var args = command.slice(1);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        return [command[0], that[command[0]], that, args];\n      }));\n    }\n    Object.keys(this).forEach(function(key2) {\n      rc[key2] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        toApply.push([key2, that[key2], that, args]);\n        return this;\n      };\n    });\n    rc.exec = function(callback) {\n      if (toApply.some(function(apply) {\n        var check = apply[3][0];\n        if (exists(watchers[check]) && watchers[check].modified && watchers[check].watchers.indexOf(that) !== -1) {\n          return true;\n        }\n        return false;\n      })) {\n        that.unwatch();\n        return cb(callback)(null, null);\n      }\n      toApply.forEach(function(apply) {\n        apply[1].apply(apply[2], apply[3]);\n      });\n      that.unwatch();\n      return cb(callback)(null, replies);\n    };\n    rc.discard = function(callback) {\n      toApply = [];\n      that.unwatch();\n      return cb(callback)(null, \"OK\");\n    };\n    return rc;\n  };\n  redismock2.unwatch = function(callback) {\n    var that = this;\n    Object.keys(watchers).forEach(function(k) {\n      if (exists(watchers[k])) {\n        watchers[k].watchers = watchers[k].watchers.filter(function(mock) {\n          return that !== mock;\n        });\n        if (watchers[k].watchers.length === 0) {\n          watchers[k] = void 0;\n        }\n      }\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.watch = function(key2, callback) {\n    if (!exists(watchers[key2])) {\n      watchers[key2] = {\n        modified: false,\n        watchers: []\n      };\n    }\n    watchers[key2].watchers.push(this);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.eval = function(script, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.evalsha = function(sha1, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_exists = function(script, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_flush = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_load = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.auth = function(password, callback) {\n    if (!redismock2.password) {\n      return cb(callback)(new Error(\"ERR Client sent AUTH, but no password is set\"));\n    }\n    if (password === redismock2.password) {\n      return cb(callback)(null, \"OK\");\n    }\n    return cb(callback)(new Error(\"ERR invalid password\"));\n  };\n  redismock2.echo = function(message, callback) {\n    return cb(callback)(null, message);\n  };\n  redismock2.ping = function(callback) {\n    return cb(callback)(null, \"PONG\");\n  };\n  redismock2.quit = function(callback) {\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.select = function(index, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.createClient = function() {\n    return redismock2.copy();\n  };\n  redismock2.bgrewriteaof = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.bgsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_list = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_getname = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_pause = function(timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_setname = function(connection_name, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.cluster_slots = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_count = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_getkeys = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_get = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_rewrite = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_set = function(parameter, value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_resetstat = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.dbsize = function(callback) {\n    var count = 0, key2;\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    return cb(callback)(null, count);\n  };\n  redismock2.debug_object = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.debug_segfault = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.flushall = function(callback) {\n    return this.flushdb(callback);\n  };\n  redismock2.flushdb = function(callback) {\n    cache = {};\n    cache[sets] = {};\n    cache[zsets] = {};\n    cache[hashes] = {};\n    Object.keys(timeouts).forEach(function(key2) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n    });\n    timeouts = {};\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.lastsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.monitor = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.role = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.save = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.shutdown = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.slaveof = function(host, port, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.slowlog = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.sync = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.time = function(callback) {\n    var now = /* @__PURE__ */ new Date();\n    var epoch = now.getTime();\n    var us;\n    if (root.performance) {\n      if (root.performance.now) {\n        now = root.performance.now();\n        us = (now - Math.floor(now)) * 1e5;\n      } else if (root.performance.webkitNow) {\n        now = root.performance.webkitNow();\n        us = (now - Math.floor(now)) * 1e5;\n      } else {\n        us = 0;\n      }\n    } else if (typeof process !== \"undefined\" && process.hrtime) {\n      us = process.hrtime()[1] / 1e3;\n    } else {\n      us = 0;\n    }\n    return cb(callback)(null, [epoch, us]);\n  };\n  var modifiers = [\"del\", \"mset\", \"msetnx\", \"psetex\", \"set\", \"setbit\", \"setex\", \"setrange\", \"incr\", \"decr\", \"incrby\", \"decrby\", \"incrbyfloat\", \"blpop\", \"brpop\", \"brpoplpush\", \"linsert\", \"lpush\", \"lpushx\", \"rpush\", \"rpushx\", \"lpop\", \"rpop\", \"rpoplpush\", \"ltrim\", \"lset\", \"lrem\", \"sadd\", \"smove\", \"spop\", \"sdiffstore\", \"sinterstore\", \"srem\", \"sunionstore\", \"zadd\", \"zrem\", \"zunionstore\", \"zinterstore\", \"zincrby\", \"zremrangebylex\", \"zremrangebyrank\", \"zremrangebyscore\", \"hdel\", \"hincrby\", \"hincrbyfloat\", \"hset\", \"hmset\", \"hsetnx\"];\n  var capture = {};\n  var fkeys = [];\n  for (var key in redismock2) {\n    if (typeof redismock2[key] === \"function\") {\n      fkeys.push(key);\n      capture[key] = redismock2[key];\n    }\n  }\n  fkeys.forEach(function(key2) {\n    redismock2[key2] = function() {\n      if (arguments.length < capture[key2].length - 1) {\n        return cb(arguments[arguments.length - 1])(new Error(\"ERR wrong number of arguments for '\" + key2 + \"' command\"));\n      }\n      return capture[key2].apply(this, arguments);\n    };\n  });\n  modifiers.forEach(function(modifier) {\n    var mod = redismock2[modifier];\n    redismock2[modifier] = function() {\n      var key2 = arguments[0];\n      if (exists(watchers[key2])) {\n        watchers[key2].modified = true;\n      }\n      return mod.apply(this, arguments);\n    };\n  });\n  function toPromise(f, context, deferFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      var deferred = deferFactory(), promise;\n      var callback;\n      while (args.length < f.length - 1) {\n        args.push(void 0);\n      }\n      if (typeof args[args.length - 1] === \"function\") {\n        callback = args[args.length - 1];\n        args.pop();\n      }\n      args.push(function(err, reply) {\n        if (err) {\n          if (callback && typeof callback === \"function\") {\n            callback(err);\n          }\n          return deferred.reject(err);\n        }\n        if (callback && typeof callback === \"function\") {\n          callback(null, reply);\n        }\n        deferred.resolve(reply);\n      });\n      f.apply(context, args);\n      promise = deferred.promise;\n      if (typeof promise === \"function\") {\n        promise = promise();\n      }\n      return promise;\n    };\n  }\n  redismock2.toPromiseStyle = function(deferFactory) {\n    var that = this;\n    return Object.keys(this).filter(function(key2) {\n      return typeof that[key2] === \"function\" && key2 !== \"multi\";\n    }).map(function(key2) {\n      return [key2, toPromise(that[key2], that, deferFactory)];\n    }).reduce(function(promised, f) {\n      promised[f[0]] = f[1];\n      return promised;\n    }, { multi: this.multi });\n  };\n  redismock2.copy = function() {\n    var copied = {};\n    fkeys.forEach(function(key2) {\n      copied[key2] = function() {\n        return redismock2[key2].apply(copied, arguments);\n      };\n    });\n    copied.toPromiseStyle = redismock2.toPromiseStyle;\n    copied.listeners = {};\n    return copied;\n  };\n  redismock2.unref = function() {\n  };\n  if (typeof process !== \"undefined\" && process.env.REDIS_JS_TO_NODE_REDIS === \"1\") {\n    var asNodeRedis;\n    var node_redis_args = [];\n    if (process.env.REDIS_JS_NODE_REDIS_PORT) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_PORT);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_HOST) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_HOST);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_OPTIONS) {\n      node_redis_args.push(JSON.parse(process.env.REDIS_JS_NODE_REDIS_OPTIONS));\n    }\n  }\n}).call(void 0);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redismock);\n\n\n//# sourceURL=webpack://HyphaCore/./src/utils/redis-mock.js?");

/***/ }),

/***/ "./src/workspace.js":
/*!**************************!*\
  !*** ./src/workspace.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Workspace: () => (/* binding */ Workspace)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/index.js */ \"./src/utils/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\nconst _allowedCharacters = /^[a-zA-Z0-9-_/*]*$/;\nfunction validateKeyPart(keyPart) {\n  if (!_allowedCharacters.test(keyPart)) {\n    throw new Error(`Invalid characters in query part: ${keyPart}`);\n  }\n}\nfunction base64UrlEncode(data) {\n  const base64 = btoa(\n    typeof data === \"string\" ? data : String.fromCharCode(...new Uint8Array(data))\n  );\n  return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlDecode(base64Url) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  return atob(base64);\n}\nasync function hmacSha256(key, data) {\n  const encoder = new TextEncoder();\n  const keyData = encoder.encode(key);\n  const msgData = encoder.encode(data);\n  const cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    keyData,\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"]\n  );\n  const signature = await crypto.subtle.sign(\"HMAC\", cryptoKey, msgData);\n  return new Uint8Array(signature);\n}\nasync function generateJWT(payload, secret) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await hmacSha256(secret, unsigned);\n  const encodedSignature = base64UrlEncode(signature);\n  return `${unsigned}.${encodedSignature}`;\n}\nasync function verifyJWT(token, secret) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  const [encodedHeader, encodedPayload, encodedSignature] = parts;\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  try {\n    const header = JSON.parse(base64UrlDecode(encodedHeader));\n    if (header.alg !== \"HS256\") {\n      throw new Error(\"Unsupported algorithm\");\n    }\n    const expectedSignature = await hmacSha256(secret, unsigned);\n    const actualSignature = new Uint8Array(\n      Array.from(base64UrlDecode(encodedSignature)).map((c) => c.charCodeAt(0))\n    );\n    if (expectedSignature.length !== actualSignature.length) {\n      throw new Error(\"Invalid signature\");\n    }\n    for (let i = 0; i < expectedSignature.length; i++) {\n      if (expectedSignature[i] !== actualSignature[i]) {\n        throw new Error(\"Invalid signature\");\n      }\n    }\n    const payload = JSON.parse(base64UrlDecode(encodedPayload));\n    if (payload.exp && Date.now() / 1e3 > payload.exp) {\n      throw new Error(\"Token expired\");\n    }\n    return payload;\n  } catch (error) {\n    throw new Error(`JWT verification failed: ${error.message}`);\n  }\n}\nclass Workspace {\n  constructor(hyphaCore) {\n    this._server = hyphaCore;\n    this._redis = hyphaCore.redis;\n    this.connections = hyphaCore.connections;\n    this.eventBus = hyphaCore;\n    this.serverUrl = hyphaCore.url;\n    this.baseUrl = hyphaCore.baseUrl;\n    this._rpc = null;\n    this._localServices = /* @__PURE__ */ new Map();\n  }\n  waitForClient(cid, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        const ccid = info.id.split(\":\")[0];\n        if (ccid !== cid) {\n          console.log(`\\u{1F6AB} [DEBUG] ccid mismatch, ignoring service: ${info.id}`);\n          return;\n        }\n        this.eventBus.off(\"service_added\", handler);\n        if (info.type === \"imjoy\") {\n          clearTimeout(timeoutId);\n          resolve(info);\n          return;\n        } else {\n          if (!info.id.endsWith(\":default\")) {\n            console.error(`\\u274C [DEBUG] Unexpected service added (not :default):`, info);\n            return;\n          }\n          const defaultService = info;\n          clearTimeout(timeoutId);\n          this._rpc.get_remote_service(defaultService.id).then(async (svc) => {\n            try {\n              await this.eventBus.emit(\"client_ready\", svc);\n              resolve(svc);\n            } catch (e) {\n              reject(e);\n            }\n          }).catch((error) => {\n            console.error(`\\u274C [DEBUG] Failed to get remote service:`, error);\n            reject(error);\n          });\n        }\n      };\n      let timeoutId = setTimeout(() => {\n        this.eventBus.off(\"service_added\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"service_added\", handler);\n    });\n  }\n  async setup(config) {\n    if (!config.client_id) {\n      throw new Error(\"client_id is required in the config\");\n    }\n    const workspace = \"*\";\n    const connection = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.RedisRPCConnection(\n      this.eventBus,\n      workspace,\n      config.client_id,\n      null,\n      null\n    );\n    this.windows = [];\n    this.services = {};\n    this.plugins = {};\n    this.eventBus.on(\"client_ready\", async (svc) => {\n      this.plugins[svc.id] = svc;\n    });\n    const rpc = new hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.RPC(connection, {\n      client_id: config.client_id,\n      default_context: { connection_type: \"websocket\" },\n      workspace,\n      server_base_url: this.serverUrl,\n      silent: false\n    });\n    this._rpc = rpc;\n    const defaultServices = this.getDefaultService();\n    await rpc.register_service(Object.assign(defaultServices, config.default_service || {}), { notify: false });\n  }\n  async registerService(service, context) {\n    const ws = context.ws;\n    const clientId = context.from;\n    const userInfo = context.user;\n    service.config = service.config || {};\n    service.config.workspace = ws;\n    const originalServiceId = service.id;\n    let simpleServiceId = originalServiceId;\n    let isAlreadyConstructed = false;\n    if (originalServiceId.includes(\"/\") && originalServiceId.includes(\":\")) {\n      const parts = originalServiceId.split(\"/\");\n      if (parts.length === 2 && parts[1].includes(\":\")) {\n        isAlreadyConstructed = true;\n        simpleServiceId = parts[1];\n      }\n    }\n    const isBuiltInService = simpleServiceId.includes(\":built-in\") || simpleServiceId === \"built-in\";\n    const isLegitimateDefaultService = simpleServiceId === \"default\" || simpleServiceId.endsWith(\":default\") && clientId.endsWith(\"/\" + simpleServiceId.split(\":\")[0]);\n    if (ws === \"default\" && !clientId.endsWith(\"/root\") && !isBuiltInService && !isLegitimateDefaultService) {\n      throw new Error(`Access denied: Only root user can register services in '${ws}' workspace. Current client: ${clientId}`);\n    }\n    if (!isAlreadyConstructed) {\n      if (!service.id.includes(\":\")) {\n        service.id = `${clientId.split(\"/\")[1]}:${service.id}`;\n      }\n      if (service.id.includes(\"/\")) {\n        throw new Error(\"Service id must not contain '/'\");\n      }\n      service.id = `${ws}/${service.id}`;\n    }\n    service.app_id = service.app_id || \"*\";\n    service.config.visibility = service.config.visibility || \"protected\";\n    const isLocalService = this._hasServiceFunctions(service);\n    if (isLocalService) {\n      const localServiceKey = `${service.id}@${service.app_id}`;\n      this._localServices.set(localServiceKey, service);\n      console.info(`Storing local service: ${localServiceKey}`);\n    }\n    const serviceExists = this._redis.exists(`services:*:${service.id}@${service.app_id}`);\n    const key = `services:${service.config.visibility}:${service.id}@${service.app_id}`;\n    const serviceMetadata = {};\n    for (const [k, v] of Object.entries(service)) {\n      if (isLocalService && typeof v === \"function\") {\n        serviceMetadata[k] = { type: \"function\", name: v.name || k };\n      } else if (isLocalService && typeof v === \"object\" && v !== null && !Array.isArray(v)) {\n        const objMetadata = {};\n        for (const [subK, subV] of Object.entries(v)) {\n          if (typeof subV === \"function\") {\n            objMetadata[subK] = { type: \"function\", name: subV.name || subK };\n          } else {\n            objMetadata[subK] = subV;\n          }\n        }\n        serviceMetadata[k] = objMetadata;\n      } else {\n        serviceMetadata[k] = v;\n      }\n    }\n    for (const [k, v] of Object.entries(serviceMetadata)) {\n      this._redis.hset(key, k, v);\n    }\n    if (serviceExists) {\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_updated\", { id: clientId, workspace: ws });\n        console.info(`Updating built-in service: ${service.id}`);\n      } else {\n        this.eventBus.emit(\"service_updated\", service);\n        console.info(`Updating service: ${service.id}`);\n      }\n    } else {\n      if (key.includes(\":default@\")) {\n        if (isLocalService && service.setup) {\n          setTimeout(async () => {\n            try {\n              await service.setup();\n              console.debug(`\\u2705 Local setup completed for service \\`${clientId}\\``);\n            } catch (e) {\n              console.error(`Failed to run setup for local default service \\`${clientId}\\`: ${e}`);\n            }\n          }, 10);\n        } else if (!isLocalService && this._shouldAttemptRpcSetup(clientId, service)) {\n          this._setupServiceWithRetry(clientId, 3);\n        }\n      }\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_connected\", { id: clientId, workspace: ws });\n        console.info(`Adding built-in service: ${service.id}, key: ${key}`);\n      } else {\n        this.eventBus.emit(\"service_added\", service);\n        console.info(`Adding service ${service.id}, key: ${key}`);\n      }\n    }\n    return service;\n  }\n  /**\n   * Determine if we should attempt RPC setup for a service\n   */\n  _shouldAttemptRpcSetup(clientId, service) {\n    const clientPart = clientId.includes(\"/\") ? clientId.split(\"/\")[1] : clientId;\n    if (clientPart.startsWith(\"client-\")) {\n      return false;\n    }\n    if (service.config && service.config.no_setup) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if a service object contains function properties (indicating it's a local service)\n   */\n  _hasServiceFunctions(service) {\n    for (const [key, value] of Object.entries(service)) {\n      if ([\"id\", \"name\", \"description\", \"config\", \"app_id\"].includes(key)) {\n        continue;\n      }\n      if (typeof value === \"function\") {\n        return true;\n      }\n      if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        if (value._rintf) {\n          continue;\n        }\n        for (const subValue of Object.values(value)) {\n          if (typeof subValue === \"function\") {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Setup service with retry mechanism to handle timing issues\n   */\n  async _setupServiceWithRetry(clientId, maxRetries = 3) {\n    const clientPart = clientId.includes(\"/\") ? clientId.split(\"/\")[1] : clientId;\n    setTimeout(async () => {\n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n          const delay = 100 * Math.pow(4, attempt - 1);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          if (this._rpc) {\n            const svc = await this._rpc.get_remote_service(`${clientPart}:default`, 5);\n            if (svc && svc.setup) {\n              await svc.setup();\n              console.debug(`\\u2705 Setup completed for default service \\`${clientId}\\``);\n              return;\n            }\n          }\n        } catch (e) {\n          if (attempt === maxRetries) {\n            console.debug(`Setup not available for default service \\`${clientId}\\` (this is normal for local services)`);\n          } else {\n            continue;\n          }\n        }\n      }\n    }, 50);\n  }\n  async unregisterService(serviceId, context) {\n    const ws = context.ws;\n    if (!serviceId.includes(\"/\")) {\n      serviceId = `${ws}/${serviceId}`;\n    }\n    if (!serviceId.includes(\":\")) {\n      throw new Error(\"Service id info must contain ':'\");\n    }\n    if (!serviceId.includes(\"@\")) {\n      serviceId = serviceId + \"@*\";\n    }\n    if (this._localServices.has(serviceId)) {\n      this._localServices.delete(serviceId);\n      console.info(`Removed local service: ${serviceId}`);\n    }\n    const key = `services:*:${serviceId}`;\n    console.info(`Removing service: ${key}`);\n    const serviceExists = this._redis.exists(key);\n    if (serviceExists) {\n      this._redis.delete(key);\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_disconnected\", { id: context.from, workspace: ws });\n      } else {\n        this.eventBus.emit(\"service_removed\", { id: serviceId });\n      }\n    } else {\n      console.warning(`Service ${key} does not exist and cannot be removed.`);\n    }\n  }\n  async getService(query, { mode = \"default\", skipTimeout = false, timeout = 5 }, context) {\n    const ws = context.ws;\n    const userInfo = context.user;\n    let serviceId;\n    if (typeof query === \"string\") {\n      serviceId = query;\n      query = { id: serviceId };\n    } else {\n      if (!query.id) {\n        serviceId = query.service_id || \"*\";\n      } else {\n        serviceId = query.id;\n      }\n    }\n    if (typeof serviceId !== \"string\") {\n      throw new Error(\"Service ID must be a string\");\n    }\n    if ((serviceId.match(/\\//g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one '/'\");\n    }\n    if ((serviceId.match(/:/g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one ':'\");\n    }\n    if ((serviceId.match(/@/g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one '@'\");\n    }\n    if (serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n      serviceId += \":default\";\n      query.workspace = serviceId.split(\"/\")[0];\n      if (query.client_id && query.client_id !== serviceId.split(\"/\")[1]) {\n        throw new Error(`client_id (${query.client_id}) does not match service_id (${serviceId})`);\n      }\n      query.client_id = serviceId.split(\"/\")[1];\n    } else if (!serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n      const workspace = query.workspace || ws;\n      serviceId = `${workspace}/*:${serviceId}`;\n      query.workspace = workspace;\n      query.client_id = \"*\";\n    } else if (!serviceId.includes(\"/\") && serviceId.includes(\":\")) {\n      const workspace = query.workspace || ws;\n      query.client_id = serviceId.split(\":\")[0];\n      serviceId = `${workspace}/${serviceId}`;\n      query.workspace = workspace;\n    } else {\n      const workspace = serviceId.split(\"/\")[0];\n      query.client_id = serviceId.split(\"/\")[1].split(\":\")[0];\n      query.workspace = workspace;\n      if (!serviceId.includes(\"*\")) {\n        const localServiceKey = `${serviceId}@*`;\n        if (this._localServices.has(localServiceKey)) {\n          console.info(`Found local service (direct): ${localServiceKey}`);\n          const localService = this._localServices.get(localServiceKey);\n          return this.patchServiceConfig(workspace, localService);\n        }\n        if (this._rpc) {\n          const serviceApi = await this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        }\n        return null;\n      }\n    }\n    let appId = \"*\";\n    if (serviceId.includes(\"@\")) {\n      [serviceId, appId] = serviceId.split(\"@\");\n      if (query.app_id && query.app_id !== appId) {\n        throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n      }\n    }\n    query.app_id = query.app_id || appId;\n    query.service_id = serviceId.split(\"/\")[1].split(\":\")[1];\n    const originalVisibility = query.visibility || \"*\";\n    let visibility;\n    if (query.workspace === \"*\") {\n      visibility = \"public\";\n    } else {\n      visibility = \"*\";\n    }\n    const pattern = `services:${visibility}:${query.workspace}/${query.client_id}:${query.service_id}@${query.app_id}`;\n    if (!pattern.startsWith(\"services:\")) {\n      throw new Error(\"Query pattern does not start with 'services:'.\");\n    }\n    if (pattern.includes(\"{\") || pattern.includes(\"}\")) {\n      throw new Error(\"Query pattern contains invalid characters.\");\n    }\n    const keys = this._redis.keys(pattern);\n    if (query.workspace === \"*\") {\n      const wsPattern = `services:${originalVisibility}:${ws}/${query.client_id}:${query.service_id}@${query.app_id}`;\n      keys.push(...this._redis.keys(wsPattern));\n    }\n    const withinWorkspaceKeys = [];\n    const outsideWorkspaceKeys = [];\n    keys.forEach((key) => {\n      const keyWorkspace = key.split(\"/\")[1];\n      if (keyWorkspace === ws) {\n        withinWorkspaceKeys.push(key);\n      } else {\n        outsideWorkspaceKeys.push(key);\n      }\n    });\n    if (mode === \"random\") {\n      withinWorkspaceKeys.sort(() => Math.random() - 0.5);\n      outsideWorkspaceKeys.sort(() => Math.random() - 0.5);\n    } else {\n      withinWorkspaceKeys.sort();\n      outsideWorkspaceKeys.sort();\n    }\n    const sortedKeys = [...withinWorkspaceKeys, ...outsideWorkspaceKeys];\n    for (const key of sortedKeys) {\n      try {\n        const parts = key.split(\":\");\n        serviceId = parts[2] + \":\" + parts[3];\n        [serviceId, appId] = serviceId.split(\"@\");\n        const workspace = serviceId.split(\"/\")[0];\n        const localServiceKey = `${serviceId}@${appId}`;\n        if (this._localServices.has(localServiceKey)) {\n          const localService = this._localServices.get(localServiceKey);\n          return this.patchServiceConfig(workspace, localService);\n        }\n        if (this._rpc) {\n          const serviceApi = await this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        }\n      } catch (e) {\n        if (skipTimeout && e instanceof TimeoutError) {\n          console.warning(`Timeout while getting service ${serviceId}, skipping to the next one.`);\n          continue;\n        } else {\n          throw new Error(`Timeout while getting service ${serviceId}`);\n        }\n      }\n    }\n    if (query.app_id && query.app_id !== \"*\") {\n      const serviceApi = await this._launch_application_for_service(query, context);\n      return serviceApi;\n    }\n    return null;\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    return serviceApi;\n  }\n  async listServices(query, context) {\n    if (!context) {\n      throw new Error(\"context is required\");\n    }\n    const cws = context.ws;\n    const userInfo = context.user;\n    if (!query) {\n      query = {\n        visibility: \"*\",\n        workspace: cws,\n        client_id: \"*\",\n        service_id: \"*\"\n      };\n    } else if (typeof query === \"string\") {\n      let visibility2 = \"*\";\n      let workspace2 = \"*\";\n      let clientId2 = \"*\";\n      let serviceId2 = \"*\";\n      if (query.includes(\"/\") && query.includes(\":\")) {\n        const [workspacePart, remaining] = query.split(\"/\");\n        const [clientPart, servicePart] = remaining.split(\":\");\n        workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n        clientId2 = clientPart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else if (query.includes(\":\")) {\n        const [clientPart, servicePart] = query.split(\":\");\n        clientId2 = clientPart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else if (query.includes(\"/\")) {\n        const [workspacePart, servicePart] = query.split(\"/\");\n        workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else {\n        workspace2 = query;\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      }\n    } else {\n      if (query.id) {\n        if (query.service_id) {\n          throw new Error(\"Cannot specify both 'id' and 'service_id' in the query.\");\n        }\n        query.service_id = query.id;\n        delete query.id;\n      }\n    }\n    const originalVisibility = query.visibility || \"*\";\n    const workspace = query.workspace || \"*\";\n    if (workspace === \"*\") {\n      if (originalVisibility === \"protected\") {\n        throw new Error(\"Cannot list protected services in all workspaces.\");\n      }\n      query.visibility = \"public\";\n    } else if (workspace !== \"public\" && workspace !== cws) {\n    }\n    const visibility = query.visibility || \"*\";\n    const clientId = query.client_id || \"*\";\n    const serviceId = query.service_id || \"*\";\n    const typeFilter = query.type || null;\n    let appId = \"*\";\n    if (serviceId.includes(\"@\")) {\n      [serviceId, appId] = serviceId.split(\"@\");\n      if (query.app_id && query.app_id !== appId) {\n        throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n      }\n    }\n    appId = query.app_id || appId;\n    const allowedKeys = [\"visibility\", \"workspace\", \"client_id\", \"service_id\", \"type\", \"app_id\"];\n    if (Object.keys(query).some((key) => !allowedKeys.includes(key))) {\n      console.error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n      throw new Error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n    }\n    validateKeyPart(visibility);\n    validateKeyPart(workspace);\n    validateKeyPart(clientId);\n    validateKeyPart(serviceId);\n    validateKeyPart(appId);\n    const pattern = `services:${visibility}:${workspace}/${clientId}:${serviceId}@${appId}`;\n    if (!pattern.startsWith(\"services:\")) {\n      throw new Error(\"Query pattern does not start with 'services:'.\");\n    }\n    const keys = this._redis.keys(pattern);\n    if (workspace === \"*\") {\n      const wsPattern = `services:${originalVisibility}:${cws}/${clientId}:${serviceId}@${appId}`;\n      keys.push(...this._redis.keys(wsPattern));\n    }\n    const services = [];\n    for (const key of new Set(keys)) {\n      const serviceData = this._redis.hgetall(key);\n      const convertedServiceData = {};\n      for (const [k, v] of Object.entries(serviceData)) {\n        const keyStr = k;\n        let valueStr = v;\n        if (typeof valueStr === \"string\" && (valueStr.startsWith(\"{\") && valueStr.endsWith(\"}\") || valueStr.startsWith(\"[\") && valueStr.endsWith(\"]\"))) {\n          valueStr = JSON.parse(valueStr);\n        }\n        convertedServiceData[keyStr] = valueStr;\n      }\n      if (typeFilter) {\n        if (convertedServiceData.type === typeFilter) {\n          services.push(convertedServiceData);\n        }\n      } else {\n        services.push(convertedServiceData);\n      }\n    }\n    return services;\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    return serviceApi;\n  }\n  async createWindow(config, extra_config, context) {\n    _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.requireBrowser(\"Window/iframe creation\");\n    let elem;\n    const ws = context.ws;\n    const clientId = \"client-\" + Date.now();\n    const connectionId = ws + \"/\" + clientId;\n    this.connections[connectionId] = {\n      id: connectionId,\n      workspace: ws,\n      user: context.user,\n      // Store user info for nested app creation\n      websocket: null,\n      postMessage: (data) => {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.safePostMessage(elem.contentWindow, data);\n      }\n    };\n    let authToken = context.token;\n    if (!authToken) {\n      try {\n        authToken = await this.getDefaultService().generate_token({\n          workspace: ws,\n          client_id: clientId,\n          user_id: context.user?.id || \"anonymous\",\n          email: context.user?.email || \"\",\n          roles: context.user?.roles || [],\n          scopes: context.user?.scopes || [],\n          expires_in: 3600\n          // 1 hour\n        }, context);\n      } catch (error) {\n        console.warn(\"Failed to generate auth token for iframe:\", error);\n      }\n    }\n    const authParams = new URLSearchParams();\n    authParams.set(\"client_id\", clientId);\n    authParams.set(\"workspace\", ws);\n    authParams.set(\"server_url\", this.serverUrl);\n    if (authToken) {\n      authParams.set(\"token\", authToken);\n    }\n    if (context.user) {\n      authParams.set(\"user_info\", JSON.stringify(context.user));\n    }\n    const authHash = `#${authParams.toString()}`;\n    if (config.type === \"iframe\") {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"iframe creation requires browser environment with document API\");\n      }\n      elem = document.createElement(\"iframe\");\n      elem.src = config.src + authHash;\n      elem.id = config.window_id || \"window-\" + Date.now();\n      elem.style.width = config.width || \"100%\";\n      elem.style.height = config.height || \"100%\";\n      elem.style.display = \"none\";\n      document.body.appendChild(elem);\n    } else if (config.window_id) {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"Window element access requires browser environment with document API\");\n      }\n      let count = 0;\n      while (!document.getElementById(config.window_id) && count < 9) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        count++;\n      }\n      elem = document.getElementById(config.window_id);\n      if (!elem) {\n        throw new Error(\"Window element not found: \" + config.window_id);\n      }\n    } else {\n      config.window_id = \"window-\" + Date.now();\n      config.workspace = ws;\n      await this.eventBus.emit(\"add_window\", config);\n      await new Promise((resolve) => setTimeout(resolve, 0));\n      let count = 0;\n      while (!document.getElementById(config.window_id) && count < 9) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        count++;\n      }\n      elem = document.getElementById(config.window_id);\n      if (!elem) {\n        throw new Error(`iframe element not found ${config.window_id} in ${9 * 500 / 1e3} s`);\n      }\n    }\n    if (elem.tagName !== \"IFRAME\") {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"iframe creation requires browser environment with document API\");\n      }\n      const iframe = document.createElement(\"iframe\");\n      iframe.style.width = config.width || \"100%\";\n      iframe.style.height = config.height || \"100%\";\n      iframe.src = config.src + authHash;\n      elem.appendChild(iframe);\n      elem = iframe;\n    }\n    this.connections[connectionId].source = elem.contentWindow;\n    let waitClientPromise;\n    if (!config.passive) {\n      waitClientPromise = this.waitForClient(connectionId, 18e4);\n    }\n    await new Promise((resolve, reject) => {\n      elem.onload = resolve;\n      elem.onerror = reject;\n    });\n    if (config.passive) {\n      delete this.connections[connectionId];\n      return;\n    }\n    const initMessage = {\n      type: \"initializeHyphaClient\",\n      server_url: this.serverUrl,\n      client_id: clientId,\n      workspace: ws,\n      token: authToken || null,\n      user_info: context.user || null,\n      config\n    };\n    setTimeout(() => {\n      try {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.safePostMessage(elem.contentWindow, initMessage);\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] Failed to send initializeHyphaClient to ${connectionId}:`, error);\n      }\n    }, 0);\n    const svc = await waitClientPromise;\n    if (svc.setup && typeof svc.setup === \"function\") {\n      try {\n        await svc.setup();\n        svc._hyphaSetupCalled = true;\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] setup() failed for window plugin: ${config.name || config.src}:`, error);\n      }\n    }\n    if (svc.run && typeof svc.run === \"function\") {\n      try {\n        await svc.run({ data: config.data, config: config.config });\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] run() failed for window plugin: ${config.name || config.src}:`, error);\n      }\n    }\n    this.windows.push({ id: config.window_id, name: config.name || config.src, service: svc });\n    return svc;\n  }\n  async getWindow(config, context) {\n    if (typeof config === \"string\") {\n      return this.windows.find((w) => w.name === config);\n    } else if (config.id) {\n      return this.windows.find((w) => w.id === config.id);\n    } else if (config.name) {\n      return this.windows.find((w) => w.name === config.name);\n    }\n    return void 0;\n  }\n  async loadApp(config, extra_config, context) {\n    let code;\n    const ws = context.ws;\n    const src = config.src;\n    if (config.type === \"web-worker\" && src && (src.startsWith(\"http\") || src.startsWith(\"blob:\"))) {\n      return await this.createWorker(config, ws, src, context);\n    }\n    if (src.startsWith(\"http\") && !src.split(\"?\")[0].endsWith(\".imjoy.html\")) {\n      return await this.createWindow(config, extra_config, context);\n    }\n    if (src.startsWith(\"http\")) {\n      const resp = await fetch(src);\n      code = await resp.text();\n    } else if (src.includes(\"\\n\")) {\n      code = src;\n    } else {\n      throw new Error(\"Only local plugins are supported in the workspace manager.\");\n    }\n    config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.parsePluginCode)(code, {});\n    switch (config.type) {\n      case \"web-worker\":\n        return await this.createWorker(config, ws, this.baseUrl + \"hypha-app-webworker.js\", context);\n      case \"window\":\n      case \"iframe\":\n        config.src = this.baseUrl + \"hypha-app-iframe.html\";\n        return await this.createWindow(config, extra_config, context);\n      case \"web-python\":\n        return await this.createWorker(config, ws, this.baseUrl + \"hypha-app-webpython.js\", context);\n      default:\n        throw new Error(\"Unsupported plugin type: \" + config.type);\n    }\n  }\n  _waitForConnection(conn_id, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        if (info.id === conn_id) {\n          this.eventBus.off(\"connection_ready\", handler);\n          clearTimeout(timeoutId);\n          resolve(info);\n        }\n      };\n      const timeoutId = setTimeout(() => {\n        this.eventBus.off(\"connection_ready\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"connection_ready\", handler);\n    });\n  }\n  async createWorker(config, workspace, workerUrl, context) {\n    if (typeof Worker === \"undefined\") {\n      throw new Error(\"WebWorker creation requires browser environment with Worker API\");\n    }\n    const clientId = \"client-\" + Date.now();\n    let authToken = context.token;\n    if (!authToken) {\n      try {\n        authToken = await this.getDefaultService().generate_token({\n          workspace,\n          client_id: clientId,\n          user_id: context.user?.id || \"anonymous\",\n          email: context.user?.email || \"\",\n          roles: context.user?.roles || [],\n          scopes: context.user?.scopes || [],\n          expires_in: 3600\n          // 1 hour\n        }, context);\n      } catch (error) {\n        console.warn(\"Failed to generate auth token for worker:\", error);\n      }\n    }\n    const authParams = new URLSearchParams();\n    authParams.set(\"client_id\", clientId);\n    authParams.set(\"workspace\", workspace);\n    authParams.set(\"server_url\", this.serverUrl);\n    if (authToken) {\n      authParams.set(\"token\", authToken);\n    }\n    if (context.user) {\n      authParams.set(\"user_info\", JSON.stringify(context.user));\n    }\n    const authHash = `#${authParams.toString()}`;\n    const worker = new Worker(workerUrl + authHash);\n    this.connections[workspace + \"/\" + clientId] = {\n      id: workspace + \"/\" + clientId,\n      source: worker,\n      workspace,\n      user: context.user,\n      // Store user info for nested app creation\n      websocket: null,\n      postMessage: (data) => {\n        worker.postMessage(data);\n      }\n    };\n    worker.onmessage = this._server.messageHandler;\n    await this._waitForConnection(workspace + \"/\" + clientId, 6e4);\n    worker.postMessage({\n      type: \"initializeHyphaClient\",\n      server_url: this.serverUrl,\n      workspace,\n      client_id: clientId,\n      token: authToken || null,\n      user_info: context?.user || null,\n      config\n    });\n    const svc = await this.waitForClient(workspace + \"/\" + clientId, 6e4);\n    if (svc.setup && typeof svc.setup === \"function\") {\n      try {\n        await svc.setup();\n        svc._hyphaSetupCalled = true;\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] setup() failed for ${config.type} plugin: ${config.name || \"unnamed\"}:`, error);\n      }\n    }\n    if (config.type === \"window\" && svc.run && typeof svc.run === \"function\") {\n      try {\n        await svc.run({ data: config.data, config: config.config });\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] run() failed for window worker plugin: ${config.name || \"unnamed\"}:`, error);\n      }\n    }\n    return svc;\n  }\n  async getApp(config, extra_config, context) {\n    if (typeof config === \"string\") {\n      return await this.loadApp({ src: config }, extra_config, context);\n    } else if (config.id) {\n      return this.plugins[config.id];\n    } else if (config.name) {\n      for (const [key, value] of Object.entries(this.plugins)) {\n        if (value.name === config.name) {\n          return value;\n        }\n      }\n    } else {\n      throw new Error(\"Please provide either id or name for the plugin\");\n    }\n  }\n  getDefaultService() {\n    const service = {\n      \"id\": \"default\",\n      \"name\": \"Default workspace management service\",\n      \"description\": \"Services for managing workspace.\",\n      \"config\": {\n        \"require_context\": true,\n        \"visibility\": \"public\"\n      },\n      \"emit\": async (type, data, context) => {\n        const workspaceId = context.ws;\n        await this.eventBus.emit(type, data);\n      },\n      \"on\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.on(event, handler);\n      },\n      \"off\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.off(event, handler);\n      },\n      \"echo\": (msg, context) => {\n        return msg;\n      },\n      \"alert\": (msg, context) => {\n        alert(msg);\n      },\n      \"confirm\": (msg, context) => {\n        return confirm(msg);\n      },\n      \"prompt\": (msg, default_value, context) => {\n        return prompt(msg, default_value);\n      },\n      \"show_progress\": (progress, context) => {\n        if (progress !== 0 && progress !== 100) {\n          console.debug(\"showProgress\", progress);\n        }\n      },\n      \"show_message\": (msg, context) => {\n        console.log(msg);\n      },\n      \"log\": (msg, context) => {\n        console.log(msg);\n      },\n      \"info\": (msg, context) => {\n        console.info(msg);\n      },\n      \"error\": (msg, context) => {\n        console.error(msg);\n      },\n      \"warning\": (msg, context) => {\n        console.warn(msg);\n      },\n      \"critical\": (msg, context) => {\n        console.error(msg);\n      },\n      \"get_service\": this.getService.bind(this),\n      \"getService\": this.getService.bind(this),\n      // camelCase alias\n      \"list_services\": this.listServices.bind(this),\n      \"listServices\": this.listServices.bind(this),\n      // camelCase alias\n      \"generate_token\": async (tokenConfig, context) => {\n        if (!tokenConfig) {\n          tokenConfig = {};\n        }\n        const currentWorkspace = context.ws;\n        const currentClientId = context.from?.split(\"/\")[1];\n        let targetWorkspace = tokenConfig.workspace || currentWorkspace;\n        if (targetWorkspace !== currentWorkspace) {\n          if (currentWorkspace !== \"default\" || currentClientId !== \"root\") {\n            throw new Error(`Access denied: Cannot generate token for workspace '${targetWorkspace}' from workspace '${currentWorkspace}' with client '${currentClientId}'. Only root client in default workspace can generate cross-workspace tokens.`);\n          }\n        }\n        const payload = {\n          sub: tokenConfig.user_id || context.user?.id || \"anonymous\",\n          workspace: targetWorkspace,\n          client_id: tokenConfig.client_id || context.from?.split(\"/\")[1] || \"anonymouz-\" + Date.now().toString(),\n          email: tokenConfig.email || context.user?.email || \"\",\n          roles: tokenConfig.roles || context.user?.roles || [],\n          scope: Array.isArray(tokenConfig.scopes) ? tokenConfig.scopes.join(\" \") : tokenConfig.scope || \"\",\n          iat: Math.floor(Date.now() / 1e3),\n          exp: tokenConfig.expires_in ? Math.floor(Date.now() / 1e3) + tokenConfig.expires_in : Math.floor(Date.now() / 1e3) + 24 * 60 * 60,\n          // Default 24 hours\n          iss: \"hypha-core\",\n          aud: \"hypha-api\"\n        };\n        const jwtSecret = this._server.jwtSecret;\n        if (!jwtSecret) {\n          throw new Error(\"JWT secret not configured on server\");\n        }\n        return await generateJWT(payload, jwtSecret);\n      },\n      \"load_app\": async (config, extra_config, context) => {\n        return this.loadApp(config, extra_config, context);\n      },\n      \"create_window\": async (config, extra_config, context) => {\n        return this.createWindow(config, extra_config, context);\n      },\n      \"get_window\": async (config, context) => {\n        return this.getWindow(config, context);\n      },\n      \"get_app\": async (config, extra_config, context) => {\n        return this.getApp(config, extra_config, context);\n      },\n      \"register_service\": async (service2, context) => {\n        return await this.registerService(service2, context);\n      }\n    };\n    service.getPlugin = service.get_app;\n    service.loadPlugin = service.load_app;\n    service.getWindow = service.get_window;\n    return service;\n  }\n}\n__publicField(Workspace, \"workspaces\", {});\n__publicField(Workspace, \"clients\", {});\n\n\n//# sourceURL=webpack://HyphaCore/./src/workspace.js?");

/***/ }),

/***/ "./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/rpc.js\":\n/*!********************!*\\\n  !*** ./src/rpc.js ***!\n  \\********************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_667__) => {\n\n__nested_webpack_require_667__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_667__.d(__nested_webpack_exports__, {\n/* harmony export */   API_VERSION: () => (/* binding */ API_VERSION),\n/* harmony export */   RPC: () => (/* binding */ RPC)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_667__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _utils_schema__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_667__(/*! ./utils/schema */ \"./src/utils/schema.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_667__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_667__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/**\n * Contains the RPC object used both by the application\n * site, and by each plugin\n */\n\n\n\n\n\nconst API_VERSION = 3;\nconst CHUNK_SIZE = 1024 * 256;\nconst CONCURRENCY_LIMIT = 30;\n\nconst ArrayBufferView = Object.getPrototypeOf(\n  Object.getPrototypeOf(new Uint8Array()),\n).constructor;\n\nfunction _appendBuffer(buffer1, buffer2) {\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n  tmp.set(new Uint8Array(buffer1), 0);\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n  return tmp.buffer;\n}\n\nfunction indexObject(obj, is) {\n  if (!is) throw new Error(\"undefined index\");\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));\n  else if (is.length === 0) return obj;\n  else return indexObject(obj[is[0]], is.slice(1));\n}\n\nfunction _get_schema(obj, name = null, skipContext = false) {\n  if (Array.isArray(obj)) {\n    return obj.map((v, i) => _get_schema(v, null, skipContext));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    let schema = {};\n    for (let k in obj) {\n      schema[k] = _get_schema(obj[k], k, skipContext);\n    }\n    return schema;\n  } else if (typeof obj === \"function\") {\n    if (obj.__schema__) {\n      const schema = JSON.parse(JSON.stringify(obj.__schema__));\n      if (name) {\n        schema.name = name;\n        obj.__schema__.name = name;\n      }\n      if (skipContext) {\n        if (schema.parameters && schema.parameters.properties) {\n          delete schema.parameters.properties[\"context\"];\n        }\n      }\n      return { type: \"function\", function: schema };\n    } else {\n      return { type: \"function\" };\n    }\n  } else if (typeof obj === \"number\") {\n    return { type: \"number\" };\n  } else if (typeof obj === \"string\") {\n    return { type: \"string\" };\n  } else if (typeof obj === \"boolean\") {\n    return { type: \"boolean\" };\n  } else if (obj === null) {\n    return { type: \"null\" };\n  } else {\n    return {};\n  }\n}\n\nfunction _annotate_service(service, serviceTypeInfo) {\n  function validateKeys(serviceDict, schemaDict, path = \"root\") {\n    // Validate that all keys in schemaDict exist in serviceDict\n    for (let key in schemaDict) {\n      if (!serviceDict.hasOwnProperty(key)) {\n        throw new Error(`Missing key '${key}' in service at path '${path}'`);\n      }\n    }\n\n    // Check for any unexpected keys in serviceDict\n    for (let key in serviceDict) {\n      if (key !== \"type\" && !schemaDict.hasOwnProperty(key)) {\n        throw new Error(`Unexpected key '${key}' in service at path '${path}'`);\n      }\n    }\n  }\n\n  function annotateRecursive(newService, schemaInfo, path = \"root\") {\n    if (typeof newService === \"object\" && !Array.isArray(newService)) {\n      validateKeys(newService, schemaInfo, path);\n      for (let k in newService) {\n        let v = newService[k];\n        let newPath = `${path}.${k}`;\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n          annotateRecursive(v, schemaInfo[k], newPath);\n        } else if (typeof v === \"function\") {\n          if (schemaInfo.hasOwnProperty(k)) {\n            newService[k] = (0,_utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n              name: schemaInfo[k][\"name\"],\n              description: schemaInfo[k].description || \"\",\n              parameters: schemaInfo[k][\"parameters\"],\n            });\n          } else {\n            throw new Error(\n              `Missing schema for function '${k}' at path '${newPath}'`,\n            );\n          }\n        }\n      }\n    } else if (Array.isArray(newService)) {\n      if (newService.length !== schemaInfo.length) {\n        throw new Error(`Length mismatch at path '${path}'`);\n      }\n      newService.forEach((v, i) => {\n        let newPath = `${path}[${i}]`;\n        if (typeof v === \"object\" && !Array.isArray(v)) {\n          annotateRecursive(v, schemaInfo[i], newPath);\n        } else if (typeof v === \"function\") {\n          if (schemaInfo.hasOwnProperty(i)) {\n            newService[i] = (0,_utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n              name: schemaInfo[i][\"name\"],\n              description: schemaInfo[i].description || \"\",\n              parameters: schemaInfo[i][\"parameters\"],\n            });\n          } else {\n            throw new Error(\n              `Missing schema for function at index ${i} in path '${newPath}'`,\n            );\n          }\n        }\n      });\n    }\n  }\n\n  validateKeys(service, serviceTypeInfo[\"definition\"]);\n  annotateRecursive(service, serviceTypeInfo[\"definition\"]);\n  return service;\n}\n\nfunction getFunctionInfo(func) {\n  const funcString = func.toString();\n\n  // Extract function name\n  const nameMatch = funcString.match(/function\\s*(\\w*)/);\n  const name = (nameMatch && nameMatch[1]) || \"\";\n\n  // Extract function parameters, excluding comments\n  const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n  let params = \"\";\n  if (paramsMatch) {\n    params = paramsMatch[1]\n      .split(\",\")\n      .map((p) =>\n        p\n          .replace(/\\/\\*.*?\\*\\//g, \"\") // Remove block comments\n          .replace(/\\/\\/.*$/g, \"\"),\n      ) // Remove line comments\n      .filter((p) => p.trim().length > 0) // Remove empty strings after removing comments\n      .map((p) => p.trim()) // Trim remaining whitespace\n      .join(\", \");\n  }\n\n  // Extract function docstring (block comment)\n  let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n  const docstringBlock = (docMatch && docMatch[1].trim()) || \"\";\n\n  // Extract function docstring (line comment)\n  docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n  const docstringLine =\n    (docMatch &&\n      docMatch[1]\n        .split(\"\\n\")\n        .map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim())\n        .join(\"\\n\")) ||\n    \"\";\n\n  const docstring = docstringBlock || docstringLine;\n  return (\n    name &&\n    params.length > 0 && {\n      name: name,\n      sig: params,\n      doc: docstring,\n    }\n  );\n}\n\nfunction concatArrayBuffers(buffers) {\n  var buffersLengths = buffers.map(function (b) {\n      return b.byteLength;\n    }),\n    totalBufferlength = buffersLengths.reduce(function (p, c) {\n      return p + c;\n    }, 0),\n    unit8Arr = new Uint8Array(totalBufferlength);\n  buffersLengths.reduce(function (p, c, i) {\n    unit8Arr.set(new Uint8Array(buffers[i]), p);\n    return p + c;\n  }, 0);\n  return unit8Arr.buffer;\n}\n\nclass Timer {\n  constructor(timeout, callback, args, label) {\n    this._timeout = timeout;\n    this._callback = callback;\n    this._args = args;\n    this._label = label || \"timer\";\n    this._task = null;\n    this.started = false;\n  }\n\n  start() {\n    if (this.started) {\n      this.reset();\n    } else {\n      this._task = setTimeout(() => {\n        this._callback.apply(this, this._args);\n      }, this._timeout * 1000);\n      this.started = true;\n    }\n  }\n\n  clear() {\n    if (this._task && this.started) {\n      clearTimeout(this._task);\n      this._task = null;\n      this.started = false;\n    } else {\n      console.warn(`Clearing a timer (${this._label}) which is not started`);\n    }\n  }\n\n  reset() {\n    if (this._task) {\n      clearTimeout(this._task);\n    }\n    this._task = setTimeout(() => {\n      this._callback.apply(this, this._args);\n    }, this._timeout * 1000);\n    this.started = true;\n  }\n}\n\nclass RemoteService extends Object {}\n\n/**\n * RPC object represents a single site in the\n * communication protocol between the application and the plugin\n *\n * @param {Object} connection a special object allowing to send\n * and receive messages from the opposite site (basically it\n * should only provide send() and onMessage() methods)\n */\nclass RPC extends _utils__WEBPACK_IMPORTED_MODULE_0__.MessageEmitter {\n  constructor(\n    connection,\n    {\n      client_id = null,\n      default_context = null,\n      name = null,\n      codecs = null,\n      method_timeout = null,\n      max_message_buffer_size = 0,\n      debug = false,\n      workspace = null,\n      silent = false,\n      app_id = null,\n      server_base_url = null,\n      long_message_chunk_size = null,\n    },\n  ) {\n    super(debug);\n    this._codecs = codecs || {};\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id && typeof client_id === \"string\");\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id, \"client_id is required\");\n    this._client_id = client_id;\n    this._name = name;\n    this._app_id = app_id || \"*\";\n    this._local_workspace = workspace;\n    this._silent = silent;\n    this.default_context = default_context || {};\n    this._method_annotations = new WeakMap();\n    this._max_message_buffer_size = max_message_buffer_size;\n    this._chunk_store = {};\n    this._method_timeout = method_timeout || 30;\n    this._server_base_url = server_base_url;\n    this._long_message_chunk_size = long_message_chunk_size || CHUNK_SIZE;\n\n    // make sure there is an execute function\n    this._services = {};\n    this._object_store = {\n      services: this._services,\n    };\n\n    if (connection) {\n      this.add_service({\n        id: \"built-in\",\n        type: \"built-in\",\n        name: `Built-in services for ${this._local_workspace}/${this._client_id}`,\n        config: {\n          require_context: true,\n          visibility: \"public\",\n          api_version: API_VERSION,\n        },\n        ping: this._ping.bind(this),\n        get_service: this.get_local_service.bind(this),\n        message_cache: {\n          create: this._create_message.bind(this),\n          append: this._append_message.bind(this),\n          set: this._set_message.bind(this),\n          process: this._process_message.bind(this),\n          remove: this._remove_message.bind(this),\n        },\n      });\n      this.on(\"method\", this._handle_method.bind(this));\n      this.on(\"error\", console.error);\n\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(connection.emit_message && connection.on_message);\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        connection.manager_id !== undefined,\n        \"Connection must have manager_id\",\n      );\n      this._emit_message = connection.emit_message.bind(connection);\n      connection.on_message(this._on_message.bind(this));\n      this._connection = connection;\n      const onConnected = async (connectionInfo) => {\n        if (!this._silent && this._connection.manager_id) {\n          console.debug(\"Connection established, reporting services...\");\n          try {\n            const manager = await this.get_manager_service({\n              timeout: 10,\n              case_conversion: \"camel\",\n            });\n            const services = Object.values(this._services);\n            const servicesCount = services.length;\n            let registeredCount = 0;\n\n            for (let service of services) {\n              try {\n                const serviceInfo = this._extract_service_info(service);\n                await manager.registerService(serviceInfo);\n                registeredCount++;\n              } catch (serviceError) {\n                console.error(\n                  `Failed to register service ${service.id || \"unknown\"}: ${serviceError}`,\n                );\n              }\n            }\n\n            if (registeredCount === servicesCount) {\n              console.info(\n                `Successfully registered all ${registeredCount} services with the server`,\n              );\n            } else {\n              console.warn(\n                `Only registered ${registeredCount} out of ${servicesCount} services with the server`,\n              );\n            }\n          } catch (managerError) {\n            console.error(\n              `Failed to get manager service for registering services: ${managerError}`,\n            );\n          }\n        } else {\n          // console.debug(\"Connection established\", connectionInfo);\n        }\n        if (connectionInfo) {\n          if (connectionInfo.public_base_url) {\n            this._server_base_url = connectionInfo.public_base_url;\n          }\n          this._fire(\"connected\", connectionInfo);\n        }\n      };\n      connection.on_connected(onConnected);\n      onConnected();\n    } else {\n      this._emit_message = function () {\n        console.log(\"No connection to emit message\");\n      };\n    }\n  }\n\n  register_codec(config) {\n    if (!config[\"name\"] || (!config[\"encoder\"] && !config[\"decoder\"])) {\n      throw new Error(\n        \"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\",\n      );\n    } else {\n      if (config.type) {\n        for (let k of Object.keys(this._codecs)) {\n          if (this._codecs[k].type === config.type || k === config.name) {\n            delete this._codecs[k];\n            console.warn(\"Remove duplicated codec: \" + k);\n          }\n        }\n      }\n      this._codecs[config[\"name\"]] = config;\n    }\n  }\n\n  async _ping(msg, context) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(msg == \"ping\");\n    return \"pong\";\n  }\n\n  async ping(client_id, timeout) {\n    let method = this._generate_remote_method({\n      _rserver: this._server_base_url,\n      _rtarget: client_id,\n      _rmethod: \"services.built-in.ping\",\n      _rpromise: true,\n      _rdoc: \"Ping a remote client\",\n    });\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)((await method(\"ping\", timeout)) == \"pong\");\n  }\n\n  _create_message(key, heartbeat, overwrite, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n\n    if (!this._object_store[\"message_cache\"]) {\n      this._object_store[\"message_cache\"] = {};\n    }\n    if (!overwrite && this._object_store[\"message_cache\"][key]) {\n      throw new Error(\n        `Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`,\n      );\n    }\n    this._object_store[\"message_cache\"][key] = [];\n  }\n\n  _append_message(key, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n    cache[key].push(data);\n  }\n\n  _set_message(key, index, data, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n    cache[key][index] = data;\n  }\n\n  _remove_message(key, context) {\n    const cache = this._object_store[\"message_cache\"];\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    delete cache[key];\n  }\n\n  _process_message(key, heartbeat, context) {\n    if (heartbeat) {\n      if (!this._object_store[key]) {\n        throw new Error(`session does not exist anymore: ${key}`);\n      }\n      this._object_store[key][\"timer\"].reset();\n    }\n    const cache = this._object_store[\"message_cache\"];\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!context, \"Context is required\");\n    if (!cache[key]) {\n      throw new Error(`Message with key ${key} does not exists.`);\n    }\n    cache[key] = concatArrayBuffers(cache[key]);\n    // console.debug(`Processing message ${key} (bytes=${cache[key].byteLength})`);\n    let unpacker = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(cache[key]);\n    const { done, value } = unpacker.next();\n    const main = value;\n    // Make sure the fields are from trusted source\n    Object.assign(main, {\n      from: context.from,\n      to: context.to,\n      ws: context.ws,\n      user: context.user,\n    });\n    main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n    Object.assign(main[\"ctx\"], this.default_context);\n    if (!done) {\n      let extra = unpacker.next();\n      Object.assign(main, extra.value);\n    }\n    this._fire(main[\"type\"], main);\n    // console.debug(\n    //   this._client_id,\n    //   `Processed message ${key} (bytes=${cache[key].byteLength})`,\n    // );\n    delete cache[key];\n  }\n\n  _on_message(message) {\n    if (typeof message === \"string\") {\n      const main = JSON.parse(message);\n      this._fire(main[\"type\"], main);\n    } else if (message instanceof ArrayBuffer) {\n      let unpacker = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(message);\n      const { done, value } = unpacker.next();\n      const main = value;\n      // Add trusted context to the method call\n      main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n      Object.assign(main[\"ctx\"], this.default_context);\n      if (!done) {\n        let extra = unpacker.next();\n        Object.assign(main, extra.value);\n      }\n      this._fire(main[\"type\"], main);\n    } else if (typeof message === \"object\") {\n      this._fire(message[\"type\"], message);\n    } else {\n      throw new Error(\"Invalid message format\");\n    }\n  }\n\n  reset() {\n    this._event_handlers = {};\n    this._services = {};\n  }\n\n  async disconnect() {\n    this._fire(\"disconnected\");\n    await this._connection.disconnect();\n  }\n\n  async get_manager_service(config) {\n    config = config || {};\n\n    // Add retry logic\n    const maxRetries = 20;\n    const retryDelay = 500; // 500ms\n\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      if (!this._connection.manager_id) {\n        if (attempt < maxRetries - 1) {\n          console.warn(\n            `Manager ID not set, retrying in ${retryDelay}ms (attempt ${attempt + 1}/${maxRetries})`,\n          );\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n          continue;\n        } else {\n          throw new Error(\"Manager ID not set after maximum retries\");\n        }\n      }\n\n      try {\n        const svc = await this.get_remote_service(\n          `*/${this._connection.manager_id}:default`,\n          config,\n        );\n        return svc;\n      } catch (e) {\n        if (attempt < maxRetries - 1) {\n          console.warn(\n            `Failed to get manager service, retrying in ${retryDelay}ms: ${e.message}`,\n          );\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n  get_all_local_services() {\n    return this._services;\n  }\n  get_local_service(service_id, context) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(service_id);\n    const [ws, client_id] = context[\"to\"].split(\"/\");\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      client_id === this._client_id,\n      \"Services can only be accessed locally\",\n    );\n\n    const service = this._services[service_id];\n    if (!service) {\n      throw new Error(\"Service not found: \" + service_id);\n    }\n\n    service.config[\"workspace\"] = context[\"ws\"];\n    // allow access for the same workspace\n    if (service.config.visibility == \"public\") {\n      return service;\n    }\n\n    // allow access for the same workspace\n    if (context[\"ws\"] === ws) {\n      return service;\n    }\n\n    throw new Error(\n      `Permission denied for getting protected service: ${service_id}, workspace mismatch: ${ws} != ${context[\"ws\"]}`,\n    );\n  }\n  async get_remote_service(service_uri, config) {\n    let { timeout, case_conversion, kwargs_expansion } = config || {};\n    timeout = timeout === undefined ? this._method_timeout : timeout;\n    if (!service_uri && this._connection.manager_id) {\n      service_uri = \"*/\" + this._connection.manager_id;\n    } else if (!service_uri.includes(\":\")) {\n      service_uri = this._client_id + \":\" + service_uri;\n    }\n    const provider = service_uri.split(\":\")[0];\n    let service_id = service_uri.split(\":\")[1];\n    if (service_id.includes(\"@\")) {\n      service_id = service_id.split(\"@\")[0];\n      const app_id = service_uri.split(\"@\")[1];\n      if (this._app_id && this._app_id !== \"*\")\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          app_id === this._app_id,\n          `Invalid app id: ${app_id} != ${this._app_id}`,\n        );\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, `Invalid service uri: ${service_uri}`);\n\n    try {\n      const method = this._generate_remote_method({\n        _rserver: this._server_base_url,\n        _rtarget: provider,\n        _rmethod: \"services.built-in.get_service\",\n        _rpromise: true,\n        _rdoc: \"Get a remote service\",\n      });\n      let svc = await (0,_utils__WEBPACK_IMPORTED_MODULE_0__.waitFor)(\n        method(service_id),\n        timeout,\n        \"Timeout Error: Failed to get remote service: \" + service_uri,\n      );\n      svc.id = `${provider}:${service_id}`;\n      if (kwargs_expansion) {\n        svc = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.expandKwargs)(svc);\n      }\n      if (case_conversion)\n        return Object.assign(\n          new RemoteService(),\n          (0,_utils__WEBPACK_IMPORTED_MODULE_0__.convertCase)(svc, case_conversion),\n        );\n      else return Object.assign(new RemoteService(), svc);\n    } catch (e) {\n      console.warn(\"Failed to get remote service: \" + service_uri, e);\n      throw e;\n    }\n  }\n  _annotate_service_methods(\n    aObject,\n    object_id,\n    require_context,\n    run_in_executor,\n    visibility,\n  ) {\n    if (typeof aObject === \"function\") {\n      // mark the method as a remote method that requires context\n      let method_name = object_id.split(\".\")[1];\n      this._method_annotations.set(aObject, {\n        require_context: Array.isArray(require_context)\n          ? require_context.includes(method_name)\n          : !!require_context,\n        run_in_executor: run_in_executor,\n        method_id: \"services.\" + object_id,\n        visibility: visibility,\n      });\n    } else if (aObject instanceof Array || aObject instanceof Object) {\n      for (let key of Object.keys(aObject)) {\n        let val = aObject[key];\n        if (typeof val === \"function\" && val.__rpc_object__) {\n          let client_id = val.__rpc_object__._rtarget;\n          if (client_id.includes(\"/\")) {\n            client_id = client_id.split(\"/\")[1];\n          }\n          if (this._client_id === client_id) {\n            if (aObject instanceof Array) {\n              aObject = aObject.slice();\n            }\n            // recover local method\n            aObject[key] = indexObject(\n              this._object_store,\n              val.__rpc_object__._rmethod,\n            );\n            val = aObject[key]; // make sure it's annotated later\n          } else {\n            throw new Error(\n              `Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`,\n            );\n          }\n        }\n        this._annotate_service_methods(\n          val,\n          object_id + \".\" + key,\n          require_context,\n          run_in_executor,\n          visibility,\n        );\n      }\n    }\n  }\n  add_service(api, overwrite) {\n    if (!api || Array.isArray(api)) throw new Error(\"Invalid service object\");\n    if (api.constructor === Object) {\n      api = Object.assign({}, api);\n    } else {\n      const normApi = {};\n      const props = Object.getOwnPropertyNames(api).concat(\n        Object.getOwnPropertyNames(Object.getPrototypeOf(api)),\n      );\n      for (let k of props) {\n        if (k !== \"constructor\") {\n          if (typeof api[k] === \"function\") normApi[k] = api[k].bind(api);\n          else normApi[k] = api[k];\n        }\n      }\n      // For class instance, we need set a default id\n      api.id = api.id || \"default\";\n      api = normApi;\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      api.id && typeof api.id === \"string\",\n      `Service id not found: ${api}`,\n    );\n    if (!api.name) {\n      api.name = api.id;\n    }\n    if (!api.config) {\n      api.config = {};\n    }\n    if (!api.type) {\n      api.type = \"generic\";\n    }\n    // require_context only applies to the top-level functions\n    let require_context = false,\n      run_in_executor = false;\n    if (api.config.require_context)\n      require_context = api.config.require_context;\n    if (api.config.run_in_executor) run_in_executor = true;\n    const visibility = api.config.visibility || \"protected\";\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)([\"protected\", \"public\"].includes(visibility));\n    this._annotate_service_methods(\n      api,\n      api[\"id\"],\n      require_context,\n      run_in_executor,\n      visibility,\n    );\n\n    if (this._services[api.id]) {\n      if (overwrite) {\n        delete this._services[api.id];\n      } else {\n        throw new Error(\n          `Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`,\n        );\n      }\n    }\n    this._services[api.id] = api;\n    return api;\n  }\n\n  _extract_service_info(service) {\n    const config = service.config || {};\n    config.workspace =\n      config.workspace || this._local_workspace || this._connection.workspace;\n    const skipContext = config.require_context;\n    const serviceSchema = _get_schema(service, null, skipContext);\n    const serviceInfo = {\n      config: config,\n      id: `${config.workspace}/${this._client_id}:${service[\"id\"]}`,\n      name: service.name || service[\"id\"],\n      description: service.description || \"\",\n      type: service.type || \"generic\",\n      docs: service.docs || null,\n      app_id: this._app_id,\n      service_schema: serviceSchema,\n    };\n    return serviceInfo;\n  }\n\n  async get_service_schema(service) {\n    const skipContext = service.config.require_context;\n    return _get_schema(service, null, skipContext);\n  }\n\n  async register_service(api, config) {\n    let { check_type, notify, overwrite } = config || {};\n    notify = notify === undefined ? true : notify;\n    let manager;\n    if (check_type && api.type) {\n      try {\n        manager = await this.get_manager_service({\n          timeout: 10,\n          case_conversion: \"camel\",\n        });\n        const type_info = await manager.get_service_type(api.type);\n        api = _annotate_service(api, type_info);\n      } catch (e) {\n        throw new Error(`Failed to get service type ${api.type}, error: ${e}`);\n      }\n    }\n\n    const service = this.add_service(api, overwrite);\n    const serviceInfo = this._extract_service_info(service);\n    if (notify) {\n      try {\n        manager =\n          manager ||\n          (await this.get_manager_service({\n            timeout: 10,\n            case_conversion: \"camel\",\n          }));\n        await manager.registerService(serviceInfo);\n      } catch (e) {\n        throw new Error(`Failed to notify workspace manager: ${e}`);\n      }\n    }\n    return serviceInfo;\n  }\n\n  async unregister_service(service, notify) {\n    notify = notify === undefined ? true : notify;\n    let service_id;\n    if (typeof service === \"string\") {\n      service_id = service;\n    } else {\n      service_id = service.id;\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      service_id && typeof service_id === \"string\",\n      `Invalid service id: ${service_id}`,\n    );\n    if (service_id.includes(\":\")) {\n      service_id = service_id.split(\":\")[1];\n    }\n    if (service_id.includes(\"@\")) {\n      service_id = service_id.split(\"@\")[0];\n    }\n    if (!this._services[service_id]) {\n      throw new Error(`Service not found: ${service_id}`);\n    }\n    if (notify) {\n      const manager = await this.get_manager_service({\n        timeout: 10,\n        case_conversion: \"camel\",\n      });\n      await manager.unregisterService(service_id);\n    }\n    delete this._services[service_id];\n  }\n\n  _ndarray(typedArray, shape, dtype) {\n    const _dtype = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(typedArray);\n    if (dtype && dtype !== _dtype) {\n      throw (\n        \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype\n      );\n    }\n    shape = shape || [typedArray.length];\n    return {\n      _rtype: \"ndarray\",\n      _rvalue: typedArray.buffer,\n      _rshape: shape,\n      _rdtype: _dtype,\n    };\n  }\n\n  _encode_callback(\n    name,\n    callback,\n    session_id,\n    clear_after_called,\n    timer,\n    local_workspace,\n    description,\n  ) {\n    let method_id = `${session_id}.${name}`;\n    let encoded = {\n      _rtype: \"method\",\n      _rtarget: local_workspace\n        ? `${local_workspace}/${this._client_id}`\n        : this._client_id,\n      _rmethod: method_id,\n      _rpromise: false,\n    };\n\n    const self = this;\n    let wrapped_callback = function () {\n      try {\n        callback.apply(null, Array.prototype.slice.call(arguments));\n      } catch (error) {\n        console.error(\n          `Error in callback(${method_id}, ${description}): ${error}`,\n        );\n      } finally {\n        if (timer && timer.started) {\n          timer.clear();\n        }\n        if (clear_after_called && self._object_store[session_id]) {\n          // console.log(\"Deleting session\", session_id, \"from\", self._client_id);\n          delete self._object_store[session_id];\n        }\n      }\n    };\n    wrapped_callback.__name__ = `callback(${method_id})`;\n    return [encoded, wrapped_callback];\n  }\n\n  async _encode_promise(\n    resolve,\n    reject,\n    session_id,\n    clear_after_called,\n    timer,\n    local_workspace,\n    description,\n  ) {\n    let store = this._get_session_store(session_id, true);\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      store,\n      `Failed to create session store ${session_id} due to invalid parent`,\n    );\n    let encoded = {};\n\n    if (timer && reject && this._method_timeout) {\n      [encoded.heartbeat, store.heartbeat] = this._encode_callback(\n        \"heartbeat\",\n        timer.reset.bind(timer),\n        session_id,\n        false,\n        null,\n        local_workspace,\n        // `heartbeat (${description})`,\n      );\n      store.timer = timer;\n      encoded.interval = this._method_timeout / 2;\n    } else {\n      timer = null;\n    }\n\n    [encoded.resolve, store.resolve] = this._encode_callback(\n      \"resolve\",\n      resolve,\n      session_id,\n      clear_after_called,\n      timer,\n      local_workspace,\n      `resolve (${description})`,\n    );\n    [encoded.reject, store.reject] = this._encode_callback(\n      \"reject\",\n      reject,\n      session_id,\n      clear_after_called,\n      timer,\n      local_workspace,\n      `reject (${description})`,\n    );\n    return encoded;\n  }\n\n  async _send_chunks(data, target_id, session_id) {\n    // 1) Get the remote service\n    const remote_services = await this.get_remote_service(\n      `${target_id}:built-in`,\n    );\n    if (!remote_services.message_cache) {\n      throw new Error(\n        \"Remote client does not support message caching for large messages.\",\n      );\n    }\n\n    const message_cache = remote_services.message_cache;\n    const message_id = session_id || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n    const total_size = data.length;\n    const start_time = Date.now(); // measure time\n    const chunk_num = Math.ceil(total_size / this._long_message_chunk_size);\n    if (remote_services.config.api_version >= 3) {\n      await message_cache.create(message_id, !!session_id);\n      const semaphore = new _utils__WEBPACK_IMPORTED_MODULE_0__.Semaphore(CONCURRENCY_LIMIT);\n\n      const tasks = [];\n      for (let idx = 0; idx < chunk_num; idx++) {\n        const startByte = idx * this._long_message_chunk_size;\n        const chunk = data.slice(\n          startByte,\n          startByte + this._long_message_chunk_size,\n        );\n\n        const taskFn = async () => {\n          await message_cache.set(message_id, idx, chunk, !!session_id);\n          console.debug(\n            `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`,\n          );\n        };\n\n        // Push into an array, each one runs under the semaphore\n        tasks.push(semaphore.run(taskFn));\n      }\n\n      // Wait for all chunk uploads to finish\n      await Promise.all(tasks);\n    } else {\n      // 3) Legacy version (sequential appends):\n      await message_cache.create(message_id, !!session_id);\n      for (let idx = 0; idx < chunk_num; idx++) {\n        const startByte = idx * this._long_message_chunk_size;\n        const chunk = data.slice(\n          startByte,\n          startByte + this._long_message_chunk_size,\n        );\n        await message_cache.append(message_id, chunk, !!session_id);\n        console.debug(\n          `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`,\n        );\n      }\n    }\n    await message_cache.process(message_id, !!session_id);\n    const durationSec = ((Date.now() - start_time) / 1000).toFixed(2);\n    console.debug(`All chunks (${total_size} bytes) sent in ${durationSec} s`);\n  }\n\n  emit(main_message, extra_data) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n      typeof main_message === \"object\" && main_message.type,\n      \"Invalid message, must be an object with a `type` fields.\",\n    );\n    if (!main_message.to) {\n      this._fire(main_message.type, main_message);\n      return;\n    }\n    let message_package = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n    if (extra_data) {\n      const extra = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n      message_package = new Uint8Array([...message_package, ...extra]);\n    }\n    const total_size = message_package.length;\n    if (total_size > this._long_message_chunk_size + 1024) {\n      console.warn(`Sending large message (size=${total_size})`);\n    }\n    return this._emit_message(message_package);\n  }\n\n  _generate_remote_method(\n    encoded_method,\n    remote_parent,\n    local_parent,\n    remote_workspace,\n    local_workspace,\n  ) {\n    let target_id = encoded_method._rtarget;\n    if (remote_workspace && !target_id.includes(\"/\")) {\n      if (remote_workspace !== target_id) {\n        target_id = remote_workspace + \"/\" + target_id;\n      }\n      // Fix the target id to be an absolute id\n      encoded_method._rtarget = target_id;\n    }\n    let method_id = encoded_method._rmethod;\n    let with_promise = encoded_method._rpromise || false;\n    const description = `method: ${method_id}, docs: ${encoded_method._rdoc}`;\n    const self = this;\n\n    function remote_method() {\n      return new Promise(async (resolve, reject) => {\n        let local_session_id = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n        if (local_parent) {\n          // Store the children session under the parent\n          local_session_id = local_parent + \".\" + local_session_id;\n        }\n        let store = self._get_session_store(local_session_id, true);\n        if (!store) {\n          reject(\n            new Error(\n              `Runtime Error: Failed to get session store ${local_session_id} (context: ${description})`,\n            ),\n          );\n          return;\n        }\n        store[\"target_id\"] = target_id;\n        const args = await self._encode(\n          Array.prototype.slice.call(arguments),\n          local_session_id,\n          local_workspace,\n        );\n        const argLength = args.length;\n        // if the last argument is an object, mark it as kwargs\n        const withKwargs =\n          argLength > 0 &&\n          typeof args[argLength - 1] === \"object\" &&\n          args[argLength - 1] !== null &&\n          args[argLength - 1]._rkwargs;\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\n\n        let from_client;\n        if (!self._local_workspace) {\n          from_client = self._client_id;\n        } else {\n          from_client = self._local_workspace + \"/\" + self._client_id;\n        }\n\n        let main_message = {\n          type: \"method\",\n          from: from_client,\n          to: target_id,\n          method: method_id,\n        };\n        let extra_data = {};\n        if (args) {\n          extra_data[\"args\"] = args;\n        }\n        if (withKwargs) {\n          extra_data[\"with_kwargs\"] = withKwargs;\n        }\n\n        // console.log(\n        //   `Calling remote method ${target_id}:${method_id}, session: ${local_session_id}`\n        // );\n        if (remote_parent) {\n          // Set the parent session\n          // Note: It's a session id for the remote, not the current client\n          main_message[\"parent\"] = remote_parent;\n        }\n\n        let timer = null;\n        if (with_promise) {\n          // Only pass the current session id to the remote\n          // if we want to received the result\n          // I.e. the session id won't be passed for promises themselves\n          main_message[\"session\"] = local_session_id;\n          let method_name = `${target_id}:${method_id}`;\n          timer = new Timer(\n            self._method_timeout,\n            reject,\n            [`Method call time out: ${method_name}, context: ${description}`],\n            method_name,\n          );\n          // By default, hypha will clear the session after the method is called\n          // However, if the args contains _rintf === true, we will not clear the session\n          let clear_after_called = true;\n          for (let arg of args) {\n            if (typeof arg === \"object\" && arg._rintf === true) {\n              clear_after_called = false;\n              break;\n            }\n          }\n          const promiseData = await self._encode_promise(\n            resolve,\n            reject,\n            local_session_id,\n            clear_after_called,\n            timer,\n            local_workspace,\n            description,\n          );\n\n          if (with_promise === true) {\n            extra_data[\"promise\"] = promiseData;\n          } else if (with_promise === \"*\") {\n            extra_data[\"promise\"] = \"*\";\n            extra_data[\"t\"] = self._method_timeout / 2;\n          } else {\n            throw new Error(`Unsupported promise type: ${with_promise}`);\n          }\n        }\n        // The message consists of two segments, the main message and extra data\n        let message_package = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n        if (extra_data) {\n          const extra = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n          message_package = new Uint8Array([...message_package, ...extra]);\n        }\n        const total_size = message_package.length;\n        if (\n          total_size <= self._long_message_chunk_size + 1024 ||\n          remote_method.__no_chunk__\n        ) {\n          self\n            ._emit_message(message_package)\n            .then(function () {\n              if (timer) {\n                // If resolved successfully, reset the timer\n                timer.reset();\n              }\n            })\n            .catch(function (err) {\n              console.error(\"Failed to send message\", err);\n              reject(err);\n              if (timer) {\n                timer.clear();\n              }\n            });\n        } else {\n          // send chunk by chunk\n          self\n            ._send_chunks(message_package, target_id, remote_parent)\n            .then(function () {\n              if (timer) {\n                // If resolved successfully, reset the timer\n                timer.reset();\n              }\n            })\n            .catch(function (err) {\n              console.error(\"Failed to send message\", err);\n              reject(err);\n              if (timer) {\n                timer.clear();\n              }\n            });\n        }\n      });\n    }\n\n    // Generate debugging information for the method\n    remote_method.__rpc_object__ = encoded_method;\n    const parts = method_id.split(\".\");\n\n    remote_method.__name__ = encoded_method._rname || parts[parts.length - 1];\n    if (remote_method.__name__.includes(\"#\")) {\n      remote_method.__name__ = remote_method.__name__.split(\"#\")[1];\n    }\n    remote_method.__doc__ =\n      encoded_method._rdoc || `Remote method: ${method_id}`;\n    remote_method.__schema__ = encoded_method._rschema;\n    // Prevent circular chunk sending\n    remote_method.__no_chunk__ =\n      encoded_method._rmethod === \"services.built-in.message_cache.append\";\n    return remote_method;\n  }\n\n  get_client_info() {\n    const services = [];\n    for (let service of Object.values(this._services)) {\n      services.push(this._extract_service_info(service));\n    }\n\n    return {\n      id: this._client_id,\n      services: services,\n    };\n  }\n\n  async _handle_method(data) {\n    let reject = null;\n    let heartbeat_task = null;\n    try {\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data.method && data.ctx && data.from);\n      const method_name = data.from + \":\" + data.method;\n      const remote_workspace = data.from.split(\"/\")[0];\n      const remote_client_id = data.from.split(\"/\")[1];\n      // Make sure the target id is an absolute id\n      data[\"to\"] = data[\"to\"].includes(\"/\")\n        ? data[\"to\"]\n        : remote_workspace + \"/\" + data[\"to\"];\n      data[\"ctx\"][\"to\"] = data[\"to\"];\n      let local_workspace;\n      if (!this._local_workspace) {\n        local_workspace = data[\"to\"].split(\"/\")[0];\n      } else {\n        if (this._local_workspace && this._local_workspace !== \"*\") {\n          (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n            data[\"to\"].split(\"/\")[0] === this._local_workspace,\n            \"Workspace mismatch: \" +\n              data[\"to\"].split(\"/\")[0] +\n              \" != \" +\n              this._local_workspace,\n          );\n        }\n        local_workspace = this._local_workspace;\n      }\n      const local_parent = data.parent;\n\n      let resolve, reject;\n      if (data.promise) {\n        // Decode the promise with the remote session id\n        // Such that the session id will be passed to the remote as a parent session id\n        const promise = await this._decode(\n          data.promise === \"*\" ? this._expand_promise(data) : data.promise,\n          data.session,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        resolve = promise.resolve;\n        reject = promise.reject;\n        if (promise.heartbeat && promise.interval) {\n          async function heartbeat() {\n            try {\n              // console.debug(\"Reset heartbeat timer: \" + data.method);\n              await promise.heartbeat();\n            } catch (err) {\n              console.error(err);\n            }\n          }\n          heartbeat_task = setInterval(heartbeat, promise.interval * 1000);\n        }\n      }\n\n      let method;\n\n      try {\n        method = indexObject(this._object_store, data[\"method\"]);\n      } catch (e) {\n        // console.debug(\"Failed to find method\", method_name, this._client_id, e);\n        throw new Error(\n          `Method not found: ${method_name} at ${this._client_id}`,\n        );\n      }\n\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        method && typeof method === \"function\",\n        \"Invalid method: \" + method_name,\n      );\n\n      // Check permission\n      if (this._method_annotations.has(method)) {\n        // For services, it should not be protected\n        if (this._method_annotations.get(method).visibility === \"protected\") {\n          if (\n            local_workspace !== remote_workspace &&\n            (remote_workspace !== \"*\" ||\n              remote_client_id !== this._connection.manager_id)\n          ) {\n            throw new Error(\n              \"Permission denied for invoking protected method \" +\n                method_name +\n                \", workspace mismatch: \" +\n                local_workspace +\n                \" != \" +\n                remote_workspace,\n            );\n          }\n        }\n      } else {\n        // For sessions, the target_id should match exactly\n        let session_target_id =\n          this._object_store[data.method.split(\".\")[0]].target_id;\n        if (\n          local_workspace === remote_workspace &&\n          session_target_id &&\n          session_target_id.indexOf(\"/\") === -1\n        ) {\n          session_target_id = local_workspace + \"/\" + session_target_id;\n        }\n        if (session_target_id !== data.from) {\n          throw new Error(\n            \"Access denied for method call (\" +\n              method_name +\n              \") from \" +\n              data.from +\n              \" to target \" +\n              session_target_id,\n          );\n        }\n      }\n\n      // Make sure the parent session is still open\n      if (local_parent) {\n        // The parent session should be a session that generate the current method call\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          this._get_session_store(local_parent, true) !== null,\n          \"Parent session was closed: \" + local_parent,\n        );\n      }\n      let args;\n      if (data.args) {\n        args = await this._decode(\n          data.args,\n          data.session,\n          null,\n          remote_workspace,\n          null,\n        );\n      } else {\n        args = [];\n      }\n      if (\n        this._method_annotations.has(method) &&\n        this._method_annotations.get(method).require_context\n      ) {\n        // if args.length + 1 is less than the required number of arguments we will pad with undefined\n        // so we make sure the last argument is the context\n        if (args.length + 1 < method.length) {\n          for (let i = args.length; i < method.length - 1; i++) {\n            args.push(undefined);\n          }\n        }\n        args.push(data.ctx);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          args.length === method.length,\n          `Runtime Error: Invalid number of arguments for method ${method_name}, expected ${method.length} but got ${args.length}`,\n        );\n      }\n      // console.debug(`Executing method: ${method_name} (${data.method})`);\n      if (data.promise) {\n        const result = method.apply(null, args);\n        if (result instanceof Promise) {\n          result\n            .then((result) => {\n              resolve(result);\n              clearInterval(heartbeat_task);\n            })\n            .catch((err) => {\n              reject(err);\n              clearInterval(heartbeat_task);\n            });\n        } else {\n          resolve(result);\n          clearInterval(heartbeat_task);\n        }\n      } else {\n        method.apply(null, args);\n        clearInterval(heartbeat_task);\n      }\n    } catch (err) {\n      if (reject) {\n        reject(err);\n        // console.debug(\"Error during calling method: \", err);\n      } else {\n        console.error(\"Error during calling method: \", err);\n      }\n      // make sure we clear the heartbeat timer\n      clearInterval(heartbeat_task);\n    }\n  }\n\n  encode(aObject, session_id) {\n    return this._encode(aObject, session_id);\n  }\n\n  _get_session_store(session_id, create) {\n    let store = this._object_store;\n    const levels = session_id.split(\".\");\n    if (create) {\n      const last_index = levels.length - 1;\n      for (let level of levels.slice(0, last_index)) {\n        if (!store[level]) {\n          return null;\n        }\n        store = store[level];\n      }\n      // Create the last level\n      if (!store[levels[last_index]]) {\n        store[levels[last_index]] = {};\n      }\n      return store[levels[last_index]];\n    } else {\n      for (let level of levels) {\n        if (!store[level]) {\n          return null;\n        }\n        store = store[level];\n      }\n      return store;\n    }\n  }\n\n  /**\n   * Prepares the provided set of remote method arguments for\n   * sending to the remote site, replaces all the callbacks with\n   * identifiers\n   *\n   * @param {Array} args to wrap\n   *\n   * @returns {Array} wrapped arguments\n   */\n  async _encode(aObject, session_id, local_workspace) {\n    const aType = typeof aObject;\n    if (\n      aType === \"number\" ||\n      aType === \"string\" ||\n      aType === \"boolean\" ||\n      aObject === null ||\n      aObject === undefined ||\n      aObject instanceof Uint8Array\n    ) {\n      return aObject;\n    }\n    if (aObject instanceof ArrayBuffer) {\n      return {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject),\n      };\n    }\n    // Reuse the remote object\n    if (aObject.__rpc_object__) {\n      const _server = aObject.__rpc_object__._rserver || this._server_base_url;\n      if (_server === this._server_base_url) {\n        return aObject.__rpc_object__;\n      } // else {\n      //   console.debug(\n      //     `Encoding remote function from a different server ${_server}, current server: ${this._server_base_url}`,\n      //   );\n      // }\n    }\n\n    let bObject;\n\n    // skip if already encoded\n    if (aObject.constructor instanceof Object && aObject._rtype) {\n      // make sure the interface functions are encoded\n      const temp = aObject._rtype;\n      delete aObject._rtype;\n      bObject = await this._encode(aObject, session_id, local_workspace);\n      bObject._rtype = temp;\n      return bObject;\n    }\n\n    if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.isGenerator)(aObject) || (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isAsyncGenerator)(aObject)) {\n      // Handle generator functions and generator objects\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        session_id && typeof session_id === \"string\",\n        \"Session ID is required for generator encoding\",\n      );\n      const object_id = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n\n      // Get the session store\n      const store = this._get_session_store(session_id, true);\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n        store !== null,\n        `Failed to create session store ${session_id} due to invalid parent`,\n      );\n\n      // Check if it's an async generator\n      const isAsync = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.isAsyncGenerator)(aObject);\n\n      // Define method to get next item from the generator\n      const nextItemMethod = async () => {\n        if (isAsync) {\n          const iterator = aObject;\n          const result = await iterator.next();\n          if (result.done) {\n            delete store[object_id];\n            return { _rtype: \"stop_iteration\" };\n          }\n          return result.value;\n        } else {\n          const iterator = aObject;\n          const result = iterator.next();\n          if (result.done) {\n            delete store[object_id];\n            return { _rtype: \"stop_iteration\" };\n          }\n          return result.value;\n        }\n      };\n\n      // Store the next_item method in the session\n      store[object_id] = nextItemMethod;\n\n      // Create a method that will be used to fetch the next item from the generator\n      bObject = {\n        _rtype: \"generator\",\n        _rserver: this._server_base_url,\n        _rtarget: this._client_id,\n        _rmethod: `${session_id}.${object_id}`,\n        _rpromise: \"*\",\n        _rdoc: \"Remote generator\",\n      };\n      return bObject;\n    } else if (typeof aObject === \"function\") {\n      if (this._method_annotations.has(aObject)) {\n        let annotation = this._method_annotations.get(aObject);\n        bObject = {\n          _rtype: \"method\",\n          _rserver: this._server_base_url,\n          _rtarget: this._client_id,\n          _rmethod: annotation.method_id,\n          _rpromise: \"*\",\n          _rname: aObject.name,\n        };\n      } else {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof session_id === \"string\");\n        let object_id;\n        if (aObject.__name__) {\n          object_id = `${(0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)()}#${aObject.__name__}`;\n        } else {\n          object_id = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n        }\n        bObject = {\n          _rtype: \"method\",\n          _rserver: this._server_base_url,\n          _rtarget: this._client_id,\n          _rmethod: `${session_id}.${object_id}`,\n          _rpromise: \"*\",\n          _rname: aObject.name,\n        };\n        let store = this._get_session_store(session_id, true);\n        (0,_utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n          store !== null,\n          `Failed to create session store ${session_id} due to invalid parent`,\n        );\n        store[object_id] = aObject;\n      }\n      bObject._rdoc = aObject.__doc__;\n      if (!bObject._rdoc) {\n        try {\n          const funcInfo = getFunctionInfo(aObject);\n          if (funcInfo && !bObject._rdoc) {\n            bObject._rdoc = `${funcInfo.doc}`;\n          }\n        } catch (e) {\n          console.error(\"Failed to extract function docstring:\", aObject);\n        }\n      }\n      bObject._rschema = aObject.__schema__;\n      return bObject;\n    }\n    const isarray = Array.isArray(aObject);\n\n    for (let tp of Object.keys(this._codecs)) {\n      const codec = this._codecs[tp];\n      if (codec.encoder && aObject instanceof codec.type) {\n        // TODO: what if multiple encoders found\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name;\n        // encode the functions in the interface object\n        if (typeof encodedObj === \"object\") {\n          const temp = encodedObj._rtype;\n          delete encodedObj._rtype;\n          encodedObj = await this._encode(\n            encodedObj,\n            session_id,\n            local_workspace,\n          );\n          encodedObj._rtype = temp;\n        }\n        bObject = encodedObj;\n        return bObject;\n      }\n    }\n\n    if (\n      /*global tf*/\n      typeof tf !== \"undefined\" &&\n      tf.Tensor &&\n      aObject instanceof tf.Tensor\n    ) {\n      const v_buffer = aObject.dataSync();\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(v_buffer.buffer),\n        _rshape: aObject.shape,\n        _rdtype: aObject.dtype,\n      };\n    } else if (\n      /*global nj*/\n      typeof nj !== \"undefined\" &&\n      nj.NdArray &&\n      aObject instanceof nj.NdArray\n    ) {\n      const dtype = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject.selection.data);\n      bObject = {\n        _rtype: \"ndarray\",\n        _rvalue: new Uint8Array(aObject.selection.data.buffer),\n        _rshape: aObject.shape,\n        _rdtype: dtype,\n      };\n    } else if (aObject instanceof Error) {\n      console.error(aObject);\n      bObject = {\n        _rtype: \"error\",\n        _rvalue: aObject.toString(),\n        _rtrace: aObject.stack,\n      };\n    }\n    // send objects supported by structure clone algorithm\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n    else if (\n      aObject !== Object(aObject) ||\n      aObject instanceof Boolean ||\n      aObject instanceof String ||\n      aObject instanceof Date ||\n      aObject instanceof RegExp ||\n      aObject instanceof ImageData ||\n      (typeof FileList !== \"undefined\" && aObject instanceof FileList) ||\n      (typeof FileSystemDirectoryHandle !== \"undefined\" &&\n        aObject instanceof FileSystemDirectoryHandle) ||\n      (typeof FileSystemFileHandle !== \"undefined\" &&\n        aObject instanceof FileSystemFileHandle) ||\n      (typeof FileSystemHandle !== \"undefined\" &&\n        aObject instanceof FileSystemHandle) ||\n      (typeof FileSystemWritableFileStream !== \"undefined\" &&\n        aObject instanceof FileSystemWritableFileStream)\n    ) {\n      bObject = aObject;\n      // TODO: avoid object such as DynamicPlugin instance.\n    } else if (aObject instanceof Blob) {\n      let _current_pos = 0;\n      async function read(length) {\n        let blob;\n        if (length) {\n          blob = aObject.slice(_current_pos, _current_pos + length);\n        } else {\n          blob = aObject.slice(_current_pos);\n        }\n        const ret = new Uint8Array(await blob.arrayBuffer());\n        _current_pos = _current_pos + ret.byteLength;\n        return ret;\n      }\n      function seek(pos) {\n        _current_pos = pos;\n      }\n      bObject = {\n        _rtype: \"iostream\",\n        _rnative: \"js:blob\",\n        type: aObject.type,\n        name: aObject.name,\n        size: aObject.size,\n        path: aObject._path || aObject.webkitRelativePath,\n        read: await this._encode(read, session_id, local_workspace),\n        seek: await this._encode(seek, session_id, local_workspace),\n      };\n    } else if (aObject instanceof ArrayBufferView) {\n      const dtype = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject);\n      bObject = {\n        _rtype: \"typedarray\",\n        _rvalue: new Uint8Array(aObject.buffer),\n        _rdtype: dtype,\n      };\n    } else if (aObject instanceof DataView) {\n      bObject = {\n        _rtype: \"memoryview\",\n        _rvalue: new Uint8Array(aObject.buffer),\n      };\n    } else if (aObject instanceof Set) {\n      bObject = {\n        _rtype: \"set\",\n        _rvalue: await this._encode(\n          Array.from(aObject),\n          session_id,\n          local_workspace,\n        ),\n      };\n    } else if (aObject instanceof Map) {\n      bObject = {\n        _rtype: \"orderedmap\",\n        _rvalue: await this._encode(\n          Array.from(aObject),\n          session_id,\n          local_workspace,\n        ),\n      };\n    } else if (\n      aObject.constructor instanceof Object ||\n      Array.isArray(aObject)\n    ) {\n      bObject = isarray ? [] : {};\n      const keys = Object.keys(aObject);\n      for (let k of keys) {\n        bObject[k] = await this._encode(\n          aObject[k],\n          session_id,\n          local_workspace,\n        );\n      }\n    } else {\n      throw `hypha-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n    }\n\n    if (!bObject) {\n      throw new Error(\"Failed to encode object\");\n    }\n    return bObject;\n  }\n\n  async decode(aObject) {\n    return await this._decode(aObject);\n  }\n\n  async _decode(\n    aObject,\n    remote_parent,\n    local_parent,\n    remote_workspace,\n    local_workspace,\n  ) {\n    if (!aObject) {\n      return aObject;\n    }\n    let bObject;\n    if (aObject._rtype) {\n      if (\n        this._codecs[aObject._rtype] &&\n        this._codecs[aObject._rtype].decoder\n      ) {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        aObject = await this._decode(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        aObject._rtype = temp;\n\n        bObject = await Promise.resolve(\n          this._codecs[aObject._rtype].decoder(aObject),\n        );\n      } else if (aObject._rtype === \"method\") {\n        bObject = this._generate_remote_method(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n      } else if (aObject._rtype === \"generator\") {\n        // Create a method to fetch next items from the remote generator\n        const gen_method = this._generate_remote_method(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n\n        // Create an async generator proxy\n        async function* asyncGeneratorProxy() {\n          try {\n            while (true) {\n              try {\n                const next_item = await gen_method();\n                // Check for StopIteration signal\n                if (next_item && next_item._rtype === \"stop_iteration\") {\n                  break;\n                }\n                yield next_item;\n              } catch (error) {\n                console.error(\"Error in generator:\", error);\n                throw error;\n              }\n            }\n          } catch (error) {\n            console.error(\"Error in generator:\", error);\n            throw error;\n          }\n        }\n        bObject = asyncGeneratorProxy();\n      } else if (aObject._rtype === \"ndarray\") {\n        /*global nj tf*/\n        //create build array/tensor if used in the plugin\n        if (typeof nj !== \"undefined\" && nj.array) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n          bObject = nj\n            .array(new Uint8(aObject._rvalue), aObject._rdtype)\n            .reshape(aObject._rshape);\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n          if (Array.isArray(aObject._rvalue)) {\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n          }\n          const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n          bObject = tf.tensor(\n            new arraytype(aObject._rvalue),\n            aObject._rshape,\n            aObject._rdtype,\n          );\n        } else {\n          //keep it as regular if transfered to the main app\n          bObject = aObject;\n        }\n      } else if (aObject._rtype === \"error\") {\n        bObject = new Error(\n          \"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"),\n        );\n      } else if (aObject._rtype === \"typedarray\") {\n        const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n        if (!arraytype)\n          throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n        const buffer = aObject._rvalue.buffer.slice(\n          aObject._rvalue.byteOffset,\n          aObject._rvalue.byteOffset + aObject._rvalue.byteLength,\n        );\n        bObject = new arraytype(buffer);\n      } else if (aObject._rtype === \"memoryview\") {\n        bObject = aObject._rvalue.buffer.slice(\n          aObject._rvalue.byteOffset,\n          aObject._rvalue.byteOffset + aObject._rvalue.byteLength,\n        ); // ArrayBuffer\n      } else if (aObject._rtype === \"iostream\") {\n        if (aObject._rnative === \"js:blob\") {\n          const read = await this._generate_remote_method(\n            aObject.read,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          );\n          const bytes = await read();\n          bObject = new Blob([bytes], {\n            type: aObject.type,\n            name: aObject.name,\n          });\n        } else {\n          bObject = {};\n          for (let k of Object.keys(aObject)) {\n            if (!k.startsWith(\"_\")) {\n              bObject[k] = await this._decode(\n                aObject[k],\n                remote_parent,\n                local_parent,\n                remote_workspace,\n                local_workspace,\n              );\n            }\n          }\n        }\n        bObject[\"__rpc_object__\"] = aObject;\n      } else if (aObject._rtype === \"orderedmap\") {\n        bObject = new Map(\n          await this._decode(\n            aObject._rvalue,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          ),\n        );\n      } else if (aObject._rtype === \"set\") {\n        bObject = new Set(\n          await this._decode(\n            aObject._rvalue,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          ),\n        );\n      } else {\n        const temp = aObject._rtype;\n        delete aObject._rtype;\n        bObject = await this._decode(\n          aObject,\n          remote_parent,\n          local_parent,\n          remote_workspace,\n          local_workspace,\n        );\n        bObject._rtype = temp;\n      }\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n      const isarray = Array.isArray(aObject);\n      bObject = isarray ? [] : {};\n      for (let k of Object.keys(aObject)) {\n        if (isarray || aObject.hasOwnProperty(k)) {\n          const v = aObject[k];\n          bObject[k] = await this._decode(\n            v,\n            remote_parent,\n            local_parent,\n            remote_workspace,\n            local_workspace,\n          );\n        }\n      }\n    } else {\n      bObject = aObject;\n    }\n    if (bObject === undefined) {\n      throw new Error(\"Failed to decode object\");\n    }\n    return bObject;\n  }\n\n  _expand_promise(data) {\n    return {\n      heartbeat: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".heartbeat\",\n        _rdoc: `heartbeat callback for method: ${data.method}`,\n      },\n      resolve: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".resolve\",\n        _rdoc: `resolve callback for method: ${data.method}`,\n      },\n      reject: {\n        _rtype: \"method\",\n        _rtarget: data.from.split(\"/\")[1],\n        _rmethod: data.session + \".reject\",\n        _rdoc: `reject callback for method: ${data.method}`,\n      },\n      interval: data.t,\n    };\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/index.js\":\n/*!****************************!*\\\n  !*** ./src/utils/index.js ***!\n  \\****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_66189__) => {\n\n__nested_webpack_require_66189__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_66189__.d(__nested_webpack_exports__, {\n/* harmony export */   MessageEmitter: () => (/* binding */ MessageEmitter),\n/* harmony export */   Semaphore: () => (/* binding */ Semaphore),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   cacheRequirements: () => (/* binding */ cacheRequirements),\n/* harmony export */   convertCase: () => (/* binding */ convertCase),\n/* harmony export */   dtypeToTypedArray: () => (/* binding */ dtypeToTypedArray),\n/* harmony export */   expandKwargs: () => (/* binding */ expandKwargs),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isGenerator: () => (/* binding */ isGenerator),\n/* harmony export */   loadRequirements: () => (/* binding */ loadRequirements),\n/* harmony export */   loadRequirementsInWebworker: () => (/* binding */ loadRequirementsInWebworker),\n/* harmony export */   loadRequirementsInWindow: () => (/* binding */ loadRequirementsInWindow),\n/* harmony export */   normalizeConfig: () => (/* binding */ normalizeConfig),\n/* harmony export */   parseServiceUrl: () => (/* binding */ parseServiceUrl),\n/* harmony export */   randId: () => (/* binding */ randId),\n/* harmony export */   toCamelCase: () => (/* binding */ toCamelCase),\n/* harmony export */   toSnakeCase: () => (/* binding */ toSnakeCase),\n/* harmony export */   typedArrayToDtype: () => (/* binding */ typedArrayToDtype),\n/* harmony export */   typedArrayToDtypeMapping: () => (/* binding */ typedArrayToDtypeMapping),\n/* harmony export */   urlJoin: () => (/* binding */ urlJoin),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\n}\n\nfunction toCamelCase(str) {\n  // Check if the string is already in camelCase\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  // Convert from snake_case to camelCase\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\n\nfunction toSnakeCase(str) {\n  // Convert from camelCase to snake_case\n  return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n}\n\nfunction expandKwargs(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj; // Return the value if obj is not an object\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n\n      if (typeof value === \"function\") {\n        newObj[key] = (...args) => {\n          if (args.length === 0) {\n            throw new Error(`Function \"${key}\" expects at least one argument.`);\n          }\n\n          // Check if the last argument is an object\n          const lastArg = args[args.length - 1];\n          let kwargs = {};\n\n          if (\n            typeof lastArg === \"object\" &&\n            lastArg !== null &&\n            !Array.isArray(lastArg)\n          ) {\n            // Extract kwargs from the last argument\n            kwargs = { ...lastArg, _rkwarg: true };\n            args = args.slice(0, -1); // Remove the last argument from args\n          }\n\n          // Call the original function with positional args followed by kwargs\n          return value(...args, kwargs);\n        };\n\n        // Preserve metadata like __name__ and __schema__\n        newObj[key].__name__ = key;\n        if (value.__schema__) {\n          newObj[key].__schema__ = { ...value.__schema__ };\n          newObj[key].__schema__.name = key;\n        }\n      } else {\n        newObj[key] = expandKwargs(value); // Recursively process nested objects\n      }\n    }\n  }\n\n  return newObj;\n}\n\nfunction convertCase(obj, caseType) {\n  if (typeof obj !== \"object\" || obj === null || !caseType) {\n    return obj; // Return the value if obj is not an object\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n      const camelKey = toCamelCase(key);\n      const snakeKey = toSnakeCase(key);\n\n      if (caseType === \"camel\") {\n        newObj[camelKey] = convertCase(value, caseType);\n        if (typeof value === \"function\") {\n          newObj[camelKey].__name__ = camelKey;\n          if (value.__schema__) {\n            newObj[camelKey].__schema__ = { ...value.__schema__ };\n            newObj[camelKey].__schema__.name = camelKey;\n          }\n        }\n      } else if (caseType === \"snake\") {\n        newObj[snakeKey] = convertCase(value, caseType);\n        if (typeof value === \"function\") {\n          newObj[snakeKey].__name__ = snakeKey;\n          if (value.__schema__) {\n            newObj[snakeKey].__schema__ = { ...value.__schema__ };\n            newObj[snakeKey].__schema__.name = snakeKey;\n          }\n        }\n      } else {\n        // TODO handle schema for camel + snake\n        if (caseType.includes(\"camel\")) {\n          newObj[camelKey] = convertCase(value, \"camel\");\n        }\n        if (caseType.includes(\"snake\")) {\n          newObj[snakeKey] = convertCase(value, \"snake\");\n        }\n      }\n    }\n  }\n\n  return newObj;\n}\n\nfunction parseServiceUrl(url) {\n  // Ensure no trailing slash\n  url = url.replace(/\\/$/, \"\");\n\n  // Regex pattern to match the URL structure\n  const pattern = new RegExp(\n    \"^(https?:\\\\/\\\\/[^/]+)\" + // server_url (http or https followed by domain)\n      \"\\\\/([a-z0-9_-]+)\" + // workspace (lowercase letters, numbers, - or _)\n      \"\\\\/services\\\\/\" + // static part of the URL\n      \"(?:(?<clientId>[a-zA-Z0-9_-]+):)?\" + // optional client_id\n      \"(?<serviceId>[a-zA-Z0-9_-]+)\" + // service_id\n      \"(?:@(?<appId>[a-zA-Z0-9_-]+))?\", // optional app_id\n  );\n\n  const match = url.match(pattern);\n  if (!match) {\n    throw new Error(\"URL does not match the expected pattern\");\n  }\n\n  const serverUrl = match[1];\n  const workspace = match[2];\n  const clientId = match.groups?.clientId || \"*\";\n  const serviceId = match.groups?.serviceId;\n  const appId = match.groups?.appId || \"*\";\n\n  return { serverUrl, workspace, clientId, serviceId, appId };\n}\n\nconst dtypeToTypedArray = {\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  float32: Float32Array,\n  float64: Float64Array,\n  array: Array,\n};\n\nasync function loadRequirementsInWindow(requirements) {\n  function _importScript(url) {\n    //url is URL of external file, implementationCode is the code\n    //to be called from the file, location is the location to\n    //insert the <script> element\n    return new Promise((resolve, reject) => {\n      var scriptTag = document.createElement(\"script\");\n      scriptTag.src = url;\n      scriptTag.type = \"text/javascript\";\n      scriptTag.onload = resolve;\n      scriptTag.onreadystatechange = function () {\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n          resolve();\n        }\n      };\n      scriptTag.onerror = reject;\n      document.head.appendChild(scriptTag);\n    });\n  }\n\n  // support importScripts outside web worker\n  async function importScripts() {\n    var args = Array.prototype.slice.call(arguments),\n      len = args.length,\n      i = 0;\n    for (; i < len; i++) {\n      await _importScript(args[i]);\n    }\n  }\n\n  if (\n    requirements &&\n    (Array.isArray(requirements) || typeof requirements === \"string\")\n  ) {\n    try {\n      var link_node;\n      requirements =\n        typeof requirements === \"string\" ? [requirements] : requirements;\n      if (Array.isArray(requirements)) {\n        for (var i = 0; i < requirements.length; i++) {\n          if (\n            requirements[i].toLowerCase().endsWith(\".css\") ||\n            requirements[i].startsWith(\"css:\")\n          ) {\n            if (requirements[i].startsWith(\"css:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n            link_node = document.createElement(\"link\");\n            link_node.rel = \"stylesheet\";\n            link_node.href = requirements[i];\n            document.head.appendChild(link_node);\n          } else if (\n            requirements[i].toLowerCase().endsWith(\".mjs\") ||\n            requirements[i].startsWith(\"mjs:\")\n          ) {\n            // import esmodule\n            if (requirements[i].startsWith(\"mjs:\")) {\n              requirements[i] = requirements[i].slice(4);\n            }\n            await import(/* webpackIgnore: true */ requirements[i]);\n          } else if (\n            requirements[i].toLowerCase().endsWith(\".js\") ||\n            requirements[i].startsWith(\"js:\")\n          ) {\n            if (requirements[i].startsWith(\"js:\")) {\n              requirements[i] = requirements[i].slice(3);\n            }\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"http\")) {\n            await importScripts(requirements[i]);\n          } else if (requirements[i].startsWith(\"cache:\")) {\n            //ignore cache\n          } else {\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\n          }\n        }\n      } else {\n        throw \"unsupported requirements definition\";\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\n\nasync function loadRequirementsInWebworker(requirements) {\n  if (\n    requirements &&\n    (Array.isArray(requirements) || typeof requirements === \"string\")\n  ) {\n    try {\n      if (!Array.isArray(requirements)) {\n        requirements = [requirements];\n      }\n      for (var i = 0; i < requirements.length; i++) {\n        if (\n          requirements[i].toLowerCase().endsWith(\".css\") ||\n          requirements[i].startsWith(\"css:\")\n        ) {\n          throw \"unable to import css in a webworker\";\n        } else if (\n          requirements[i].toLowerCase().endsWith(\".js\") ||\n          requirements[i].startsWith(\"js:\")\n        ) {\n          if (requirements[i].startsWith(\"js:\")) {\n            requirements[i] = requirements[i].slice(3);\n          }\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"http\")) {\n          importScripts(requirements[i]);\n        } else if (requirements[i].startsWith(\"cache:\")) {\n          //ignore cache\n        } else {\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\n        }\n      }\n    } catch (e) {\n      throw \"failed to import required scripts: \" + requirements.toString();\n    }\n  }\n}\n\nfunction loadRequirements(requirements) {\n  if (\n    typeof WorkerGlobalScope !== \"undefined\" &&\n    self instanceof WorkerGlobalScope\n  ) {\n    return loadRequirementsInWebworker(requirements);\n  } else {\n    return loadRequirementsInWindow(requirements);\n  }\n}\n\nfunction normalizeConfig(config) {\n  config.version = config.version || \"0.1.0\";\n  config.description =\n    config.description || `[TODO: add description for ${config.name} ]`;\n  config.type = config.type || \"rpc-window\";\n  config.id = config.id || randId();\n  config.target_origin = config.target_origin || \"*\";\n  config.allow_execution = config.allow_execution || false;\n  // remove functions\n  config = Object.keys(config).reduce((p, c) => {\n    if (typeof config[c] !== \"function\") p[c] = config[c];\n    return p;\n  }, {});\n  return config;\n}\nconst typedArrayToDtypeMapping = {\n  Int8Array: \"int8\",\n  Int16Array: \"int16\",\n  Int32Array: \"int32\",\n  Uint8Array: \"uint8\",\n  Uint16Array: \"uint16\",\n  Uint32Array: \"uint32\",\n  Float32Array: \"float32\",\n  Float64Array: \"float64\",\n  Array: \"array\",\n};\n\nconst typedArrayToDtypeKeys = [];\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n  typedArrayToDtypeKeys.push(eval(arrType));\n}\n\nfunction typedArrayToDtype(obj) {\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n  if (!dtype) {\n    const pt = Object.getPrototypeOf(obj);\n    for (const arrType of typedArrayToDtypeKeys) {\n      if (pt instanceof arrType) {\n        dtype = typedArrayToDtypeMapping[arrType.name];\n        break;\n      }\n    }\n  }\n  return dtype;\n}\n\nfunction cacheUrlInServiceWorker(url) {\n  return new Promise(function (resolve, reject) {\n    const message = {\n      command: \"add\",\n      url: url,\n    };\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n      reject(\"Service worker is not supported.\");\n      return;\n    }\n    const messageChannel = new MessageChannel();\n    messageChannel.port1.onmessage = function (event) {\n      if (event.data && event.data.error) {\n        reject(event.data.error);\n      } else {\n        resolve(event.data && event.data.result);\n      }\n    };\n\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage(message, [\n        messageChannel.port2,\n      ]);\n    } else {\n      reject(\"Service worker controller is not available\");\n    }\n  });\n}\n\nasync function cacheRequirements(requirements) {\n  requirements = requirements || [];\n  if (!Array.isArray(requirements)) {\n    requirements = [requirements];\n  }\n  for (let req of requirements) {\n    //remove prefix\n    if (req.startsWith(\"js:\")) req = req.slice(3);\n    if (req.startsWith(\"css:\")) req = req.slice(4);\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\n    if (!req.startsWith(\"http\")) continue;\n\n    await cacheUrlInServiceWorker(req).catch((e) => {\n      console.error(e);\n    });\n  }\n}\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\n//#Source https://bit.ly/2neWfJ2\nfunction urlJoin(...args) {\n  return args\n    .join(\"/\")\n    .replace(/[\\/]+/g, \"/\")\n    .replace(/^(.+):\\//, \"$1://\")\n    .replace(/^file:/, \"file:/\")\n    .replace(/\\/(\\?|&|#[^!])/g, \"$1\")\n    .replace(/\\?/g, \"&\")\n    .replace(\"&\", \"?\");\n}\n\nfunction waitFor(prom, time, error) {\n  let timer;\n  return Promise.race([\n    prom,\n    new Promise(\n      (_r, rej) =>\n        (timer = setTimeout(() => {\n          rej(error || \"Timeout Error\");\n        }, time * 1000)),\n    ),\n  ]).finally(() => clearTimeout(timer));\n}\n\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      // remove all events handlers\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      // remove all hanlders for the event\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\n    } else {\n      // remove a specific handler\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout);\n    });\n  }\n}\n\nclass Semaphore {\n  constructor(max) {\n    this.max = max;\n    this.queue = [];\n    this.current = 0;\n  }\n  async run(task) {\n    if (this.current >= this.max) {\n      // Wait until a slot is free\n      await new Promise((resolve) => this.queue.push(resolve));\n    }\n    this.current++;\n    try {\n      return await task();\n    } finally {\n      this.current--;\n      if (this.queue.length > 0) {\n        // release one waiter\n        this.queue.shift()();\n      }\n    }\n  }\n}\n\n/**\n * Check if the object is a generator\n * @param {Object} obj - Object to check\n * @returns {boolean} - True if the object is a generator\n */\nfunction isGenerator(obj) {\n  if (!obj) return false;\n\n  return (\n    typeof obj === \"object\" &&\n    typeof obj.next === \"function\" &&\n    typeof obj.throw === \"function\" &&\n    typeof obj.return === \"function\"\n  );\n}\n\n/**\n * Check if an object is an async generator object\n * @param {any} obj - Object to check\n * @returns {boolean} True if object is an async generator object\n */\nfunction isAsyncGenerator(obj) {\n  if (!obj) return false;\n  // Check if it's an async generator object\n  return (\n    typeof obj === \"object\" &&\n    typeof obj.next === \"function\" &&\n    typeof obj.throw === \"function\" &&\n    typeof obj.return === \"function\" &&\n    Symbol.asyncIterator in Object(obj) &&\n    obj[Symbol.toStringTag] === \"AsyncGenerator\"\n  );\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/schema.js\":\n/*!*****************************!*\\\n  !*** ./src/utils/schema.js ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_83640__) => {\n\n__nested_webpack_require_83640__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_83640__.d(__nested_webpack_exports__, {\n/* harmony export */   schemaFunction: () => (/* binding */ schemaFunction)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_83640__(/*! . */ \"./src/utils/index.js\");\n\n\nfunction schemaFunction(\n  func,\n  { schema_type = \"auto\", name = null, description = null, parameters = null },\n) {\n  if (!func || typeof func !== \"function\") {\n    throw Error(\"func should be a function\");\n  }\n  (0,___WEBPACK_IMPORTED_MODULE_0__.assert)(schema_type === \"auto\", \"schema_type should be auto\");\n  (0,___WEBPACK_IMPORTED_MODULE_0__.assert)(name, \"name should not be null\");\n  (0,___WEBPACK_IMPORTED_MODULE_0__.assert)(\n    parameters && parameters.type === \"object\",\n    \"parameters should be an object\",\n  );\n  func.__schema__ = {\n    name: name,\n    description: description,\n    parameters: parameters || [],\n  };\n  return func;\n}\n\n\n/***/ }),\n\n/***/ \"./src/webrtc-client.js\":\n/*!******************************!*\\\n  !*** ./src/webrtc-client.js ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_84847__) => {\n\n__nested_webpack_require_84847__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_84847__.d(__nested_webpack_exports__, {\n/* harmony export */   getRTCService: () => (/* binding */ getRTCService),\n/* harmony export */   registerRTCService: () => (/* binding */ registerRTCService)\n/* harmony export */ });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_84847__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_84847__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_84847__(/*! ./utils/schema.js */ \"./src/utils/schema.js\");\n\n\n\n\nclass WebRTCConnection {\n  constructor(channel) {\n    this._data_channel = channel;\n    this._handle_message = null;\n    this._reconnection_token = null;\n    this._handle_disconnected = null;\n    this._handle_connected = () => {};\n    this.manager_id = null;\n    this._last_message = null;\n    this._data_channel.onopen = async () => {\n      if (this._last_message) {\n        console.info(\"Resending last message after connection established\");\n        this._data_channel.send(this._last_message);\n        this._last_message = null;\n      }\n      this._handle_connected &&\n        this._handle_connected({ channel: this._data_channel });\n    };\n    this._data_channel.onmessage = async (event) => {\n      let data = event.data;\n      if (data instanceof Blob) {\n        data = await data.arrayBuffer();\n      }\n      this._handle_message(data);\n    };\n    const self = this;\n    this._data_channel.onclose = function () {\n      if (this._handle_disconnected) this._handle_disconnected(\"closed\");\n      console.log(\"websocket closed\");\n      self._data_channel = null;\n    };\n  }\n\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  on_message(handler) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  async emit_message(data) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(this._handle_message, \"No handler for message\");\n    try {\n      this._last_message = data;\n      this._data_channel.send(data);\n      this._last_message = null;\n    } catch (exp) {\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  async disconnect(reason) {\n    this._last_message = null;\n    this._data_channel = null;\n    console.info(`data channel connection disconnected (${reason})`);\n  }\n}\n\nasync function _setupRPC(config) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(config.channel, \"No channel provided\");\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(config.workspace, \"No workspace provided\");\n  const channel = config.channel;\n  const clientId = config.client_id || (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n  const connection = new WebRTCConnection(channel);\n  config.context = config.context || {};\n  config.context.connection_type = \"webrtc\";\n  config.context.ws = config.workspace;\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC(connection, {\n    client_id: clientId,\n    default_context: config.context,\n    name: config.name,\n    method_timeout: config.method_timeout || 10.0,\n    workspace: config.workspace,\n    app_id: config.app_id,\n    long_message_chunk_size: config.long_message_chunk_size,\n  });\n  return rpc;\n}\n\nasync function _createOffer(params, server, config, onInit, context) {\n  config = config || {};\n  let offer = new RTCSessionDescription({\n    sdp: params.sdp,\n    type: params.type,\n  });\n\n  let pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [\n      { urls: [\"stun:stun.l.google.com:19302\"] },\n    ],\n    sdpSemantics: \"unified-plan\",\n  });\n\n  if (server) {\n    pc.addEventListener(\"datachannel\", async (event) => {\n      const channel = event.channel;\n      let ctx = null;\n      if (context && context.user) ctx = { user: context.user, ws: context.ws };\n      const rpc = await _setupRPC({\n        channel: channel,\n        client_id: channel.label,\n        workspace: server.config.workspace,\n        context: ctx,\n      });\n      // Map all the local services to the webrtc client\n      rpc._services = server.rpc._services;\n    });\n  }\n\n  if (onInit) {\n    await onInit(pc);\n  }\n\n  await pc.setRemoteDescription(offer);\n\n  let answer = await pc.createAnswer();\n  await pc.setLocalDescription(answer);\n\n  return {\n    sdp: pc.localDescription.sdp,\n    type: pc.localDescription.type,\n    workspace: server.config.workspace,\n  };\n}\n\nasync function getRTCService(server, service_id, config) {\n  config = config || {};\n  config.peer_id = config.peer_id || (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n\n  const pc = new RTCPeerConnection({\n    iceServers: config.ice_servers || [\n      { urls: [\"stun:stun.l.google.com:19302\"] },\n    ],\n    sdpSemantics: \"unified-plan\",\n  });\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      pc.addEventListener(\n        \"connectionstatechange\",\n        () => {\n          if (pc.connectionState === \"failed\") {\n            pc.close();\n            reject(new Error(\"WebRTC Connection failed\"));\n          } else if (pc.connectionState === \"closed\") {\n            reject(new Error(\"WebRTC Connection closed\"));\n          } else {\n            console.log(\"WebRTC Connection state: \", pc.connectionState);\n          }\n        },\n        false,\n      );\n\n      if (config.on_init) {\n        await config.on_init(pc);\n        delete config.on_init;\n      }\n      let channel = pc.createDataChannel(config.peer_id, { ordered: true });\n      channel.binaryType = \"arraybuffer\";\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      const svc = await server.getService(service_id);\n      const answer = await svc.offer({\n        sdp: pc.localDescription.sdp,\n        type: pc.localDescription.type,\n      });\n\n      channel.onopen = () => {\n        config.channel = channel;\n        config.workspace = answer.workspace;\n        // Wait for the channel to be open before returning the rpc\n        // This is needed for safari to work\n        setTimeout(async () => {\n          const rpc = await _setupRPC(config);\n          pc.rpc = rpc;\n          async function get_service(name, ...args) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n              !name.includes(\":\"),\n              \"WebRTC service name should not contain ':'\",\n            );\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n              !name.includes(\"/\"),\n              \"WebRTC service name should not contain '/'\",\n            );\n            return await rpc.get_remote_service(\n              config.workspace + \"/\" + config.peer_id + \":\" + name,\n              ...args,\n            );\n          }\n          async function disconnect() {\n            await rpc.disconnect();\n            pc.close();\n          }\n          pc.getService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(get_service, {\n            name: \"getService\",\n            description: \"Get a remote service via webrtc\",\n            parameters: {\n              type: \"object\",\n              properties: {\n                service_id: {\n                  type: \"string\",\n                  description:\n                    \"Service ID. This should be a service id in the format: 'workspace/service_id', 'workspace/client_id:service_id' or 'workspace/client_id:service_id@app_id'\",\n                },\n                config: {\n                  type: \"object\",\n                  description: \"Options for the service\",\n                },\n              },\n              required: [\"id\"],\n            },\n          });\n          pc.disconnect = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(disconnect, {\n            name: \"disconnect\",\n            description: \"Disconnect from the webrtc connection via webrtc\",\n            parameters: { type: \"object\", properties: {} },\n          });\n          pc.registerCodec = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_codec, {\n            name: \"registerCodec\",\n            description: \"Register a codec for the webrtc connection\",\n            parameters: {\n              type: \"object\",\n              properties: {\n                codec: {\n                  type: \"object\",\n                  description: \"Codec to register\",\n                  properties: {\n                    name: { type: \"string\" },\n                    type: {},\n                    encoder: { type: \"function\" },\n                    decoder: { type: \"function\" },\n                  },\n                },\n              },\n            },\n          });\n          resolve(pc);\n        }, 500);\n      };\n\n      channel.onclose = () => reject(new Error(\"Data channel closed\"));\n\n      await pc.setRemoteDescription(\n        new RTCSessionDescription({\n          sdp: answer.sdp,\n          type: answer.type,\n        }),\n      );\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nasync function registerRTCService(server, service_id, config) {\n  config = config || {\n    visibility: \"protected\",\n    require_context: true,\n  };\n  const onInit = config.on_init;\n  delete config.on_init;\n  return await server.registerService({\n    id: service_id,\n    config,\n    offer: (params, context) =>\n      _createOffer(params, server, config, onInit, context),\n  });\n}\n\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n  \\*************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_94718__) => {\n\n__nested_webpack_require_94718__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_94718__.d(__nested_webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_94718__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n  \\********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_98233__) => {\n\n__nested_webpack_require_98233__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_98233__.d(__nested_webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_100198__) => {\n\n__nested_webpack_require_100198__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_100198__.d(__nested_webpack_exports__, {\n/* harmony export */   DataViewIndexOutOfBoundsError: () => (/* binding */ DataViewIndexOutOfBoundsError),\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_100198__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_100198__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_100198__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_100198__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_100198__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_100198__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_100198__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = ( false) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = ( false) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = ( false) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar isValidMapKeyType = function (key) {\n    var keyType = typeof key;\n    return keyType === \"string\" || keyType === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nvar DataViewIndexOutOfBoundsError = (function () {\n    try {\n        // IE11: The spec says it should throw RangeError,\n        // IE11: but in IE11 it throws TypeError.\n        EMPTY_VIEW.getInt8(0);\n    }\n    catch (e) {\n        return e.constructor;\n    }\n    throw new Error(\"never reached\");\n})();\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxStrLength === void 0) { maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxBinLength === void 0) { maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxArrayLength === void 0) { maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxMapLength === void 0) { maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (maxExtLength === void 0) { maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX; }\n        if (keyDecoder === void 0) { keyDecoder = sharedCachedKeyDecoder; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxStrLength = maxStrLength;\n        this.maxBinLength = maxBinLength;\n        this.maxArrayLength = maxArrayLength;\n        this.maxMapLength = maxMapLength;\n        this.maxExtLength = maxExtLength;\n        this.keyDecoder = keyDecoder;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n        this.view = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var stream_1, stream_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        decoded = false;\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [3 /*break*/, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                        }\n                        catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                throw e; // rethrow\n                            }\n                            // fallthrough\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(stream_1)];\n                    case 8:\n                        _c.sent();\n                        _c.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var e_3, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [3 /*break*/, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                    case 5:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 6: return [4 /*yield*/, _b.sent()];\n                    case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 5];\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 10];\n                    case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                    case 11: return [3 /*break*/, 2];\n                    case 12: return [3 /*break*/, 19];\n                    case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 19];\n                    case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [3 /*break*/, 16];\n                        return [4 /*yield*/, __await(_a.call(stream_2))];\n                    case 15:\n                        _b.sent();\n                        _b.label = 16;\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 18: return [7 /*endfinally*/];\n                    case 19: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                object = this.readU64();\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                object = this.readI64();\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === 0 /* State.ARRAY */) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === 1 /* State.MAP_KEY */) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = 2 /* State.MAP_VALUE */;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = 1 /* State.MAP_KEY */;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: 1 /* State.MAP_KEY */,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: 0 /* State.ARRAY */,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.TEXT_DECODER_THRESHOLD) {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeTD)(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeJs)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === 1 /* State.MAP_KEY */;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_133924__) => {\n\n__nested_webpack_require_133924__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_133924__.d(__nested_webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_133924__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_133924__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_133924__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_133924__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n        if (extensionCodec === void 0) { extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec; }\n        if (context === void 0) { context = undefined; }\n        if (maxDepth === void 0) { maxDepth = DEFAULT_MAX_DEPTH; }\n        if (initialBufferSize === void 0) { initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE; }\n        if (sortKeys === void 0) { sortKeys = false; }\n        if (forceFloat32 === void 0) { forceFloat32 = false; }\n        if (ignoreUndefined === void 0) { ignoreUndefined = false; }\n        if (forceIntegerToFloat === void 0) { forceIntegerToFloat = false; }\n        this.extensionCodec = extensionCodec;\n        this.context = context;\n        this.maxDepth = maxDepth;\n        this.initialBufferSize = initialBufferSize;\n        this.sortKeys = sortKeys;\n        this.forceFloat32 = forceFloat32;\n        this.ignoreUndefined = ignoreUndefined;\n        this.forceIntegerToFloat = forceIntegerToFloat;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            this.encodeNumber(object);\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n            }\n        }\n        else {\n            // non-integer numbers\n            if (this.forceFloat32) {\n                // float 32\n                this.writeU8(0xca);\n                this.writeF32(object);\n            }\n            else {\n                // float 64\n                this.writeU8(0xcb);\n                this.writeF64(object);\n            }\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var strLength = object.length;\n        if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER_THRESHOLD) {\n            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeTE)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n        else {\n            var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n            this.writeStringHeader(byteLength);\n            (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeJs)(object, this.bytes, this.pos);\n            this.pos += byteLength;\n        }\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_149849__) => {\n\n__nested_webpack_require_149849__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_149849__.d(__nested_webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n  \\***********************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_150750__) => {\n\n__nested_webpack_require_150750__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_150750__.d(__nested_webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_150750__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_150750__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n  \\***************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_154277__) => {\n\n__nested_webpack_require_154277__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_154277__.d(__nested_webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeMulti: () => (/* binding */ decodeMulti),\n/* harmony export */   defaultDecodeOptions: () => (/* binding */ defaultDecodeOptions)\n/* harmony export */ });\n/* harmony import */ var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_154277__(/*! ./Decoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n\nvar defaultDecodeOptions = {};\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync()}, {@link decodeStream()}, or {@link decodeArrayStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decode(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decode(buffer);\n}\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream()}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nfunction decodeMulti(buffer, options) {\n    if (options === void 0) { options = defaultDecodeOptions; }\n    var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n    return decoder.decodeMulti(buffer);\n}\n//# sourceMappingURL=decode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n  \\***************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_156692__) => {\n\n__nested_webpack_require_156692__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_156692__.d(__nested_webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_156692__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\nvar defaultEncodeOptions = {};\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    if (options === void 0) { options = defaultEncodeOptions; }\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_158189__) => {\n\n__nested_webpack_require_158189__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_158189__.d(__nested_webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_158189__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_158189__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n  \\******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_163227__) => {\n\n__nested_webpack_require_163227__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_163227__.d(__nested_webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n  \\*************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_165043__) => {\n\n__nested_webpack_require_165043__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_165043__.d(__nested_webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n  \\**************************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_165838__) => {\n\n__nested_webpack_require_165838__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_165838__.d(__nested_webpack_exports__, {\n/* harmony export */   createDataView: () => (/* binding */ createDataView),\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n/***/ }),\n\n/***/ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n  \\*******************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_167237__) => {\n\n__nested_webpack_require_167237__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_167237__.d(__nested_webpack_exports__, {\n/* harmony export */   TEXT_DECODER_THRESHOLD: () => (/* binding */ TEXT_DECODER_THRESHOLD),\n/* harmony export */   TEXT_ENCODER_THRESHOLD: () => (/* binding */ TEXT_ENCODER_THRESHOLD),\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\n/* harmony import */ var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_167237__(/*! ./int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\nvar _a, _b, _c;\n/* eslint-disable @typescript-eslint/no-unnecessary-condition */\n\nvar TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") &&\n    typeof TextEncoder !== \"undefined\" &&\n    typeof TextDecoder !== \"undefined\";\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\nvar sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nvar TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX\n    : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\"\n        ? 200\n        : 0;\nfunction utf8EncodeTEencode(str, output, outputOffset) {\n    output.set(sharedTextEncoder.encode(str), outputOffset);\n}\nfunction utf8EncodeTEencodeInto(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nvar utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nvar TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE\n    ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX\n    : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\"\n        ? 200\n        : 0;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\n//# sourceMappingURL=utf8.mjs.map\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_174356__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_174356__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_174356__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_174356__.o(definition, key) && !__nested_webpack_require_174356__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_174356__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_174356__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n/*!*********************************!*\\\n  !*** ./src/websocket-client.js ***!\n  \\*********************************/\n__nested_webpack_require_174356__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_174356__.d(__nested_webpack_exports__, {\n/* harmony export */   API_VERSION: () => (/* reexport safe */ _rpc_js__WEBPACK_IMPORTED_MODULE_0__.API_VERSION),\n/* harmony export */   LocalWebSocket: () => (/* binding */ LocalWebSocket),\n/* harmony export */   RPC: () => (/* reexport safe */ _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC),\n/* harmony export */   connectToServer: () => (/* binding */ connectToServer),\n/* harmony export */   getRTCService: () => (/* reexport safe */ _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService),\n/* harmony export */   getRemoteService: () => (/* binding */ getRemoteService),\n/* harmony export */   loadRequirements: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.loadRequirements),\n/* harmony export */   login: () => (/* binding */ login),\n/* harmony export */   registerRTCService: () => (/* reexport safe */ _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService),\n/* harmony export */   schemaFunction: () => (/* reexport safe */ _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction),\n/* harmony export */   setupLocalClient: () => (/* binding */ setupLocalClient)\n/* harmony export */ });\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_174356__(/*! ./rpc.js */ \"./src/rpc.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_174356__(/*! ./utils */ \"./src/utils/index.js\");\n/* harmony import */ var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_174356__(/*! ./utils/schema.js */ \"./src/utils/schema.js\");\n/* harmony import */ var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_174356__(/*! ./webrtc-client.js */ \"./src/webrtc-client.js\");\n\n\n\n\n\n\n\n\n\nconst MAX_RETRY = 1000000;\n\nclass WebsocketRPCConnection {\n  constructor(\n    server_url,\n    client_id,\n    workspace,\n    token,\n    reconnection_token = null,\n    timeout = 60,\n    WebSocketClass = null,\n    token_refresh_interval = 2 * 60 * 60,\n  ) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(server_url && client_id, \"server_url and client_id are required\");\n    this._server_url = server_url;\n    this._client_id = client_id;\n    this._workspace = workspace;\n    this._token = token;\n    this._reconnection_token = reconnection_token;\n    this._websocket = null;\n    this._handle_message = null;\n    this._handle_connected = null; // Connection open event handler\n    this._handle_disconnected = null; // Disconnection event handler\n    this._timeout = timeout;\n    this._WebSocketClass = WebSocketClass || WebSocket; // Allow overriding the WebSocket class\n    this._closed = false;\n    this._legacy_auth = null;\n    this.connection_info = null;\n    this._enable_reconnect = false;\n    this._token_refresh_interval = token_refresh_interval;\n    this.manager_id = null;\n    this._refresh_token_task = null;\n    this._last_message = null; // Store the last sent message\n  }\n\n  on_message(handler) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n\n  async _attempt_connection(server_url, attempt_fallback = true) {\n    return new Promise((resolve, reject) => {\n      this._legacy_auth = false;\n      const websocket = new this._WebSocketClass(server_url);\n      websocket.binaryType = \"arraybuffer\";\n\n      websocket.onopen = () => {\n        console.info(\"WebSocket connection established\");\n        resolve(websocket);\n      };\n\n      websocket.onerror = (event) => {\n        console.error(\"WebSocket connection error:\", event);\n        reject(new Error(`WebSocket connection error: ${event}`));\n      };\n\n      websocket.onclose = (event) => {\n        if (event.code === 1003 && attempt_fallback) {\n          console.info(\n            \"Received 1003 error, attempting connection with query parameters.\",\n          );\n          this._legacy_auth = true;\n          this._attempt_connection_with_query_params(server_url)\n            .then(resolve)\n            .catch(reject);\n        } else if (this._handle_disconnected) {\n          this._handle_disconnected(event.reason);\n        }\n      };\n    });\n  }\n\n  async _attempt_connection_with_query_params(server_url) {\n    // Initialize an array to hold parts of the query string\n    const queryParamsParts = [];\n\n    // Conditionally add each parameter if it has a non-empty value\n    if (this._client_id)\n      queryParamsParts.push(`client_id=${encodeURIComponent(this._client_id)}`);\n    if (this._workspace)\n      queryParamsParts.push(`workspace=${encodeURIComponent(this._workspace)}`);\n    if (this._token)\n      queryParamsParts.push(`token=${encodeURIComponent(this._token)}`);\n    if (this._reconnection_token)\n      queryParamsParts.push(\n        `reconnection_token=${encodeURIComponent(this._reconnection_token)}`,\n      );\n\n    // Join the parts with '&' to form the final query string, prepend '?' if there are any parameters\n    const queryString =\n      queryParamsParts.length > 0 ? `?${queryParamsParts.join(\"&\")}` : \"\";\n\n    // Construct the full URL by appending the query string if it exists\n    const full_url = server_url + queryString;\n\n    return await this._attempt_connection(full_url, false);\n  }\n\n  _establish_connection() {\n    return new Promise((resolve, reject) => {\n      this._websocket.onmessage = (event) => {\n        const data = event.data;\n        const first_message = JSON.parse(data);\n        if (first_message.type == \"connection_info\") {\n          this.connection_info = first_message;\n          if (this._workspace) {\n            (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n              this.connection_info.workspace === this._workspace,\n              `Connected to the wrong workspace: ${this.connection_info.workspace}, expected: ${this._workspace}`,\n            );\n          }\n          if (this.connection_info.reconnection_token) {\n            this._reconnection_token = this.connection_info.reconnection_token;\n          }\n          if (this.connection_info.reconnection_token_life_time) {\n            // make sure the token refresh interval is less than the token life time\n            if (\n              this.token_refresh_interval >\n              this.connection_info.reconnection_token_life_time / 1.5\n            ) {\n              console.warn(\n                `Token refresh interval is too long (${this.token_refresh_interval}), setting it to 1.5 times of the token life time(${this.connection_info.reconnection_token_life_time}).`,\n              );\n              this.token_refresh_interval =\n                this.connection_info.reconnection_token_life_time / 1.5;\n            }\n          }\n          this.manager_id = this.connection_info.manager_id || null;\n          console.log(\n            `Successfully connected to the server, workspace: ${this.connection_info.workspace}, manager_id: ${this.manager_id}`,\n          );\n          if (this.connection_info.announcement) {\n            console.log(`${this.connection_info.announcement}`);\n          }\n          resolve(this.connection_info);\n        } else if (first_message.type == \"error\") {\n          const error = \"ConnectionAbortedError: \" + first_message.message;\n          console.error(\"Failed to connect, \" + error);\n          reject(new Error(error));\n          return;\n        } else {\n          console.error(\n            \"ConnectionAbortedError: Unexpected message received from the server:\",\n            data,\n          );\n          reject(\n            new Error(\n              \"ConnectionAbortedError: Unexpected message received from the server\",\n            ),\n          );\n          return;\n        }\n      };\n    });\n  }\n\n  async open() {\n    console.log(\n      \"Creating a new websocket connection to\",\n      this._server_url.split(\"?\")[0],\n    );\n    try {\n      this._websocket = await this._attempt_connection(this._server_url);\n      if (this._legacy_auth) {\n        throw new Error(\n          \"NotImplementedError: Legacy authentication is not supported\",\n        );\n      }\n      // Send authentication info as the first message if connected without query params\n      const authInfo = JSON.stringify({\n        client_id: this._client_id,\n        workspace: this._workspace,\n        token: this._token,\n        reconnection_token: this._reconnection_token,\n      });\n      this._websocket.send(authInfo);\n      // Wait for the first message from the server\n      await (0,_utils__WEBPACK_IMPORTED_MODULE_1__.waitFor)(\n        this._establish_connection(),\n        this._timeout,\n        \"Failed to receive the first message from the server\",\n      );\n      if (this._token_refresh_interval > 0) {\n        setTimeout(() => {\n          this._send_refresh_token();\n          this._refresh_token_task = setInterval(() => {\n            this._send_refresh_token();\n          }, this._token_refresh_interval * 1000);\n        }, 2000);\n      }\n      // Listen to messages from the server\n      this._enable_reconnect = true;\n      this._closed = false;\n      this._websocket.onmessage = (event) => {\n        if (typeof event.data === \"string\") {\n          const parsedData = JSON.parse(event.data);\n          // Check if the message is a reconnection token\n          if (parsedData.type === \"reconnection_token\") {\n            this._reconnection_token = parsedData.reconnection_token;\n            console.log(\"Reconnection token received\");\n          } else {\n            console.log(\"Received message from the server:\", parsedData);\n          }\n        } else {\n          this._handle_message(event.data);\n        }\n      };\n\n      this._websocket.onerror = (event) => {\n        console.error(\"WebSocket connection error:\", event);\n      };\n\n      this._websocket.onclose = this._handle_close.bind(this);\n\n      if (this._handle_connected) {\n        this._handle_connected(this.connection_info);\n      }\n      return this.connection_info;\n    } catch (error) {\n      console.error(\n        \"Failed to connect to\",\n        this._server_url.split(\"?\")[0],\n        error,\n      );\n      throw error;\n    }\n  }\n\n  _send_refresh_token() {\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      const refreshMessage = JSON.stringify({ type: \"refresh_token\" });\n      this._websocket.send(refreshMessage);\n      console.log(\"Requested refresh token\");\n    }\n  }\n\n  _handle_close(event) {\n    if (\n      !this._closed &&\n      this._websocket &&\n      this._websocket.readyState === WebSocket.CLOSED\n    ) {\n      if ([1000, 1001].includes(event.code)) {\n        console.info(\n          `Websocket connection closed (code: ${event.code}): ${event.reason}`,\n        );\n        if (this._handle_disconnected) {\n          this._handle_disconnected(event.reason);\n        }\n        this._closed = true;\n      } else if (this._enable_reconnect) {\n        console.warn(\n          \"Websocket connection closed unexpectedly (code: %s): %s\",\n          event.code,\n          event.reason,\n        );\n        let retry = 0;\n        const reconnect = async () => {\n          try {\n            console.warn(\n              `Reconnecting to ${this._server_url.split(\"?\")[0]} (attempt #${retry})`,\n            );\n            // Open the connection, this will trigger the on_connected callback\n            await this.open();\n\n            // Wait a short time for services to be registered\n            // This gives time for the on_connected callback to complete\n            // which includes re-registering all services to the server\n            await new Promise((resolve) => setTimeout(resolve, 500));\n\n            // Resend last message if there was one\n            if (this._last_message) {\n              console.info(\"Resending last message after reconnection\");\n              this._websocket.send(this._last_message);\n              this._last_message = null;\n            }\n            console.warn(\n              `Successfully reconnected to server ${this._server_url} (services re-registered)`,\n            );\n          } catch (e) {\n            if (`${e}`.includes(\"ConnectionAbortedError:\")) {\n              console.warn(\"Failed to reconnect, connection aborted:\", e);\n              return;\n            } else if (`${e}`.includes(\"NotImplementedError:\")) {\n              console.error(\n                `${e}\\nIt appears that you are trying to connect to a hypha server that is older than 0.20.0, please upgrade the hypha server or use the websocket client in imjoy-rpc(https://www.npmjs.com/package/imjoy-rpc) instead`,\n              );\n              return;\n            }\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n            if (\n              this._websocket &&\n              this._websocket.readyState === WebSocket.CONNECTED\n            ) {\n              return;\n            }\n            retry += 1;\n            if (retry < MAX_RETRY) {\n              await reconnect();\n            } else {\n              console.error(\"Failed to reconnect after\", MAX_RETRY, \"attempts\");\n            }\n          }\n        };\n        reconnect();\n      }\n    } else {\n      if (this._handle_disconnected) {\n        this._handle_disconnected(event.reason);\n      }\n    }\n  }\n\n  async emit_message(data) {\n    if (this._closed) {\n      throw new Error(\"Connection is closed\");\n    }\n    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n      await this.open();\n    }\n    try {\n      this._last_message = data; // Store the message before sending\n      this._websocket.send(data);\n      this._last_message = null; // Clear after successful send\n    } catch (exp) {\n      console.error(`Failed to send data, error: ${exp}`);\n      throw exp;\n    }\n  }\n\n  disconnect(reason) {\n    this._closed = true;\n    this._last_message = null; // Clear last message on disconnect\n    // Ensure websocket is closed if it exists and is not already closed or closing\n    if (\n      this._websocket &&\n      this._websocket.readyState !== WebSocket.CLOSED &&\n      this._websocket.readyState !== WebSocket.CLOSING\n    ) {\n      this._websocket.close(1000, reason);\n    }\n    if (this._refresh_token_task) {\n      clearInterval(this._refresh_token_task);\n    }\n    console.info(`WebSocket connection disconnected (${reason})`);\n  }\n}\n\nfunction normalizeServerUrl(server_url) {\n  if (!server_url) throw new Error(\"server_url is required\");\n  if (server_url.startsWith(\"http://\")) {\n    server_url =\n      server_url.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n  } else if (server_url.startsWith(\"https://\")) {\n    server_url =\n      server_url.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n  }\n  return server_url;\n}\n\nasync function login(config) {\n  const service_id = config.login_service_id || \"public/hypha-login\";\n  const workspace = config.workspace;\n  const expires_in = config.expires_in;\n  const timeout = config.login_timeout || 60;\n  const callback = config.login_callback;\n  const profile = config.profile;\n\n  const server = await connectToServer({\n    name: \"initial login client\",\n    server_url: config.server_url,\n  });\n  try {\n    const svc = await server.getService(service_id);\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(svc, `Failed to get the login service: ${service_id}`);\n    let context;\n    if (workspace) {\n      context = await svc.start({ workspace, expires_in, _rkwargs: true });\n    } else {\n      context = await svc.start();\n    }\n    if (callback) {\n      await callback(context);\n    } else {\n      console.log(`Please open your browser and login at ${context.login_url}`);\n    }\n    return await svc.check(context.key, { timeout, profile, _rkwargs: true });\n  } catch (error) {\n    throw error;\n  } finally {\n    await server.disconnect();\n  }\n}\n\nasync function webrtcGetService(wm, rtc_service_id, query, config) {\n  config = config || {};\n  const webrtc = config.webrtc;\n  const webrtc_config = config.webrtc_config;\n  if (config.webrtc !== undefined) delete config.webrtc;\n  if (config.webrtc_config !== undefined) delete config.webrtc_config;\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n    [undefined, true, false, \"auto\"].includes(webrtc),\n    \"webrtc must be true, false or 'auto'\",\n  );\n\n  const svc = await wm.getService(query, config);\n  if (webrtc === true || webrtc === \"auto\") {\n    if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n      try {\n        // Assuming that the client registered a webrtc service with the client_id + \"-rtc\"\n        const peer = await (0,_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService)(wm, rtc_service_id, webrtc_config);\n        const rtcSvc = await peer.getService(svc.id.split(\":\")[1], config);\n        rtcSvc._webrtc = true;\n        rtcSvc._peer = peer;\n        rtcSvc._service = svc;\n        return rtcSvc;\n      } catch (e) {\n        console.warn(\n          \"Failed to get webrtc service, using websocket connection\",\n          e,\n        );\n      }\n    }\n    if (webrtc === true) {\n      throw new Error(\"Failed to get the service via webrtc\");\n    }\n  }\n  return svc;\n}\n\nasync function connectToServer(config) {\n  if (config.server) {\n    config.server_url = config.server_url || config.server.url;\n    config.WebSocketClass =\n      config.WebSocketClass || config.server.WebSocketClass;\n  }\n  let clientId = config.client_id;\n  if (!clientId) {\n    clientId = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n    config.client_id = clientId;\n  }\n\n  let server_url = normalizeServerUrl(config.server_url);\n\n  let connection = new WebsocketRPCConnection(\n    server_url,\n    clientId,\n    config.workspace,\n    config.token,\n    config.reconnection_token,\n    config.method_timeout || 60,\n    config.WebSocketClass,\n  );\n  const connection_info = await connection.open();\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n    connection_info,\n    \"Failed to connect to the server, no connection info obtained. This issue is most likely due to an outdated Hypha server version. Please use `imjoy-rpc` for compatibility, or upgrade the Hypha server to the latest version.\",\n  );\n  // wait for 0.5 seconds\n  await new Promise((resolve) => setTimeout(resolve, 100));\n  // Ensure manager_id is set before proceeding\n  if (!connection.manager_id) {\n    console.warn(\"Manager ID not set immediately, waiting...\");\n\n    // Wait for manager_id to be set with timeout\n    const maxWaitTime = 5000; // 5 seconds\n    const checkInterval = 100; // 100ms\n    const startTime = Date.now();\n\n    while (!connection.manager_id && Date.now() - startTime < maxWaitTime) {\n      await new Promise((resolve) => setTimeout(resolve, checkInterval));\n    }\n\n    if (!connection.manager_id) {\n      console.error(\"Manager ID still not set after waiting\");\n      throw new Error(\"Failed to get manager ID from server\");\n    } else {\n      console.info(`Manager ID set after waiting: ${connection.manager_id}`);\n    }\n  }\n  if (config.workspace && connection_info.workspace !== config.workspace) {\n    throw new Error(\n      `Connected to the wrong workspace: ${connection_info.workspace}, expected: ${config.workspace}`,\n    );\n  }\n\n  const workspace = connection_info.workspace;\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC(connection, {\n    client_id: clientId,\n    workspace,\n    default_context: { connection_type: \"websocket\" },\n    name: config.name,\n    method_timeout: config.method_timeout,\n    app_id: config.app_id,\n    server_base_url: connection_info.public_base_url,\n    long_message_chunk_size: config.long_message_chunk_size,\n  });\n  const wm = await rpc.get_manager_service({\n    timeout: config.method_timeout,\n    case_conversion: \"camel\",\n    kwargs_expansion: config.kwargs_expansion || false,\n  });\n  wm.rpc = rpc;\n\n  async function _export(api) {\n    api.id = \"default\";\n    api.name = api.name || config.name || api.id;\n    api.description = api.description || config.description;\n    await rpc.register_service(api, { overwrite: true });\n  }\n\n  async function getApp(clientId) {\n    clientId = clientId || \"*\";\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!clientId.includes(\":\"), \"clientId should not contain ':'\");\n    if (!clientId.includes(\"/\")) {\n      clientId = connection_info.workspace + \"/\" + clientId;\n    }\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n      clientId.split(\"/\").length === 2,\n      \"clientId should match pattern workspace/clientId\",\n    );\n    return await wm.getService(`${clientId}:default`);\n  }\n\n  async function listApps(ws) {\n    ws = ws || workspace;\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\":\"), \"workspace should not contain ':'\");\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\"/\"), \"workspace should not contain '/'\");\n    const query = { workspace: ws, service_id: \"default\" };\n    return await wm.listServices(query);\n  }\n\n  if (connection_info) {\n    wm.config = Object.assign(wm.config, connection_info);\n  }\n  wm.export = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_export, {\n    name: \"export\",\n    description: \"Export the api.\",\n    parameters: {\n      properties: { api: { description: \"The api to export\", type: \"object\" } },\n      required: [\"api\"],\n      type: \"object\",\n    },\n  });\n  wm.getApp = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(getApp, {\n    name: \"getApp\",\n    description: \"Get the app.\",\n    parameters: {\n      properties: {\n        clientId: { default: \"*\", description: \"The clientId\", type: \"string\" },\n      },\n      type: \"object\",\n    },\n  });\n  wm.listApps = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(listApps, {\n    name: \"listApps\",\n    description: \"List the apps.\",\n    parameters: {\n      properties: {\n        workspace: {\n          default: workspace,\n          description: \"The workspace\",\n          type: \"string\",\n        },\n      },\n      type: \"object\",\n    },\n  });\n  wm.disconnect = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.disconnect.bind(rpc), {\n    name: \"disconnect\",\n    description: \"Disconnect from the server.\",\n    parameters: { type: \"object\", properties: {}, required: [] },\n  });\n  wm.registerCodec = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_codec.bind(rpc), {\n    name: \"registerCodec\",\n    description: \"Register a codec for the webrtc connection\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        codec: {\n          type: \"object\",\n          description: \"Codec to register\",\n          properties: {\n            name: { type: \"string\" },\n            type: {},\n            encoder: { type: \"function\" },\n            decoder: { type: \"function\" },\n          },\n        },\n      },\n    },\n  });\n\n  wm.emit = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.emit.bind(rpc), {\n    name: \"emit\",\n    description: \"Emit a message.\",\n    parameters: {\n      properties: { data: { description: \"The data to emit\", type: \"object\" } },\n      required: [\"data\"],\n      type: \"object\",\n    },\n  });\n\n  wm.on = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.on.bind(rpc), {\n    name: \"on\",\n    description: \"Register a message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to listen to\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.off = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.off.bind(rpc), {\n    name: \"off\",\n    description: \"Remove a message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to remove\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.once = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.once.bind(rpc), {\n    name: \"once\",\n    description: \"Register a one-time message handler.\",\n    parameters: {\n      properties: {\n        event: { description: \"The event to listen to\", type: \"string\" },\n        handler: { description: \"The handler function\", type: \"function\" },\n      },\n      required: [\"event\", \"handler\"],\n      type: \"object\",\n    },\n  });\n\n  wm.getServiceSchema = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.get_service_schema, {\n    name: \"getServiceSchema\",\n    description: \"Get the service schema.\",\n    parameters: {\n      properties: {\n        service: {\n          description: \"The service to extract schema\",\n          type: \"object\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n\n  wm.registerService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_service.bind(rpc), {\n    name: \"registerService\",\n    description: \"Register a service.\",\n    parameters: {\n      properties: {\n        service: { description: \"The service to register\", type: \"object\" },\n        force: {\n          default: false,\n          description: \"Force to register the service\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n  wm.unregisterService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.unregister_service.bind(rpc), {\n    name: \"unregisterService\",\n    description: \"Unregister a service.\",\n    parameters: {\n      properties: {\n        service: {\n          description: \"The service id to unregister\",\n          type: \"string\",\n        },\n        notify: {\n          default: true,\n          description: \"Notify the workspace manager\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"service\"],\n      type: \"object\",\n    },\n  });\n  if (connection.manager_id) {\n    rpc.on(\"force-exit\", async (message) => {\n      if (message.from === \"*/\" + connection.manager_id) {\n        console.log(\"Disconnecting from server, reason:\", message.reason);\n        await rpc.disconnect();\n      }\n    });\n  }\n  if (config.webrtc) {\n    await (0,_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService)(wm, `${clientId}-rtc`, config.webrtc_config);\n    // make a copy of wm, so webrtc can use the original wm.getService\n    const _wm = Object.assign({}, wm);\n    const description = _wm.getService.__schema__.description;\n    // TODO: Fix the schema for adding options for webrtc\n    const parameters = _wm.getService.__schema__.parameters;\n    wm.getService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(\n      webrtcGetService.bind(null, _wm, `${workspace}/${clientId}-rtc`),\n      {\n        name: \"getService\",\n        description,\n        parameters,\n      },\n    );\n\n    wm.getRTCService = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService.bind(null, wm), {\n      name: \"getRTCService\",\n      description: \"Get the webrtc connection, returns a peer connection.\",\n      parameters: {\n        properties: {\n          config: {\n            description: \"The config for the webrtc service\",\n            type: \"object\",\n          },\n        },\n        required: [\"config\"],\n        type: \"object\",\n      },\n    });\n  } else {\n    const _getService = wm.getService;\n    wm.getService = (query, config) => {\n      config = config || {};\n      return _getService(query, config);\n    };\n    wm.getService.__schema__ = _getService.__schema__;\n  }\n\n  async function registerProbes(probes) {\n    probes.id = \"probes\";\n    probes.name = \"Probes\";\n    probes.config = { visibility: \"public\" };\n    probes.type = \"probes\";\n    probes.description = `Probes Service, visit ${server_url}/${workspace}services/probes for the available probes.`;\n    return await wm.registerService(probes, { overwrite: true });\n  }\n\n  wm.registerProbes = (0,_utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(registerProbes, {\n    name: \"registerProbes\",\n    description: \"Register probes service\",\n    parameters: {\n      properties: {\n        probes: {\n          description:\n            \"The probes to register, e.g. {'liveness': {'type': 'function', 'description': 'Check the liveness of the service'}}\",\n          type: \"object\",\n        },\n      },\n      required: [\"probes\"],\n      type: \"object\",\n    },\n  });\n\n  return wm;\n}\n\nasync function getRemoteService(serviceUri, config = {}) {\n  const { serverUrl, workspace, clientId, serviceId, appId } =\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.parseServiceUrl)(serviceUri);\n  const fullServiceId = `${workspace}/${clientId}:${serviceId}@${appId}`;\n\n  if (config.serverUrl) {\n    if (config.serverUrl !== serverUrl) {\n      throw new Error(\n        \"server_url in config does not match the server_url in the url\",\n      );\n    }\n  }\n  config.serverUrl = serverUrl;\n  const server = await connectToServer(config);\n  return await server.getService(fullServiceId);\n}\n\nclass LocalWebSocket {\n  constructor(url, client_id, workspace) {\n    this.url = url;\n    this.onopen = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.client_id = client_id;\n    this.workspace = workspace;\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    this.postMessage = (message) => {\n      if (isWindow) {\n        window.parent.postMessage(message, \"*\");\n      } else {\n        self.postMessage(message);\n      }\n    };\n\n    this.readyState = WebSocket.CONNECTING;\n    context.addEventListener(\n      \"message\",\n      (event) => {\n        const { type, data, to } = event.data;\n        if (to !== this.client_id) {\n          // console.debug(\"message not for me\", to, this.client_id);\n          return;\n        }\n        switch (type) {\n          case \"message\":\n            if (this.readyState === WebSocket.OPEN && this.onmessage) {\n              this.onmessage({ data: data });\n            }\n            break;\n          case \"connected\":\n            this.readyState = WebSocket.OPEN;\n            this.onopen(event);\n            break;\n          case \"closed\":\n            this.readyState = WebSocket.CLOSED;\n            this.onclose(event);\n            break;\n          default:\n            break;\n        }\n      },\n      false,\n    );\n\n    if (!this.client_id) throw new Error(\"client_id is required\");\n    if (!this.workspace) throw new Error(\"workspace is required\");\n    this.postMessage({\n      type: \"connect\",\n      url: this.url,\n      from: this.client_id,\n      workspace: this.workspace,\n    });\n  }\n\n  send(data) {\n    if (this.readyState === WebSocket.OPEN) {\n      this.postMessage({\n        type: \"message\",\n        data: data,\n        from: this.client_id,\n        workspace: this.workspace,\n      });\n    }\n  }\n\n  close() {\n    this.readyState = WebSocket.CLOSING;\n    this.postMessage({\n      type: \"close\",\n      from: this.client_id,\n      workspace: this.workspace,\n    });\n    this.onclose();\n  }\n\n  addEventListener(type, listener) {\n    if (type === \"message\") {\n      this.onmessage = listener;\n    }\n    if (type === \"open\") {\n      this.onopen = listener;\n    }\n    if (type === \"close\") {\n      this.onclose = listener;\n    }\n    if (type === \"error\") {\n      this.onerror = listener;\n    }\n  }\n}\n\nfunction setupLocalClient({\n  enable_execution = false,\n  on_ready = null,\n}) {\n  return new Promise((resolve, reject) => {\n    const context = typeof window !== \"undefined\" ? window : self;\n    const isWindow = typeof window !== \"undefined\";\n    context.addEventListener(\n      \"message\",\n      (event) => {\n        const {\n          type,\n          server_url,\n          workspace,\n          client_id,\n          token,\n          method_timeout,\n          name,\n          config,\n        } = event.data;\n\n        if (type === \"initializeHyphaClient\") {\n          if (!server_url || !workspace || !client_id) {\n            console.error(\"server_url, workspace, and client_id are required.\");\n            return;\n          }\n\n          if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n            console.error(\n              \"server_url should start with https://local-hypha-server:\",\n            );\n            return;\n          }\n\n          class FixedLocalWebSocket extends LocalWebSocket {\n            constructor(url) {\n              // Call the parent class's constructor with fixed values\n              super(url, client_id, workspace);\n            }\n          }\n          connectToServer({\n            server_url,\n            workspace,\n            client_id,\n            token,\n            method_timeout,\n            name,\n            WebSocketClass: FixedLocalWebSocket,\n          }).then(async (server) => {\n            globalThis.api = server;\n            try {\n              // for iframe\n              if (isWindow && enable_execution) {\n                function loadScript(script) {\n                  return new Promise((resolve, reject) => {\n                    const scriptElement = document.createElement(\"script\");\n                    scriptElement.innerHTML = script.content;\n                    scriptElement.lang = script.lang;\n\n                    scriptElement.onload = () => resolve();\n                    scriptElement.onerror = (e) => reject(e);\n\n                    document.head.appendChild(scriptElement);\n                  });\n                }\n                if (config.styles && config.styles.length > 0) {\n                  for (const style of config.styles) {\n                    const styleElement = document.createElement(\"style\");\n                    styleElement.innerHTML = style.content;\n                    styleElement.lang = style.lang;\n                    document.head.appendChild(styleElement);\n                  }\n                }\n                if (config.links && config.links.length > 0) {\n                  for (const link of config.links) {\n                    const linkElement = document.createElement(\"a\");\n                    linkElement.href = link.url;\n                    linkElement.innerText = link.text;\n                    document.body.appendChild(linkElement);\n                  }\n                }\n                if (config.windows && config.windows.length > 0) {\n                  for (const w of config.windows) {\n                    document.body.innerHTML = w.content;\n                    break;\n                  }\n                }\n                if (config.scripts && config.scripts.length > 0) {\n                  for (const script of config.scripts) {\n                    if (script.lang !== \"javascript\")\n                      throw new Error(\"Only javascript scripts are supported\");\n                    await loadScript(script); // Await the loading of each script\n                  }\n                }\n              }\n              // for web worker\n              else if (\n                !isWindow &&\n                enable_execution &&\n                config.scripts &&\n                config.scripts.length > 0\n              ) {\n                for (const script of config.scripts) {\n                  if (script.lang !== \"javascript\")\n                    throw new Error(\"Only javascript scripts are supported\");\n                  eval(script.content);\n                }\n              }\n\n              if (on_ready) {\n                await on_ready(server, config);\n              }\n              resolve(server);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        }\n      },\n      false,\n    );\n    if (isWindow) {\n      window.parent.postMessage({ type: \"hyphaClientReady\" }, \"*\");\n    } else {\n      self.postMessage({ type: \"hyphaClientReady\" });\n    }\n  });\n}\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=hypha-rpc-websocket.js.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/hypha-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hypha-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js\")};\n\n//# sourceURL=webpack://HyphaCore/./node_modules/hypha-rpc/index.js?");

/***/ }),

/***/ "./node_modules/mock-socket/dist/mock-socket.js":
/*!******************************************************!*\
  !*** ./node_modules/mock-socket/dist/mock-socket.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nvar requiresPort = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) { return false; }\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\nvar has = Object.prototype.hasOwnProperty;\nvar undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) { continue; }\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) { prefix = '?'; }\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) { continue; }\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nvar stringify = querystringify;\nvar parse = querystring;\n\nvar querystringify_1 = {\n\tstringify: stringify,\n\tparse: parse\n};\n\nvar CRHTLF = /[\\n\\r\\t]/g;\nvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\nvar protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i;\nvar windowsDriveLetter = /^[a-zA-Z]:/;\nvar whitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(whitespace, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') { globalVar = window; }\n  else if (typeof commonjsGlobal !== 'undefined') { globalVar = commonjsGlobal; }\n  else if (typeof self !== 'undefined') { globalVar = self; }\n  else { globalVar = {}; }\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) { delete finaldestination[key]; }\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) { continue; }\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4];\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') { return base; }\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) { unshift = true; }\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) { path.unshift(''); }\n  if (last === '.' || last === '..') { path.push(''); }\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) { parser = querystringify_1.parse; }\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@'\n        ? address.lastIndexOf(parse)\n        : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) { url[key] = url[key].toLowerCase(); }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) { url.query = parser(url.query); }\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!requiresPort(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password));\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username +':'+ url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || querystringify_1.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!requiresPort(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) { value += ':'+ url.port; }\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) { url[ins[1]] = url[ins[1]].toLowerCase(); }\n  }\n\n  url.auth = url.password ? url.username +':'+ url.password : url.username;\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) { stringify = querystringify_1.stringify; }\n\n  var query\n    , url = this\n    , host = url.host\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') { protocol += ':'; }\n\n  var result =\n    protocol +\n    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) { result += ':'+ url.password; }\n    result += '@';\n  } else if (url.password) {\n    result += ':'+ url.password;\n    result += '@';\n  } else if (\n    url.protocol !== 'file:' &&\n    isSpecial(url.protocol) &&\n    !host &&\n    url.pathname !== '/'\n  ) {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  }\n\n  //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n  if (host[host.length - 1] === ':') { host += ':'; }\n  result += host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) { result += '?' !== query.charAt(0) ? '?'+ query : query; }\n\n  if (url.hash) { result += url.hash; }\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = querystringify_1;\n\nvar urlParse = Url;\n\n/*\n * This delay allows the thread to finish assigning its on* methods\n * before invoking the delay callback. This is purely a timing hack.\n * http://geekabyte.blogspot.com/2014/01/javascript-effect-of-setting-settimeout.html\n *\n * @param {callback: function} the callback which will be invoked after the timeout\n * @parma {context: object} the context in which to invoke the function\n */\nfunction delay(callback, context) {\n  setTimeout(function (timeoutContext) { return callback.call(timeoutContext); }, 4, context);\n}\n\nfunction log(method, message) {\n  /* eslint-disable no-console */\n  if (typeof process !== 'undefined' && \"development\" !== 'test') {\n    console[method].call(null, message);\n  }\n  /* eslint-enable no-console */\n}\n\nfunction reject(array, callback) {\n  if ( array === void 0 ) array = [];\n\n  var results = [];\n  array.forEach(function (itemInArray) {\n    if (!callback(itemInArray)) {\n      results.push(itemInArray);\n    }\n  });\n\n  return results;\n}\n\nfunction filter(array, callback) {\n  if ( array === void 0 ) array = [];\n\n  var results = [];\n  array.forEach(function (itemInArray) {\n    if (callback(itemInArray)) {\n      results.push(itemInArray);\n    }\n  });\n\n  return results;\n}\n\n/*\n * EventTarget is an interface implemented by objects that can\n * receive events and may have listeners for them.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n */\nvar EventTarget = function EventTarget() {\n  this.listeners = {};\n};\n\n/*\n * Ties a listener function to an event type which can later be invoked via the\n * dispatchEvent method.\n *\n * @param {string} type - the type of event (ie: 'open', 'message', etc.)\n * @param {function} listener - callback function to invoke when an event is dispatched matching the type\n * @param {boolean} useCapture - N/A TODO: implement useCapture functionality\n */\nEventTarget.prototype.addEventListener = function addEventListener (type, listener /* , useCapture */) {\n  if (typeof listener === 'function') {\n    if (!Array.isArray(this.listeners[type])) {\n      this.listeners[type] = [];\n    }\n\n    // Only add the same function once\n    if (filter(this.listeners[type], function (item) { return item === listener; }).length === 0) {\n      this.listeners[type].push(listener);\n    }\n  }\n};\n\n/*\n * Removes the listener so it will no longer be invoked via the dispatchEvent method.\n *\n * @param {string} type - the type of event (ie: 'open', 'message', etc.)\n * @param {function} listener - callback function to invoke when an event is dispatched matching the type\n * @param {boolean} useCapture - N/A TODO: implement useCapture functionality\n */\nEventTarget.prototype.removeEventListener = function removeEventListener (type, removingListener /* , useCapture */) {\n  var arrayOfListeners = this.listeners[type];\n  this.listeners[type] = reject(arrayOfListeners, function (listener) { return listener === removingListener; });\n};\n\n/*\n * Invokes all listener functions that are listening to the given event.type property. Each\n * listener will be passed the event as the first argument.\n *\n * @param {object} event - event object which will be passed to all listeners of the event.type property\n */\nEventTarget.prototype.dispatchEvent = function dispatchEvent (event) {\n    var this$1 = this;\n    var customArguments = [], len = arguments.length - 1;\n    while ( len-- > 0 ) customArguments[ len ] = arguments[ len + 1 ];\n\n  var eventName = event.type;\n  var listeners = this.listeners[eventName];\n\n  if (!Array.isArray(listeners)) {\n    return false;\n  }\n\n  listeners.forEach(function (listener) {\n    if (customArguments.length > 0) {\n      listener.apply(this$1, customArguments);\n    } else {\n      listener.call(this$1, event);\n    }\n  });\n\n  return true;\n};\n\nfunction trimQueryPartFromURL(url) {\n  var queryIndex = url.indexOf('?');\n  return queryIndex >= 0 ? url.slice(0, queryIndex) : url;\n}\n\n/*\n * The network bridge is a way for the mock websocket object to 'communicate' with\n * all available servers. This is a singleton object so it is important that you\n * clean up urlMap whenever you are finished.\n */\nvar NetworkBridge = function NetworkBridge() {\n  this.urlMap = {};\n};\n\n/*\n * Attaches a websocket object to the urlMap hash so that it can find the server\n * it is connected to and the server in turn can find it.\n *\n * @param {object} websocket - websocket object to add to the urlMap hash\n * @param {string} url\n */\nNetworkBridge.prototype.attachWebSocket = function attachWebSocket (websocket, url) {\n  var serverURL = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverURL];\n\n  if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) === -1) {\n    connectionLookup.websockets.push(websocket);\n    return connectionLookup.server;\n  }\n};\n\n/*\n * Attaches a websocket to a room\n */\nNetworkBridge.prototype.addMembershipToRoom = function addMembershipToRoom (websocket, room) {\n  var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n\n  if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) !== -1) {\n    if (!connectionLookup.roomMemberships[room]) {\n      connectionLookup.roomMemberships[room] = [];\n    }\n\n    connectionLookup.roomMemberships[room].push(websocket);\n  }\n};\n\n/*\n * Attaches a server object to the urlMap hash so that it can find a websockets\n * which are connected to it and so that websockets can in turn can find it.\n *\n * @param {object} server - server object to add to the urlMap hash\n * @param {string} url\n */\nNetworkBridge.prototype.attachServer = function attachServer (server, url) {\n  var serverUrl = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverUrl];\n\n  if (!connectionLookup) {\n    this.urlMap[serverUrl] = {\n      server: server,\n      websockets: [],\n      roomMemberships: {}\n    };\n\n    return server;\n  }\n};\n\n/*\n * Finds the server which is 'running' on the given url.\n *\n * @param {string} url - the url to use to find which server is running on it\n */\nNetworkBridge.prototype.serverLookup = function serverLookup (url) {\n  var serverURL = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverURL];\n\n  if (connectionLookup) {\n    return connectionLookup.server;\n  }\n};\n\n/*\n * Finds all websockets which is 'listening' on the given url.\n *\n * @param {string} url - the url to use to find all websockets which are associated with it\n * @param {string} room - if a room is provided, will only return sockets in this room\n * @param {class} broadcaster - socket that is broadcasting and is to be excluded from the lookup\n */\nNetworkBridge.prototype.websocketsLookup = function websocketsLookup (url, room, broadcaster) {\n  var serverURL = trimQueryPartFromURL(url);\n  var websockets;\n  var connectionLookup = this.urlMap[serverURL];\n\n  websockets = connectionLookup ? connectionLookup.websockets : [];\n\n  if (room) {\n    var members = connectionLookup.roomMemberships[room];\n    websockets = members || [];\n  }\n\n  return broadcaster ? websockets.filter(function (websocket) { return websocket !== broadcaster; }) : websockets;\n};\n\n/*\n * Removes the entry associated with the url.\n *\n * @param {string} url\n */\nNetworkBridge.prototype.removeServer = function removeServer (url) {\n  delete this.urlMap[trimQueryPartFromURL(url)];\n};\n\n/*\n * Removes the individual websocket from the map of associated websockets.\n *\n * @param {object} websocket - websocket object to remove from the url map\n * @param {string} url\n */\nNetworkBridge.prototype.removeWebSocket = function removeWebSocket (websocket, url) {\n  var serverURL = trimQueryPartFromURL(url);\n  var connectionLookup = this.urlMap[serverURL];\n\n  if (connectionLookup) {\n    connectionLookup.websockets = reject(connectionLookup.websockets, function (socket) { return socket === websocket; });\n  }\n};\n\n/*\n * Removes a websocket from a room\n */\nNetworkBridge.prototype.removeMembershipFromRoom = function removeMembershipFromRoom (websocket, room) {\n  var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n  var memberships = connectionLookup.roomMemberships[room];\n\n  if (connectionLookup && memberships !== null) {\n    connectionLookup.roomMemberships[room] = reject(memberships, function (socket) { return socket === websocket; });\n  }\n};\n\nvar networkBridge = new NetworkBridge(); // Note: this is a singleton\n\n/*\n * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n */\nvar CLOSE_CODES = {\n  CLOSE_NORMAL: 1000,\n  CLOSE_GOING_AWAY: 1001,\n  CLOSE_PROTOCOL_ERROR: 1002,\n  CLOSE_UNSUPPORTED: 1003,\n  CLOSE_NO_STATUS: 1005,\n  CLOSE_ABNORMAL: 1006,\n  UNSUPPORTED_DATA: 1007,\n  POLICY_VIOLATION: 1008,\n  CLOSE_TOO_LARGE: 1009,\n  MISSING_EXTENSION: 1010,\n  INTERNAL_ERROR: 1011,\n  SERVICE_RESTART: 1012,\n  TRY_AGAIN_LATER: 1013,\n  TLS_HANDSHAKE: 1015\n};\n\nvar ERROR_PREFIX = {\n  CONSTRUCTOR_ERROR: \"Failed to construct 'WebSocket':\",\n  CLOSE_ERROR: \"Failed to execute 'close' on 'WebSocket':\",\n  EVENT: {\n    CONSTRUCT: \"Failed to construct 'Event':\",\n    MESSAGE: \"Failed to construct 'MessageEvent':\",\n    CLOSE: \"Failed to construct 'CloseEvent':\"\n  }\n};\n\nvar EventPrototype = function EventPrototype () {};\n\nEventPrototype.prototype.stopPropagation = function stopPropagation () {};\nEventPrototype.prototype.stopImmediatePropagation = function stopImmediatePropagation () {};\n\n// if no arguments are passed then the type is set to \"undefined\" on\n// chrome and safari.\nEventPrototype.prototype.initEvent = function initEvent (type, bubbles, cancelable) {\n    if ( type === void 0 ) type = 'undefined';\n    if ( bubbles === void 0 ) bubbles = false;\n    if ( cancelable === void 0 ) cancelable = false;\n\n  this.type = \"\" + type;\n  this.bubbles = Boolean(bubbles);\n  this.cancelable = Boolean(cancelable);\n};\n\nvar Event = (function (EventPrototype$$1) {\n  function Event(type, eventInitConfig) {\n    if ( eventInitConfig === void 0 ) eventInitConfig = {};\n\n    EventPrototype$$1.call(this);\n\n    if (!type) {\n      throw new TypeError(((ERROR_PREFIX.EVENT_ERROR) + \" 1 argument required, but only 0 present.\"));\n    }\n\n    if (typeof eventInitConfig !== 'object') {\n      throw new TypeError(((ERROR_PREFIX.EVENT_ERROR) + \" parameter 2 ('eventInitDict') is not an object.\"));\n    }\n\n    var bubbles = eventInitConfig.bubbles;\n    var cancelable = eventInitConfig.cancelable;\n\n    this.type = \"\" + type;\n    this.timeStamp = Date.now();\n    this.target = null;\n    this.srcElement = null;\n    this.returnValue = true;\n    this.isTrusted = false;\n    this.eventPhase = 0;\n    this.defaultPrevented = false;\n    this.currentTarget = null;\n    this.cancelable = cancelable ? Boolean(cancelable) : false;\n    this.cancelBubble = false;\n    this.bubbles = bubbles ? Boolean(bubbles) : false;\n  }\n\n  if ( EventPrototype$$1 ) Event.__proto__ = EventPrototype$$1;\n  Event.prototype = Object.create( EventPrototype$$1 && EventPrototype$$1.prototype );\n  Event.prototype.constructor = Event;\n\n  return Event;\n}(EventPrototype));\n\nvar MessageEvent = (function (EventPrototype$$1) {\n  function MessageEvent(type, eventInitConfig) {\n    if ( eventInitConfig === void 0 ) eventInitConfig = {};\n\n    EventPrototype$$1.call(this);\n\n    if (!type) {\n      throw new TypeError(((ERROR_PREFIX.EVENT.MESSAGE) + \" 1 argument required, but only 0 present.\"));\n    }\n\n    if (typeof eventInitConfig !== 'object') {\n      throw new TypeError(((ERROR_PREFIX.EVENT.MESSAGE) + \" parameter 2 ('eventInitDict') is not an object\"));\n    }\n\n    var bubbles = eventInitConfig.bubbles;\n    var cancelable = eventInitConfig.cancelable;\n    var data = eventInitConfig.data;\n    var origin = eventInitConfig.origin;\n    var lastEventId = eventInitConfig.lastEventId;\n    var ports = eventInitConfig.ports;\n\n    this.type = \"\" + type;\n    this.timeStamp = Date.now();\n    this.target = null;\n    this.srcElement = null;\n    this.returnValue = true;\n    this.isTrusted = false;\n    this.eventPhase = 0;\n    this.defaultPrevented = false;\n    this.currentTarget = null;\n    this.cancelable = cancelable ? Boolean(cancelable) : false;\n    this.canncelBubble = false;\n    this.bubbles = bubbles ? Boolean(bubbles) : false;\n    this.origin = \"\" + origin;\n    this.ports = typeof ports === 'undefined' ? null : ports;\n    this.data = typeof data === 'undefined' ? null : data;\n    this.lastEventId = \"\" + (lastEventId || '');\n  }\n\n  if ( EventPrototype$$1 ) MessageEvent.__proto__ = EventPrototype$$1;\n  MessageEvent.prototype = Object.create( EventPrototype$$1 && EventPrototype$$1.prototype );\n  MessageEvent.prototype.constructor = MessageEvent;\n\n  return MessageEvent;\n}(EventPrototype));\n\nvar CloseEvent = (function (EventPrototype$$1) {\n  function CloseEvent(type, eventInitConfig) {\n    if ( eventInitConfig === void 0 ) eventInitConfig = {};\n\n    EventPrototype$$1.call(this);\n\n    if (!type) {\n      throw new TypeError(((ERROR_PREFIX.EVENT.CLOSE) + \" 1 argument required, but only 0 present.\"));\n    }\n\n    if (typeof eventInitConfig !== 'object') {\n      throw new TypeError(((ERROR_PREFIX.EVENT.CLOSE) + \" parameter 2 ('eventInitDict') is not an object\"));\n    }\n\n    var bubbles = eventInitConfig.bubbles;\n    var cancelable = eventInitConfig.cancelable;\n    var code = eventInitConfig.code;\n    var reason = eventInitConfig.reason;\n    var wasClean = eventInitConfig.wasClean;\n\n    this.type = \"\" + type;\n    this.timeStamp = Date.now();\n    this.target = null;\n    this.srcElement = null;\n    this.returnValue = true;\n    this.isTrusted = false;\n    this.eventPhase = 0;\n    this.defaultPrevented = false;\n    this.currentTarget = null;\n    this.cancelable = cancelable ? Boolean(cancelable) : false;\n    this.cancelBubble = false;\n    this.bubbles = bubbles ? Boolean(bubbles) : false;\n    this.code = typeof code === 'number' ? parseInt(code, 10) : 0;\n    this.reason = \"\" + (reason || '');\n    this.wasClean = wasClean ? Boolean(wasClean) : false;\n  }\n\n  if ( EventPrototype$$1 ) CloseEvent.__proto__ = EventPrototype$$1;\n  CloseEvent.prototype = Object.create( EventPrototype$$1 && EventPrototype$$1.prototype );\n  CloseEvent.prototype.constructor = CloseEvent;\n\n  return CloseEvent;\n}(EventPrototype));\n\n/*\n * Creates an Event object and extends it to allow full modification of\n * its properties.\n *\n * @param {object} config - within config you will need to pass type and optionally target\n */\nfunction createEvent(config) {\n  var type = config.type;\n  var target = config.target;\n  var eventObject = new Event(type);\n\n  if (target) {\n    eventObject.target = target;\n    eventObject.srcElement = target;\n    eventObject.currentTarget = target;\n  }\n\n  return eventObject;\n}\n\n/*\n * Creates a MessageEvent object and extends it to allow full modification of\n * its properties.\n *\n * @param {object} config - within config: type, origin, data and optionally target\n */\nfunction createMessageEvent(config) {\n  var type = config.type;\n  var origin = config.origin;\n  var data = config.data;\n  var target = config.target;\n  var messageEvent = new MessageEvent(type, {\n    data: data,\n    origin: origin\n  });\n\n  if (target) {\n    messageEvent.target = target;\n    messageEvent.srcElement = target;\n    messageEvent.currentTarget = target;\n  }\n\n  return messageEvent;\n}\n\n/*\n * Creates a CloseEvent object and extends it to allow full modification of\n * its properties.\n *\n * @param {object} config - within config: type and optionally target, code, and reason\n */\nfunction createCloseEvent(config) {\n  var code = config.code;\n  var reason = config.reason;\n  var type = config.type;\n  var target = config.target;\n  var wasClean = config.wasClean;\n\n  if (!wasClean) {\n    wasClean = code === CLOSE_CODES.CLOSE_NORMAL || code === CLOSE_CODES.CLOSE_NO_STATUS;\n  }\n\n  var closeEvent = new CloseEvent(type, {\n    code: code,\n    reason: reason,\n    wasClean: wasClean\n  });\n\n  if (target) {\n    closeEvent.target = target;\n    closeEvent.srcElement = target;\n    closeEvent.currentTarget = target;\n  }\n\n  return closeEvent;\n}\n\nfunction closeWebSocketConnection(context, code, reason) {\n  context.readyState = WebSocket$1.CLOSING;\n\n  var server = networkBridge.serverLookup(context.url);\n  var closeEvent = createCloseEvent({\n    type: 'close',\n    target: context.target,\n    code: code,\n    reason: reason\n  });\n\n  delay(function () {\n    networkBridge.removeWebSocket(context, context.url);\n\n    context.readyState = WebSocket$1.CLOSED;\n    context.dispatchEvent(closeEvent);\n\n    if (server) {\n      server.dispatchEvent(closeEvent, server);\n    }\n  }, context);\n}\n\nfunction failWebSocketConnection(context, code, reason) {\n  context.readyState = WebSocket$1.CLOSING;\n\n  var server = networkBridge.serverLookup(context.url);\n  var closeEvent = createCloseEvent({\n    type: 'close',\n    target: context.target,\n    code: code,\n    reason: reason,\n    wasClean: false\n  });\n\n  var errorEvent = createEvent({\n    type: 'error',\n    target: context.target\n  });\n\n  delay(function () {\n    networkBridge.removeWebSocket(context, context.url);\n\n    context.readyState = WebSocket$1.CLOSED;\n    context.dispatchEvent(errorEvent);\n    context.dispatchEvent(closeEvent);\n\n    if (server) {\n      server.dispatchEvent(closeEvent, server);\n    }\n  }, context);\n}\n\nfunction normalizeSendData(data) {\n  if (Object.prototype.toString.call(data) !== '[object Blob]' && !(data instanceof ArrayBuffer)) {\n    data = String(data);\n  }\n\n  return data;\n}\n\nvar proxies = new WeakMap();\n\nfunction proxyFactory(target) {\n  if (proxies.has(target)) {\n    return proxies.get(target);\n  }\n\n  var proxy = new Proxy(target, {\n    get: function get(obj, prop) {\n      if (prop === 'close') {\n        return function close(options) {\n          if ( options === void 0 ) options = {};\n\n          var code = options.code || CLOSE_CODES.CLOSE_NORMAL;\n          var reason = options.reason || '';\n\n          closeWebSocketConnection(proxy, code, reason);\n        };\n      }\n\n      if (prop === 'send') {\n        return function send(data) {\n          data = normalizeSendData(data);\n\n          target.dispatchEvent(\n            createMessageEvent({\n              type: 'message',\n              data: data,\n              origin: this.url,\n              target: target\n            })\n          );\n        };\n      }\n\n      var toSocketName = function (type) { return (type === 'message' ? (\"server::\" + type) : type); };\n      if (prop === 'on') {\n        return function onWrapper(type, cb) {\n          target.addEventListener(toSocketName(type), cb);\n        };\n      }\n      if (prop === 'off') {\n        return function offWrapper(type, cb) {\n          target.removeEventListener(toSocketName(type), cb);\n        };\n      }\n\n      if (prop === 'target') {\n        return target;\n      }\n\n      return obj[prop];\n    }\n  });\n  proxies.set(target, proxy);\n\n  return proxy;\n}\n\nfunction lengthInUtf8Bytes(str) {\n  // Matches only the 10.. bytes that are non-initial characters in a multi-byte sequence.\n  var m = encodeURIComponent(str).match(/%[89ABab]/g);\n  return str.length + (m ? m.length : 0);\n}\n\nfunction urlVerification(url) {\n  var urlRecord = new urlParse(url);\n  var pathname = urlRecord.pathname;\n  var protocol = urlRecord.protocol;\n  var hash = urlRecord.hash;\n\n  if (!url) {\n    throw new TypeError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" 1 argument required, but only 0 present.\"));\n  }\n\n  if (!pathname) {\n    urlRecord.pathname = '/';\n  }\n\n  if (protocol === '') {\n    throw new SyntaxError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The URL '\" + (urlRecord.toString()) + \"' is invalid.\"));\n  }\n\n  if (protocol !== 'ws:' && protocol !== 'wss:') {\n    throw new SyntaxError(\n      ((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The URL's scheme must be either 'ws' or 'wss'. '\" + protocol + \"' is not allowed.\")\n    );\n  }\n\n  if (hash !== '') {\n    /* eslint-disable max-len */\n    throw new SyntaxError(\n      ((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The URL contains a fragment identifier ('\" + hash + \"'). Fragment identifiers are not allowed in WebSocket URLs.\")\n    );\n    /* eslint-enable max-len */\n  }\n\n  return urlRecord.toString();\n}\n\nfunction protocolVerification(protocols) {\n  if ( protocols === void 0 ) protocols = [];\n\n  if (!Array.isArray(protocols) && typeof protocols !== 'string') {\n    throw new SyntaxError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The subprotocol '\" + (protocols.toString()) + \"' is invalid.\"));\n  }\n\n  if (typeof protocols === 'string') {\n    protocols = [protocols];\n  }\n\n  var uniq = protocols\n    .map(function (p) { return ({ count: 1, protocol: p }); })\n    .reduce(function (a, b) {\n      a[b.protocol] = (a[b.protocol] || 0) + b.count;\n      return a;\n    }, {});\n\n  var duplicates = Object.keys(uniq).filter(function (a) { return uniq[a] > 1; });\n\n  if (duplicates.length > 0) {\n    throw new SyntaxError(((ERROR_PREFIX.CONSTRUCTOR_ERROR) + \" The subprotocol '\" + (duplicates[0]) + \"' is duplicated.\"));\n  }\n\n  return protocols;\n}\n\n/*\n * The main websocket class which is designed to mimick the native WebSocket class as close\n * as possible.\n *\n * https://html.spec.whatwg.org/multipage/web-sockets.html\n */\nvar WebSocket$1 = (function (EventTarget$$1) {\n  function WebSocket(url, protocols) {\n    EventTarget$$1.call(this);\n\n    this._onopen = null;\n    this._onmessage = null;\n    this._onerror = null;\n    this._onclose = null;\n\n    this.url = urlVerification(url);\n    protocols = protocolVerification(protocols);\n    this.protocol = protocols[0] || '';\n\n    this.binaryType = 'blob';\n    this.readyState = WebSocket.CONNECTING;\n\n    var client = proxyFactory(this);\n    var server = networkBridge.attachWebSocket(client, this.url);\n\n    /*\n     * This delay is needed so that we dont trigger an event before the callbacks have been\n     * setup. For example:\n     *\n     * var socket = new WebSocket('ws://localhost');\n     *\n     * If we dont have the delay then the event would be triggered right here and this is\n     * before the onopen had a chance to register itself.\n     *\n     * socket.onopen = () => { // this would never be called };\n     *\n     * and with the delay the event gets triggered here after all of the callbacks have been\n     * registered :-)\n     */\n    delay(function delayCallback() {\n      if (this.readyState !== WebSocket.CONNECTING) {\n        return;\n      }\n      if (server) {\n        if (\n          server.options.verifyClient &&\n          typeof server.options.verifyClient === 'function' &&\n          !server.options.verifyClient()\n        ) {\n          this.readyState = WebSocket.CLOSED;\n\n          log(\n            'error',\n            (\"WebSocket connection to '\" + (this.url) + \"' failed: HTTP Authentication failed; no valid credentials available\")\n          );\n\n          networkBridge.removeWebSocket(client, this.url);\n          this.dispatchEvent(createEvent({ type: 'error', target: this }));\n          this.dispatchEvent(createCloseEvent({ type: 'close', target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n        } else {\n          if (server.options.selectProtocol && typeof server.options.selectProtocol === 'function') {\n            var selectedProtocol = server.options.selectProtocol(protocols);\n            var isFilled = selectedProtocol !== '';\n            var isRequested = protocols.indexOf(selectedProtocol) !== -1;\n            if (isFilled && !isRequested) {\n              this.readyState = WebSocket.CLOSED;\n\n              log('error', (\"WebSocket connection to '\" + (this.url) + \"' failed: Invalid Sub-Protocol\"));\n\n              networkBridge.removeWebSocket(client, this.url);\n              this.dispatchEvent(createEvent({ type: 'error', target: this }));\n              this.dispatchEvent(createCloseEvent({ type: 'close', target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n              return;\n            }\n            this.protocol = selectedProtocol;\n          }\n          this.readyState = WebSocket.OPEN;\n          this.dispatchEvent(createEvent({ type: 'open', target: this }));\n          server.dispatchEvent(createEvent({ type: 'connection' }), client);\n        }\n      } else {\n        this.readyState = WebSocket.CLOSED;\n        this.dispatchEvent(createEvent({ type: 'error', target: this }));\n        this.dispatchEvent(createCloseEvent({ type: 'close', target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n\n        log('error', (\"WebSocket connection to '\" + (this.url) + \"' failed\"));\n      }\n    }, this);\n  }\n\n  if ( EventTarget$$1 ) WebSocket.__proto__ = EventTarget$$1;\n  WebSocket.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );\n  WebSocket.prototype.constructor = WebSocket;\n\n  var prototypeAccessors = { onopen: {},onmessage: {},onclose: {},onerror: {} };\n\n  prototypeAccessors.onopen.get = function () {\n    return this._onopen;\n  };\n\n  prototypeAccessors.onmessage.get = function () {\n    return this._onmessage;\n  };\n\n  prototypeAccessors.onclose.get = function () {\n    return this._onclose;\n  };\n\n  prototypeAccessors.onerror.get = function () {\n    return this._onerror;\n  };\n\n  prototypeAccessors.onopen.set = function (listener) {\n    this.removeEventListener('open', this._onopen);\n    this._onopen = listener;\n    this.addEventListener('open', listener);\n  };\n\n  prototypeAccessors.onmessage.set = function (listener) {\n    this.removeEventListener('message', this._onmessage);\n    this._onmessage = listener;\n    this.addEventListener('message', listener);\n  };\n\n  prototypeAccessors.onclose.set = function (listener) {\n    this.removeEventListener('close', this._onclose);\n    this._onclose = listener;\n    this.addEventListener('close', listener);\n  };\n\n  prototypeAccessors.onerror.set = function (listener) {\n    this.removeEventListener('error', this._onerror);\n    this._onerror = listener;\n    this.addEventListener('error', listener);\n  };\n\n  WebSocket.prototype.send = function send (data) {\n    var this$1 = this;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      // TODO: node>=17 replace with DOMException\n      throw new Error(\"Failed to execute 'send' on 'WebSocket': Still in CONNECTING state\");\n    }\n\n    // TODO: handle bufferedAmount\n\n    var messageEvent = createMessageEvent({\n      type: 'server::message',\n      origin: this.url,\n      data: normalizeSendData(data)\n    });\n\n    var server = networkBridge.serverLookup(this.url);\n\n    if (server) {\n      delay(function () {\n        this$1.dispatchEvent(messageEvent, data);\n      }, server);\n    }\n  };\n\n  WebSocket.prototype.close = function close (code, reason) {\n    if (code !== undefined) {\n      if (typeof code !== 'number' || (code !== 1000 && (code < 3000 || code > 4999))) {\n        throw new TypeError(\n          ((ERROR_PREFIX.CLOSE_ERROR) + \" The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\")\n        );\n      }\n    }\n\n    if (reason !== undefined) {\n      var length = lengthInUtf8Bytes(reason);\n\n      if (length > 123) {\n        throw new SyntaxError(((ERROR_PREFIX.CLOSE_ERROR) + \" The message must not be greater than 123 bytes.\"));\n      }\n    }\n\n    if (this.readyState === WebSocket.CLOSING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n\n    var client = proxyFactory(this);\n    if (this.readyState === WebSocket.CONNECTING) {\n      failWebSocketConnection(client, code || CLOSE_CODES.CLOSE_ABNORMAL, reason);\n    } else {\n      closeWebSocketConnection(client, code || CLOSE_CODES.CLOSE_NO_STATUS, reason);\n    }\n  };\n\n  Object.defineProperties( WebSocket.prototype, prototypeAccessors );\n\n  return WebSocket;\n}(EventTarget));\n\nWebSocket$1.CONNECTING = 0;\nWebSocket$1.prototype.CONNECTING = WebSocket$1.CONNECTING;\nWebSocket$1.OPEN = 1;\nWebSocket$1.prototype.OPEN = WebSocket$1.OPEN;\nWebSocket$1.CLOSING = 2;\nWebSocket$1.prototype.CLOSING = WebSocket$1.CLOSING;\nWebSocket$1.CLOSED = 3;\nWebSocket$1.prototype.CLOSED = WebSocket$1.CLOSED;\n\n/*\n * The socket-io class is designed to mimick the real API as closely as possible.\n *\n * http://socket.io/docs/\n */\nvar SocketIO$1 = (function (EventTarget$$1) {\n  function SocketIO(url, protocol) {\n    var this$1 = this;\n    if ( url === void 0 ) url = 'socket.io';\n    if ( protocol === void 0 ) protocol = '';\n\n    EventTarget$$1.call(this);\n\n    this.binaryType = 'blob';\n    var urlRecord = new urlParse(url);\n\n    if (!urlRecord.pathname) {\n      urlRecord.pathname = '/';\n    }\n\n    this.url = urlRecord.toString();\n    this.readyState = SocketIO.CONNECTING;\n    this.protocol = '';\n    this.target = this;\n\n    if (typeof protocol === 'string' || (typeof protocol === 'object' && protocol !== null)) {\n      this.protocol = protocol;\n    } else if (Array.isArray(protocol) && protocol.length > 0) {\n      this.protocol = protocol[0];\n    }\n\n    var server = networkBridge.attachWebSocket(this, this.url);\n\n    /*\n     * Delay triggering the connection events so they can be defined in time.\n     */\n    delay(function delayCallback() {\n      if (server) {\n        this.readyState = SocketIO.OPEN;\n        server.dispatchEvent(createEvent({ type: 'connection' }), server, this);\n        server.dispatchEvent(createEvent({ type: 'connect' }), server, this); // alias\n        this.dispatchEvent(createEvent({ type: 'connect', target: this }));\n      } else {\n        this.readyState = SocketIO.CLOSED;\n        this.dispatchEvent(createEvent({ type: 'error', target: this }));\n        this.dispatchEvent(\n          createCloseEvent({\n            type: 'close',\n            target: this,\n            code: CLOSE_CODES.CLOSE_NORMAL\n          })\n        );\n\n        log('error', (\"Socket.io connection to '\" + (this.url) + \"' failed\"));\n      }\n    }, this);\n\n    /**\n      Add an aliased event listener for close / disconnect\n     */\n    this.addEventListener('close', function (event) {\n      this$1.dispatchEvent(\n        createCloseEvent({\n          type: 'disconnect',\n          target: event.target,\n          code: event.code\n        })\n      );\n    });\n  }\n\n  if ( EventTarget$$1 ) SocketIO.__proto__ = EventTarget$$1;\n  SocketIO.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );\n  SocketIO.prototype.constructor = SocketIO;\n\n  var prototypeAccessors = { broadcast: {} };\n\n  /*\n   * Closes the SocketIO connection or connection attempt, if any.\n   * If the connection is already CLOSED, this method does nothing.\n   */\n  SocketIO.prototype.close = function close () {\n    if (this.readyState !== SocketIO.OPEN) {\n      return undefined;\n    }\n\n    var server = networkBridge.serverLookup(this.url);\n    networkBridge.removeWebSocket(this, this.url);\n\n    this.readyState = SocketIO.CLOSED;\n    this.dispatchEvent(\n      createCloseEvent({\n        type: 'close',\n        target: this,\n        code: CLOSE_CODES.CLOSE_NORMAL\n      })\n    );\n\n    if (server) {\n      server.dispatchEvent(\n        createCloseEvent({\n          type: 'disconnect',\n          target: this,\n          code: CLOSE_CODES.CLOSE_NORMAL\n        }),\n        server\n      );\n    }\n\n    return this;\n  };\n\n  /*\n   * Alias for Socket#close\n   *\n   * https://github.com/socketio/socket.io-client/blob/master/lib/socket.js#L383\n   */\n  SocketIO.prototype.disconnect = function disconnect () {\n    return this.close();\n  };\n\n  /*\n   * Submits an event to the server with a payload\n   */\n  SocketIO.prototype.emit = function emit (event) {\n    var data = [], len = arguments.length - 1;\n    while ( len-- > 0 ) data[ len ] = arguments[ len + 1 ];\n\n    if (this.readyState !== SocketIO.OPEN) {\n      throw new Error('SocketIO is already in CLOSING or CLOSED state');\n    }\n\n    var messageEvent = createMessageEvent({\n      type: event,\n      origin: this.url,\n      data: data\n    });\n\n    var server = networkBridge.serverLookup(this.url);\n\n    if (server) {\n      server.dispatchEvent.apply(server, [ messageEvent ].concat( data ));\n    }\n\n    return this;\n  };\n\n  /*\n   * Submits a 'message' event to the server.\n   *\n   * Should behave exactly like WebSocket#send\n   *\n   * https://github.com/socketio/socket.io-client/blob/master/lib/socket.js#L113\n   */\n  SocketIO.prototype.send = function send (data) {\n    this.emit('message', data);\n    return this;\n  };\n\n  /*\n   * For broadcasting events to other connected sockets.\n   *\n   * e.g. socket.broadcast.emit('hi!');\n   * e.g. socket.broadcast.to('my-room').emit('hi!');\n   */\n  prototypeAccessors.broadcast.get = function () {\n    if (this.readyState !== SocketIO.OPEN) {\n      throw new Error('SocketIO is already in CLOSING or CLOSED state');\n    }\n\n    var self = this;\n    var server = networkBridge.serverLookup(this.url);\n    if (!server) {\n      throw new Error((\"SocketIO can not find a server at the specified URL (\" + (this.url) + \")\"));\n    }\n\n    return {\n      emit: function emit(event, data) {\n        server.emit(event, data, { websockets: networkBridge.websocketsLookup(self.url, null, self) });\n        return self;\n      },\n      to: function to(room) {\n        return server.to(room, self);\n      },\n      in: function in$1(room) {\n        return server.in(room, self);\n      }\n    };\n  };\n\n  /*\n   * For registering events to be received from the server\n   */\n  SocketIO.prototype.on = function on (type, callback) {\n    this.addEventListener(type, callback);\n    return this;\n  };\n\n  /*\n   * Remove event listener\n   *\n   * https://github.com/component/emitter#emitteroffevent-fn\n   */\n  SocketIO.prototype.off = function off (type, callback) {\n    this.removeEventListener(type, callback);\n  };\n\n  /*\n   * Check if listeners have already been added for an event\n   *\n   * https://github.com/component/emitter#emitterhaslistenersevent\n   */\n  SocketIO.prototype.hasListeners = function hasListeners (type) {\n    var listeners = this.listeners[type];\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n    return !!listeners.length;\n  };\n\n  /*\n   * Join a room on a server\n   *\n   * http://socket.io/docs/rooms-and-namespaces/#joining-and-leaving\n   */\n  SocketIO.prototype.join = function join (room) {\n    networkBridge.addMembershipToRoom(this, room);\n  };\n\n  /*\n   * Get the websocket to leave the room\n   *\n   * http://socket.io/docs/rooms-and-namespaces/#joining-and-leaving\n   */\n  SocketIO.prototype.leave = function leave (room) {\n    networkBridge.removeMembershipFromRoom(this, room);\n  };\n\n  SocketIO.prototype.to = function to (room) {\n    return this.broadcast.to(room);\n  };\n\n  SocketIO.prototype.in = function in$1 () {\n    return this.to.apply(null, arguments);\n  };\n\n  /*\n   * Invokes all listener functions that are listening to the given event.type property. Each\n   * listener will be passed the event as the first argument.\n   *\n   * @param {object} event - event object which will be passed to all listeners of the event.type property\n   */\n  SocketIO.prototype.dispatchEvent = function dispatchEvent (event) {\n    var this$1 = this;\n    var customArguments = [], len = arguments.length - 1;\n    while ( len-- > 0 ) customArguments[ len ] = arguments[ len + 1 ];\n\n    var eventName = event.type;\n    var listeners = this.listeners[eventName];\n\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n\n    listeners.forEach(function (listener) {\n      if (customArguments.length > 0) {\n        listener.apply(this$1, customArguments);\n      } else {\n        // Regular WebSockets expect a MessageEvent but Socketio.io just wants raw data\n        //  payload instanceof MessageEvent works, but you can't isntance of NodeEvent\n        //  for now we detect if the output has data defined on it\n        listener.call(this$1, event.data ? event.data : event);\n      }\n    });\n  };\n\n  Object.defineProperties( SocketIO.prototype, prototypeAccessors );\n\n  return SocketIO;\n}(EventTarget));\n\nSocketIO$1.CONNECTING = 0;\nSocketIO$1.OPEN = 1;\nSocketIO$1.CLOSING = 2;\nSocketIO$1.CLOSED = 3;\n\n/*\n * Static constructor methods for the IO Socket\n */\nvar IO = function ioConstructor(url, protocol) {\n  return new SocketIO$1(url, protocol);\n};\n\n/*\n * Alias the raw IO() constructor\n */\nIO.connect = function ioConnect(url, protocol) {\n  /* eslint-disable new-cap */\n  return IO(url, protocol);\n  /* eslint-enable new-cap */\n};\n\nvar dedupe = function (arr) { return arr.reduce(function (deduped, b) {\n    if (deduped.indexOf(b) > -1) { return deduped; }\n    return deduped.concat(b);\n  }, []); };\n\nfunction retrieveGlobalObject() {\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  return typeof process === 'object' && \"function\" === 'function' && typeof __webpack_require__.g === 'object' ? __webpack_require__.g : this;\n}\n\nvar defaultOptions = {\n  mock: true,\n  verifyClient: null,\n  selectProtocol: null\n};\n\nvar Server$1 = (function (EventTarget$$1) {\n  function Server(url, options) {\n    if ( options === void 0 ) options = defaultOptions;\n\n    EventTarget$$1.call(this);\n    var urlRecord = new urlParse(url);\n\n    if (!urlRecord.pathname) {\n      urlRecord.pathname = '/';\n    }\n\n    this.url = urlRecord.toString();\n\n    this.originalWebSocket = null;\n    var server = networkBridge.attachServer(this, this.url);\n\n    if (!server) {\n      this.dispatchEvent(createEvent({ type: 'error' }));\n      throw new Error('A mock server is already listening on this url');\n    }\n\n    this.options = Object.assign({}, defaultOptions, options);\n\n    if (this.options.mock) {\n      this.mockWebsocket();\n    }\n  }\n\n  if ( EventTarget$$1 ) Server.__proto__ = EventTarget$$1;\n  Server.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );\n  Server.prototype.constructor = Server;\n\n  /*\n   * Attaches the mock websocket object to the global object\n   */\n  Server.prototype.mockWebsocket = function mockWebsocket () {\n    var globalObj = retrieveGlobalObject();\n\n    this.originalWebSocket = globalObj.WebSocket;\n    globalObj.WebSocket = WebSocket$1;\n  };\n\n  /*\n   * Removes the mock websocket object from the global object\n   */\n  Server.prototype.restoreWebsocket = function restoreWebsocket () {\n    var globalObj = retrieveGlobalObject();\n\n    if (this.originalWebSocket !== null) {\n      globalObj.WebSocket = this.originalWebSocket;\n    }\n\n    this.originalWebSocket = null;\n  };\n\n  /**\n   * Removes itself from the urlMap so another server could add itself to the url.\n   * @param {function} callback - The callback is called when the server is stopped\n   */\n  Server.prototype.stop = function stop (callback) {\n    if ( callback === void 0 ) callback = function () {};\n\n    if (this.options.mock) {\n      this.restoreWebsocket();\n    }\n\n    networkBridge.removeServer(this.url);\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n\n  /*\n   * This is the main function for the mock server to subscribe to the on events.\n   *\n   * ie: mockServer.on('connection', function() { console.log('a mock client connected'); });\n   *\n   * @param {string} type - The event key to subscribe to. Valid keys are: connection, message, and close.\n   * @param {function} callback - The callback which should be called when a certain event is fired.\n   */\n  Server.prototype.on = function on (type, callback) {\n    this.addEventListener(type, callback);\n  };\n\n  /*\n   * Remove event listener\n   */\n  Server.prototype.off = function off (type, callback) {\n    this.removeEventListener(type, callback);\n  };\n\n  /*\n   * Closes the connection and triggers the onclose method of all listening\n   * websockets. After that it removes itself from the urlMap so another server\n   * could add itself to the url.\n   *\n   * @param {object} options\n   */\n  Server.prototype.close = function close (options) {\n    if ( options === void 0 ) options = {};\n\n    var code = options.code;\n    var reason = options.reason;\n    var wasClean = options.wasClean;\n    var listeners = networkBridge.websocketsLookup(this.url);\n\n    // Remove server before notifications to prevent immediate reconnects from\n    // socket onclose handlers\n    networkBridge.removeServer(this.url);\n\n    listeners.forEach(function (socket) {\n      socket.readyState = WebSocket$1.CLOSED;\n      socket.dispatchEvent(\n        createCloseEvent({\n          type: 'close',\n          target: socket.target,\n          code: code || CLOSE_CODES.CLOSE_NORMAL,\n          reason: reason || '',\n          wasClean: wasClean\n        })\n      );\n    });\n\n    this.dispatchEvent(createCloseEvent({ type: 'close' }), this);\n  };\n\n  /*\n   * Sends a generic message event to all mock clients.\n   */\n  Server.prototype.emit = function emit (event, data, options) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n    var websockets = options.websockets;\n\n    if (!websockets) {\n      websockets = networkBridge.websocketsLookup(this.url);\n    }\n\n    var normalizedData;\n    if (typeof options !== 'object' || arguments.length > 3) {\n      data = Array.prototype.slice.call(arguments, 1, arguments.length);\n      normalizedData = data.map(function (item) { return normalizeSendData(item); });\n    } else {\n      normalizedData = normalizeSendData(data);\n    }\n\n    websockets.forEach(function (socket) {\n      var messageData = socket instanceof SocketIO$1 ? data : normalizedData;\n      if (Array.isArray(messageData)) {\n        socket.dispatchEvent.apply(\n          socket, [ createMessageEvent({\n            type: event,\n            data: messageData,\n            origin: this$1.url,\n            target: socket.target\n          }) ].concat( messageData )\n        );\n      } else {\n        socket.dispatchEvent(\n          createMessageEvent({\n            type: event,\n            data: messageData,\n            origin: this$1.url,\n            target: socket.target\n          })\n        );\n      }\n    });\n  };\n\n  /*\n   * Returns an array of websockets which are listening to this server\n   * TOOD: this should return a set and not be a method\n   */\n  Server.prototype.clients = function clients () {\n    return networkBridge.websocketsLookup(this.url);\n  };\n\n  /*\n   * Prepares a method to submit an event to members of the room\n   *\n   * e.g. server.to('my-room').emit('hi!');\n   */\n  Server.prototype.to = function to (room, broadcaster, broadcastList) {\n    var this$1 = this;\n    if ( broadcastList === void 0 ) broadcastList = [];\n\n    var self = this;\n    var websockets = dedupe(broadcastList.concat(networkBridge.websocketsLookup(this.url, room, broadcaster)));\n\n    return {\n      to: function (chainedRoom, chainedBroadcaster) { return this$1.to.call(this$1, chainedRoom, chainedBroadcaster, websockets); },\n      emit: function emit(event, data) {\n        self.emit(event, data, { websockets: websockets });\n      }\n    };\n  };\n\n  /*\n   * Alias for Server.to\n   */\n  Server.prototype.in = function in$1 () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return this.to.apply(null, args);\n  };\n\n  /*\n   * Simulate an event from the server to the clients. Useful for\n   * simulating errors.\n   */\n  Server.prototype.simulate = function simulate (event) {\n    var listeners = networkBridge.websocketsLookup(this.url);\n\n    if (event === 'error') {\n      listeners.forEach(function (socket) {\n        socket.readyState = WebSocket$1.CLOSED;\n        socket.dispatchEvent(createEvent({ type: 'error', target: socket.target }));\n      });\n    }\n  };\n\n  return Server;\n}(EventTarget));\n\n/*\n * Alternative constructor to support namespaces in socket.io\n *\n * http://socket.io/docs/rooms-and-namespaces/#custom-namespaces\n */\nServer$1.of = function of(url) {\n  return new Server$1(url);\n};\n\nvar Server = Server$1;\nvar WebSocket = WebSocket$1;\nvar SocketIO$$1 = IO;\n\nexports.Server = Server;\nexports.WebSocket = WebSocket;\nexports.SocketIO = SocketIO$$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n//# sourceURL=webpack://HyphaCore/./node_modules/mock-socket/dist/mock-socket.js?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataViewIndexOutOfBoundsError: () => (/* binding */ DataViewIndexOutOfBoundsError),\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar STATE_ARRAY = \"array\";\nvar STATE_MAP_KEY = \"map_key\";\nvar STATE_MAP_VALUE = \"map_value\";\nvar isValidMapKeyType = function (key) {\n    return typeof key === \"string\" || typeof key === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n}\ncatch (e) {\n    if (!(e instanceof RangeError)) {\n        throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n    }\n}\nvar DataViewIndexOutOfBoundsError = RangeError;\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(options) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n        this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;\n        this.maxStrLength = (_c = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _c !== void 0 ? _c : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxBinLength = (_d = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _d !== void 0 ? _d : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxArrayLength = (_e = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _e !== void 0 ? _e : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxMapLength = (_f = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _f !== void 0 ? _f : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxExtLength = (_g = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _g !== void 0 ? _g : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.keyDecoder = ((options === null || options === void 0 ? void 0 : options.keyDecoder) !== undefined) ? options.keyDecoder : sharedCachedKeyDecoder;\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n        this.view = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var _a, stream_1, stream_1_1;\n        var _b, e_1, _c, _d;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        decoded = false;\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 6, 7, 12]);\n                        _a = true, stream_1 = __asyncValues(stream);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3 /*break*/, 5];\n                        _d = stream_1_1.value;\n                        _a = false;\n                        try {\n                            buffer = _d;\n                            if (decoded) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            this.appendBuffer(buffer);\n                            try {\n                                object = this.doDecodeSync();\n                                decoded = true;\n                            }\n                            catch (e) {\n                                if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                    throw e; // rethrow\n                                }\n                                // fallthrough\n                            }\n                            this.totalPos += this.pos;\n                        }\n                        finally {\n                            _a = true;\n                        }\n                        _f.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _f.trys.push([7, , 10, 11]);\n                        if (!(!_a && !_b && (_c = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _c.call(stream_1)];\n                    case 8:\n                        _f.sent();\n                        _f.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var _b, e_3, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _e.label = 1;\n                    case 1:\n                        _e.trys.push([1, 15, 16, 21]);\n                        _a = true, stream_2 = __asyncValues(stream);\n                        _e.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3 /*break*/, 14];\n                        _d = stream_2_1.value;\n                        _a = false;\n                        _e.label = 4;\n                    case 4:\n                        _e.trys.push([4, , 12, 13]);\n                        buffer = _d;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _e.label = 5;\n                    case 5:\n                        _e.trys.push([5, 10, , 11]);\n                        _e.label = 6;\n                    case 6:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 7: return [4 /*yield*/, _e.sent()];\n                    case 8:\n                        _e.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 9];\n                        }\n                        return [3 /*break*/, 6];\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        e_2 = _e.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 11];\n                    case 11:\n                        this.totalPos += this.pos;\n                        return [3 /*break*/, 13];\n                    case 12:\n                        _a = true;\n                        return [7 /*endfinally*/];\n                    case 13: return [3 /*break*/, 2];\n                    case 14: return [3 /*break*/, 21];\n                    case 15:\n                        e_3_1 = _e.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 21];\n                    case 16:\n                        _e.trys.push([16, , 19, 20]);\n                        if (!(!_a && !_b && (_c = stream_2.return))) return [3 /*break*/, 18];\n                        return [4 /*yield*/, __await(_c.call(stream_2))];\n                    case 17:\n                        _e.sent();\n                        _e.label = 18;\n                    case 18: return [3 /*break*/, 20];\n                    case 19:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 20: return [7 /*endfinally*/];\n                    case 21: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                if (this.useBigInt64) {\n                    object = this.readU64AsBigInt();\n                }\n                else {\n                    object = this.readU64();\n                }\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                if (this.useBigInt64) {\n                    object = this.readI64AsBigInt();\n                }\n                else {\n                    object = this.readI64();\n                }\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === STATE_ARRAY) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === STATE_MAP_KEY) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = STATE_MAP_VALUE;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = STATE_MAP_KEY;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: STATE_MAP_KEY,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: STATE_ARRAY,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8Decode)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === STATE_MAP_KEY;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readU64AsBigInt = function () {\n        var value = this.view.getBigUint64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64AsBigInt = function () {\n        var value = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;\n        this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;\n        this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;\n        this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;\n        this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;\n        this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;\n        this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;\n        this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            if (!this.forceIntegerToFloat) {\n                this.encodeNumber(object);\n            }\n            else {\n                this.encodeNumberAsFloat(object);\n            }\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else if (this.useBigInt64 && typeof object === \"bigint\") {\n            this.encodeBigInt64(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n        }\n        else {\n            this.encodeNumberAsFloat(object);\n        }\n    };\n    Encoder.prototype.encodeNumberAsFloat = function (object) {\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        }\n        else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    };\n    Encoder.prototype.encodeBigInt64 = function (object) {\n        if (object >= BigInt(0)) {\n            // uint 64\n            this.writeU8(0xcf);\n            this.writeBigUint64(object);\n        }\n        else {\n            // int 64\n            this.writeU8(0xd3);\n            this.writeBigInt64(object);\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n        this.writeStringHeader(byteLength);\n        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Encode)(object, this.bytes, this.pos);\n        this.pos += byteLength;\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeBigUint64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigUint64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeBigInt64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultEncodeOptions: () => (/* binding */ defaultEncodeOptions),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\n/**\n * @deprecated No longer supported.\n */\nvar defaultEncodeOptions = undefined;\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDataView: () => (/* binding */ createDataView),\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nvar sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nvar TEXT_ENCODER_THRESHOLD = 50;\nfunction utf8EncodeTE(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nfunction utf8Encode(str, output, outputOffset) {\n    if (str.length > TEXT_ENCODER_THRESHOLD) {\n        utf8EncodeTE(str, output, outputOffset);\n    }\n    else {\n        utf8EncodeJs(str, output, outputOffset);\n    }\n}\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nvar TEXT_DECODER_THRESHOLD = 200;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\nfunction utf8Decode(bytes, inputOffset, byteLength) {\n    if (byteLength > TEXT_DECODER_THRESHOLD) {\n        return utf8DecodeTD(bytes, inputOffset, byteLength);\n    }\n    else {\n        return utf8DecodeJs(bytes, inputOffset, byteLength);\n    }\n}\n//# sourceMappingURL=utf8.mjs.map\n\n//# sourceURL=webpack://HyphaCore/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".hypha-core.umd.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "HyphaCore:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"lib": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = this["webpackChunkHyphaCore"] = this["webpackChunkHyphaCore"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/hypha-core.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});