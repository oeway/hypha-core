/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhypha_core"] = self["webpackChunkhypha_core"] || []).push([["vendors-node_modules_imjoy-rpc_index_js"],{

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js":
/*!******************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/hypha/sse-client.js\");\n    }({\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: CachedKeyDecoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"CachedKeyDecoder\", function() {\n            return CachedKeyDecoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var DEFAULT_MAX_KEY_LENGTH = 16;\n          var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n          var CachedKeyDecoder = (\n            /** @class */\n            function() {\n              function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                if (maxKeyLength === void 0) {\n                  maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                }\n                if (maxLengthPerKey === void 0) {\n                  maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                }\n                this.maxKeyLength = maxKeyLength;\n                this.maxLengthPerKey = maxLengthPerKey;\n                this.hit = 0;\n                this.miss = 0;\n                this.caches = [];\n                for (var i = 0; i < this.maxKeyLength; i++) {\n                  this.caches.push([]);\n                }\n              }\n              CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                return byteLength > 0 && byteLength <= this.maxKeyLength;\n              };\n              CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                var records = this.caches[byteLength - 1];\n                FIND_CHUNK:\n                  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                    var record = records_1[_i];\n                    var recordBytes = record.bytes;\n                    for (var j = 0; j < byteLength; j++) {\n                      if (recordBytes[j] !== bytes[inputOffset + j]) {\n                        continue FIND_CHUNK;\n                      }\n                    }\n                    return record.str;\n                  }\n                return null;\n              };\n              CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                var records = this.caches[bytes.length - 1];\n                var record = { bytes, str: value };\n                if (records.length >= this.maxLengthPerKey) {\n                  records[Math.random() * records.length | 0] = record;\n                } else {\n                  records.push(record);\n                }\n              };\n              CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                var cachedValue = this.find(bytes, inputOffset, byteLength);\n                if (cachedValue != null) {\n                  this.hit++;\n                  return cachedValue;\n                }\n                this.miss++;\n                var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n                var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                this.store(slicedCopyOfBytes, str);\n                return str;\n              };\n              return CachedKeyDecoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: DecodeError */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return DecodeError;\n          });\n          var __extends = function() {\n            var extendStatics = function(d, b) {\n              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                d2.__proto__ = b2;\n              } || function(d2, b2) {\n                for (var p in b2)\n                  if (Object.prototype.hasOwnProperty.call(b2, p))\n                    d2[p] = b2[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function(d, b) {\n              if (typeof b !== \"function\" && b !== null)\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          var DecodeError = (\n            /** @class */\n            function(_super) {\n              __extends(DecodeError2, _super);\n              function DecodeError2(message) {\n                var _this = _super.call(this, message) || this;\n                var proto = Object.create(DecodeError2.prototype);\n                Object.setPrototypeOf(_this, proto);\n                Object.defineProperty(_this, \"name\", {\n                  configurable: true,\n                  enumerable: false,\n                  value: DecodeError2.name\n                });\n                return _this;\n              }\n              return DecodeError2;\n            }(Error)\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return DataViewIndexOutOfBoundsError;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/prettyByte.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./CachedKeyDecoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n          );\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __asyncValues = function(o) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i);\n            function verb(n) {\n              i[n] = o[n] && function(v) {\n                return new Promise(function(resolve, reject) {\n                  v = o[n](v), settle(resolve, reject, v.done, v.value);\n                });\n              };\n            }\n            function settle(resolve, reject, d, v) {\n              Promise.resolve(v).then(function(v2) {\n                resolve({ value: v2, done: d });\n              }, reject);\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          var isValidMapKeyType = function(key) {\n            var keyType = typeof key;\n            return keyType === \"string\" || keyType === \"number\";\n          };\n          var HEAD_BYTE_REQUIRED = -1;\n          var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n          var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n          var DataViewIndexOutOfBoundsError = function() {\n            try {\n              EMPTY_VIEW.getInt8(0);\n            } catch (e) {\n              return e.constructor;\n            }\n            throw new Error(\"never reached\");\n          }();\n          var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n          var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\n          var Decoder = (\n            /** @class */\n            function() {\n              function Decoder2(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxStrLength === void 0) {\n                  maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxBinLength === void 0) {\n                  maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxArrayLength === void 0) {\n                  maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxMapLength === void 0) {\n                  maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxExtLength === void 0) {\n                  maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (keyDecoder === void 0) {\n                  keyDecoder = sharedCachedKeyDecoder;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxStrLength = maxStrLength;\n                this.maxBinLength = maxBinLength;\n                this.maxArrayLength = maxArrayLength;\n                this.maxMapLength = maxMapLength;\n                this.maxExtLength = maxExtLength;\n                this.keyDecoder = keyDecoder;\n                this.totalPos = 0;\n                this.pos = 0;\n                this.view = EMPTY_VIEW;\n                this.bytes = EMPTY_BYTES;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack = [];\n              }\n              Decoder2.prototype.reinitializeState = function() {\n                this.totalPos = 0;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack.length = 0;\n              };\n              Decoder2.prototype.setBuffer = function(buffer) {\n                this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n                this.pos = 0;\n              };\n              Decoder2.prototype.appendBuffer = function(buffer) {\n                if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                  this.setBuffer(buffer);\n                } else {\n                  var remainingData = this.bytes.subarray(this.pos);\n                  var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                  var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                  newBuffer.set(remainingData);\n                  newBuffer.set(newData, remainingData.length);\n                  this.setBuffer(newBuffer);\n                }\n              };\n              Decoder2.prototype.hasRemaining = function(size) {\n                return this.view.byteLength - this.pos >= size;\n              };\n              Decoder2.prototype.createExtraByteError = function(posToShow) {\n                var _a = this, view = _a.view, pos = _a.pos;\n                return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n              };\n              Decoder2.prototype.decode = function(buffer) {\n                this.reinitializeState();\n                this.setBuffer(buffer);\n                var object = this.doDecodeSync();\n                if (this.hasRemaining(1)) {\n                  throw this.createExtraByteError(this.pos);\n                }\n                return object;\n              };\n              Decoder2.prototype.decodeMulti = function(buffer) {\n                return __generator(this, function(_a) {\n                  switch (_a.label) {\n                    case 0:\n                      this.reinitializeState();\n                      this.setBuffer(buffer);\n                      _a.label = 1;\n                    case 1:\n                      if (!this.hasRemaining(1))\n                        return [3, 3];\n                      return [4, this.doDecodeSync()];\n                    case 2:\n                      _a.sent();\n                      return [3, 1];\n                    case 3:\n                      return [\n                        2\n                        /*return*/\n                      ];\n                  }\n                });\n              };\n              Decoder2.prototype.decodeAsync = function(stream) {\n                var stream_1, stream_1_1;\n                var e_1, _a;\n                return __awaiter(this, void 0, void 0, function() {\n                  var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                  return __generator(this, function(_c) {\n                    switch (_c.label) {\n                      case 0:\n                        decoded = false;\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                      case 2:\n                        return [4, stream_1.next()];\n                      case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                          return [3, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                          object = this.doDecodeSync();\n                          decoded = true;\n                        } catch (e) {\n                          if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e;\n                          }\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                      case 4:\n                        return [3, 2];\n                      case 5:\n                        return [3, 12];\n                      case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3, 12];\n                      case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                          return [3, 9];\n                        return [4, _a.call(stream_1)];\n                      case 8:\n                        _c.sent();\n                        _c.label = 9;\n                      case 9:\n                        return [3, 11];\n                      case 10:\n                        if (e_1)\n                          throw e_1.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 11:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 12:\n                        if (decoded) {\n                          if (this.hasRemaining(1)) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          return [2, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.decodeArrayStream = function(stream) {\n                return this.decodeMultiAsync(stream, true);\n              };\n              Decoder2.prototype.decodeStream = function(stream) {\n                return this.decodeMultiAsync(stream, false);\n              };\n              Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                  var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                  var e_3, _a;\n                  return __generator(this, function(_b) {\n                    switch (_b.label) {\n                      case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                      case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                      case 2:\n                        return [4, __await(stream_2.next())];\n                      case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                          return [3, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                          arrayItemsLeft = this.readArraySize();\n                          isArrayHeaderRequired = false;\n                          this.complete();\n                        }\n                        _b.label = 4;\n                      case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                      case 5:\n                        if (false) {}\n                        return [4, __await(this.doDecodeSync())];\n                      case 6:\n                        return [4, _b.sent()];\n                      case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                          return [3, 8];\n                        }\n                        return [3, 5];\n                      case 8:\n                        return [3, 10];\n                      case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                          throw e_2;\n                        }\n                        return [3, 10];\n                      case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                      case 11:\n                        return [3, 2];\n                      case 12:\n                        return [3, 19];\n                      case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3, 19];\n                      case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                          return [3, 16];\n                        return [4, __await(_a.call(stream_2))];\n                      case 15:\n                        _b.sent();\n                        _b.label = 16;\n                      case 16:\n                        return [3, 18];\n                      case 17:\n                        if (e_3)\n                          throw e_3.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 18:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 19:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.doDecodeSync = function() {\n                DECODE:\n                  while (true) {\n                    var headByte = this.readHeadByte();\n                    var object = void 0;\n                    if (headByte >= 224) {\n                      object = headByte - 256;\n                    } else if (headByte < 192) {\n                      if (headByte < 128) {\n                        object = headByte;\n                      } else if (headByte < 144) {\n                        var size = headByte - 128;\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte < 160) {\n                        var size = headByte - 144;\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else {\n                        var byteLength = headByte - 160;\n                        object = this.decodeUtf8String(byteLength, 0);\n                      }\n                    } else if (headByte === 192) {\n                      object = null;\n                    } else if (headByte === 194) {\n                      object = false;\n                    } else if (headByte === 195) {\n                      object = true;\n                    } else if (headByte === 202) {\n                      object = this.readF32();\n                    } else if (headByte === 203) {\n                      object = this.readF64();\n                    } else if (headByte === 204) {\n                      object = this.readU8();\n                    } else if (headByte === 205) {\n                      object = this.readU16();\n                    } else if (headByte === 206) {\n                      object = this.readU32();\n                    } else if (headByte === 207) {\n                      object = this.readU64();\n                    } else if (headByte === 208) {\n                      object = this.readI8();\n                    } else if (headByte === 209) {\n                      object = this.readI16();\n                    } else if (headByte === 210) {\n                      object = this.readI32();\n                    } else if (headByte === 211) {\n                      object = this.readI64();\n                    } else if (headByte === 217) {\n                      var byteLength = this.lookU8();\n                      object = this.decodeUtf8String(byteLength, 1);\n                    } else if (headByte === 218) {\n                      var byteLength = this.lookU16();\n                      object = this.decodeUtf8String(byteLength, 2);\n                    } else if (headByte === 219) {\n                      var byteLength = this.lookU32();\n                      object = this.decodeUtf8String(byteLength, 4);\n                    } else if (headByte === 220) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 221) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 222) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 223) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 196) {\n                      var size = this.lookU8();\n                      object = this.decodeBinary(size, 1);\n                    } else if (headByte === 197) {\n                      var size = this.lookU16();\n                      object = this.decodeBinary(size, 2);\n                    } else if (headByte === 198) {\n                      var size = this.lookU32();\n                      object = this.decodeBinary(size, 4);\n                    } else if (headByte === 212) {\n                      object = this.decodeExtension(1, 0);\n                    } else if (headByte === 213) {\n                      object = this.decodeExtension(2, 0);\n                    } else if (headByte === 214) {\n                      object = this.decodeExtension(4, 0);\n                    } else if (headByte === 215) {\n                      object = this.decodeExtension(8, 0);\n                    } else if (headByte === 216) {\n                      object = this.decodeExtension(16, 0);\n                    } else if (headByte === 199) {\n                      var size = this.lookU8();\n                      object = this.decodeExtension(size, 1);\n                    } else if (headByte === 200) {\n                      var size = this.lookU16();\n                      object = this.decodeExtension(size, 2);\n                    } else if (headByte === 201) {\n                      var size = this.lookU32();\n                      object = this.decodeExtension(size, 4);\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                    this.complete();\n                    var stack = this.stack;\n                    while (stack.length > 0) {\n                      var state = stack[stack.length - 1];\n                      if (state.type === 0) {\n                        state.array[state.position] = object;\n                        state.position++;\n                        if (state.position === state.size) {\n                          stack.pop();\n                          object = state.array;\n                        } else {\n                          continue DECODE;\n                        }\n                      } else if (state.type === 1) {\n                        if (!isValidMapKeyType(object)) {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                        }\n                        if (object === \"__proto__\") {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                        }\n                        state.key = object;\n                        state.type = 2;\n                        continue DECODE;\n                      } else {\n                        state.map[state.key] = object;\n                        state.readCount++;\n                        if (state.readCount === state.size) {\n                          stack.pop();\n                          object = state.map;\n                        } else {\n                          state.key = null;\n                          state.type = 1;\n                          continue DECODE;\n                        }\n                      }\n                    }\n                    return object;\n                  }\n              };\n              Decoder2.prototype.readHeadByte = function() {\n                if (this.headByte === HEAD_BYTE_REQUIRED) {\n                  this.headByte = this.readU8();\n                }\n                return this.headByte;\n              };\n              Decoder2.prototype.complete = function() {\n                this.headByte = HEAD_BYTE_REQUIRED;\n              };\n              Decoder2.prototype.readArraySize = function() {\n                var headByte = this.readHeadByte();\n                switch (headByte) {\n                  case 220:\n                    return this.readU16();\n                  case 221:\n                    return this.readU32();\n                  default: {\n                    if (headByte < 160) {\n                      return headByte - 144;\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                  }\n                }\n              };\n              Decoder2.prototype.pushMapState = function(size) {\n                if (size > this.maxMapLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n                }\n                this.stack.push({\n                  type: 1,\n                  size,\n                  key: null,\n                  readCount: 0,\n                  map: {}\n                });\n              };\n              Decoder2.prototype.pushArrayState = function(size) {\n                if (size > this.maxArrayLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n                }\n                this.stack.push({\n                  type: 0,\n                  size,\n                  array: new Array(size),\n                  position: 0\n                });\n              };\n              Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                var _a;\n                if (byteLength > this.maxStrLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n                }\n                if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headerOffset;\n                var object;\n                if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                  object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n                } else {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n                }\n                this.pos += headerOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.stateIsMapKey = function() {\n                if (this.stack.length > 0) {\n                  var state = this.stack[this.stack.length - 1];\n                  return state.type === 1;\n                }\n                return false;\n              };\n              Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                if (byteLength > this.maxBinLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n                }\n                if (!this.hasRemaining(byteLength + headOffset)) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headOffset;\n                var object = this.bytes.subarray(offset, offset + byteLength);\n                this.pos += headOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                if (size > this.maxExtLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n                }\n                var extType = this.view.getInt8(this.pos + headOffset);\n                var data = this.decodeBinary(\n                  size,\n                  headOffset + 1\n                  /* extType */\n                );\n                return this.extensionCodec.decode(data, extType, this.context);\n              };\n              Decoder2.prototype.lookU8 = function() {\n                return this.view.getUint8(this.pos);\n              };\n              Decoder2.prototype.lookU16 = function() {\n                return this.view.getUint16(this.pos);\n              };\n              Decoder2.prototype.lookU32 = function() {\n                return this.view.getUint32(this.pos);\n              };\n              Decoder2.prototype.readU8 = function() {\n                var value = this.view.getUint8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readI8 = function() {\n                var value = this.view.getInt8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readU16 = function() {\n                var value = this.view.getUint16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readI16 = function() {\n                var value = this.view.getInt16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readU32 = function() {\n                var value = this.view.getUint32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readI32 = function() {\n                var value = this.view.getInt32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readU64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readI64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readF32 = function() {\n                var value = this.view.getFloat32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readF64 = function() {\n                var value = this.view.getFloat64(this.pos);\n                this.pos += 8;\n                return value;\n              };\n              return Decoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_MAX_DEPTH\", function() {\n            return DEFAULT_MAX_DEPTH;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() {\n            return DEFAULT_INITIAL_BUFFER_SIZE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var DEFAULT_MAX_DEPTH = 100;\n          var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n          var Encoder = (\n            /** @class */\n            function() {\n              function Encoder2(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxDepth === void 0) {\n                  maxDepth = DEFAULT_MAX_DEPTH;\n                }\n                if (initialBufferSize === void 0) {\n                  initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                }\n                if (sortKeys === void 0) {\n                  sortKeys = false;\n                }\n                if (forceFloat32 === void 0) {\n                  forceFloat32 = false;\n                }\n                if (ignoreUndefined === void 0) {\n                  ignoreUndefined = false;\n                }\n                if (forceIntegerToFloat === void 0) {\n                  forceIntegerToFloat = false;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxDepth = maxDepth;\n                this.initialBufferSize = initialBufferSize;\n                this.sortKeys = sortKeys;\n                this.forceFloat32 = forceFloat32;\n                this.ignoreUndefined = ignoreUndefined;\n                this.forceIntegerToFloat = forceIntegerToFloat;\n                this.pos = 0;\n                this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                this.bytes = new Uint8Array(this.view.buffer);\n              }\n              Encoder2.prototype.getUint8Array = function() {\n                return this.bytes.subarray(0, this.pos);\n              };\n              Encoder2.prototype.reinitializeState = function() {\n                this.pos = 0;\n              };\n              Encoder2.prototype.encode = function(object) {\n                this.reinitializeState();\n                this.doEncode(object, 1);\n                return this.getUint8Array();\n              };\n              Encoder2.prototype.doEncode = function(object, depth) {\n                if (depth > this.maxDepth) {\n                  throw new Error(\"Too deep objects in depth \" + depth);\n                }\n                if (object == null) {\n                  this.encodeNil();\n                } else if (typeof object === \"boolean\") {\n                  this.encodeBoolean(object);\n                } else if (typeof object === \"number\") {\n                  this.encodeNumber(object);\n                } else if (typeof object === \"string\") {\n                  this.encodeString(object);\n                } else {\n                  this.encodeObject(object, depth);\n                }\n              };\n              Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                var requiredSize = this.pos + sizeToWrite;\n                if (this.view.byteLength < requiredSize) {\n                  this.resizeBuffer(requiredSize * 2);\n                }\n              };\n              Encoder2.prototype.resizeBuffer = function(newSize) {\n                var newBuffer = new ArrayBuffer(newSize);\n                var newBytes = new Uint8Array(newBuffer);\n                var newView = new DataView(newBuffer);\n                newBytes.set(this.bytes);\n                this.view = newView;\n                this.bytes = newBytes;\n              };\n              Encoder2.prototype.encodeNil = function() {\n                this.writeU8(192);\n              };\n              Encoder2.prototype.encodeBoolean = function(object) {\n                if (object === false) {\n                  this.writeU8(194);\n                } else {\n                  this.writeU8(195);\n                }\n              };\n              Encoder2.prototype.encodeNumber = function(object) {\n                if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                  if (object >= 0) {\n                    if (object < 128) {\n                      this.writeU8(object);\n                    } else if (object < 256) {\n                      this.writeU8(204);\n                      this.writeU8(object);\n                    } else if (object < 65536) {\n                      this.writeU8(205);\n                      this.writeU16(object);\n                    } else if (object < 4294967296) {\n                      this.writeU8(206);\n                      this.writeU32(object);\n                    } else {\n                      this.writeU8(207);\n                      this.writeU64(object);\n                    }\n                  } else {\n                    if (object >= -32) {\n                      this.writeU8(224 | object + 32);\n                    } else if (object >= -128) {\n                      this.writeU8(208);\n                      this.writeI8(object);\n                    } else if (object >= -32768) {\n                      this.writeU8(209);\n                      this.writeI16(object);\n                    } else if (object >= -2147483648) {\n                      this.writeU8(210);\n                      this.writeI32(object);\n                    } else {\n                      this.writeU8(211);\n                      this.writeI64(object);\n                    }\n                  }\n                } else {\n                  if (this.forceFloat32) {\n                    this.writeU8(202);\n                    this.writeF32(object);\n                  } else {\n                    this.writeU8(203);\n                    this.writeF64(object);\n                  }\n                }\n              };\n              Encoder2.prototype.writeStringHeader = function(byteLength) {\n                if (byteLength < 32) {\n                  this.writeU8(160 + byteLength);\n                } else if (byteLength < 256) {\n                  this.writeU8(217);\n                  this.writeU8(byteLength);\n                } else if (byteLength < 65536) {\n                  this.writeU8(218);\n                  this.writeU16(byteLength);\n                } else if (byteLength < 4294967296) {\n                  this.writeU8(219);\n                  this.writeU32(byteLength);\n                } else {\n                  throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n                }\n              };\n              Encoder2.prototype.encodeString = function(object) {\n                var maxHeaderSize = 1 + 4;\n                var strLength = object.length;\n                if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                } else {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                }\n              };\n              Encoder2.prototype.encodeObject = function(object, depth) {\n                var ext = this.extensionCodec.tryToEncode(object, this.context);\n                if (ext != null) {\n                  this.encodeExtension(ext);\n                } else if (Array.isArray(object)) {\n                  this.encodeArray(object, depth);\n                } else if (ArrayBuffer.isView(object)) {\n                  this.encodeBinary(object);\n                } else if (typeof object === \"object\") {\n                  this.encodeMap(object, depth);\n                } else {\n                  throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n                }\n              };\n              Encoder2.prototype.encodeBinary = function(object) {\n                var size = object.byteLength;\n                if (size < 256) {\n                  this.writeU8(196);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(197);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(198);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large binary: \" + size);\n                }\n                var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n                this.writeU8a(bytes);\n              };\n              Encoder2.prototype.encodeArray = function(object, depth) {\n                var size = object.length;\n                if (size < 16) {\n                  this.writeU8(144 + size);\n                } else if (size < 65536) {\n                  this.writeU8(220);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(221);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large array: \" + size);\n                }\n                for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                  var item = object_1[_i];\n                  this.doEncode(item, depth + 1);\n                }\n              };\n              Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                var count = 0;\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                  var key = keys_1[_i];\n                  if (object[key] !== void 0) {\n                    count++;\n                  }\n                }\n                return count;\n              };\n              Encoder2.prototype.encodeMap = function(object, depth) {\n                var keys = Object.keys(object);\n                if (this.sortKeys) {\n                  keys.sort();\n                }\n                var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                if (size < 16) {\n                  this.writeU8(128 + size);\n                } else if (size < 65536) {\n                  this.writeU8(222);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(223);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large map object: \" + size);\n                }\n                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                  var key = keys_2[_i];\n                  var value = object[key];\n                  if (!(this.ignoreUndefined && value === void 0)) {\n                    this.encodeString(key);\n                    this.doEncode(value, depth + 1);\n                  }\n                }\n              };\n              Encoder2.prototype.encodeExtension = function(ext) {\n                var size = ext.data.length;\n                if (size === 1) {\n                  this.writeU8(212);\n                } else if (size === 2) {\n                  this.writeU8(213);\n                } else if (size === 4) {\n                  this.writeU8(214);\n                } else if (size === 8) {\n                  this.writeU8(215);\n                } else if (size === 16) {\n                  this.writeU8(216);\n                } else if (size < 256) {\n                  this.writeU8(199);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(200);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(201);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large extension object: \" + size);\n                }\n                this.writeI8(ext.type);\n                this.writeU8a(ext.data);\n              };\n              Encoder2.prototype.writeU8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setUint8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU8a = function(values) {\n                var size = values.length;\n                this.ensureBufferSizeToWrite(size);\n                this.bytes.set(values, this.pos);\n                this.pos += size;\n              };\n              Encoder2.prototype.writeI8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setInt8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setUint16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeI16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setInt16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeU32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setUint32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeI32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setInt32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setFloat32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                this.view.setFloat64(this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeU64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeI64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              return Encoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: ExtData */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return ExtData;\n          });\n          var ExtData = (\n            /** @class */\n            function() {\n              function ExtData2(type, data) {\n                this.type = type;\n                this.data = data;\n              }\n              return ExtData2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n          \\***********************************************************************/\n        /*! exports provided: ExtensionCodec */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return ExtensionCodec;\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          var ExtensionCodec = (\n            /** @class */\n            function() {\n              function ExtensionCodec2() {\n                this.builtInEncoders = [];\n                this.builtInDecoders = [];\n                this.encoders = [];\n                this.decoders = [];\n                this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n              }\n              ExtensionCodec2.prototype.register = function(_a) {\n                var type = _a.type, encode = _a.encode, decode = _a.decode;\n                if (type >= 0) {\n                  this.encoders[type] = encode;\n                  this.decoders[type] = decode;\n                } else {\n                  var index = 1 + type;\n                  this.builtInEncoders[index] = encode;\n                  this.builtInDecoders[index] = decode;\n                }\n              };\n              ExtensionCodec2.prototype.tryToEncode = function(object, context) {\n                for (var i = 0; i < this.builtInEncoders.length; i++) {\n                  var encodeExt = this.builtInEncoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = -1 - i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                for (var i = 0; i < this.encoders.length; i++) {\n                  var encodeExt = this.encoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n                  return object;\n                }\n                return null;\n              };\n              ExtensionCodec2.prototype.decode = function(data, type, context) {\n                var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n                if (decodeExt) {\n                  return decodeExt(data, type, context);\n                } else {\n                  return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n              };\n              ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n              return ExtensionCodec2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"defaultDecodeOptions\", function() {\n            return defaultDecodeOptions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return decodeMulti;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var defaultDecodeOptions = {};\n          function decode(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decode(buffer);\n          }\n          function decodeMulti(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeMulti(buffer);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return decodeAsync;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return decodeArrayStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return decodeMultiStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return decodeStream;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/stream.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\"\n          );\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          function decodeAsync(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return __awaiter(this, void 0, void 0, function() {\n              var stream, decoder;\n              return __generator(this, function(_a) {\n                stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n                decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n                return [2, decoder.decodeAsync(stream)];\n              });\n            });\n          }\n          function decodeArrayStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeArrayStream(stream);\n          }\n          function decodeMultiStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeStream(stream);\n          }\n          function decodeStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return decodeMultiStream(streamLike, options);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: encode */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          var defaultEncodeOptions = {};\n          function encode(value, options) {\n            if (options === void 0) {\n              options = defaultEncodeOptions;\n            }\n            var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n            return encoder.encode(value);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n          \\**************************************************************/\n        /*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"];\n          });\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"];\n          });\n          var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decodeAsync.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"];\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"];\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"];\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"];\n          });\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"];\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"];\n          });\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"];\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return EXT_TIMESTAMP;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return encodeTimeSpecToTimestamp;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return encodeDateToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return encodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return decodeTimestampToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return decodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"timestampExtension\", function() {\n            return timestampExtension;\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var EXT_TIMESTAMP = -1;\n          var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n          var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n          function encodeTimeSpecToTimestamp(_a) {\n            var sec = _a.sec, nsec = _a.nsec;\n            if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n              if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                var rv = new Uint8Array(4);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, sec);\n                return rv;\n              } else {\n                var secHigh = sec / 4294967296;\n                var secLow = sec & 4294967295;\n                var rv = new Uint8Array(8);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec << 2 | secHigh & 3);\n                view.setUint32(4, secLow);\n                return rv;\n              }\n            } else {\n              var rv = new Uint8Array(12);\n              var view = new DataView(rv.buffer);\n              view.setUint32(0, nsec);\n              Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n              return rv;\n            }\n          }\n          function encodeDateToTimeSpec(date) {\n            var msec = date.getTime();\n            var sec = Math.floor(msec / 1e3);\n            var nsec = (msec - sec * 1e3) * 1e6;\n            var nsecInSec = Math.floor(nsec / 1e9);\n            return {\n              sec: sec + nsecInSec,\n              nsec: nsec - nsecInSec * 1e9\n            };\n          }\n          function encodeTimestampExtension(object) {\n            if (object instanceof Date) {\n              var timeSpec = encodeDateToTimeSpec(object);\n              return encodeTimeSpecToTimestamp(timeSpec);\n            } else {\n              return null;\n            }\n          }\n          function decodeTimestampToTimeSpec(data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            switch (data.byteLength) {\n              case 4: {\n                var sec = view.getUint32(0);\n                var nsec = 0;\n                return { sec, nsec };\n              }\n              case 8: {\n                var nsec30AndSecHigh2 = view.getUint32(0);\n                var secLow32 = view.getUint32(4);\n                var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                var nsec = nsec30AndSecHigh2 >>> 2;\n                return { sec, nsec };\n              }\n              case 12: {\n                var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n                var nsec = view.getUint32(0);\n                return { sec, nsec };\n              }\n              default:\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n            }\n          }\n          function decodeTimestampExtension(data) {\n            var timeSpec = decodeTimestampToTimeSpec(data);\n            return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n          }\n          var timestampExtension = {\n            type: EXT_TIMESTAMP,\n            encode: encodeTimestampExtension,\n            decode: decodeTimestampExtension\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"UINT32_MAX\", function() {\n            return UINT32_MAX;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setUint64\", function() {\n            return setUint64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setInt64\", function() {\n            return setInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getInt64\", function() {\n            return getInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getUint64\", function() {\n            return getUint64;\n          });\n          var UINT32_MAX = 4294967295;\n          function setUint64(view, offset, value) {\n            var high = value / 4294967296;\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function setInt64(view, offset, value) {\n            var high = Math.floor(value / 4294967296);\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function getInt64(view, offset) {\n            var high = view.getInt32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n          function getUint64(view, offset) {\n            var high = view.getUint32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: prettyByte */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"prettyByte\", function() {\n            return prettyByte;\n          });\n          function prettyByte(byte) {\n            return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n          \\*********************************************************************/\n        /*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isAsyncIterable\", function() {\n            return isAsyncIterable;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"asyncIterableFromStream\", function() {\n            return asyncIterableFromStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ensureAsyncIterable\", function() {\n            return ensureAsyncIterable;\n          });\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          function isAsyncIterable(object) {\n            return object[Symbol.asyncIterator] != null;\n          }\n          function assertNonNull(value) {\n            if (value == null) {\n              throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n            }\n          }\n          function asyncIterableFromStream(stream) {\n            return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n              var reader, _a, done, value;\n              return __generator(this, function(_b) {\n                switch (_b.label) {\n                  case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                  case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                  case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done)\n                      return [3, 5];\n                    return [4, __await(void 0)];\n                  case 4:\n                    return [2, _b.sent()];\n                  case 5:\n                    assertNonNull(value);\n                    return [4, __await(value)];\n                  case 6:\n                    return [4, _b.sent()];\n                  case 7:\n                    _b.sent();\n                    return [3, 2];\n                  case 8:\n                    return [3, 10];\n                  case 9:\n                    reader.releaseLock();\n                    return [\n                      7\n                      /*endfinally*/\n                    ];\n                  case 10:\n                    return [\n                      2\n                      /*return*/\n                    ];\n                }\n              });\n            });\n          }\n          function ensureAsyncIterable(streamLike) {\n            if (isAsyncIterable(streamLike)) {\n              return streamLike;\n            } else {\n              return asyncIterableFromStream(streamLike);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n        /*!**************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n          \\**************************************************************************/\n        /*! exports provided: ensureUint8Array, createDataView */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ensureUint8Array\", function() {\n            return ensureUint8Array;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"createDataView\", function() {\n            return createDataView;\n          });\n          function ensureUint8Array(buffer) {\n            if (buffer instanceof Uint8Array) {\n              return buffer;\n            } else if (ArrayBuffer.isView(buffer)) {\n              return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            } else if (buffer instanceof ArrayBuffer) {\n              return new Uint8Array(buffer);\n            } else {\n              return Uint8Array.from(buffer);\n            }\n          }\n          function createDataView(buffer) {\n            if (buffer instanceof ArrayBuffer) {\n              return new DataView(buffer);\n            }\n            var bufferView = ensureUint8Array(buffer);\n            return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n          \\*******************************************************************/\n        /*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"utf8Count\", function() {\n            return utf8Count;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeJs\", function() {\n            return utf8EncodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_ENCODER_THRESHOLD\", function() {\n            return TEXT_ENCODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeTE\", function() {\n            return utf8EncodeTE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeJs\", function() {\n            return utf8DecodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_DECODER_THRESHOLD\", function() {\n            return TEXT_DECODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeTD\", function() {\n            return utf8DecodeTD;\n          });\n          var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n          function utf8Count(str) {\n            var strLength = str.length;\n            var byteLength = 0;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                byteLength++;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                byteLength += 2;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  byteLength += 3;\n                } else {\n                  byteLength += 4;\n                }\n              }\n            }\n            return byteLength;\n          }\n          function utf8EncodeJs(str, output, outputOffset) {\n            var strLength = str.length;\n            var offset = outputOffset;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                output[offset++] = value;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                output[offset++] = value >> 6 & 31 | 192;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  output[offset++] = value >> 12 & 15 | 224;\n                  output[offset++] = value >> 6 & 63 | 128;\n                } else {\n                  output[offset++] = value >> 18 & 7 | 240;\n                  output[offset++] = value >> 12 & 63 | 128;\n                  output[offset++] = value >> 6 & 63 | 128;\n                }\n              }\n              output[offset++] = value & 63 | 128;\n            }\n          }\n          var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n          var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\" ? 200 : 0;\n          function utf8EncodeTEencode(str, output, outputOffset) {\n            output.set(sharedTextEncoder.encode(str), outputOffset);\n          }\n          function utf8EncodeTEencodeInto(str, output, outputOffset) {\n            sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n          }\n          var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n          var CHUNK_SIZE = 4096;\n          function utf8DecodeJs(bytes, inputOffset, byteLength) {\n            var offset = inputOffset;\n            var end = offset + byteLength;\n            var units = [];\n            var result = \"\";\n            while (offset < end) {\n              var byte1 = bytes[offset++];\n              if ((byte1 & 128) === 0) {\n                units.push(byte1);\n              } else if ((byte1 & 224) === 192) {\n                var byte2 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 6 | byte2);\n              } else if ((byte1 & 240) === 224) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n              } else if ((byte1 & 248) === 240) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                var byte4 = bytes[offset++] & 63;\n                var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                if (unit > 65535) {\n                  unit -= 65536;\n                  units.push(unit >>> 10 & 1023 | 55296);\n                  unit = 56320 | unit & 1023;\n                }\n                units.push(unit);\n              } else {\n                units.push(byte1);\n              }\n              if (units.length >= CHUNK_SIZE) {\n                result += String.fromCharCode.apply(String, units);\n                units.length = 0;\n              }\n            }\n            if (units.length > 0) {\n              result += String.fromCharCode.apply(String, units);\n            }\n            return result;\n          }\n          var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n          var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\" ? 200 : 0;\n          function utf8DecodeTD(bytes, inputOffset, byteLength) {\n            var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n            return sharedTextDecoder.decode(stringBytes);\n          }\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/hypha/rpc.js\": (\n        /*!**************************!*\\\n          !*** ./src/hypha/rpc.js ***!\n          \\**************************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @msgpack/msgpack */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\"\n          );\n          const API_VERSION = \"0.3.0\";\n          const CHUNK_SIZE = 1024 * 500;\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          function getFunctionInfo(func) {\n            const funcString = func.toString();\n            const nameMatch = funcString.match(/function\\s*(\\w*)/);\n            const name = nameMatch && nameMatch[1] || \"\";\n            const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n            let params = \"\";\n            if (paramsMatch) {\n              params = paramsMatch[1].split(\",\").map((p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n            }\n            let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n            const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n            docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n            const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n            const docstring = docstringBlock || docstringLine;\n            return name && params.length > 0 && {\n              name,\n              sig: params,\n              doc: docstring\n            };\n          }\n          function concatArrayBuffers(buffers) {\n            var buffersLengths = buffers.map(function(b) {\n              return b.byteLength;\n            }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n              return p + c;\n            }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n            buffersLengths.reduce(function(p, c, i) {\n              unit8Arr.set(new Uint8Array(buffers[i]), p);\n              return p + c;\n            }, 0);\n            return unit8Arr.buffer;\n          }\n          class Timer {\n            constructor(timeout, callback, args, label) {\n              this._timeout = timeout;\n              this._callback = callback;\n              this._args = args;\n              this._label = label || \"timer\";\n              this._task = null;\n              this.started = false;\n            }\n            start() {\n              if (this.started) {\n                this.reset();\n              } else {\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            clear() {\n              if (this._task) {\n                clearTimeout(this._task);\n                this._task = null;\n                this.started = false;\n              } else {\n                console.warn(`Clearing a timer (${this._label}) which is not started`);\n              }\n            }\n            reset() {\n              if (this._task) {\n                clearTimeout(this._task);\n              }\n              this._task = setTimeout(() => {\n                this._callback.apply(this, this._args);\n              }, this._timeout * 1e3);\n              this.started = true;\n            }\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, {\n              client_id = null,\n              manager_id = null,\n              default_context = null,\n              name = null,\n              codecs = null,\n              method_timeout = null,\n              max_message_buffer_size = 0,\n              debug = false,\n              workspace = null\n            }) {\n              super(debug);\n              this._codecs = codecs || {};\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n              this._client_id = client_id;\n              this._name = name;\n              this._connection_info = null;\n              this._workspace = null;\n              this._local_workspace = workspace;\n              this.manager_id = manager_id;\n              this.default_context = default_context || {};\n              this._method_annotations = /* @__PURE__ */ new WeakMap();\n              this._manager_service = null;\n              this._max_message_buffer_size = max_message_buffer_size;\n              this._chunk_store = {};\n              this._method_timeout = method_timeout || 30;\n              this._services = {};\n              this._object_store = {\n                services: this._services\n              };\n              if (connection) {\n                this.add_service({\n                  id: \"built-in\",\n                  type: \"built-in\",\n                  name: \"RPC built-in services\",\n                  config: {\n                    require_context: true,\n                    visibility: \"public\"\n                  },\n                  ping: this._ping.bind(this),\n                  get_service: this.get_local_service.bind(this),\n                  register_service: this.register_service.bind(this),\n                  message_cache: {\n                    create: this._create_message.bind(this),\n                    append: this._append_message.bind(this),\n                    process: this._process_message.bind(this),\n                    remove: this._remove_message.bind(this)\n                  }\n                });\n                this.on(\"method\", this._handle_method.bind(this));\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n                this._emit_message = connection.emit_message.bind(connection);\n                connection.on_message(this._on_message.bind(this));\n                this._connection = connection;\n                this._get_connection_info();\n              } else {\n                this._emit_message = function() {\n                  console.log(\"No connection to emit message\");\n                };\n              }\n            }\n            async _get_connection_info() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  this._connection_info = await this._manager_service.get_connection_info();\n                  if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n                    this._local_workspace = this._connection_info.workspace;\n                  }\n                  if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n                    this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n                    const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8;\n                    this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1e3);\n                  }\n                } catch (exp) {\n                  console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n                }\n              }\n            }\n            register_codec(config) {\n              if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n                throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n              } else {\n                if (config.type) {\n                  for (let k of Object.keys(this._codecs)) {\n                    if (this._codecs[k].type === config.type || k === config.name) {\n                      delete this._codecs[k];\n                      console.warn(\"Remove duplicated codec: \" + k);\n                    }\n                  }\n                }\n                this._codecs[config[\"name\"]] = config;\n              }\n            }\n            async _ping(msg, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n              return \"pong\";\n            }\n            async ping(client_id, timeout) {\n              let method = this._generate_remote_method({\n                _rtarget: client_id,\n                _rmethod: \"services.built-in.ping\",\n                _rpromise: true,\n                _rdoc: \"Ping a remote client\",\n                _rsig: \"ping(msg)\"\n              });\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(await method(\"ping\", timeout) == \"pong\");\n            }\n            _create_message(key, heartbeat, overwrite, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              if (!this._object_store[\"message_cache\"]) {\n                this._object_store[\"message_cache\"] = {};\n              }\n              if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n              }\n              this._object_store[\"message_cache\"][key] = [];\n            }\n            _append_message(key, data, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n              cache[key].push(data);\n            }\n            _remove_message(key, context) {\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              delete cache[key];\n            }\n            _process_message(key, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              cache[key] = concatArrayBuffers(cache[key]);\n              console.debug(`Processing message ${key} (size=${cache[key].length})`);\n              let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n              const {\n                done,\n                value\n              } = unpacker.next();\n              const main = value;\n              Object.assign(main, {\n                from: context.from,\n                to: context.to,\n                user: context.user\n              });\n              main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n              Object.assign(main[\"ctx\"], this.default_context);\n              if (!done) {\n                let extra = unpacker.next();\n                Object.assign(main, extra.value);\n              }\n              this._fire(main[\"type\"], main);\n              delete cache[key];\n            }\n            _on_message(message) {\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n                let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n                const {\n                  done,\n                  value\n                } = unpacker.next();\n                const main = value;\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n              } catch (error) {\n                console.error(error);\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._services = {};\n            }\n            async disconnect() {\n              if (this._get_connection_info_task) {\n                clearTimeout(this._get_connection_info_task);\n                this._get_connection_info_task = null;\n              }\n              this._fire(\"disconnect\");\n            }\n            async get_manager_service(timeout) {\n              if (this.manager_id && !this._manager_service) {\n                this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n              }\n            }\n            get_all_local_services() {\n              return this._services;\n            }\n            get_local_service(service_id, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n              const [ws, client_id] = context[\"to\"].split(\"/\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n              const service = this._services[service_id];\n              if (!service) {\n                throw new Error(\"Service not found: \" + service_id);\n              }\n              if (service.config.visibility == \"public\") {\n                return service;\n              }\n              if (context[\"from\"].startsWith(ws + \"/\")) {\n                return service;\n              }\n              throw new Error(\"Permission denied for service: \" + service_id);\n            }\n            async get_remote_service(service_uri, timeout) {\n              timeout = timeout === void 0 ? this._method_timeout : timeout;\n              if (!service_uri && this.manager_id) {\n                service_uri = this.manager_id;\n              } else if (!service_uri.includes(\":\")) {\n                service_uri = this._client_id + \":\" + service_uri;\n              }\n              const provider = service_uri.split(\":\")[0];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n              try {\n                const method = this._generate_remote_method({\n                  _rtarget: provider,\n                  _rmethod: \"services.built-in.get_service\",\n                  _rpromise: true,\n                  _rdoc: \"Get a remote service\",\n                  _rsig: \"get_service(service_id)\"\n                });\n                const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n                svc.id = service_uri;\n                return svc;\n              } catch (e) {\n                console.error(\"Failed to get remote service: \" + service_uri, e);\n                throw e;\n              }\n            }\n            _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n              if (typeof aObject === \"function\") {\n                let method_name = object_id.split(\".\")[1];\n                this._method_annotations.set(aObject, {\n                  require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                  run_in_executor,\n                  method_id: \"services.\" + object_id,\n                  visibility\n                });\n              } else if (aObject instanceof Array || aObject instanceof Object) {\n                for (let key of Object.keys(aObject)) {\n                  let val = aObject[key];\n                  if (typeof val === \"function\" && val.__rpc_object__) {\n                    let client_id = val.__rpc_object__._rtarget;\n                    if (client_id.includes(\"/\")) {\n                      client_id = client_id.split(\"/\")[1];\n                    }\n                    if (this._client_id === client_id) {\n                      if (aObject instanceof Array) {\n                        aObject = aObject.slice();\n                      }\n                      aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n                      val = aObject[key];\n                    } else {\n                      throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n                    }\n                  }\n                  this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n                }\n              }\n            }\n            add_service(api, overwrite) {\n              if (!api || Array.isArray(api))\n                throw new Error(\"Invalid service object\");\n              if (api.constructor === Object) {\n                api = Object.assign({}, api);\n              } else {\n                const normApi = {};\n                const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n                for (let k of props) {\n                  if (k !== \"constructor\") {\n                    if (typeof api[k] === \"function\")\n                      normApi[k] = api[k].bind(api);\n                    else\n                      normApi[k] = api[k];\n                  }\n                }\n                api.id = api.id || \"default\";\n                api = normApi;\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n              if (!api.name) {\n                api.name = api.id;\n              }\n              if (!api.config) {\n                api.config = {};\n              }\n              if (!api.type) {\n                api.type = \"generic\";\n              }\n              let require_context = false, run_in_executor = false;\n              if (api.config.require_context)\n                require_context = api.config.require_context;\n              if (api.config.run_in_executor)\n                run_in_executor = true;\n              const visibility = api.config.visibility || \"protected\";\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n              this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n              if (this._services[api.id]) {\n                if (overwrite) {\n                  delete this._services[api.id];\n                } else {\n                  throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n                }\n              }\n              this._services[api.id] = api;\n              return api;\n            }\n            async register_service(api, overwrite, notify, context) {\n              if (notify === void 0)\n                notify = true;\n              if (context) {\n                const [workspace, client_id] = context[\"to\"].split(\"/\");\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n              }\n              const service = this.add_service(api, overwrite);\n              if (notify) {\n                this._fire(\"service-updated\", {\n                  service_id: service[\"id\"],\n                  api: service,\n                  type: \"add\"\n                });\n                await this._notify_service_update();\n              }\n              return {\n                id: `${this._client_id}:${service[\"id\"]}`,\n                type: service[\"type\"],\n                name: service[\"name\"],\n                description: service[\"description\"] || \"\",\n                config: service[\"config\"]\n              };\n            }\n            async unregister_service(service, notify) {\n              if (service instanceof Object) {\n                service = service.id;\n              }\n              if (!this._services[service]) {\n                throw new Error(`Service not found: ${service}`);\n              }\n              const api = this._services[service];\n              delete this._services[service];\n              this._fire(\"service-updated\", {\n                service_id: service,\n                api,\n                type: \"remove\"\n              });\n              await this._notify_service_update();\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n              let method_id = `${session_id}.${name}`;\n              let encoded = {\n                _rtype: \"method\",\n                _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                _rmethod: method_id,\n                _rpromise: false\n              };\n              const self2 = this;\n              let wrapped_callback = function() {\n                try {\n                  callback.apply(null, Array.prototype.slice.call(arguments));\n                } catch (error) {\n                  console.error(\"Error in callback:\", method_id, error);\n                } finally {\n                  if (clear_after_called && self2._object_store[session_id]) {\n                    delete self2._object_store[session_id];\n                  }\n                  if (timer && timer.started) {\n                    timer.clear();\n                  }\n                }\n              };\n              return [encoded, wrapped_callback];\n            }\n            async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n              let store = this._get_session_store(session_id, true);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n              let encoded = {};\n              if (timer && reject && this._method_timeout) {\n                encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n                encoded.interval = this._method_timeout / 2;\n                store.timer = timer;\n              } else {\n                timer = null;\n              }\n              [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n              [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n              return encoded;\n            }\n            async _send_chunks(data, target_id, session_id) {\n              let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n              let message_cache = remote_services.message_cache;\n              let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n              await message_cache.create(message_id, !!session_id);\n              let total_size = data.length;\n              let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n              for (let idx = 0; idx < chunk_num; idx++) {\n                let start_byte = idx * CHUNK_SIZE;\n                await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id);\n              }\n              await message_cache.process(message_id, !!session_id);\n            }\n            emit(main_message, extra_data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n              let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n              if (extra_data) {\n                const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                message_package = new Uint8Array([...message_package, ...extra]);\n              }\n              const total_size = message_package.length;\n              if (total_size <= CHUNK_SIZE + 1024) {\n                return this._emit_message(message_package);\n              } else {\n                throw new Error(\"Message is too large to send in one go.\");\n              }\n            }\n            _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n              let target_id = encoded_method._rtarget;\n              if (remote_workspace && !target_id.includes(\"/\")) {\n                if (remote_workspace !== target_id) {\n                  target_id = remote_workspace + \"/\" + target_id;\n                }\n                encoded_method._rtarget = target_id;\n              }\n              let method_id = encoded_method._rmethod;\n              let with_promise = encoded_method._rpromise;\n              const self2 = this;\n              function remote_method() {\n                return new Promise(async (resolve, reject) => {\n                  let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  if (local_parent) {\n                    local_session_id = local_parent + \".\" + local_session_id;\n                  }\n                  let store = self2._get_session_store(local_session_id, true);\n                  if (!store) {\n                    reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n                    return;\n                  }\n                  store[\"target_id\"] = target_id;\n                  const args = await self2._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  let main_message = {\n                    type: \"method\",\n                    from: self2._local_workspace ? self2._local_workspace + \"/\" + self2._client_id : self2._client_id,\n                    to: target_id,\n                    method: method_id\n                  };\n                  let extra_data = {};\n                  if (args) {\n                    extra_data[\"args\"] = args;\n                  }\n                  if (withKwargs) {\n                    extra_data[\"with_kwargs\"] = withKwargs;\n                  }\n                  if (remote_parent) {\n                    main_message[\"parent\"] = remote_parent;\n                  }\n                  let timer = null;\n                  if (with_promise) {\n                    main_message[\"session\"] = local_session_id;\n                    let method_name = `${target_id}:${method_id}`;\n                    timer = new Timer(self2._method_timeout, reject, [`Method call time out: ${method_name}`], method_name);\n                    let clear_after_called = true;\n                    for (let arg of args) {\n                      if (typeof arg === \"object\" && arg._rintf === true) {\n                        clear_after_called = false;\n                        break;\n                      }\n                    }\n                    extra_data[\"promise\"] = await self2._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n                  }\n                  let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n                  if (extra_data) {\n                    const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                    message_package = new Uint8Array([...message_package, ...extra]);\n                  }\n                  const total_size = message_package.length;\n                  if (total_size <= CHUNK_SIZE + 1024) {\n                    self2._emit_message(message_package).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  } else {\n                    self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  }\n                });\n              }\n              remote_method.__rpc_object__ = encoded_method;\n              const parts = method_id.split(\".\");\n              remote_method.__name__ = parts[parts.length - 1];\n              remote_method.__doc__ = encoded_method._rdoc;\n              remote_method.__sig__ = encoded_method._rsig;\n              return remote_method;\n            }\n            async _notify_service_update() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  await this._manager_service.update_client_info(this.get_client_info());\n                } catch (exp) {\n                  console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n                }\n              }\n            }\n            get_client_info() {\n              const services = [];\n              for (let service of Object.values(this._services)) {\n                services.push({\n                  id: `${this._client_id}:${service[\"id\"]}`,\n                  type: service[\"type\"],\n                  name: service[\"name\"],\n                  description: service[\"description\"] || \"\",\n                  config: service[\"config\"]\n                });\n              }\n              return {\n                id: this._client_id,\n                services\n              };\n            }\n            async _handle_method(data) {\n              let reject = null;\n              let heartbeat_task = null;\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n                const method_name = data.from + \":\" + data.method;\n                const remote_workspace = data.from.split(\"/\")[0];\n                data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                data[\"ctx\"][\"to\"] = data[\"to\"];\n                const local_workspace = data.to.split(\"/\")[0];\n                const local_parent = data.parent;\n                let resolve, reject2;\n                if (data.promise) {\n                  const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n                  resolve = promise.resolve;\n                  reject2 = promise.reject;\n                  if (promise.heartbeat && promise.interval) {\n                    async function heartbeat() {\n                      try {\n                        await promise.heartbeat();\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                    heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                  }\n                }\n                let method;\n                try {\n                  method = indexObject(this._object_store, data[\"method\"]);\n                } catch (e) {\n                  console.debug(\"Failed to find method\", method_name, e);\n                  throw new Error(`Method not found: ${method_name}`);\n                }\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name);\n                if (this._method_annotations.has(method)) {\n                  if (this._method_annotations.get(method).visibility === \"protected\") {\n                    if (local_workspace !== remote_workspace) {\n                      throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n                    }\n                  }\n                } else {\n                  let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                  if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                    session_target_id = local_workspace + \"/\" + session_target_id;\n                  }\n                  if (session_target_id !== data.from) {\n                    throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n                  }\n                }\n                if (local_parent) {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n                }\n                let args;\n                if (data.args) {\n                  args = await this._decode(data.args, data.session, null, remote_workspace, null);\n                } else {\n                  args = [];\n                }\n                if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                  args.push(data.ctx);\n                }\n                if (data.promise) {\n                  const result = method.apply(null, args);\n                  if (result instanceof Promise) {\n                    result.then((result2) => {\n                      resolve(result2);\n                      clearInterval(heartbeat_task);\n                    }).catch((err) => {\n                      reject2(err);\n                      clearInterval(heartbeat_task);\n                    });\n                  } else {\n                    resolve(result);\n                    clearInterval(heartbeat_task);\n                  }\n                } else {\n                  method.apply(null, args);\n                  clearInterval(heartbeat_task);\n                }\n              } catch (err) {\n                if (reject) {\n                  reject(err);\n                  console.debug(\"Error during calling method: \", err);\n                } else {\n                  console.error(\"Error during calling method: \", err);\n                }\n                clearInterval(heartbeat_task);\n              }\n            }\n            encode(aObject, session_id) {\n              return this._encode(aObject, session_id);\n            }\n            _get_session_store(session_id, create) {\n              let store = this._object_store;\n              const levels = session_id.split(\".\");\n              if (create) {\n                const last_index = levels.length - 1;\n                for (let level of levels.slice(0, last_index)) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                if (!store[levels[last_index]]) {\n                  store[levels[last_index]] = {};\n                }\n                return store[levels[last_index]];\n              } else {\n                for (let level of levels) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                return store;\n              }\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, session_id, local_workspace) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                return aObject;\n              }\n              if (aObject instanceof ArrayBuffer) {\n                return {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject)\n                };\n              }\n              if (aObject.__rpc_object__) {\n                return aObject.__rpc_object__;\n              }\n              let bObject;\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                const temp = aObject._rtype;\n                delete aObject._rtype;\n                bObject = await this._encode(aObject, session_id, local_workspace);\n                bObject._rtype = temp;\n                return bObject;\n              }\n              if (typeof aObject === \"function\") {\n                if (this._method_annotations.has(aObject)) {\n                  let annotation = this._method_annotations.get(aObject);\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: annotation.method_id,\n                    _rpromise: true\n                  };\n                } else {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n                  let object_id;\n                  if (aObject.__name__) {\n                    object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n                  } else {\n                    object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  }\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: true\n                  };\n                  let store = this._get_session_store(session_id, true);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n                  store[object_id] = aObject;\n                }\n                bObject._rdoc = aObject.__doc__;\n                bObject._rsig = aObject.__sig__;\n                if (!bObject._rdoc || !bObject._rsig) {\n                  try {\n                    const funcInfo = getFunctionInfo(aObject);\n                    if (funcInfo && !bObject._rdoc) {\n                      bObject._rdoc = `${funcInfo.doc}`;\n                    }\n                    if (funcInfo && !bObject._rsig) {\n                      bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n                    }\n                  } catch (e) {\n                    console.error(\"Failed to extract function docstring:\", aObject);\n                  }\n                }\n                return bObject;\n              }\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (typeof encodedObj === \"object\") {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(v_buffer.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString(),\n                  _rtrace: aObject.stack\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (aObject instanceof Blob) {\n                let seek = function(pos) {\n                  _current_pos = pos;\n                };\n                let _current_pos = 0;\n                async function read(length) {\n                  let blob;\n                  if (length) {\n                    blob = aObject.slice(_current_pos, _current_pos + length);\n                  } else {\n                    blob = aObject.slice(_current_pos);\n                  }\n                  const ret = new Uint8Array(await blob.arrayBuffer());\n                  _current_pos = _current_pos + ret.byteLength;\n                  return ret;\n                }\n                bObject = {\n                  _rtype: \"iostream\",\n                  _rnative: \"js:blob\",\n                  type: aObject.type,\n                  name: aObject.name,\n                  size: aObject.size,\n                  path: aObject._path || aObject.webkitRelativePath,\n                  read: await this._encode(read, session_id, local_workspace),\n                  seek: await this._encode(seek, session_id, local_workspace)\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: new Uint8Array(aObject.buffer),\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject.buffer)\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                const keys = Object.keys(aObject);\n                for (let k of keys) {\n                  bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n                }\n              } else {\n                throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async decode(aObject) {\n              return await this._decode(aObject);\n            }\n            async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject._rtype) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  aObject._rtype = temp;\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"method\") {\n                  bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                  bObject = new arraytype(buffer);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                } else if (aObject._rtype === \"iostream\") {\n                  if (aObject._rnative === \"js:blob\") {\n                    const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n                    const bytes = await read();\n                    bObject = new Blob([bytes], {\n                      type: aObject.type,\n                      name: aObject.name\n                    });\n                  } else {\n                    bObject = {};\n                    for (let k of Object.keys(aObject)) {\n                      if (!k.startsWith(\"_\")) {\n                        bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n                      }\n                    }\n                  }\n                  bObject[\"__rpc_object__\"] = aObject;\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  bObject._rtype = temp;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              return bObject;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/sse-client.js\": (\n        /*!*********************************!*\\\n          !*** ./src/hypha/sse-client.js ***!\n          \\*********************************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, getRTCService, registerRTCService, login, connectToServer */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"login\", function() {\n            return login;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"connectToServer\", function() {\n            return connectToServer;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"API_VERSION\"];\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"loadRequirements\"];\n          });\n          var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./webrtc-client.js */\n            \"./src/hypha/webrtc-client.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"getRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"registerRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ../../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_3__[\"version\"];\n          });\n          function b64toArrayBuffer(base64, type = \"application/octet-stream\") {\n            return fetch(`data:${type};base64,${base64}`).then((res) => res.arrayBuffer());\n          }\n          class SSERPCConnection {\n            constructor(server_url, client_id, workspace, token, timeout = 120) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(server_url && client_id, \"server_url and client_id are required\");\n              server_url = server_url + \"?client_id=\" + client_id;\n              if (workspace) {\n                server_url += \"&workspace=\" + workspace;\n              }\n              if (token) {\n                server_url += \"&token=\" + token;\n              }\n              server_url += \"&session_id=\" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n              this._events = null;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._server_url = server_url;\n              this._timeout = timeout * 1e3;\n              this._opening = false;\n              this._retry_count = 0;\n              this._closing = false;\n            }\n            set_reconnection_token(token) {\n              this._reconnection_token = token;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            open() {\n              if (this._opening)\n                return this._opening;\n              this._opening = new Promise((resolve, reject) => {\n                const server_url = this._reconnection_token ? `${this._server_url}&reconnection_token=${this._reconnection_token}` : this._server_url;\n                console.info(\"Creating a new connection to \", server_url.split(\"?\")[0]);\n                this._events = new EventSource(server_url);\n                this._events.onmessage = async (event) => {\n                  const data = await b64toArrayBuffer(event.data);\n                  this._handle_message(data);\n                };\n                this._events.onclose = (event) => {\n                  console.log(\"eventsource closed\");\n                  if (!this._closing) {\n                    console.log(\"Connection interrupted, retrying...\");\n                    this._retry_count++;\n                    setTimeout(() => this.open(), this._timeout);\n                  }\n                  this._events = null;\n                  this._opening = false;\n                  reject(\"closed\");\n                };\n                this._events.onerror = (event) => {\n                  console.trace();\n                  console.log(\"Error occurred in eventsource connection: \", event.message);\n                  debugger;\n                  reject(event.toString());\n                };\n                this._events.onopen = (event) => {\n                  resolve(true);\n                };\n              });\n              return this._opening;\n            }\n            async _send(data) {\n              await fetch(this._server_url, {\n                method: \"POST\",\n                mode: \"cors\",\n                // no-cors, *cors, same-origin\n                cache: \"no-cache\",\n                // *default, no-cache, reload, force-cache, only-if-cached\n                credentials: \"same-origin\",\n                // include, *same-origin, omit\n                headers: {\n                  \"Content-Type\": \"octet-stream\"\n                  // 'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                redirect: \"follow\",\n                // manual, *follow, error\n                referrerPolicy: \"no-referrer\",\n                // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n                body: data\n                // body data type must match \"Content-Type\" header\n              });\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n              if (!this._events || this._events.readyState === EventSource.CLOSED) {\n                await this.open();\n              }\n              await this._send(data);\n            }\n            disconnect(reason) {\n              this._closing = true;\n              const ev = this._events;\n              this._events = null;\n              if (ev && ev.readyState === EventSource.OPEN) {\n                ev.close();\n              }\n              console.info(`EventSource connection disconnected (${reason})`);\n            }\n          }\n          function normalizeServerUrl(server_url) {\n            if (!server_url)\n              throw new Error(\"server_url is required\");\n            server_url = server_url.replace(/\\/$/, \"\") + \"/sse\";\n            return server_url;\n          }\n          async function login(config) {\n            const service_id = config.login_service_id || \"public/*:hypha-login\";\n            const timeout = config.login_timeout || 120;\n            const callback = config.login_callback;\n            const server = await connectToServer({\n              name: \"initial login client\",\n              server_url: config.server_url,\n              method_timeout: timeout\n            });\n            try {\n              const svc = await server.get_service(service_id);\n              const context = await svc.start();\n              if (callback) {\n                await callback(context);\n              } else {\n                console.log(`Please open your browser and login at ${context.login_url}`);\n              }\n              return await svc.check(context.key, timeout);\n            } catch (error) {\n              throw error;\n            } finally {\n              await server.disconnect();\n            }\n          }\n          async function connectToServer(config) {\n            let clientId = config.client_id;\n            if (!clientId) {\n              clientId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n            }\n            let server_url = normalizeServerUrl(config.server_url);\n            let connection = new SSERPCConnection(server_url, clientId, config.workspace, config.token, config.method_timeout || 120);\n            await connection.open();\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: \"workspace-manager\",\n              default_context: {\n                connection_type: \"eventsource\"\n              },\n              name: config.name,\n              method_timeout: config.method_timeout\n            });\n            const wm = await rpc.get_remote_service(\"workspace-manager:default\", config.method_timeout);\n            wm.rpc = rpc;\n            async function _export(api) {\n              api.id = \"default\";\n              api.name = config.name || api.id;\n              await rpc.register_service(api, true);\n            }\n            async function getPlugin(query) {\n              return await wm.get_service(query + \":default\");\n            }\n            async function disconnect() {\n              await rpc.disconnect();\n              await connection.disconnect();\n            }\n            wm.export = _export;\n            wm.getPlugin = getPlugin;\n            wm.listPlugins = wm.listServices;\n            wm.disconnect = disconnect;\n            wm.registerCodec = rpc.register_codec.bind(rpc);\n            if (config.webrtc) {\n              await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"])(wm, clientId + \"-rtc\", config.webrtc_config);\n            }\n            if (wm.get_service || wm.getService) {\n              const _get_service = wm.get_service || wm.getService;\n              wm.get_service = async function(query, webrtc, webrtc_config) {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])([void 0, true, false, \"auto\"].includes(webrtc), \"webrtc must be true, false or 'auto'\");\n                const svc = await _get_service(query);\n                if (webrtc === true || webrtc === \"auto\") {\n                  if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n                    const client = svc.id.split(\":\")[0];\n                    try {\n                      const peer = await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"])(wm, client + \":\" + client.split(\"/\")[1] + \"-rtc\", webrtc_config);\n                      const rtcSvc = await peer.get_service(svc.id.split(\":\")[1]);\n                      rtcSvc._webrtc = true;\n                      rtcSvc._peer = peer;\n                      rtcSvc._service = svc;\n                      return rtcSvc;\n                    } catch (e) {\n                      console.warn(\"Failed to get webrtc service, using eventsource connection\", e);\n                    }\n                  }\n                  if (webrtc === true) {\n                    throw new Error(\"Failed to get the service via webrtc\");\n                  }\n                }\n                return svc;\n              };\n              wm.getService = wm.get_service;\n            }\n            return wm;\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/utils.js\": (\n        /*!****************************!*\\\n          !*** ./src/hypha/utils.js ***!\n          \\****************************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_179193__) {\n          \"use strict\";\n          __nested_webpack_require_179193__.r(__nested_webpack_exports__);\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"assert\", function() {\n            return assert;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"waitFor\", function() {\n            return waitFor;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message || \"Assertion failed\");\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          function waitFor(prom, time, error) {\n            let timer;\n            return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n              rej(error || \"Timeout Error\");\n            }, time * 1e3))]).finally(() => clearTimeout(timer));\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/webrtc-client.js\": (\n        /*!************************************!*\\\n          !*** ./src/hypha/webrtc-client.js ***!\n          \\************************************/\n        /*! exports provided: getRTCService, registerRTCService */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"getRTCService\", function() {\n            return getRTCService;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"registerRTCService\", function() {\n            return registerRTCService;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          class WebRTCConnection {\n            constructor(channel) {\n              this._data_channel = channel;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._data_channel.onmessage = async (event) => {\n                let data = event.data;\n                if (data instanceof Blob) {\n                  data = await data.arrayBuffer();\n                }\n                this._handle_message(data);\n              };\n              const self2 = this;\n              this._data_channel.onclose = function() {\n                console.log(\"websocket closed\");\n                self2._data_channel = null;\n              };\n            }\n            set_reconnection_token(token) {\n              this._reconnection_token = token;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n              try {\n                this._data_channel.send(data);\n              } catch (exp) {\n                console.error(`Failed to send data, error: ${exp}`);\n                throw exp;\n              }\n            }\n            async disconnect(reason) {\n              this._data_channel = null;\n              console.info(`data channel connection disconnected (${reason})`);\n            }\n          }\n          async function _setupRPC(config) {\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.channel, \"No channel provided\");\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.workspace, \"No workspace provided\");\n            const channel = config.channel;\n            const clientId = config.client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n            const connection = new WebRTCConnection(channel);\n            config.context = config.context || {};\n            config.context.connection_type = \"webrtc\";\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: null,\n              default_context: config.context,\n              name: config.name,\n              method_timeout: config.method_timeout || 10,\n              workspace: config.workspace\n            });\n            return rpc;\n          }\n          async function _createOffer(params, server, config, onInit, context) {\n            config = config || {};\n            let offer = new RTCSessionDescription({\n              sdp: params.sdp,\n              type: params.type\n            });\n            let pc = new RTCPeerConnection({\n              iceServers: config.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            if (server) {\n              pc.addEventListener(\"datachannel\", async (event) => {\n                const channel = event.channel;\n                let ctx = null;\n                if (context && context.user)\n                  ctx = {\n                    user: context.user\n                  };\n                const rpc = await _setupRPC({\n                  channel,\n                  client_id: channel.label,\n                  workspace: server.config.workspace,\n                  context: ctx\n                });\n                rpc._services = server.rpc._services;\n              });\n            }\n            if (onInit) {\n              await onInit(pc);\n            }\n            await pc.setRemoteDescription(offer);\n            let answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            return {\n              sdp: pc.localDescription.sdp,\n              type: pc.localDescription.type,\n              workspace: server.config.workspace\n            };\n          }\n          async function getRTCService(server, service_id, config) {\n            config = config || {};\n            config.peer_id = config.peer_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n            const pc = new RTCPeerConnection({\n              iceServers: config.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            return new Promise(async (resolve, reject) => {\n              try {\n                pc.addEventListener(\"connectionstatechange\", () => {\n                  if (pc.connectionState === \"failed\") {\n                    pc.close();\n                    reject(new Error(\"Connection failed\"));\n                  }\n                }, false);\n                if (config.on_init) {\n                  await config.on_init(pc);\n                  delete config.on_init;\n                }\n                let channel = pc.createDataChannel(config.peer_id, {\n                  ordered: true\n                });\n                channel.binaryType = \"arraybuffer\";\n                const offer = await pc.createOffer();\n                await pc.setLocalDescription(offer);\n                const svc = await server.getService(service_id);\n                const answer = await svc.offer({\n                  sdp: pc.localDescription.sdp,\n                  type: pc.localDescription.type\n                });\n                channel.onopen = () => {\n                  config.channel = channel;\n                  config.workspace = answer.workspace;\n                  setTimeout(async () => {\n                    const rpc = await _setupRPC(config);\n                    pc.rpc = rpc;\n                    async function getService(name) {\n                      return await rpc.get_remote_service(config.peer_id + \":\" + name);\n                    }\n                    async function disconnect() {\n                      await rpc.disconnect();\n                      pc.close();\n                    }\n                    pc.get_service = getService;\n                    pc.getService = getService;\n                    pc.disconnect = disconnect;\n                    pc.register_codec = rpc.register_codec;\n                    pc.registerCodec = rpc.register_codec;\n                    resolve(pc);\n                  }, 500);\n                };\n                channel.onclose = () => reject(new Error(\"Data channel closed\"));\n                await pc.setRemoteDescription(new RTCSessionDescription({\n                  sdp: answer.sdp,\n                  type: answer.type\n                }));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          }\n          async function registerRTCService(server, service_id, config) {\n            config = config || {\n              visibility: \"protected\",\n              require_context: true\n            };\n            const onInit = config.on_init;\n            delete config.on_init;\n            await server.registerService({\n              id: service_id,\n              config,\n              offer: (params, context) => _createOffer(params, server, config, onInit, context)\n            });\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name2, getter) {\n        if (!__webpack_require__2.o(exports2, name2)) {\n          Object.defineProperty(exports2, name2, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/hypha/websocket-client.js\");\n    }({\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: CachedKeyDecoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"CachedKeyDecoder\", function() {\n            return CachedKeyDecoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var DEFAULT_MAX_KEY_LENGTH = 16;\n          var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n          var CachedKeyDecoder = (\n            /** @class */\n            function() {\n              function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                if (maxKeyLength === void 0) {\n                  maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                }\n                if (maxLengthPerKey === void 0) {\n                  maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                }\n                this.maxKeyLength = maxKeyLength;\n                this.maxLengthPerKey = maxLengthPerKey;\n                this.hit = 0;\n                this.miss = 0;\n                this.caches = [];\n                for (var i = 0; i < this.maxKeyLength; i++) {\n                  this.caches.push([]);\n                }\n              }\n              CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                return byteLength > 0 && byteLength <= this.maxKeyLength;\n              };\n              CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                var records = this.caches[byteLength - 1];\n                FIND_CHUNK:\n                  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                    var record = records_1[_i];\n                    var recordBytes = record.bytes;\n                    for (var j = 0; j < byteLength; j++) {\n                      if (recordBytes[j] !== bytes[inputOffset + j]) {\n                        continue FIND_CHUNK;\n                      }\n                    }\n                    return record.str;\n                  }\n                return null;\n              };\n              CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                var records = this.caches[bytes.length - 1];\n                var record = { bytes, str: value };\n                if (records.length >= this.maxLengthPerKey) {\n                  records[Math.random() * records.length | 0] = record;\n                } else {\n                  records.push(record);\n                }\n              };\n              CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                var cachedValue = this.find(bytes, inputOffset, byteLength);\n                if (cachedValue != null) {\n                  this.hit++;\n                  return cachedValue;\n                }\n                this.miss++;\n                var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n                var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                this.store(slicedCopyOfBytes, str);\n                return str;\n              };\n              return CachedKeyDecoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: DecodeError */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return DecodeError;\n          });\n          var __extends = function() {\n            var extendStatics = function(d, b) {\n              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                d2.__proto__ = b2;\n              } || function(d2, b2) {\n                for (var p in b2)\n                  if (Object.prototype.hasOwnProperty.call(b2, p))\n                    d2[p] = b2[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function(d, b) {\n              if (typeof b !== \"function\" && b !== null)\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          var DecodeError = (\n            /** @class */\n            function(_super) {\n              __extends(DecodeError2, _super);\n              function DecodeError2(message) {\n                var _this = _super.call(this, message) || this;\n                var proto = Object.create(DecodeError2.prototype);\n                Object.setPrototypeOf(_this, proto);\n                Object.defineProperty(_this, \"name\", {\n                  configurable: true,\n                  enumerable: false,\n                  value: DecodeError2.name\n                });\n                return _this;\n              }\n              return DecodeError2;\n            }(Error)\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return DataViewIndexOutOfBoundsError;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/prettyByte.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./CachedKeyDecoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n          );\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve2) {\n                resolve2(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve2, reject2) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __asyncValues = function(o) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i);\n            function verb(n) {\n              i[n] = o[n] && function(v) {\n                return new Promise(function(resolve2, reject2) {\n                  v = o[n](v), settle(resolve2, reject2, v.done, v.value);\n                });\n              };\n            }\n            function settle(resolve2, reject2, d, v) {\n              Promise.resolve(v).then(function(v2) {\n                resolve2({ value: v2, done: d });\n              }, reject2);\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject2(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          var isValidMapKeyType = function(key) {\n            var keyType = typeof key;\n            return keyType === \"string\" || keyType === \"number\";\n          };\n          var HEAD_BYTE_REQUIRED = -1;\n          var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n          var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n          var DataViewIndexOutOfBoundsError = function() {\n            try {\n              EMPTY_VIEW.getInt8(0);\n            } catch (e) {\n              return e.constructor;\n            }\n            throw new Error(\"never reached\");\n          }();\n          var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n          var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\n          var Decoder = (\n            /** @class */\n            function() {\n              function Decoder2(extensionCodec, context2, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context2 === void 0) {\n                  context2 = void 0;\n                }\n                if (maxStrLength === void 0) {\n                  maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxBinLength === void 0) {\n                  maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxArrayLength === void 0) {\n                  maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxMapLength === void 0) {\n                  maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxExtLength === void 0) {\n                  maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (keyDecoder === void 0) {\n                  keyDecoder = sharedCachedKeyDecoder;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context2;\n                this.maxStrLength = maxStrLength;\n                this.maxBinLength = maxBinLength;\n                this.maxArrayLength = maxArrayLength;\n                this.maxMapLength = maxMapLength;\n                this.maxExtLength = maxExtLength;\n                this.keyDecoder = keyDecoder;\n                this.totalPos = 0;\n                this.pos = 0;\n                this.view = EMPTY_VIEW;\n                this.bytes = EMPTY_BYTES;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack = [];\n              }\n              Decoder2.prototype.reinitializeState = function() {\n                this.totalPos = 0;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack.length = 0;\n              };\n              Decoder2.prototype.setBuffer = function(buffer) {\n                this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n                this.pos = 0;\n              };\n              Decoder2.prototype.appendBuffer = function(buffer) {\n                if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                  this.setBuffer(buffer);\n                } else {\n                  var remainingData = this.bytes.subarray(this.pos);\n                  var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                  var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                  newBuffer.set(remainingData);\n                  newBuffer.set(newData, remainingData.length);\n                  this.setBuffer(newBuffer);\n                }\n              };\n              Decoder2.prototype.hasRemaining = function(size) {\n                return this.view.byteLength - this.pos >= size;\n              };\n              Decoder2.prototype.createExtraByteError = function(posToShow) {\n                var _a = this, view = _a.view, pos = _a.pos;\n                return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n              };\n              Decoder2.prototype.decode = function(buffer) {\n                this.reinitializeState();\n                this.setBuffer(buffer);\n                var object = this.doDecodeSync();\n                if (this.hasRemaining(1)) {\n                  throw this.createExtraByteError(this.pos);\n                }\n                return object;\n              };\n              Decoder2.prototype.decodeMulti = function(buffer) {\n                return __generator(this, function(_a) {\n                  switch (_a.label) {\n                    case 0:\n                      this.reinitializeState();\n                      this.setBuffer(buffer);\n                      _a.label = 1;\n                    case 1:\n                      if (!this.hasRemaining(1))\n                        return [3, 3];\n                      return [4, this.doDecodeSync()];\n                    case 2:\n                      _a.sent();\n                      return [3, 1];\n                    case 3:\n                      return [\n                        2\n                        /*return*/\n                      ];\n                  }\n                });\n              };\n              Decoder2.prototype.decodeAsync = function(stream) {\n                var stream_1, stream_1_1;\n                var e_1, _a;\n                return __awaiter(this, void 0, void 0, function() {\n                  var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                  return __generator(this, function(_c) {\n                    switch (_c.label) {\n                      case 0:\n                        decoded = false;\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                      case 2:\n                        return [4, stream_1.next()];\n                      case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                          return [3, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                          object = this.doDecodeSync();\n                          decoded = true;\n                        } catch (e) {\n                          if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e;\n                          }\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                      case 4:\n                        return [3, 2];\n                      case 5:\n                        return [3, 12];\n                      case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3, 12];\n                      case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                          return [3, 9];\n                        return [4, _a.call(stream_1)];\n                      case 8:\n                        _c.sent();\n                        _c.label = 9;\n                      case 9:\n                        return [3, 11];\n                      case 10:\n                        if (e_1)\n                          throw e_1.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 11:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 12:\n                        if (decoded) {\n                          if (this.hasRemaining(1)) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          return [2, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.decodeArrayStream = function(stream) {\n                return this.decodeMultiAsync(stream, true);\n              };\n              Decoder2.prototype.decodeStream = function(stream) {\n                return this.decodeMultiAsync(stream, false);\n              };\n              Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                  var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                  var e_3, _a;\n                  return __generator(this, function(_b) {\n                    switch (_b.label) {\n                      case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                      case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                      case 2:\n                        return [4, __await(stream_2.next())];\n                      case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                          return [3, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                          arrayItemsLeft = this.readArraySize();\n                          isArrayHeaderRequired = false;\n                          this.complete();\n                        }\n                        _b.label = 4;\n                      case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                      case 5:\n                        if (false) {}\n                        return [4, __await(this.doDecodeSync())];\n                      case 6:\n                        return [4, _b.sent()];\n                      case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                          return [3, 8];\n                        }\n                        return [3, 5];\n                      case 8:\n                        return [3, 10];\n                      case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                          throw e_2;\n                        }\n                        return [3, 10];\n                      case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                      case 11:\n                        return [3, 2];\n                      case 12:\n                        return [3, 19];\n                      case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3, 19];\n                      case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                          return [3, 16];\n                        return [4, __await(_a.call(stream_2))];\n                      case 15:\n                        _b.sent();\n                        _b.label = 16;\n                      case 16:\n                        return [3, 18];\n                      case 17:\n                        if (e_3)\n                          throw e_3.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 18:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 19:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.doDecodeSync = function() {\n                DECODE:\n                  while (true) {\n                    var headByte = this.readHeadByte();\n                    var object = void 0;\n                    if (headByte >= 224) {\n                      object = headByte - 256;\n                    } else if (headByte < 192) {\n                      if (headByte < 128) {\n                        object = headByte;\n                      } else if (headByte < 144) {\n                        var size = headByte - 128;\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte < 160) {\n                        var size = headByte - 144;\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else {\n                        var byteLength = headByte - 160;\n                        object = this.decodeUtf8String(byteLength, 0);\n                      }\n                    } else if (headByte === 192) {\n                      object = null;\n                    } else if (headByte === 194) {\n                      object = false;\n                    } else if (headByte === 195) {\n                      object = true;\n                    } else if (headByte === 202) {\n                      object = this.readF32();\n                    } else if (headByte === 203) {\n                      object = this.readF64();\n                    } else if (headByte === 204) {\n                      object = this.readU8();\n                    } else if (headByte === 205) {\n                      object = this.readU16();\n                    } else if (headByte === 206) {\n                      object = this.readU32();\n                    } else if (headByte === 207) {\n                      object = this.readU64();\n                    } else if (headByte === 208) {\n                      object = this.readI8();\n                    } else if (headByte === 209) {\n                      object = this.readI16();\n                    } else if (headByte === 210) {\n                      object = this.readI32();\n                    } else if (headByte === 211) {\n                      object = this.readI64();\n                    } else if (headByte === 217) {\n                      var byteLength = this.lookU8();\n                      object = this.decodeUtf8String(byteLength, 1);\n                    } else if (headByte === 218) {\n                      var byteLength = this.lookU16();\n                      object = this.decodeUtf8String(byteLength, 2);\n                    } else if (headByte === 219) {\n                      var byteLength = this.lookU32();\n                      object = this.decodeUtf8String(byteLength, 4);\n                    } else if (headByte === 220) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 221) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 222) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 223) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 196) {\n                      var size = this.lookU8();\n                      object = this.decodeBinary(size, 1);\n                    } else if (headByte === 197) {\n                      var size = this.lookU16();\n                      object = this.decodeBinary(size, 2);\n                    } else if (headByte === 198) {\n                      var size = this.lookU32();\n                      object = this.decodeBinary(size, 4);\n                    } else if (headByte === 212) {\n                      object = this.decodeExtension(1, 0);\n                    } else if (headByte === 213) {\n                      object = this.decodeExtension(2, 0);\n                    } else if (headByte === 214) {\n                      object = this.decodeExtension(4, 0);\n                    } else if (headByte === 215) {\n                      object = this.decodeExtension(8, 0);\n                    } else if (headByte === 216) {\n                      object = this.decodeExtension(16, 0);\n                    } else if (headByte === 199) {\n                      var size = this.lookU8();\n                      object = this.decodeExtension(size, 1);\n                    } else if (headByte === 200) {\n                      var size = this.lookU16();\n                      object = this.decodeExtension(size, 2);\n                    } else if (headByte === 201) {\n                      var size = this.lookU32();\n                      object = this.decodeExtension(size, 4);\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                    this.complete();\n                    var stack = this.stack;\n                    while (stack.length > 0) {\n                      var state = stack[stack.length - 1];\n                      if (state.type === 0) {\n                        state.array[state.position] = object;\n                        state.position++;\n                        if (state.position === state.size) {\n                          stack.pop();\n                          object = state.array;\n                        } else {\n                          continue DECODE;\n                        }\n                      } else if (state.type === 1) {\n                        if (!isValidMapKeyType(object)) {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                        }\n                        if (object === \"__proto__\") {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                        }\n                        state.key = object;\n                        state.type = 2;\n                        continue DECODE;\n                      } else {\n                        state.map[state.key] = object;\n                        state.readCount++;\n                        if (state.readCount === state.size) {\n                          stack.pop();\n                          object = state.map;\n                        } else {\n                          state.key = null;\n                          state.type = 1;\n                          continue DECODE;\n                        }\n                      }\n                    }\n                    return object;\n                  }\n              };\n              Decoder2.prototype.readHeadByte = function() {\n                if (this.headByte === HEAD_BYTE_REQUIRED) {\n                  this.headByte = this.readU8();\n                }\n                return this.headByte;\n              };\n              Decoder2.prototype.complete = function() {\n                this.headByte = HEAD_BYTE_REQUIRED;\n              };\n              Decoder2.prototype.readArraySize = function() {\n                var headByte = this.readHeadByte();\n                switch (headByte) {\n                  case 220:\n                    return this.readU16();\n                  case 221:\n                    return this.readU32();\n                  default: {\n                    if (headByte < 160) {\n                      return headByte - 144;\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                  }\n                }\n              };\n              Decoder2.prototype.pushMapState = function(size) {\n                if (size > this.maxMapLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n                }\n                this.stack.push({\n                  type: 1,\n                  size,\n                  key: null,\n                  readCount: 0,\n                  map: {}\n                });\n              };\n              Decoder2.prototype.pushArrayState = function(size) {\n                if (size > this.maxArrayLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n                }\n                this.stack.push({\n                  type: 0,\n                  size,\n                  array: new Array(size),\n                  position: 0\n                });\n              };\n              Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                var _a;\n                if (byteLength > this.maxStrLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n                }\n                if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headerOffset;\n                var object;\n                if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                  object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n                } else {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n                }\n                this.pos += headerOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.stateIsMapKey = function() {\n                if (this.stack.length > 0) {\n                  var state = this.stack[this.stack.length - 1];\n                  return state.type === 1;\n                }\n                return false;\n              };\n              Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                if (byteLength > this.maxBinLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n                }\n                if (!this.hasRemaining(byteLength + headOffset)) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headOffset;\n                var object = this.bytes.subarray(offset, offset + byteLength);\n                this.pos += headOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                if (size > this.maxExtLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n                }\n                var extType = this.view.getInt8(this.pos + headOffset);\n                var data = this.decodeBinary(\n                  size,\n                  headOffset + 1\n                  /* extType */\n                );\n                return this.extensionCodec.decode(data, extType, this.context);\n              };\n              Decoder2.prototype.lookU8 = function() {\n                return this.view.getUint8(this.pos);\n              };\n              Decoder2.prototype.lookU16 = function() {\n                return this.view.getUint16(this.pos);\n              };\n              Decoder2.prototype.lookU32 = function() {\n                return this.view.getUint32(this.pos);\n              };\n              Decoder2.prototype.readU8 = function() {\n                var value = this.view.getUint8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readI8 = function() {\n                var value = this.view.getInt8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readU16 = function() {\n                var value = this.view.getUint16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readI16 = function() {\n                var value = this.view.getInt16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readU32 = function() {\n                var value = this.view.getUint32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readI32 = function() {\n                var value = this.view.getInt32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readU64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readI64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readF32 = function() {\n                var value = this.view.getFloat32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readF64 = function() {\n                var value = this.view.getFloat64(this.pos);\n                this.pos += 8;\n                return value;\n              };\n              return Decoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_MAX_DEPTH\", function() {\n            return DEFAULT_MAX_DEPTH;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() {\n            return DEFAULT_INITIAL_BUFFER_SIZE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var DEFAULT_MAX_DEPTH = 100;\n          var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n          var Encoder = (\n            /** @class */\n            function() {\n              function Encoder2(extensionCodec, context2, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context2 === void 0) {\n                  context2 = void 0;\n                }\n                if (maxDepth === void 0) {\n                  maxDepth = DEFAULT_MAX_DEPTH;\n                }\n                if (initialBufferSize === void 0) {\n                  initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                }\n                if (sortKeys === void 0) {\n                  sortKeys = false;\n                }\n                if (forceFloat32 === void 0) {\n                  forceFloat32 = false;\n                }\n                if (ignoreUndefined === void 0) {\n                  ignoreUndefined = false;\n                }\n                if (forceIntegerToFloat === void 0) {\n                  forceIntegerToFloat = false;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context2;\n                this.maxDepth = maxDepth;\n                this.initialBufferSize = initialBufferSize;\n                this.sortKeys = sortKeys;\n                this.forceFloat32 = forceFloat32;\n                this.ignoreUndefined = ignoreUndefined;\n                this.forceIntegerToFloat = forceIntegerToFloat;\n                this.pos = 0;\n                this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                this.bytes = new Uint8Array(this.view.buffer);\n              }\n              Encoder2.prototype.getUint8Array = function() {\n                return this.bytes.subarray(0, this.pos);\n              };\n              Encoder2.prototype.reinitializeState = function() {\n                this.pos = 0;\n              };\n              Encoder2.prototype.encode = function(object) {\n                this.reinitializeState();\n                this.doEncode(object, 1);\n                return this.getUint8Array();\n              };\n              Encoder2.prototype.doEncode = function(object, depth) {\n                if (depth > this.maxDepth) {\n                  throw new Error(\"Too deep objects in depth \" + depth);\n                }\n                if (object == null) {\n                  this.encodeNil();\n                } else if (typeof object === \"boolean\") {\n                  this.encodeBoolean(object);\n                } else if (typeof object === \"number\") {\n                  this.encodeNumber(object);\n                } else if (typeof object === \"string\") {\n                  this.encodeString(object);\n                } else {\n                  this.encodeObject(object, depth);\n                }\n              };\n              Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                var requiredSize = this.pos + sizeToWrite;\n                if (this.view.byteLength < requiredSize) {\n                  this.resizeBuffer(requiredSize * 2);\n                }\n              };\n              Encoder2.prototype.resizeBuffer = function(newSize) {\n                var newBuffer = new ArrayBuffer(newSize);\n                var newBytes = new Uint8Array(newBuffer);\n                var newView = new DataView(newBuffer);\n                newBytes.set(this.bytes);\n                this.view = newView;\n                this.bytes = newBytes;\n              };\n              Encoder2.prototype.encodeNil = function() {\n                this.writeU8(192);\n              };\n              Encoder2.prototype.encodeBoolean = function(object) {\n                if (object === false) {\n                  this.writeU8(194);\n                } else {\n                  this.writeU8(195);\n                }\n              };\n              Encoder2.prototype.encodeNumber = function(object) {\n                if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                  if (object >= 0) {\n                    if (object < 128) {\n                      this.writeU8(object);\n                    } else if (object < 256) {\n                      this.writeU8(204);\n                      this.writeU8(object);\n                    } else if (object < 65536) {\n                      this.writeU8(205);\n                      this.writeU16(object);\n                    } else if (object < 4294967296) {\n                      this.writeU8(206);\n                      this.writeU32(object);\n                    } else {\n                      this.writeU8(207);\n                      this.writeU64(object);\n                    }\n                  } else {\n                    if (object >= -32) {\n                      this.writeU8(224 | object + 32);\n                    } else if (object >= -128) {\n                      this.writeU8(208);\n                      this.writeI8(object);\n                    } else if (object >= -32768) {\n                      this.writeU8(209);\n                      this.writeI16(object);\n                    } else if (object >= -2147483648) {\n                      this.writeU8(210);\n                      this.writeI32(object);\n                    } else {\n                      this.writeU8(211);\n                      this.writeI64(object);\n                    }\n                  }\n                } else {\n                  if (this.forceFloat32) {\n                    this.writeU8(202);\n                    this.writeF32(object);\n                  } else {\n                    this.writeU8(203);\n                    this.writeF64(object);\n                  }\n                }\n              };\n              Encoder2.prototype.writeStringHeader = function(byteLength) {\n                if (byteLength < 32) {\n                  this.writeU8(160 + byteLength);\n                } else if (byteLength < 256) {\n                  this.writeU8(217);\n                  this.writeU8(byteLength);\n                } else if (byteLength < 65536) {\n                  this.writeU8(218);\n                  this.writeU16(byteLength);\n                } else if (byteLength < 4294967296) {\n                  this.writeU8(219);\n                  this.writeU32(byteLength);\n                } else {\n                  throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n                }\n              };\n              Encoder2.prototype.encodeString = function(object) {\n                var maxHeaderSize = 1 + 4;\n                var strLength = object.length;\n                if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                } else {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                }\n              };\n              Encoder2.prototype.encodeObject = function(object, depth) {\n                var ext = this.extensionCodec.tryToEncode(object, this.context);\n                if (ext != null) {\n                  this.encodeExtension(ext);\n                } else if (Array.isArray(object)) {\n                  this.encodeArray(object, depth);\n                } else if (ArrayBuffer.isView(object)) {\n                  this.encodeBinary(object);\n                } else if (typeof object === \"object\") {\n                  this.encodeMap(object, depth);\n                } else {\n                  throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n                }\n              };\n              Encoder2.prototype.encodeBinary = function(object) {\n                var size = object.byteLength;\n                if (size < 256) {\n                  this.writeU8(196);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(197);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(198);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large binary: \" + size);\n                }\n                var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n                this.writeU8a(bytes);\n              };\n              Encoder2.prototype.encodeArray = function(object, depth) {\n                var size = object.length;\n                if (size < 16) {\n                  this.writeU8(144 + size);\n                } else if (size < 65536) {\n                  this.writeU8(220);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(221);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large array: \" + size);\n                }\n                for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                  var item = object_1[_i];\n                  this.doEncode(item, depth + 1);\n                }\n              };\n              Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                var count = 0;\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                  var key = keys_1[_i];\n                  if (object[key] !== void 0) {\n                    count++;\n                  }\n                }\n                return count;\n              };\n              Encoder2.prototype.encodeMap = function(object, depth) {\n                var keys = Object.keys(object);\n                if (this.sortKeys) {\n                  keys.sort();\n                }\n                var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                if (size < 16) {\n                  this.writeU8(128 + size);\n                } else if (size < 65536) {\n                  this.writeU8(222);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(223);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large map object: \" + size);\n                }\n                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                  var key = keys_2[_i];\n                  var value = object[key];\n                  if (!(this.ignoreUndefined && value === void 0)) {\n                    this.encodeString(key);\n                    this.doEncode(value, depth + 1);\n                  }\n                }\n              };\n              Encoder2.prototype.encodeExtension = function(ext) {\n                var size = ext.data.length;\n                if (size === 1) {\n                  this.writeU8(212);\n                } else if (size === 2) {\n                  this.writeU8(213);\n                } else if (size === 4) {\n                  this.writeU8(214);\n                } else if (size === 8) {\n                  this.writeU8(215);\n                } else if (size === 16) {\n                  this.writeU8(216);\n                } else if (size < 256) {\n                  this.writeU8(199);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(200);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(201);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large extension object: \" + size);\n                }\n                this.writeI8(ext.type);\n                this.writeU8a(ext.data);\n              };\n              Encoder2.prototype.writeU8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setUint8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU8a = function(values) {\n                var size = values.length;\n                this.ensureBufferSizeToWrite(size);\n                this.bytes.set(values, this.pos);\n                this.pos += size;\n              };\n              Encoder2.prototype.writeI8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setInt8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setUint16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeI16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setInt16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeU32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setUint32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeI32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setInt32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setFloat32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                this.view.setFloat64(this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeU64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeI64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              return Encoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: ExtData */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return ExtData;\n          });\n          var ExtData = (\n            /** @class */\n            function() {\n              function ExtData2(type2, data) {\n                this.type = type2;\n                this.data = data;\n              }\n              return ExtData2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n          \\***********************************************************************/\n        /*! exports provided: ExtensionCodec */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return ExtensionCodec;\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          var ExtensionCodec = (\n            /** @class */\n            function() {\n              function ExtensionCodec2() {\n                this.builtInEncoders = [];\n                this.builtInDecoders = [];\n                this.encoders = [];\n                this.decoders = [];\n                this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n              }\n              ExtensionCodec2.prototype.register = function(_a) {\n                var type2 = _a.type, encode = _a.encode, decode = _a.decode;\n                if (type2 >= 0) {\n                  this.encoders[type2] = encode;\n                  this.decoders[type2] = decode;\n                } else {\n                  var index = 1 + type2;\n                  this.builtInEncoders[index] = encode;\n                  this.builtInDecoders[index] = decode;\n                }\n              };\n              ExtensionCodec2.prototype.tryToEncode = function(object, context2) {\n                for (var i = 0; i < this.builtInEncoders.length; i++) {\n                  var encodeExt = this.builtInEncoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context2);\n                    if (data != null) {\n                      var type2 = -1 - i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type2, data);\n                    }\n                  }\n                }\n                for (var i = 0; i < this.encoders.length; i++) {\n                  var encodeExt = this.encoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context2);\n                    if (data != null) {\n                      var type2 = i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type2, data);\n                    }\n                  }\n                }\n                if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n                  return object;\n                }\n                return null;\n              };\n              ExtensionCodec2.prototype.decode = function(data, type2, context2) {\n                var decodeExt = type2 < 0 ? this.builtInDecoders[-1 - type2] : this.decoders[type2];\n                if (decodeExt) {\n                  return decodeExt(data, type2, context2);\n                } else {\n                  return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type2, data);\n                }\n              };\n              ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n              return ExtensionCodec2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"defaultDecodeOptions\", function() {\n            return defaultDecodeOptions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return decodeMulti;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var defaultDecodeOptions = {};\n          function decode(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decode(buffer);\n          }\n          function decodeMulti(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeMulti(buffer);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return decodeAsync;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return decodeArrayStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return decodeMultiStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return decodeStream;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/stream.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\"\n          );\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve2) {\n                resolve2(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve2, reject2) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          function decodeAsync(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return __awaiter(this, void 0, void 0, function() {\n              var stream, decoder;\n              return __generator(this, function(_a) {\n                stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n                decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n                return [2, decoder.decodeAsync(stream)];\n              });\n            });\n          }\n          function decodeArrayStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeArrayStream(stream);\n          }\n          function decodeMultiStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeStream(stream);\n          }\n          function decodeStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return decodeMultiStream(streamLike, options);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: encode */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          var defaultEncodeOptions = {};\n          function encode(value, options) {\n            if (options === void 0) {\n              options = defaultEncodeOptions;\n            }\n            var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n            return encoder.encode(value);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n          \\**************************************************************/\n        /*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"];\n          });\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"];\n          });\n          var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decodeAsync.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"];\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"];\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"];\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"];\n          });\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"];\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"];\n          });\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"];\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return EXT_TIMESTAMP;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return encodeTimeSpecToTimestamp;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return encodeDateToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return encodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return decodeTimestampToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return decodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"timestampExtension\", function() {\n            return timestampExtension;\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var EXT_TIMESTAMP = -1;\n          var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n          var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n          function encodeTimeSpecToTimestamp(_a) {\n            var sec = _a.sec, nsec = _a.nsec;\n            if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n              if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                var rv = new Uint8Array(4);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, sec);\n                return rv;\n              } else {\n                var secHigh = sec / 4294967296;\n                var secLow = sec & 4294967295;\n                var rv = new Uint8Array(8);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec << 2 | secHigh & 3);\n                view.setUint32(4, secLow);\n                return rv;\n              }\n            } else {\n              var rv = new Uint8Array(12);\n              var view = new DataView(rv.buffer);\n              view.setUint32(0, nsec);\n              Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n              return rv;\n            }\n          }\n          function encodeDateToTimeSpec(date) {\n            var msec = date.getTime();\n            var sec = Math.floor(msec / 1e3);\n            var nsec = (msec - sec * 1e3) * 1e6;\n            var nsecInSec = Math.floor(nsec / 1e9);\n            return {\n              sec: sec + nsecInSec,\n              nsec: nsec - nsecInSec * 1e9\n            };\n          }\n          function encodeTimestampExtension(object) {\n            if (object instanceof Date) {\n              var timeSpec = encodeDateToTimeSpec(object);\n              return encodeTimeSpecToTimestamp(timeSpec);\n            } else {\n              return null;\n            }\n          }\n          function decodeTimestampToTimeSpec(data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            switch (data.byteLength) {\n              case 4: {\n                var sec = view.getUint32(0);\n                var nsec = 0;\n                return { sec, nsec };\n              }\n              case 8: {\n                var nsec30AndSecHigh2 = view.getUint32(0);\n                var secLow32 = view.getUint32(4);\n                var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                var nsec = nsec30AndSecHigh2 >>> 2;\n                return { sec, nsec };\n              }\n              case 12: {\n                var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n                var nsec = view.getUint32(0);\n                return { sec, nsec };\n              }\n              default:\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n            }\n          }\n          function decodeTimestampExtension(data) {\n            var timeSpec = decodeTimestampToTimeSpec(data);\n            return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n          }\n          var timestampExtension = {\n            type: EXT_TIMESTAMP,\n            encode: encodeTimestampExtension,\n            decode: decodeTimestampExtension\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"UINT32_MAX\", function() {\n            return UINT32_MAX;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setUint64\", function() {\n            return setUint64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setInt64\", function() {\n            return setInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getInt64\", function() {\n            return getInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getUint64\", function() {\n            return getUint64;\n          });\n          var UINT32_MAX = 4294967295;\n          function setUint64(view, offset, value) {\n            var high = value / 4294967296;\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function setInt64(view, offset, value) {\n            var high = Math.floor(value / 4294967296);\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function getInt64(view, offset) {\n            var high = view.getInt32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n          function getUint64(view, offset) {\n            var high = view.getUint32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: prettyByte */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"prettyByte\", function() {\n            return prettyByte;\n          });\n          function prettyByte(byte) {\n            return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n          \\*********************************************************************/\n        /*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isAsyncIterable\", function() {\n            return isAsyncIterable;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"asyncIterableFromStream\", function() {\n            return asyncIterableFromStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ensureAsyncIterable\", function() {\n            return ensureAsyncIterable;\n          });\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject2(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          function isAsyncIterable(object) {\n            return object[Symbol.asyncIterator] != null;\n          }\n          function assertNonNull(value) {\n            if (value == null) {\n              throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n            }\n          }\n          function asyncIterableFromStream(stream) {\n            return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n              var reader, _a, done, value;\n              return __generator(this, function(_b) {\n                switch (_b.label) {\n                  case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                  case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                  case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done)\n                      return [3, 5];\n                    return [4, __await(void 0)];\n                  case 4:\n                    return [2, _b.sent()];\n                  case 5:\n                    assertNonNull(value);\n                    return [4, __await(value)];\n                  case 6:\n                    return [4, _b.sent()];\n                  case 7:\n                    _b.sent();\n                    return [3, 2];\n                  case 8:\n                    return [3, 10];\n                  case 9:\n                    reader.releaseLock();\n                    return [\n                      7\n                      /*endfinally*/\n                    ];\n                  case 10:\n                    return [\n                      2\n                      /*return*/\n                    ];\n                }\n              });\n            });\n          }\n          function ensureAsyncIterable(streamLike) {\n            if (isAsyncIterable(streamLike)) {\n              return streamLike;\n            } else {\n              return asyncIterableFromStream(streamLike);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n        /*!**************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n          \\**************************************************************************/\n        /*! exports provided: ensureUint8Array, createDataView */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ensureUint8Array\", function() {\n            return ensureUint8Array;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"createDataView\", function() {\n            return createDataView;\n          });\n          function ensureUint8Array(buffer) {\n            if (buffer instanceof Uint8Array) {\n              return buffer;\n            } else if (ArrayBuffer.isView(buffer)) {\n              return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            } else if (buffer instanceof ArrayBuffer) {\n              return new Uint8Array(buffer);\n            } else {\n              return Uint8Array.from(buffer);\n            }\n          }\n          function createDataView(buffer) {\n            if (buffer instanceof ArrayBuffer) {\n              return new DataView(buffer);\n            }\n            var bufferView = ensureUint8Array(buffer);\n            return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n          \\*******************************************************************/\n        /*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"utf8Count\", function() {\n            return utf8Count;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeJs\", function() {\n            return utf8EncodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_ENCODER_THRESHOLD\", function() {\n            return TEXT_ENCODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeTE\", function() {\n            return utf8EncodeTE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeJs\", function() {\n            return utf8DecodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_DECODER_THRESHOLD\", function() {\n            return TEXT_DECODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeTD\", function() {\n            return utf8DecodeTD;\n          });\n          var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n          function utf8Count(str) {\n            var strLength = str.length;\n            var byteLength = 0;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                byteLength++;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                byteLength += 2;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  byteLength += 3;\n                } else {\n                  byteLength += 4;\n                }\n              }\n            }\n            return byteLength;\n          }\n          function utf8EncodeJs(str, output, outputOffset) {\n            var strLength = str.length;\n            var offset = outputOffset;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                output[offset++] = value;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                output[offset++] = value >> 6 & 31 | 192;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  output[offset++] = value >> 12 & 15 | 224;\n                  output[offset++] = value >> 6 & 63 | 128;\n                } else {\n                  output[offset++] = value >> 18 & 7 | 240;\n                  output[offset++] = value >> 12 & 63 | 128;\n                  output[offset++] = value >> 6 & 63 | 128;\n                }\n              }\n              output[offset++] = value & 63 | 128;\n            }\n          }\n          var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n          var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\" ? 200 : 0;\n          function utf8EncodeTEencode(str, output, outputOffset) {\n            output.set(sharedTextEncoder.encode(str), outputOffset);\n          }\n          function utf8EncodeTEencodeInto(str, output, outputOffset) {\n            sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n          }\n          var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n          var CHUNK_SIZE = 4096;\n          function utf8DecodeJs(bytes, inputOffset, byteLength) {\n            var offset = inputOffset;\n            var end = offset + byteLength;\n            var units = [];\n            var result = \"\";\n            while (offset < end) {\n              var byte1 = bytes[offset++];\n              if ((byte1 & 128) === 0) {\n                units.push(byte1);\n              } else if ((byte1 & 224) === 192) {\n                var byte2 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 6 | byte2);\n              } else if ((byte1 & 240) === 224) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n              } else if ((byte1 & 248) === 240) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                var byte4 = bytes[offset++] & 63;\n                var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                if (unit > 65535) {\n                  unit -= 65536;\n                  units.push(unit >>> 10 & 1023 | 55296);\n                  unit = 56320 | unit & 1023;\n                }\n                units.push(unit);\n              } else {\n                units.push(byte1);\n              }\n              if (units.length >= CHUNK_SIZE) {\n                result += String.fromCharCode.apply(String, units);\n                units.length = 0;\n              }\n            }\n            if (units.length > 0) {\n              result += String.fromCharCode.apply(String, units);\n            }\n            return result;\n          }\n          var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n          var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\" ? 200 : 0;\n          function utf8DecodeTD(bytes, inputOffset, byteLength) {\n            var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n            return sharedTextDecoder.decode(stringBytes);\n          }\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/hypha/rpc.js\": (\n        /*!**************************!*\\\n          !*** ./src/hypha/rpc.js ***!\n          \\**************************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @msgpack/msgpack */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\"\n          );\n          const API_VERSION = \"0.3.0\";\n          const CHUNK_SIZE = 1024 * 500;\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          function getFunctionInfo(func) {\n            const funcString = func.toString();\n            const nameMatch = funcString.match(/function\\s*(\\w*)/);\n            const name2 = nameMatch && nameMatch[1] || \"\";\n            const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n            let params = \"\";\n            if (paramsMatch) {\n              params = paramsMatch[1].split(\",\").map((p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n            }\n            let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n            const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n            docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n            const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n            const docstring = docstringBlock || docstringLine;\n            return name2 && params.length > 0 && {\n              name: name2,\n              sig: params,\n              doc: docstring\n            };\n          }\n          function concatArrayBuffers(buffers) {\n            var buffersLengths = buffers.map(function(b) {\n              return b.byteLength;\n            }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n              return p + c;\n            }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n            buffersLengths.reduce(function(p, c, i) {\n              unit8Arr.set(new Uint8Array(buffers[i]), p);\n              return p + c;\n            }, 0);\n            return unit8Arr.buffer;\n          }\n          class Timer {\n            constructor(timeout, callback, args, label) {\n              this._timeout = timeout;\n              this._callback = callback;\n              this._args = args;\n              this._label = label || \"timer\";\n              this._task = null;\n              this.started = false;\n            }\n            start() {\n              if (this.started) {\n                this.reset();\n              } else {\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            clear() {\n              if (this._task) {\n                clearTimeout(this._task);\n                this._task = null;\n                this.started = false;\n              } else {\n                console.warn(`Clearing a timer (${this._label}) which is not started`);\n              }\n            }\n            reset() {\n              if (this._task) {\n                clearTimeout(this._task);\n              }\n              this._task = setTimeout(() => {\n                this._callback.apply(this, this._args);\n              }, this._timeout * 1e3);\n              this.started = true;\n            }\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, {\n              client_id: client_id2 = null,\n              manager_id = null,\n              default_context = null,\n              name: name2 = null,\n              codecs = null,\n              method_timeout: method_timeout2 = null,\n              max_message_buffer_size = 0,\n              debug = false,\n              workspace: workspace2 = null\n            }) {\n              super(debug);\n              this._codecs = codecs || {};\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2 && typeof client_id2 === \"string\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2, \"client_id is required\");\n              this._client_id = client_id2;\n              this._name = name2;\n              this._connection_info = null;\n              this._workspace = null;\n              this._local_workspace = workspace2;\n              this.manager_id = manager_id;\n              this.default_context = default_context || {};\n              this._method_annotations = /* @__PURE__ */ new WeakMap();\n              this._manager_service = null;\n              this._max_message_buffer_size = max_message_buffer_size;\n              this._chunk_store = {};\n              this._method_timeout = method_timeout2 || 30;\n              this._services = {};\n              this._object_store = {\n                services: this._services\n              };\n              if (connection) {\n                this.add_service({\n                  id: \"built-in\",\n                  type: \"built-in\",\n                  name: \"RPC built-in services\",\n                  config: {\n                    require_context: true,\n                    visibility: \"public\"\n                  },\n                  ping: this._ping.bind(this),\n                  get_service: this.get_local_service.bind(this),\n                  register_service: this.register_service.bind(this),\n                  message_cache: {\n                    create: this._create_message.bind(this),\n                    append: this._append_message.bind(this),\n                    process: this._process_message.bind(this),\n                    remove: this._remove_message.bind(this)\n                  }\n                });\n                this.on(\"method\", this._handle_method.bind(this));\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n                this._emit_message = connection.emit_message.bind(connection);\n                connection.on_message(this._on_message.bind(this));\n                this._connection = connection;\n                this._get_connection_info();\n              } else {\n                this._emit_message = function() {\n                  console.log(\"No connection to emit message\");\n                };\n              }\n            }\n            async _get_connection_info() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  this._connection_info = await this._manager_service.get_connection_info();\n                  if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n                    this._local_workspace = this._connection_info.workspace;\n                  }\n                  if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n                    this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n                    const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8;\n                    this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1e3);\n                  }\n                } catch (exp) {\n                  console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n                }\n              }\n            }\n            register_codec(config2) {\n              if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n              } else {\n                if (config2.type) {\n                  for (let k of Object.keys(this._codecs)) {\n                    if (this._codecs[k].type === config2.type || k === config2.name) {\n                      delete this._codecs[k];\n                      console.warn(\"Remove duplicated codec: \" + k);\n                    }\n                  }\n                }\n                this._codecs[config2[\"name\"]] = config2;\n              }\n            }\n            async _ping(msg, context2) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n              return \"pong\";\n            }\n            async ping(client_id2, timeout) {\n              let method = this._generate_remote_method({\n                _rtarget: client_id2,\n                _rmethod: \"services.built-in.ping\",\n                _rpromise: true,\n                _rdoc: \"Ping a remote client\",\n                _rsig: \"ping(msg)\"\n              });\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(await method(\"ping\", timeout) == \"pong\");\n            }\n            _create_message(key, heartbeat, overwrite, context2) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              if (!this._object_store[\"message_cache\"]) {\n                this._object_store[\"message_cache\"] = {};\n              }\n              if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n              }\n              this._object_store[\"message_cache\"][key] = [];\n            }\n            _append_message(key, data, heartbeat, context2) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n              cache[key].push(data);\n            }\n            _remove_message(key, context2) {\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              delete cache[key];\n            }\n            _process_message(key, heartbeat, context2) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context2, \"Context is required\");\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              cache[key] = concatArrayBuffers(cache[key]);\n              console.debug(`Processing message ${key} (size=${cache[key].length})`);\n              let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n              const {\n                done,\n                value\n              } = unpacker.next();\n              const main = value;\n              Object.assign(main, {\n                from: context2.from,\n                to: context2.to,\n                user: context2.user\n              });\n              main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n              Object.assign(main[\"ctx\"], this.default_context);\n              if (!done) {\n                let extra = unpacker.next();\n                Object.assign(main, extra.value);\n              }\n              this._fire(main[\"type\"], main);\n              delete cache[key];\n            }\n            _on_message(message) {\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n                let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n                const {\n                  done,\n                  value\n                } = unpacker.next();\n                const main = value;\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n              } catch (error) {\n                console.error(error);\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._services = {};\n            }\n            async disconnect() {\n              if (this._get_connection_info_task) {\n                clearTimeout(this._get_connection_info_task);\n                this._get_connection_info_task = null;\n              }\n              this._fire(\"disconnect\");\n            }\n            async get_manager_service(timeout) {\n              if (this.manager_id && !this._manager_service) {\n                this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n              }\n            }\n            get_all_local_services() {\n              return this._services;\n            }\n            get_local_service(service_id, context2) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n              const [ws, client_id2] = context2[\"to\"].split(\"/\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2 === this._client_id, \"Services can only be accessed locally\");\n              const service = this._services[service_id];\n              if (!service) {\n                throw new Error(\"Service not found: \" + service_id);\n              }\n              if (service.config.visibility == \"public\") {\n                return service;\n              }\n              if (context2[\"from\"].startsWith(ws + \"/\")) {\n                return service;\n              }\n              throw new Error(\"Permission denied for service: \" + service_id);\n            }\n            async get_remote_service(service_uri, timeout) {\n              timeout = timeout === void 0 ? this._method_timeout : timeout;\n              if (!service_uri && this.manager_id) {\n                service_uri = this.manager_id;\n              } else if (!service_uri.includes(\":\")) {\n                service_uri = this._client_id + \":\" + service_uri;\n              }\n              const provider = service_uri.split(\":\")[0];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n              try {\n                const method = this._generate_remote_method({\n                  _rtarget: provider,\n                  _rmethod: \"services.built-in.get_service\",\n                  _rpromise: true,\n                  _rdoc: \"Get a remote service\",\n                  _rsig: \"get_service(service_id)\"\n                });\n                const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n                svc.id = service_uri;\n                return svc;\n              } catch (e) {\n                console.error(\"Failed to get remote service: \" + service_uri, e);\n                throw e;\n              }\n            }\n            _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n              if (typeof aObject === \"function\") {\n                let method_name = object_id.split(\".\")[1];\n                this._method_annotations.set(aObject, {\n                  require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                  run_in_executor,\n                  method_id: \"services.\" + object_id,\n                  visibility\n                });\n              } else if (aObject instanceof Array || aObject instanceof Object) {\n                for (let key of Object.keys(aObject)) {\n                  let val = aObject[key];\n                  if (typeof val === \"function\" && val.__rpc_object__) {\n                    let client_id2 = val.__rpc_object__._rtarget;\n                    if (client_id2.includes(\"/\")) {\n                      client_id2 = client_id2.split(\"/\")[1];\n                    }\n                    if (this._client_id === client_id2) {\n                      if (aObject instanceof Array) {\n                        aObject = aObject.slice();\n                      }\n                      aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n                      val = aObject[key];\n                    } else {\n                      throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id2}`);\n                    }\n                  }\n                  this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n                }\n              }\n            }\n            add_service(api, overwrite) {\n              if (!api || Array.isArray(api))\n                throw new Error(\"Invalid service object\");\n              if (api.constructor === Object) {\n                api = Object.assign({}, api);\n              } else {\n                const normApi = {};\n                const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n                for (let k of props) {\n                  if (k !== \"constructor\") {\n                    if (typeof api[k] === \"function\")\n                      normApi[k] = api[k].bind(api);\n                    else\n                      normApi[k] = api[k];\n                  }\n                }\n                api.id = api.id || \"default\";\n                api = normApi;\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n              if (!api.name) {\n                api.name = api.id;\n              }\n              if (!api.config) {\n                api.config = {};\n              }\n              if (!api.type) {\n                api.type = \"generic\";\n              }\n              let require_context = false, run_in_executor = false;\n              if (api.config.require_context)\n                require_context = api.config.require_context;\n              if (api.config.run_in_executor)\n                run_in_executor = true;\n              const visibility = api.config.visibility || \"protected\";\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n              this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n              if (this._services[api.id]) {\n                if (overwrite) {\n                  delete this._services[api.id];\n                } else {\n                  throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n                }\n              }\n              this._services[api.id] = api;\n              return api;\n            }\n            async register_service(api, overwrite, notify, context2) {\n              if (notify === void 0)\n                notify = true;\n              if (context2) {\n                const [workspace2, client_id2] = context2[\"to\"].split(\"/\");\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2 === this._client_id);\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace2 === context2[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n              }\n              const service = this.add_service(api, overwrite);\n              if (notify) {\n                this._fire(\"service-updated\", {\n                  service_id: service[\"id\"],\n                  api: service,\n                  type: \"add\"\n                });\n                await this._notify_service_update();\n              }\n              return {\n                id: `${this._client_id}:${service[\"id\"]}`,\n                type: service[\"type\"],\n                name: service[\"name\"],\n                description: service[\"description\"] || \"\",\n                config: service[\"config\"]\n              };\n            }\n            async unregister_service(service, notify) {\n              if (service instanceof Object) {\n                service = service.id;\n              }\n              if (!this._services[service]) {\n                throw new Error(`Service not found: ${service}`);\n              }\n              const api = this._services[service];\n              delete this._services[service];\n              this._fire(\"service-updated\", {\n                service_id: service,\n                api,\n                type: \"remove\"\n              });\n              await this._notify_service_update();\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            _encode_callback(name2, callback, session_id, clear_after_called, timer, local_workspace) {\n              let method_id = `${session_id}.${name2}`;\n              let encoded = {\n                _rtype: \"method\",\n                _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                _rmethod: method_id,\n                _rpromise: false\n              };\n              const self2 = this;\n              let wrapped_callback = function() {\n                try {\n                  callback.apply(null, Array.prototype.slice.call(arguments));\n                } catch (error) {\n                  console.error(\"Error in callback:\", method_id, error);\n                } finally {\n                  if (clear_after_called && self2._object_store[session_id]) {\n                    delete self2._object_store[session_id];\n                  }\n                  if (timer && timer.started) {\n                    timer.clear();\n                  }\n                }\n              };\n              return [encoded, wrapped_callback];\n            }\n            async _encode_promise(resolve2, reject2, session_id, clear_after_called, timer, local_workspace) {\n              let store = this._get_session_store(session_id, true);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n              let encoded = {};\n              if (timer && reject2 && this._method_timeout) {\n                encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n                encoded.interval = this._method_timeout / 2;\n                store.timer = timer;\n              } else {\n                timer = null;\n              }\n              [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve2, session_id, clear_after_called, timer, local_workspace);\n              [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject2, session_id, clear_after_called, timer, local_workspace);\n              return encoded;\n            }\n            async _send_chunks(data, target_id, session_id) {\n              let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n              let message_cache = remote_services.message_cache;\n              let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n              await message_cache.create(message_id, !!session_id);\n              let total_size = data.length;\n              let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n              for (let idx = 0; idx < chunk_num; idx++) {\n                let start_byte = idx * CHUNK_SIZE;\n                await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id);\n              }\n              await message_cache.process(message_id, !!session_id);\n            }\n            emit(main_message, extra_data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n              let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n              if (extra_data) {\n                const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                message_package = new Uint8Array([...message_package, ...extra]);\n              }\n              const total_size = message_package.length;\n              if (total_size <= CHUNK_SIZE + 1024) {\n                return this._emit_message(message_package);\n              } else {\n                throw new Error(\"Message is too large to send in one go.\");\n              }\n            }\n            _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n              let target_id = encoded_method._rtarget;\n              if (remote_workspace && !target_id.includes(\"/\")) {\n                if (remote_workspace !== target_id) {\n                  target_id = remote_workspace + \"/\" + target_id;\n                }\n                encoded_method._rtarget = target_id;\n              }\n              let method_id = encoded_method._rmethod;\n              let with_promise = encoded_method._rpromise;\n              const self2 = this;\n              function remote_method() {\n                return new Promise(async (resolve2, reject2) => {\n                  let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  if (local_parent) {\n                    local_session_id = local_parent + \".\" + local_session_id;\n                  }\n                  let store = self2._get_session_store(local_session_id, true);\n                  if (!store) {\n                    reject2(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n                    return;\n                  }\n                  store[\"target_id\"] = target_id;\n                  const args = await self2._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  let main_message = {\n                    type: \"method\",\n                    from: self2._local_workspace ? self2._local_workspace + \"/\" + self2._client_id : self2._client_id,\n                    to: target_id,\n                    method: method_id\n                  };\n                  let extra_data = {};\n                  if (args) {\n                    extra_data[\"args\"] = args;\n                  }\n                  if (withKwargs) {\n                    extra_data[\"with_kwargs\"] = withKwargs;\n                  }\n                  if (remote_parent) {\n                    main_message[\"parent\"] = remote_parent;\n                  }\n                  let timer = null;\n                  if (with_promise) {\n                    main_message[\"session\"] = local_session_id;\n                    let method_name = `${target_id}:${method_id}`;\n                    timer = new Timer(self2._method_timeout, reject2, [`Method call time out: ${method_name}`], method_name);\n                    let clear_after_called = true;\n                    for (let arg of args) {\n                      if (typeof arg === \"object\" && arg._rintf === true) {\n                        clear_after_called = false;\n                        break;\n                      }\n                    }\n                    extra_data[\"promise\"] = await self2._encode_promise(resolve2, reject2, local_session_id, clear_after_called, timer, local_workspace);\n                  }\n                  let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n                  if (extra_data) {\n                    const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                    message_package = new Uint8Array([...message_package, ...extra]);\n                  }\n                  const total_size = message_package.length;\n                  if (total_size <= CHUNK_SIZE + 1024) {\n                    self2._emit_message(message_package).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  } else {\n                    self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  }\n                });\n              }\n              remote_method.__rpc_object__ = encoded_method;\n              const parts = method_id.split(\".\");\n              remote_method.__name__ = parts[parts.length - 1];\n              remote_method.__doc__ = encoded_method._rdoc;\n              remote_method.__sig__ = encoded_method._rsig;\n              return remote_method;\n            }\n            async _notify_service_update() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  await this._manager_service.update_client_info(this.get_client_info());\n                } catch (exp) {\n                  console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n                }\n              }\n            }\n            get_client_info() {\n              const services = [];\n              for (let service of Object.values(this._services)) {\n                services.push({\n                  id: `${this._client_id}:${service[\"id\"]}`,\n                  type: service[\"type\"],\n                  name: service[\"name\"],\n                  description: service[\"description\"] || \"\",\n                  config: service[\"config\"]\n                });\n              }\n              return {\n                id: this._client_id,\n                services\n              };\n            }\n            async _handle_method(data) {\n              let reject2 = null;\n              let heartbeat_task = null;\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n                const method_name = data.from + \":\" + data.method;\n                const remote_workspace = data.from.split(\"/\")[0];\n                data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                data[\"ctx\"][\"to\"] = data[\"to\"];\n                const local_workspace = data.to.split(\"/\")[0];\n                const local_parent = data.parent;\n                let resolve2, reject3;\n                if (data.promise) {\n                  const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n                  resolve2 = promise.resolve;\n                  reject3 = promise.reject;\n                  if (promise.heartbeat && promise.interval) {\n                    async function heartbeat() {\n                      try {\n                        await promise.heartbeat();\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                    heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                  }\n                }\n                let method;\n                try {\n                  method = indexObject(this._object_store, data[\"method\"]);\n                } catch (e) {\n                  console.debug(\"Failed to find method\", method_name, e);\n                  throw new Error(`Method not found: ${method_name}`);\n                }\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name);\n                if (this._method_annotations.has(method)) {\n                  if (this._method_annotations.get(method).visibility === \"protected\") {\n                    if (local_workspace !== remote_workspace) {\n                      throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n                    }\n                  }\n                } else {\n                  let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                  if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                    session_target_id = local_workspace + \"/\" + session_target_id;\n                  }\n                  if (session_target_id !== data.from) {\n                    throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n                  }\n                }\n                if (local_parent) {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n                }\n                let args;\n                if (data.args) {\n                  args = await this._decode(data.args, data.session, null, remote_workspace, null);\n                } else {\n                  args = [];\n                }\n                if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                  args.push(data.ctx);\n                }\n                if (data.promise) {\n                  const result = method.apply(null, args);\n                  if (result instanceof Promise) {\n                    result.then((result2) => {\n                      resolve2(result2);\n                      clearInterval(heartbeat_task);\n                    }).catch((err) => {\n                      reject3(err);\n                      clearInterval(heartbeat_task);\n                    });\n                  } else {\n                    resolve2(result);\n                    clearInterval(heartbeat_task);\n                  }\n                } else {\n                  method.apply(null, args);\n                  clearInterval(heartbeat_task);\n                }\n              } catch (err) {\n                if (reject2) {\n                  reject2(err);\n                  console.debug(\"Error during calling method: \", err);\n                } else {\n                  console.error(\"Error during calling method: \", err);\n                }\n                clearInterval(heartbeat_task);\n              }\n            }\n            encode(aObject, session_id) {\n              return this._encode(aObject, session_id);\n            }\n            _get_session_store(session_id, create) {\n              let store = this._object_store;\n              const levels = session_id.split(\".\");\n              if (create) {\n                const last_index = levels.length - 1;\n                for (let level of levels.slice(0, last_index)) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                if (!store[levels[last_index]]) {\n                  store[levels[last_index]] = {};\n                }\n                return store[levels[last_index]];\n              } else {\n                for (let level of levels) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                return store;\n              }\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, session_id, local_workspace) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                return aObject;\n              }\n              if (aObject instanceof ArrayBuffer) {\n                return {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject)\n                };\n              }\n              if (aObject.__rpc_object__) {\n                return aObject.__rpc_object__;\n              }\n              let bObject;\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                const temp = aObject._rtype;\n                delete aObject._rtype;\n                bObject = await this._encode(aObject, session_id, local_workspace);\n                bObject._rtype = temp;\n                return bObject;\n              }\n              if (typeof aObject === \"function\") {\n                if (this._method_annotations.has(aObject)) {\n                  let annotation = this._method_annotations.get(aObject);\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: annotation.method_id,\n                    _rpromise: true\n                  };\n                } else {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n                  let object_id;\n                  if (aObject.__name__) {\n                    object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n                  } else {\n                    object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  }\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: true\n                  };\n                  let store = this._get_session_store(session_id, true);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n                  store[object_id] = aObject;\n                }\n                bObject._rdoc = aObject.__doc__;\n                bObject._rsig = aObject.__sig__;\n                if (!bObject._rdoc || !bObject._rsig) {\n                  try {\n                    const funcInfo = getFunctionInfo(aObject);\n                    if (funcInfo && !bObject._rdoc) {\n                      bObject._rdoc = `${funcInfo.doc}`;\n                    }\n                    if (funcInfo && !bObject._rsig) {\n                      bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n                    }\n                  } catch (e) {\n                    console.error(\"Failed to extract function docstring:\", aObject);\n                  }\n                }\n                return bObject;\n              }\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (typeof encodedObj === \"object\") {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(v_buffer.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString(),\n                  _rtrace: aObject.stack\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (aObject instanceof Blob) {\n                let seek = function(pos) {\n                  _current_pos = pos;\n                };\n                let _current_pos = 0;\n                async function read(length) {\n                  let blob;\n                  if (length) {\n                    blob = aObject.slice(_current_pos, _current_pos + length);\n                  } else {\n                    blob = aObject.slice(_current_pos);\n                  }\n                  const ret = new Uint8Array(await blob.arrayBuffer());\n                  _current_pos = _current_pos + ret.byteLength;\n                  return ret;\n                }\n                bObject = {\n                  _rtype: \"iostream\",\n                  _rnative: \"js:blob\",\n                  type: aObject.type,\n                  name: aObject.name,\n                  size: aObject.size,\n                  path: aObject._path || aObject.webkitRelativePath,\n                  read: await this._encode(read, session_id, local_workspace),\n                  seek: await this._encode(seek, session_id, local_workspace)\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: new Uint8Array(aObject.buffer),\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject.buffer)\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                const keys = Object.keys(aObject);\n                for (let k of keys) {\n                  bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n                }\n              } else {\n                throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async decode(aObject) {\n              return await this._decode(aObject);\n            }\n            async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject._rtype) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  aObject._rtype = temp;\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"method\") {\n                  bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                  bObject = new arraytype(buffer);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                } else if (aObject._rtype === \"iostream\") {\n                  if (aObject._rnative === \"js:blob\") {\n                    const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n                    const bytes = await read();\n                    bObject = new Blob([bytes], {\n                      type: aObject.type,\n                      name: aObject.name\n                    });\n                  } else {\n                    bObject = {};\n                    for (let k of Object.keys(aObject)) {\n                      if (!k.startsWith(\"_\")) {\n                        bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n                      }\n                    }\n                  }\n                  bObject[\"__rpc_object__\"] = aObject;\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  bObject._rtype = temp;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              return bObject;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/utils.js\": (\n        /*!****************************!*\\\n          !*** ./src/hypha/utils.js ***!\n          \\****************************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_167478__) {\n          \"use strict\";\n          __nested_webpack_require_167478__.r(__nested_webpack_exports__);\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"assert\", function() {\n            return assert;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"waitFor\", function() {\n            return waitFor;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve2, reject2) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve2;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve2();\n                  }\n                };\n                scriptTag.onerror = reject2;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config2) {\n            config2.version = config2.version || \"0.1.0\";\n            config2.description = config2.description || `[TODO: add description for ${config2.name} ]`;\n            config2.type = config2.type || \"rpc-window\";\n            config2.id = config2.id || randId();\n            config2.target_origin = config2.target_origin || \"*\";\n            config2.allow_execution = config2.allow_execution || false;\n            config2 = Object.keys(config2).reduce((p, c) => {\n              if (typeof config2[c] !== \"function\")\n                p[c] = config2[c];\n              return p;\n            }, {});\n            return config2;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve2, reject2) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject2(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event2) {\n                if (event2.data && event2.data.error) {\n                  reject2(event2.data.error);\n                } else {\n                  resolve2(event2.data && event2.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject2(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message || \"Assertion failed\");\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          function waitFor(prom, time, error) {\n            let timer;\n            return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n              rej(error || \"Timeout Error\");\n            }, time * 1e3))]).finally(() => clearTimeout(timer));\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event2, handler) {\n              if (!this._event_handlers[event2]) {\n                this._event_handlers[event2] = [];\n              }\n              this._event_handlers[event2].push(handler);\n            }\n            once(event2, handler) {\n              handler.___event_run_once = true;\n              this.on(event2, handler);\n            }\n            off(event2, handler) {\n              if (!event2 && !handler) {\n                this._event_handlers = {};\n              } else if (event2 && !handler) {\n                if (this._event_handlers[event2])\n                  this._event_handlers[event2] = [];\n              } else {\n                if (this._event_handlers[event2]) {\n                  const idx = this._event_handlers[event2].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event2].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event2, data) {\n              if (this._event_handlers[event2]) {\n                var i = this._event_handlers[event2].length;\n                while (i--) {\n                  const handler = this._event_handlers[event2][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event2].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event2, data);\n                }\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/webrtc-client.js\": (\n        /*!************************************!*\\\n          !*** ./src/hypha/webrtc-client.js ***!\n          \\************************************/\n        /*! exports provided: getRTCService, registerRTCService */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"getRTCService\", function() {\n            return getRTCService;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"registerRTCService\", function() {\n            return registerRTCService;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__2 = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          class WebRTCConnection {\n            constructor(channel) {\n              this._data_channel = channel;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._data_channel.onmessage = async (event2) => {\n                let data = event2.data;\n                if (data instanceof Blob) {\n                  data = await data.arrayBuffer();\n                }\n                this._handle_message(data);\n              };\n              const self2 = this;\n              this._data_channel.onclose = function() {\n                console.log(\"websocket closed\");\n                self2._data_channel = null;\n              };\n            }\n            set_reconnection_token(token2) {\n              this._reconnection_token = token2;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(this._handle_message, \"No handler for message\");\n              try {\n                this._data_channel.send(data);\n              } catch (exp) {\n                console.error(`Failed to send data, error: ${exp}`);\n                throw exp;\n              }\n            }\n            async disconnect(reason) {\n              this._data_channel = null;\n              console.info(`data channel connection disconnected (${reason})`);\n            }\n          }\n          async function _setupRPC(config2) {\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(config2.channel, \"No channel provided\");\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(config2.workspace, \"No workspace provided\");\n            const channel = config2.channel;\n            const clientId = config2.client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"randId\"])();\n            const connection = new WebRTCConnection(channel);\n            config2.context = config2.context || {};\n            config2.context.connection_type = \"webrtc\";\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__2[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: null,\n              default_context: config2.context,\n              name: config2.name,\n              method_timeout: config2.method_timeout || 10,\n              workspace: config2.workspace\n            });\n            return rpc;\n          }\n          async function _createOffer(params, server2, config2, onInit, context2) {\n            config2 = config2 || {};\n            let offer = new RTCSessionDescription({\n              sdp: params.sdp,\n              type: params.type\n            });\n            let pc = new RTCPeerConnection({\n              iceServers: config2.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            if (server2) {\n              pc.addEventListener(\"datachannel\", async (event2) => {\n                const channel = event2.channel;\n                let ctx = null;\n                if (context2 && context2.user)\n                  ctx = {\n                    user: context2.user\n                  };\n                const rpc = await _setupRPC({\n                  channel,\n                  client_id: channel.label,\n                  workspace: server2.config.workspace,\n                  context: ctx\n                });\n                rpc._services = server2.rpc._services;\n              });\n            }\n            if (onInit) {\n              await onInit(pc);\n            }\n            await pc.setRemoteDescription(offer);\n            let answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            return {\n              sdp: pc.localDescription.sdp,\n              type: pc.localDescription.type,\n              workspace: server2.config.workspace\n            };\n          }\n          async function getRTCService(server2, service_id, config2) {\n            config2 = config2 || {};\n            config2.peer_id = config2.peer_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"randId\"])();\n            const pc = new RTCPeerConnection({\n              iceServers: config2.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            return new Promise(async (resolve2, reject2) => {\n              try {\n                pc.addEventListener(\"connectionstatechange\", () => {\n                  if (pc.connectionState === \"failed\") {\n                    pc.close();\n                    reject2(new Error(\"Connection failed\"));\n                  }\n                }, false);\n                if (config2.on_init) {\n                  await config2.on_init(pc);\n                  delete config2.on_init;\n                }\n                let channel = pc.createDataChannel(config2.peer_id, {\n                  ordered: true\n                });\n                channel.binaryType = \"arraybuffer\";\n                const offer = await pc.createOffer();\n                await pc.setLocalDescription(offer);\n                const svc = await server2.getService(service_id);\n                const answer = await svc.offer({\n                  sdp: pc.localDescription.sdp,\n                  type: pc.localDescription.type\n                });\n                channel.onopen = () => {\n                  config2.channel = channel;\n                  config2.workspace = answer.workspace;\n                  setTimeout(async () => {\n                    const rpc = await _setupRPC(config2);\n                    pc.rpc = rpc;\n                    async function getService(name2) {\n                      return await rpc.get_remote_service(config2.peer_id + \":\" + name2);\n                    }\n                    async function disconnect() {\n                      await rpc.disconnect();\n                      pc.close();\n                    }\n                    pc.get_service = getService;\n                    pc.getService = getService;\n                    pc.disconnect = disconnect;\n                    pc.register_codec = rpc.register_codec;\n                    pc.registerCodec = rpc.register_codec;\n                    resolve2(pc);\n                  }, 500);\n                };\n                channel.onclose = () => reject2(new Error(\"Data channel closed\"));\n                await pc.setRemoteDescription(new RTCSessionDescription({\n                  sdp: answer.sdp,\n                  type: answer.type\n                }));\n              } catch (e) {\n                reject2(e);\n              }\n            });\n          }\n          async function registerRTCService(server2, service_id, config2) {\n            config2 = config2 || {\n              visibility: \"protected\",\n              require_context: true\n            };\n            const onInit = config2.on_init;\n            delete config2.on_init;\n            await server2.registerService({\n              id: service_id,\n              config: config2,\n              offer: (params, context2) => _createOffer(params, server2, config2, onInit, context2)\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/websocket-client.js\": (\n        /*!***************************************!*\\\n          !*** ./src/hypha/websocket-client.js ***!\n          \\***************************************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, getRTCService, registerRTCService, login, connectToServer, setupLocalClient */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_190988__) {\n          \"use strict\";\n          __nested_webpack_require_190988__.r(__nested_webpack_exports__);\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"login\", function() {\n            return login;\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"connectToServer\", function() {\n            return connectToServer;\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"setupLocalClient\", function() {\n            return setupLocalClient;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_190988__(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"];\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"API_VERSION\"];\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_190988__(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"loadRequirements\"];\n          });\n          var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_190988__(\n            /*! ./webrtc-client.js */\n            \"./src/hypha/webrtc-client.js\"\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"getRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"];\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"registerRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_190988__(\n            /*! ../../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /* @__PURE__ */ __nested_webpack_require_190988__.t(\n            /*! ../../package.json */\n            \"./package.json\",\n            1\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_3__[\"version\"];\n          });\n          const MAX_RETRY = 1e4;\n          class WebsocketRPCConnection {\n            constructor(server_url2, client_id2, workspace2, token2, timeout = 60, WebSocketClass = null) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(server_url2 && client_id2, \"server_url and client_id are required\");\n              server_url2 = server_url2 + \"?client_id=\" + client_id2;\n              if (workspace2) {\n                server_url2 += \"&workspace=\" + workspace2;\n              }\n              if (token2) {\n                server_url2 += \"&token=\" + token2;\n              }\n              this._websocket = null;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._server_url = server_url2;\n              this._timeout = timeout * 1e3;\n              this._opening = null;\n              this._retry_count = 0;\n              this._closing = false;\n              this._client_id = client_id2;\n              this._workspace = workspace2;\n              this._WebSocketClass = WebSocketClass;\n            }\n            set_reconnection_token(token2) {\n              this._reconnection_token = token2;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            async open() {\n              if (this._opening) {\n                return this._opening;\n              }\n              this._opening = new Promise((resolve2, reject2) => {\n                const server_url2 = this._reconnection_token ? `${this._server_url}&reconnection_token=${this._reconnection_token}` : this._server_url;\n                console.info(\"Creating a new connection to \", server_url2.split(\"?\")[0]);\n                let websocket = null;\n                if (server_url2.startsWith(\"wss://local-hypha-server:\")) {\n                  if (this._WebSocketClass) {\n                    websocket = new this._WebSocketClass(server_url2);\n                  } else {\n                    console.log(\"Using local websocket\");\n                    console.log(\"Connecting to local websocket \" + server_url2);\n                    websocket = new LocalWebSocket(server_url2, this._client_id, this._workspace);\n                  }\n                } else {\n                  if (this._WebSocketClass) {\n                    websocket = new this._WebSocketClass(server_url2);\n                  } else {\n                    websocket = new WebSocket(server_url2);\n                  }\n                }\n                websocket.binaryType = \"arraybuffer\";\n                websocket.onmessage = (event2) => {\n                  const data = event2.data;\n                  this._handle_message(data);\n                };\n                websocket.onopen = () => {\n                  this._websocket = websocket;\n                  console.info(\"WebSocket connection established\");\n                  this._retry_count = 0;\n                  resolve2();\n                };\n                websocket.onclose = (event2) => {\n                  console.log(\"websocket closed\");\n                  if (!this._closing) {\n                    console.log(\"Websocket connection interrupted, retrying...\");\n                    this._retry_count++;\n                    setTimeout(() => this.open(), this._timeout);\n                  }\n                  this._websocket = null;\n                };\n                websocket.onerror = (event2) => {\n                  console.log(\"Error occurred in websocket connection: \", event2);\n                  reject2(new Error(\"Websocket connection failed.\"));\n                  this._websocket = null;\n                };\n              }).finally(() => {\n                this._opening = null;\n              });\n              return this._opening;\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n              if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n                await this.open();\n              }\n              return new Promise((resolve2, reject2) => {\n                if (!this._websocket) {\n                  reject2(new Error(\"Websocket connection not available\"));\n                } else if (this._websocket.readyState === WebSocket.CONNECTING) {\n                  const timeout = setTimeout(() => {\n                    reject2(new Error(\"WebSocket connection timed out\"));\n                  }, this._timeout);\n                  this._websocket.addEventListener(\"open\", () => {\n                    clearTimeout(timeout);\n                    try {\n                      this._websocket.send(data);\n                      resolve2();\n                    } catch (exp) {\n                      console.error(`Failed to send data, error: ${exp}`);\n                      reject2(exp);\n                    }\n                  });\n                } else if (this._websocket.readyState === WebSocket.OPEN) {\n                  try {\n                    this._websocket.send(data);\n                    resolve2();\n                  } catch (exp) {\n                    console.error(`Failed to send data, error: ${exp}`);\n                    reject2(exp);\n                  }\n                } else {\n                  reject2(new Error(\"WebSocket is not in the OPEN or CONNECTING state\"));\n                }\n              });\n            }\n            disconnect(reason) {\n              this._closing = true;\n              const ws = this._websocket;\n              this._websocket = null;\n              if (ws && ws.readyState === WebSocket.OPEN) {\n                ws.close(1e3, reason);\n              }\n              console.info(`Websocket connection disconnected (${reason})`);\n            }\n          }\n          function normalizeServerUrl(server_url2) {\n            if (!server_url2)\n              throw new Error(\"server_url is required\");\n            if (server_url2.startsWith(\"http://\")) {\n              server_url2 = server_url2.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n            } else if (server_url2.startsWith(\"https://\")) {\n              server_url2 = server_url2.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n            }\n            return server_url2;\n          }\n          async function login(config2) {\n            const service_id = config2.login_service_id || \"public/*:hypha-login\";\n            const timeout = config2.login_timeout || 60;\n            const callback = config2.login_callback;\n            const server2 = await connectToServer({\n              name: \"initial login client\",\n              server_url: config2.server_url\n            });\n            try {\n              const svc = await server2.get_service(service_id);\n              const context2 = await svc.start();\n              if (callback) {\n                await callback(context2);\n              } else {\n                console.log(`Please open your browser and login at ${context2.login_url}`);\n              }\n              return await svc.check(context2.key, timeout);\n            } catch (error) {\n              throw error;\n            } finally {\n              await server2.disconnect();\n            }\n          }\n          async function connectToServer(config2) {\n            if (config2.server) {\n              config2.server_url = config2.server_url || config2.server.url;\n              config2.WebSocketClass = config2.WebSocketClass || config2.server.WebSocketClass;\n            }\n            let clientId = config2.client_id;\n            if (!clientId) {\n              clientId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n              config2.client_id = clientId;\n            }\n            let server_url2 = normalizeServerUrl(config2.server_url);\n            let connection = new WebsocketRPCConnection(server_url2, clientId, config2.workspace, config2.token, config2.method_timeout || 60, config2.WebSocketClass);\n            await connection.open();\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: \"workspace-manager\",\n              default_context: {\n                connection_type: \"websocket\"\n              },\n              name: config2.name,\n              method_timeout: config2.method_timeout\n            });\n            const wm = await rpc.get_remote_service(\"workspace-manager:default\");\n            wm.rpc = rpc;\n            async function _export(api) {\n              api.id = \"default\";\n              api.name = config2.name || api.id;\n              await rpc.register_service(api, true);\n            }\n            async function getPlugin(query) {\n              return await wm.get_service(query + \":default\");\n            }\n            async function disconnect() {\n              await rpc.disconnect();\n              await connection.disconnect();\n            }\n            wm.config[\"client_id\"] = clientId;\n            wm.export = _export;\n            wm.getPlugin = getPlugin;\n            wm.listPlugins = wm.listServices;\n            wm.disconnect = disconnect;\n            wm.registerCodec = rpc.register_codec.bind(rpc);\n            wm.emit = async function(message) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(message && typeof message === \"object\", \"message must be a dictionary\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(\"to\" in message, \"message must have a 'to' field\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(\"type\" in message, \"message must have a 'type' field\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(type !== \"method\", \"message type cannot be 'method'\");\n              return await rpc.emit(message);\n            };\n            wm.on = function(type2, handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(type2 !== \"method\", \"message type cannot be 'method'\");\n              rpc.on(type2, handler);\n            };\n            if (config2.webrtc) {\n              await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"])(wm, clientId + \"-rtc\", config2.webrtc_config);\n            }\n            if (wm.get_service || wm.getService) {\n              const _get_service = wm.get_service || wm.getService;\n              wm.get_service = async function(query, webrtc, webrtc_config) {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])([void 0, true, false, \"auto\"].includes(webrtc), \"webrtc must be true, false or 'auto'\");\n                const svc = await _get_service(query);\n                if (webrtc === true || webrtc === \"auto\") {\n                  if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n                    const client = svc.id.split(\":\")[0];\n                    try {\n                      const peer = await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"])(wm, client + \":\" + client.split(\"/\")[1] + \"-rtc\", webrtc_config);\n                      const rtcSvc = await peer.get_service(svc.id.split(\":\")[1]);\n                      rtcSvc._webrtc = true;\n                      rtcSvc._peer = peer;\n                      rtcSvc._service = svc;\n                      return rtcSvc;\n                    } catch (e) {\n                      console.warn(\"Failed to get webrtc service, using websocket connection\", e);\n                    }\n                  }\n                  if (webrtc === true) {\n                    throw new Error(\"Failed to get the service via webrtc\");\n                  }\n                }\n                return svc;\n              };\n              wm.getService = wm.get_service;\n            }\n            return wm;\n          }\n          class LocalWebSocket {\n            constructor(url, client_id2, workspace2) {\n              this.url = url;\n              this.onopen = () => {\n              };\n              this.onmessage = () => {\n              };\n              this.onclose = () => {\n              };\n              this.onerror = () => {\n              };\n              this.client_id = client_id2;\n              this.workspace = workspace2;\n              const context2 = typeof window !== \"undefined\" ? window : self;\n              const isWindow2 = typeof window !== \"undefined\";\n              this.postMessage = (message) => {\n                if (isWindow2) {\n                  window.parent.postMessage(message, \"*\");\n                } else {\n                  self.postMessage(message);\n                }\n              };\n              this.readyState = WebSocket.CONNECTING;\n              context2.addEventListener(\"message\", (event2) => {\n                const {\n                  type: type2,\n                  data,\n                  to\n                } = event2.data;\n                if (to !== this.client_id) {\n                  console.debug(\"message not for me\", to, this.client_id);\n                  return;\n                }\n                switch (type2) {\n                  case \"message\":\n                    if (this.readyState === WebSocket.OPEN && this.onmessage) {\n                      this.onmessage({\n                        data\n                      });\n                    }\n                    break;\n                  case \"connected\":\n                    this.readyState = WebSocket.OPEN;\n                    this.onopen(event2);\n                    break;\n                  case \"closed\":\n                    this.readyState = WebSocket.CLOSED;\n                    this.onclose(event2);\n                    break;\n                  default:\n                    break;\n                }\n              }, false);\n              if (!this.client_id)\n                throw new Error(\"client_id is required\");\n              if (!this.workspace)\n                throw new Error(\"workspace is required\");\n              this.postMessage({\n                type: \"connect\",\n                url: this.url,\n                from: this.client_id,\n                workspace: this.workspace\n              });\n            }\n            send(data) {\n              if (this.readyState === WebSocket.OPEN) {\n                this.postMessage({\n                  type: \"message\",\n                  data,\n                  from: this.client_id,\n                  workspace: this.workspace\n                });\n              }\n            }\n            close() {\n              this.readyState = WebSocket.CLOSING;\n              this.postMessage({\n                type: \"close\",\n                from: this.client_id,\n                workspace: this.workspace\n              });\n              this.onclose();\n            }\n            addEventListener(type2, listener) {\n              if (type2 === \"message\") {\n                this.onmessage = listener;\n              }\n              if (type2 === \"open\") {\n                this.onopen = listener;\n              }\n              if (type2 === \"close\") {\n                this.onclose = listener;\n              }\n              if (type2 === \"error\") {\n                this.onerror = listener;\n              }\n            }\n          }\n          function setupLocalClient({\n            enable_execution = false,\n            on_ready = null\n          }) {\n            return new Promise((resolve, reject) => {\n              const context = typeof window !== \"undefined\" ? window : self;\n              const isWindow = typeof window !== \"undefined\";\n              context.addEventListener(\"message\", (event) => {\n                const {\n                  type,\n                  server_url,\n                  workspace,\n                  client_id,\n                  token,\n                  method_timeout,\n                  name,\n                  config\n                } = event.data;\n                if (type === \"initializeHyphaClient\") {\n                  if (!server_url || !workspace || !client_id) {\n                    console.error(\"server_url, workspace, and client_id are required.\");\n                    return;\n                  }\n                  if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n                    console.error(\"server_url should start with https://local-hypha-server:\");\n                    return;\n                  }\n                  connectToServer({\n                    server_url,\n                    workspace,\n                    client_id,\n                    token,\n                    method_timeout,\n                    name\n                  }).then(async (server) => {\n                    globalThis.api = server;\n                    try {\n                      if (isWindow && enable_execution) {\n                        let loadScript = function(script2) {\n                          return new Promise((resolve2, reject2) => {\n                            const scriptElement = document.createElement(\"script\");\n                            scriptElement.innerHTML = script2.content;\n                            scriptElement.lang = script2.lang;\n                            scriptElement.onload = () => resolve2();\n                            scriptElement.onerror = (e) => reject2(e);\n                            document.head.appendChild(scriptElement);\n                          });\n                        };\n                        if (config.styles && config.styles.length > 0) {\n                          for (const style of config.styles) {\n                            const styleElement = document.createElement(\"style\");\n                            styleElement.innerHTML = style.content;\n                            styleElement.lang = style.lang;\n                            document.head.appendChild(styleElement);\n                          }\n                        }\n                        if (config.links && config.links.length > 0) {\n                          for (const link of config.links) {\n                            const linkElement = document.createElement(\"a\");\n                            linkElement.href = link.url;\n                            linkElement.innerText = link.text;\n                            document.body.appendChild(linkElement);\n                          }\n                        }\n                        if (config.windows && config.windows.length > 0) {\n                          for (const w of config.windows) {\n                            document.body.innerHTML = w.content;\n                            break;\n                          }\n                        }\n                        if (config.scripts && config.scripts.length > 0) {\n                          for (const script2 of config.scripts) {\n                            if (script2.lang !== \"javascript\")\n                              throw new Error(\"Only javascript scripts are supported\");\n                            await loadScript(script2);\n                          }\n                        }\n                      } else if (!isWindow && enable_execution && config.scripts && config.scripts.length > 0) {\n                        for (const script of config.scripts) {\n                          if (script.lang !== \"javascript\")\n                            throw new Error(\"Only javascript scripts are supported\");\n                          eval(script.content);\n                        }\n                      }\n                      if (on_ready) {\n                        await on_ready(server, config);\n                      }\n                      resolve(server);\n                    } catch (e) {\n                      await server.update_client_info({\n                        id: client_id,\n                        error: e.message\n                      });\n                      reject(e);\n                    }\n                  });\n                }\n              }, false);\n              if (isWindow) {\n                window.parent.postMessage({\n                  type: \"hyphaClientReady\"\n                }, \"*\");\n              } else {\n                self.postMessage({\n                  type: \"hyphaClientReady\"\n                });\n              }\n            });\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc.js":
/*!**************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/hypha/rpc.js\");\n    }({\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: CachedKeyDecoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"CachedKeyDecoder\", function() {\n            return CachedKeyDecoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var DEFAULT_MAX_KEY_LENGTH = 16;\n          var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n          var CachedKeyDecoder = (\n            /** @class */\n            function() {\n              function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                if (maxKeyLength === void 0) {\n                  maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                }\n                if (maxLengthPerKey === void 0) {\n                  maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                }\n                this.maxKeyLength = maxKeyLength;\n                this.maxLengthPerKey = maxLengthPerKey;\n                this.hit = 0;\n                this.miss = 0;\n                this.caches = [];\n                for (var i = 0; i < this.maxKeyLength; i++) {\n                  this.caches.push([]);\n                }\n              }\n              CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                return byteLength > 0 && byteLength <= this.maxKeyLength;\n              };\n              CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                var records = this.caches[byteLength - 1];\n                FIND_CHUNK:\n                  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                    var record = records_1[_i];\n                    var recordBytes = record.bytes;\n                    for (var j = 0; j < byteLength; j++) {\n                      if (recordBytes[j] !== bytes[inputOffset + j]) {\n                        continue FIND_CHUNK;\n                      }\n                    }\n                    return record.str;\n                  }\n                return null;\n              };\n              CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                var records = this.caches[bytes.length - 1];\n                var record = { bytes, str: value };\n                if (records.length >= this.maxLengthPerKey) {\n                  records[Math.random() * records.length | 0] = record;\n                } else {\n                  records.push(record);\n                }\n              };\n              CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                var cachedValue = this.find(bytes, inputOffset, byteLength);\n                if (cachedValue != null) {\n                  this.hit++;\n                  return cachedValue;\n                }\n                this.miss++;\n                var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n                var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                this.store(slicedCopyOfBytes, str);\n                return str;\n              };\n              return CachedKeyDecoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: DecodeError */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return DecodeError;\n          });\n          var __extends = function() {\n            var extendStatics = function(d, b) {\n              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                d2.__proto__ = b2;\n              } || function(d2, b2) {\n                for (var p in b2)\n                  if (Object.prototype.hasOwnProperty.call(b2, p))\n                    d2[p] = b2[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function(d, b) {\n              if (typeof b !== \"function\" && b !== null)\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          var DecodeError = (\n            /** @class */\n            function(_super) {\n              __extends(DecodeError2, _super);\n              function DecodeError2(message) {\n                var _this = _super.call(this, message) || this;\n                var proto = Object.create(DecodeError2.prototype);\n                Object.setPrototypeOf(_this, proto);\n                Object.defineProperty(_this, \"name\", {\n                  configurable: true,\n                  enumerable: false,\n                  value: DecodeError2.name\n                });\n                return _this;\n              }\n              return DecodeError2;\n            }(Error)\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return DataViewIndexOutOfBoundsError;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/prettyByte.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./CachedKeyDecoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n          );\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __asyncValues = function(o) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i);\n            function verb(n) {\n              i[n] = o[n] && function(v) {\n                return new Promise(function(resolve, reject) {\n                  v = o[n](v), settle(resolve, reject, v.done, v.value);\n                });\n              };\n            }\n            function settle(resolve, reject, d, v) {\n              Promise.resolve(v).then(function(v2) {\n                resolve({ value: v2, done: d });\n              }, reject);\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          var isValidMapKeyType = function(key) {\n            var keyType = typeof key;\n            return keyType === \"string\" || keyType === \"number\";\n          };\n          var HEAD_BYTE_REQUIRED = -1;\n          var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n          var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n          var DataViewIndexOutOfBoundsError = function() {\n            try {\n              EMPTY_VIEW.getInt8(0);\n            } catch (e) {\n              return e.constructor;\n            }\n            throw new Error(\"never reached\");\n          }();\n          var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n          var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\n          var Decoder = (\n            /** @class */\n            function() {\n              function Decoder2(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxStrLength === void 0) {\n                  maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxBinLength === void 0) {\n                  maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxArrayLength === void 0) {\n                  maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxMapLength === void 0) {\n                  maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxExtLength === void 0) {\n                  maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (keyDecoder === void 0) {\n                  keyDecoder = sharedCachedKeyDecoder;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxStrLength = maxStrLength;\n                this.maxBinLength = maxBinLength;\n                this.maxArrayLength = maxArrayLength;\n                this.maxMapLength = maxMapLength;\n                this.maxExtLength = maxExtLength;\n                this.keyDecoder = keyDecoder;\n                this.totalPos = 0;\n                this.pos = 0;\n                this.view = EMPTY_VIEW;\n                this.bytes = EMPTY_BYTES;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack = [];\n              }\n              Decoder2.prototype.reinitializeState = function() {\n                this.totalPos = 0;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack.length = 0;\n              };\n              Decoder2.prototype.setBuffer = function(buffer) {\n                this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n                this.pos = 0;\n              };\n              Decoder2.prototype.appendBuffer = function(buffer) {\n                if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                  this.setBuffer(buffer);\n                } else {\n                  var remainingData = this.bytes.subarray(this.pos);\n                  var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                  var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                  newBuffer.set(remainingData);\n                  newBuffer.set(newData, remainingData.length);\n                  this.setBuffer(newBuffer);\n                }\n              };\n              Decoder2.prototype.hasRemaining = function(size) {\n                return this.view.byteLength - this.pos >= size;\n              };\n              Decoder2.prototype.createExtraByteError = function(posToShow) {\n                var _a = this, view = _a.view, pos = _a.pos;\n                return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n              };\n              Decoder2.prototype.decode = function(buffer) {\n                this.reinitializeState();\n                this.setBuffer(buffer);\n                var object = this.doDecodeSync();\n                if (this.hasRemaining(1)) {\n                  throw this.createExtraByteError(this.pos);\n                }\n                return object;\n              };\n              Decoder2.prototype.decodeMulti = function(buffer) {\n                return __generator(this, function(_a) {\n                  switch (_a.label) {\n                    case 0:\n                      this.reinitializeState();\n                      this.setBuffer(buffer);\n                      _a.label = 1;\n                    case 1:\n                      if (!this.hasRemaining(1))\n                        return [3, 3];\n                      return [4, this.doDecodeSync()];\n                    case 2:\n                      _a.sent();\n                      return [3, 1];\n                    case 3:\n                      return [\n                        2\n                        /*return*/\n                      ];\n                  }\n                });\n              };\n              Decoder2.prototype.decodeAsync = function(stream) {\n                var stream_1, stream_1_1;\n                var e_1, _a;\n                return __awaiter(this, void 0, void 0, function() {\n                  var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                  return __generator(this, function(_c) {\n                    switch (_c.label) {\n                      case 0:\n                        decoded = false;\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                      case 2:\n                        return [4, stream_1.next()];\n                      case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                          return [3, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                          object = this.doDecodeSync();\n                          decoded = true;\n                        } catch (e) {\n                          if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e;\n                          }\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                      case 4:\n                        return [3, 2];\n                      case 5:\n                        return [3, 12];\n                      case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3, 12];\n                      case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                          return [3, 9];\n                        return [4, _a.call(stream_1)];\n                      case 8:\n                        _c.sent();\n                        _c.label = 9;\n                      case 9:\n                        return [3, 11];\n                      case 10:\n                        if (e_1)\n                          throw e_1.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 11:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 12:\n                        if (decoded) {\n                          if (this.hasRemaining(1)) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          return [2, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.decodeArrayStream = function(stream) {\n                return this.decodeMultiAsync(stream, true);\n              };\n              Decoder2.prototype.decodeStream = function(stream) {\n                return this.decodeMultiAsync(stream, false);\n              };\n              Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                  var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                  var e_3, _a;\n                  return __generator(this, function(_b) {\n                    switch (_b.label) {\n                      case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                      case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                      case 2:\n                        return [4, __await(stream_2.next())];\n                      case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                          return [3, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                          arrayItemsLeft = this.readArraySize();\n                          isArrayHeaderRequired = false;\n                          this.complete();\n                        }\n                        _b.label = 4;\n                      case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                      case 5:\n                        if (false) {}\n                        return [4, __await(this.doDecodeSync())];\n                      case 6:\n                        return [4, _b.sent()];\n                      case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                          return [3, 8];\n                        }\n                        return [3, 5];\n                      case 8:\n                        return [3, 10];\n                      case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                          throw e_2;\n                        }\n                        return [3, 10];\n                      case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                      case 11:\n                        return [3, 2];\n                      case 12:\n                        return [3, 19];\n                      case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3, 19];\n                      case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                          return [3, 16];\n                        return [4, __await(_a.call(stream_2))];\n                      case 15:\n                        _b.sent();\n                        _b.label = 16;\n                      case 16:\n                        return [3, 18];\n                      case 17:\n                        if (e_3)\n                          throw e_3.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 18:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 19:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.doDecodeSync = function() {\n                DECODE:\n                  while (true) {\n                    var headByte = this.readHeadByte();\n                    var object = void 0;\n                    if (headByte >= 224) {\n                      object = headByte - 256;\n                    } else if (headByte < 192) {\n                      if (headByte < 128) {\n                        object = headByte;\n                      } else if (headByte < 144) {\n                        var size = headByte - 128;\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte < 160) {\n                        var size = headByte - 144;\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else {\n                        var byteLength = headByte - 160;\n                        object = this.decodeUtf8String(byteLength, 0);\n                      }\n                    } else if (headByte === 192) {\n                      object = null;\n                    } else if (headByte === 194) {\n                      object = false;\n                    } else if (headByte === 195) {\n                      object = true;\n                    } else if (headByte === 202) {\n                      object = this.readF32();\n                    } else if (headByte === 203) {\n                      object = this.readF64();\n                    } else if (headByte === 204) {\n                      object = this.readU8();\n                    } else if (headByte === 205) {\n                      object = this.readU16();\n                    } else if (headByte === 206) {\n                      object = this.readU32();\n                    } else if (headByte === 207) {\n                      object = this.readU64();\n                    } else if (headByte === 208) {\n                      object = this.readI8();\n                    } else if (headByte === 209) {\n                      object = this.readI16();\n                    } else if (headByte === 210) {\n                      object = this.readI32();\n                    } else if (headByte === 211) {\n                      object = this.readI64();\n                    } else if (headByte === 217) {\n                      var byteLength = this.lookU8();\n                      object = this.decodeUtf8String(byteLength, 1);\n                    } else if (headByte === 218) {\n                      var byteLength = this.lookU16();\n                      object = this.decodeUtf8String(byteLength, 2);\n                    } else if (headByte === 219) {\n                      var byteLength = this.lookU32();\n                      object = this.decodeUtf8String(byteLength, 4);\n                    } else if (headByte === 220) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 221) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 222) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 223) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 196) {\n                      var size = this.lookU8();\n                      object = this.decodeBinary(size, 1);\n                    } else if (headByte === 197) {\n                      var size = this.lookU16();\n                      object = this.decodeBinary(size, 2);\n                    } else if (headByte === 198) {\n                      var size = this.lookU32();\n                      object = this.decodeBinary(size, 4);\n                    } else if (headByte === 212) {\n                      object = this.decodeExtension(1, 0);\n                    } else if (headByte === 213) {\n                      object = this.decodeExtension(2, 0);\n                    } else if (headByte === 214) {\n                      object = this.decodeExtension(4, 0);\n                    } else if (headByte === 215) {\n                      object = this.decodeExtension(8, 0);\n                    } else if (headByte === 216) {\n                      object = this.decodeExtension(16, 0);\n                    } else if (headByte === 199) {\n                      var size = this.lookU8();\n                      object = this.decodeExtension(size, 1);\n                    } else if (headByte === 200) {\n                      var size = this.lookU16();\n                      object = this.decodeExtension(size, 2);\n                    } else if (headByte === 201) {\n                      var size = this.lookU32();\n                      object = this.decodeExtension(size, 4);\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                    this.complete();\n                    var stack = this.stack;\n                    while (stack.length > 0) {\n                      var state = stack[stack.length - 1];\n                      if (state.type === 0) {\n                        state.array[state.position] = object;\n                        state.position++;\n                        if (state.position === state.size) {\n                          stack.pop();\n                          object = state.array;\n                        } else {\n                          continue DECODE;\n                        }\n                      } else if (state.type === 1) {\n                        if (!isValidMapKeyType(object)) {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                        }\n                        if (object === \"__proto__\") {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                        }\n                        state.key = object;\n                        state.type = 2;\n                        continue DECODE;\n                      } else {\n                        state.map[state.key] = object;\n                        state.readCount++;\n                        if (state.readCount === state.size) {\n                          stack.pop();\n                          object = state.map;\n                        } else {\n                          state.key = null;\n                          state.type = 1;\n                          continue DECODE;\n                        }\n                      }\n                    }\n                    return object;\n                  }\n              };\n              Decoder2.prototype.readHeadByte = function() {\n                if (this.headByte === HEAD_BYTE_REQUIRED) {\n                  this.headByte = this.readU8();\n                }\n                return this.headByte;\n              };\n              Decoder2.prototype.complete = function() {\n                this.headByte = HEAD_BYTE_REQUIRED;\n              };\n              Decoder2.prototype.readArraySize = function() {\n                var headByte = this.readHeadByte();\n                switch (headByte) {\n                  case 220:\n                    return this.readU16();\n                  case 221:\n                    return this.readU32();\n                  default: {\n                    if (headByte < 160) {\n                      return headByte - 144;\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                  }\n                }\n              };\n              Decoder2.prototype.pushMapState = function(size) {\n                if (size > this.maxMapLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n                }\n                this.stack.push({\n                  type: 1,\n                  size,\n                  key: null,\n                  readCount: 0,\n                  map: {}\n                });\n              };\n              Decoder2.prototype.pushArrayState = function(size) {\n                if (size > this.maxArrayLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n                }\n                this.stack.push({\n                  type: 0,\n                  size,\n                  array: new Array(size),\n                  position: 0\n                });\n              };\n              Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                var _a;\n                if (byteLength > this.maxStrLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n                }\n                if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headerOffset;\n                var object;\n                if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                  object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n                } else {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n                }\n                this.pos += headerOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.stateIsMapKey = function() {\n                if (this.stack.length > 0) {\n                  var state = this.stack[this.stack.length - 1];\n                  return state.type === 1;\n                }\n                return false;\n              };\n              Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                if (byteLength > this.maxBinLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n                }\n                if (!this.hasRemaining(byteLength + headOffset)) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headOffset;\n                var object = this.bytes.subarray(offset, offset + byteLength);\n                this.pos += headOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                if (size > this.maxExtLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n                }\n                var extType = this.view.getInt8(this.pos + headOffset);\n                var data = this.decodeBinary(\n                  size,\n                  headOffset + 1\n                  /* extType */\n                );\n                return this.extensionCodec.decode(data, extType, this.context);\n              };\n              Decoder2.prototype.lookU8 = function() {\n                return this.view.getUint8(this.pos);\n              };\n              Decoder2.prototype.lookU16 = function() {\n                return this.view.getUint16(this.pos);\n              };\n              Decoder2.prototype.lookU32 = function() {\n                return this.view.getUint32(this.pos);\n              };\n              Decoder2.prototype.readU8 = function() {\n                var value = this.view.getUint8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readI8 = function() {\n                var value = this.view.getInt8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readU16 = function() {\n                var value = this.view.getUint16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readI16 = function() {\n                var value = this.view.getInt16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readU32 = function() {\n                var value = this.view.getUint32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readI32 = function() {\n                var value = this.view.getInt32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readU64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readI64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readF32 = function() {\n                var value = this.view.getFloat32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readF64 = function() {\n                var value = this.view.getFloat64(this.pos);\n                this.pos += 8;\n                return value;\n              };\n              return Decoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_MAX_DEPTH\", function() {\n            return DEFAULT_MAX_DEPTH;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() {\n            return DEFAULT_INITIAL_BUFFER_SIZE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var DEFAULT_MAX_DEPTH = 100;\n          var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n          var Encoder = (\n            /** @class */\n            function() {\n              function Encoder2(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxDepth === void 0) {\n                  maxDepth = DEFAULT_MAX_DEPTH;\n                }\n                if (initialBufferSize === void 0) {\n                  initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                }\n                if (sortKeys === void 0) {\n                  sortKeys = false;\n                }\n                if (forceFloat32 === void 0) {\n                  forceFloat32 = false;\n                }\n                if (ignoreUndefined === void 0) {\n                  ignoreUndefined = false;\n                }\n                if (forceIntegerToFloat === void 0) {\n                  forceIntegerToFloat = false;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxDepth = maxDepth;\n                this.initialBufferSize = initialBufferSize;\n                this.sortKeys = sortKeys;\n                this.forceFloat32 = forceFloat32;\n                this.ignoreUndefined = ignoreUndefined;\n                this.forceIntegerToFloat = forceIntegerToFloat;\n                this.pos = 0;\n                this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                this.bytes = new Uint8Array(this.view.buffer);\n              }\n              Encoder2.prototype.getUint8Array = function() {\n                return this.bytes.subarray(0, this.pos);\n              };\n              Encoder2.prototype.reinitializeState = function() {\n                this.pos = 0;\n              };\n              Encoder2.prototype.encode = function(object) {\n                this.reinitializeState();\n                this.doEncode(object, 1);\n                return this.getUint8Array();\n              };\n              Encoder2.prototype.doEncode = function(object, depth) {\n                if (depth > this.maxDepth) {\n                  throw new Error(\"Too deep objects in depth \" + depth);\n                }\n                if (object == null) {\n                  this.encodeNil();\n                } else if (typeof object === \"boolean\") {\n                  this.encodeBoolean(object);\n                } else if (typeof object === \"number\") {\n                  this.encodeNumber(object);\n                } else if (typeof object === \"string\") {\n                  this.encodeString(object);\n                } else {\n                  this.encodeObject(object, depth);\n                }\n              };\n              Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                var requiredSize = this.pos + sizeToWrite;\n                if (this.view.byteLength < requiredSize) {\n                  this.resizeBuffer(requiredSize * 2);\n                }\n              };\n              Encoder2.prototype.resizeBuffer = function(newSize) {\n                var newBuffer = new ArrayBuffer(newSize);\n                var newBytes = new Uint8Array(newBuffer);\n                var newView = new DataView(newBuffer);\n                newBytes.set(this.bytes);\n                this.view = newView;\n                this.bytes = newBytes;\n              };\n              Encoder2.prototype.encodeNil = function() {\n                this.writeU8(192);\n              };\n              Encoder2.prototype.encodeBoolean = function(object) {\n                if (object === false) {\n                  this.writeU8(194);\n                } else {\n                  this.writeU8(195);\n                }\n              };\n              Encoder2.prototype.encodeNumber = function(object) {\n                if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                  if (object >= 0) {\n                    if (object < 128) {\n                      this.writeU8(object);\n                    } else if (object < 256) {\n                      this.writeU8(204);\n                      this.writeU8(object);\n                    } else if (object < 65536) {\n                      this.writeU8(205);\n                      this.writeU16(object);\n                    } else if (object < 4294967296) {\n                      this.writeU8(206);\n                      this.writeU32(object);\n                    } else {\n                      this.writeU8(207);\n                      this.writeU64(object);\n                    }\n                  } else {\n                    if (object >= -32) {\n                      this.writeU8(224 | object + 32);\n                    } else if (object >= -128) {\n                      this.writeU8(208);\n                      this.writeI8(object);\n                    } else if (object >= -32768) {\n                      this.writeU8(209);\n                      this.writeI16(object);\n                    } else if (object >= -2147483648) {\n                      this.writeU8(210);\n                      this.writeI32(object);\n                    } else {\n                      this.writeU8(211);\n                      this.writeI64(object);\n                    }\n                  }\n                } else {\n                  if (this.forceFloat32) {\n                    this.writeU8(202);\n                    this.writeF32(object);\n                  } else {\n                    this.writeU8(203);\n                    this.writeF64(object);\n                  }\n                }\n              };\n              Encoder2.prototype.writeStringHeader = function(byteLength) {\n                if (byteLength < 32) {\n                  this.writeU8(160 + byteLength);\n                } else if (byteLength < 256) {\n                  this.writeU8(217);\n                  this.writeU8(byteLength);\n                } else if (byteLength < 65536) {\n                  this.writeU8(218);\n                  this.writeU16(byteLength);\n                } else if (byteLength < 4294967296) {\n                  this.writeU8(219);\n                  this.writeU32(byteLength);\n                } else {\n                  throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n                }\n              };\n              Encoder2.prototype.encodeString = function(object) {\n                var maxHeaderSize = 1 + 4;\n                var strLength = object.length;\n                if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                } else {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                }\n              };\n              Encoder2.prototype.encodeObject = function(object, depth) {\n                var ext = this.extensionCodec.tryToEncode(object, this.context);\n                if (ext != null) {\n                  this.encodeExtension(ext);\n                } else if (Array.isArray(object)) {\n                  this.encodeArray(object, depth);\n                } else if (ArrayBuffer.isView(object)) {\n                  this.encodeBinary(object);\n                } else if (typeof object === \"object\") {\n                  this.encodeMap(object, depth);\n                } else {\n                  throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n                }\n              };\n              Encoder2.prototype.encodeBinary = function(object) {\n                var size = object.byteLength;\n                if (size < 256) {\n                  this.writeU8(196);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(197);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(198);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large binary: \" + size);\n                }\n                var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n                this.writeU8a(bytes);\n              };\n              Encoder2.prototype.encodeArray = function(object, depth) {\n                var size = object.length;\n                if (size < 16) {\n                  this.writeU8(144 + size);\n                } else if (size < 65536) {\n                  this.writeU8(220);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(221);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large array: \" + size);\n                }\n                for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                  var item = object_1[_i];\n                  this.doEncode(item, depth + 1);\n                }\n              };\n              Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                var count = 0;\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                  var key = keys_1[_i];\n                  if (object[key] !== void 0) {\n                    count++;\n                  }\n                }\n                return count;\n              };\n              Encoder2.prototype.encodeMap = function(object, depth) {\n                var keys = Object.keys(object);\n                if (this.sortKeys) {\n                  keys.sort();\n                }\n                var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                if (size < 16) {\n                  this.writeU8(128 + size);\n                } else if (size < 65536) {\n                  this.writeU8(222);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(223);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large map object: \" + size);\n                }\n                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                  var key = keys_2[_i];\n                  var value = object[key];\n                  if (!(this.ignoreUndefined && value === void 0)) {\n                    this.encodeString(key);\n                    this.doEncode(value, depth + 1);\n                  }\n                }\n              };\n              Encoder2.prototype.encodeExtension = function(ext) {\n                var size = ext.data.length;\n                if (size === 1) {\n                  this.writeU8(212);\n                } else if (size === 2) {\n                  this.writeU8(213);\n                } else if (size === 4) {\n                  this.writeU8(214);\n                } else if (size === 8) {\n                  this.writeU8(215);\n                } else if (size === 16) {\n                  this.writeU8(216);\n                } else if (size < 256) {\n                  this.writeU8(199);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(200);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(201);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large extension object: \" + size);\n                }\n                this.writeI8(ext.type);\n                this.writeU8a(ext.data);\n              };\n              Encoder2.prototype.writeU8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setUint8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU8a = function(values) {\n                var size = values.length;\n                this.ensureBufferSizeToWrite(size);\n                this.bytes.set(values, this.pos);\n                this.pos += size;\n              };\n              Encoder2.prototype.writeI8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setInt8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setUint16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeI16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setInt16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeU32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setUint32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeI32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setInt32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setFloat32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                this.view.setFloat64(this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeU64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeI64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              return Encoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: ExtData */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return ExtData;\n          });\n          var ExtData = (\n            /** @class */\n            function() {\n              function ExtData2(type, data) {\n                this.type = type;\n                this.data = data;\n              }\n              return ExtData2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n          \\***********************************************************************/\n        /*! exports provided: ExtensionCodec */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return ExtensionCodec;\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          var ExtensionCodec = (\n            /** @class */\n            function() {\n              function ExtensionCodec2() {\n                this.builtInEncoders = [];\n                this.builtInDecoders = [];\n                this.encoders = [];\n                this.decoders = [];\n                this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n              }\n              ExtensionCodec2.prototype.register = function(_a) {\n                var type = _a.type, encode = _a.encode, decode = _a.decode;\n                if (type >= 0) {\n                  this.encoders[type] = encode;\n                  this.decoders[type] = decode;\n                } else {\n                  var index = 1 + type;\n                  this.builtInEncoders[index] = encode;\n                  this.builtInDecoders[index] = decode;\n                }\n              };\n              ExtensionCodec2.prototype.tryToEncode = function(object, context) {\n                for (var i = 0; i < this.builtInEncoders.length; i++) {\n                  var encodeExt = this.builtInEncoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = -1 - i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                for (var i = 0; i < this.encoders.length; i++) {\n                  var encodeExt = this.encoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n                  return object;\n                }\n                return null;\n              };\n              ExtensionCodec2.prototype.decode = function(data, type, context) {\n                var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n                if (decodeExt) {\n                  return decodeExt(data, type, context);\n                } else {\n                  return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n              };\n              ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n              return ExtensionCodec2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"defaultDecodeOptions\", function() {\n            return defaultDecodeOptions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return decodeMulti;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var defaultDecodeOptions = {};\n          function decode(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decode(buffer);\n          }\n          function decodeMulti(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeMulti(buffer);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return decodeAsync;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return decodeArrayStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return decodeMultiStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return decodeStream;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/stream.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\"\n          );\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          function decodeAsync(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return __awaiter(this, void 0, void 0, function() {\n              var stream, decoder;\n              return __generator(this, function(_a) {\n                stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n                decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n                return [2, decoder.decodeAsync(stream)];\n              });\n            });\n          }\n          function decodeArrayStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeArrayStream(stream);\n          }\n          function decodeMultiStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeStream(stream);\n          }\n          function decodeStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return decodeMultiStream(streamLike, options);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: encode */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          var defaultEncodeOptions = {};\n          function encode(value, options) {\n            if (options === void 0) {\n              options = defaultEncodeOptions;\n            }\n            var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n            return encoder.encode(value);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n          \\**************************************************************/\n        /*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"];\n          });\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"];\n          });\n          var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decodeAsync.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"];\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"];\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"];\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"];\n          });\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"];\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"];\n          });\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"];\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return EXT_TIMESTAMP;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return encodeTimeSpecToTimestamp;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return encodeDateToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return encodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return decodeTimestampToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return decodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"timestampExtension\", function() {\n            return timestampExtension;\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var EXT_TIMESTAMP = -1;\n          var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n          var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n          function encodeTimeSpecToTimestamp(_a) {\n            var sec = _a.sec, nsec = _a.nsec;\n            if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n              if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                var rv = new Uint8Array(4);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, sec);\n                return rv;\n              } else {\n                var secHigh = sec / 4294967296;\n                var secLow = sec & 4294967295;\n                var rv = new Uint8Array(8);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec << 2 | secHigh & 3);\n                view.setUint32(4, secLow);\n                return rv;\n              }\n            } else {\n              var rv = new Uint8Array(12);\n              var view = new DataView(rv.buffer);\n              view.setUint32(0, nsec);\n              Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n              return rv;\n            }\n          }\n          function encodeDateToTimeSpec(date) {\n            var msec = date.getTime();\n            var sec = Math.floor(msec / 1e3);\n            var nsec = (msec - sec * 1e3) * 1e6;\n            var nsecInSec = Math.floor(nsec / 1e9);\n            return {\n              sec: sec + nsecInSec,\n              nsec: nsec - nsecInSec * 1e9\n            };\n          }\n          function encodeTimestampExtension(object) {\n            if (object instanceof Date) {\n              var timeSpec = encodeDateToTimeSpec(object);\n              return encodeTimeSpecToTimestamp(timeSpec);\n            } else {\n              return null;\n            }\n          }\n          function decodeTimestampToTimeSpec(data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            switch (data.byteLength) {\n              case 4: {\n                var sec = view.getUint32(0);\n                var nsec = 0;\n                return { sec, nsec };\n              }\n              case 8: {\n                var nsec30AndSecHigh2 = view.getUint32(0);\n                var secLow32 = view.getUint32(4);\n                var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                var nsec = nsec30AndSecHigh2 >>> 2;\n                return { sec, nsec };\n              }\n              case 12: {\n                var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n                var nsec = view.getUint32(0);\n                return { sec, nsec };\n              }\n              default:\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n            }\n          }\n          function decodeTimestampExtension(data) {\n            var timeSpec = decodeTimestampToTimeSpec(data);\n            return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n          }\n          var timestampExtension = {\n            type: EXT_TIMESTAMP,\n            encode: encodeTimestampExtension,\n            decode: decodeTimestampExtension\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"UINT32_MAX\", function() {\n            return UINT32_MAX;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setUint64\", function() {\n            return setUint64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setInt64\", function() {\n            return setInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getInt64\", function() {\n            return getInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getUint64\", function() {\n            return getUint64;\n          });\n          var UINT32_MAX = 4294967295;\n          function setUint64(view, offset, value) {\n            var high = value / 4294967296;\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function setInt64(view, offset, value) {\n            var high = Math.floor(value / 4294967296);\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function getInt64(view, offset) {\n            var high = view.getInt32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n          function getUint64(view, offset) {\n            var high = view.getUint32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: prettyByte */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"prettyByte\", function() {\n            return prettyByte;\n          });\n          function prettyByte(byte) {\n            return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n          \\*********************************************************************/\n        /*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isAsyncIterable\", function() {\n            return isAsyncIterable;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"asyncIterableFromStream\", function() {\n            return asyncIterableFromStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ensureAsyncIterable\", function() {\n            return ensureAsyncIterable;\n          });\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          function isAsyncIterable(object) {\n            return object[Symbol.asyncIterator] != null;\n          }\n          function assertNonNull(value) {\n            if (value == null) {\n              throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n            }\n          }\n          function asyncIterableFromStream(stream) {\n            return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n              var reader, _a, done, value;\n              return __generator(this, function(_b) {\n                switch (_b.label) {\n                  case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                  case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                  case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done)\n                      return [3, 5];\n                    return [4, __await(void 0)];\n                  case 4:\n                    return [2, _b.sent()];\n                  case 5:\n                    assertNonNull(value);\n                    return [4, __await(value)];\n                  case 6:\n                    return [4, _b.sent()];\n                  case 7:\n                    _b.sent();\n                    return [3, 2];\n                  case 8:\n                    return [3, 10];\n                  case 9:\n                    reader.releaseLock();\n                    return [\n                      7\n                      /*endfinally*/\n                    ];\n                  case 10:\n                    return [\n                      2\n                      /*return*/\n                    ];\n                }\n              });\n            });\n          }\n          function ensureAsyncIterable(streamLike) {\n            if (isAsyncIterable(streamLike)) {\n              return streamLike;\n            } else {\n              return asyncIterableFromStream(streamLike);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n        /*!**************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n          \\**************************************************************************/\n        /*! exports provided: ensureUint8Array, createDataView */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ensureUint8Array\", function() {\n            return ensureUint8Array;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"createDataView\", function() {\n            return createDataView;\n          });\n          function ensureUint8Array(buffer) {\n            if (buffer instanceof Uint8Array) {\n              return buffer;\n            } else if (ArrayBuffer.isView(buffer)) {\n              return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            } else if (buffer instanceof ArrayBuffer) {\n              return new Uint8Array(buffer);\n            } else {\n              return Uint8Array.from(buffer);\n            }\n          }\n          function createDataView(buffer) {\n            if (buffer instanceof ArrayBuffer) {\n              return new DataView(buffer);\n            }\n            var bufferView = ensureUint8Array(buffer);\n            return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n          \\*******************************************************************/\n        /*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"utf8Count\", function() {\n            return utf8Count;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeJs\", function() {\n            return utf8EncodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_ENCODER_THRESHOLD\", function() {\n            return TEXT_ENCODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeTE\", function() {\n            return utf8EncodeTE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeJs\", function() {\n            return utf8DecodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_DECODER_THRESHOLD\", function() {\n            return TEXT_DECODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeTD\", function() {\n            return utf8DecodeTD;\n          });\n          var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n          function utf8Count(str) {\n            var strLength = str.length;\n            var byteLength = 0;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                byteLength++;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                byteLength += 2;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  byteLength += 3;\n                } else {\n                  byteLength += 4;\n                }\n              }\n            }\n            return byteLength;\n          }\n          function utf8EncodeJs(str, output, outputOffset) {\n            var strLength = str.length;\n            var offset = outputOffset;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                output[offset++] = value;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                output[offset++] = value >> 6 & 31 | 192;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  output[offset++] = value >> 12 & 15 | 224;\n                  output[offset++] = value >> 6 & 63 | 128;\n                } else {\n                  output[offset++] = value >> 18 & 7 | 240;\n                  output[offset++] = value >> 12 & 63 | 128;\n                  output[offset++] = value >> 6 & 63 | 128;\n                }\n              }\n              output[offset++] = value & 63 | 128;\n            }\n          }\n          var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n          var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\" ? 200 : 0;\n          function utf8EncodeTEencode(str, output, outputOffset) {\n            output.set(sharedTextEncoder.encode(str), outputOffset);\n          }\n          function utf8EncodeTEencodeInto(str, output, outputOffset) {\n            sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n          }\n          var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n          var CHUNK_SIZE = 4096;\n          function utf8DecodeJs(bytes, inputOffset, byteLength) {\n            var offset = inputOffset;\n            var end = offset + byteLength;\n            var units = [];\n            var result = \"\";\n            while (offset < end) {\n              var byte1 = bytes[offset++];\n              if ((byte1 & 128) === 0) {\n                units.push(byte1);\n              } else if ((byte1 & 224) === 192) {\n                var byte2 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 6 | byte2);\n              } else if ((byte1 & 240) === 224) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n              } else if ((byte1 & 248) === 240) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                var byte4 = bytes[offset++] & 63;\n                var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                if (unit > 65535) {\n                  unit -= 65536;\n                  units.push(unit >>> 10 & 1023 | 55296);\n                  unit = 56320 | unit & 1023;\n                }\n                units.push(unit);\n              } else {\n                units.push(byte1);\n              }\n              if (units.length >= CHUNK_SIZE) {\n                result += String.fromCharCode.apply(String, units);\n                units.length = 0;\n              }\n            }\n            if (units.length > 0) {\n              result += String.fromCharCode.apply(String, units);\n            }\n            return result;\n          }\n          var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n          var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\" ? 200 : 0;\n          function utf8DecodeTD(bytes, inputOffset, byteLength) {\n            var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n            return sharedTextDecoder.decode(stringBytes);\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/rpc.js\": (\n        /*!**************************!*\\\n          !*** ./src/hypha/rpc.js ***!\n          \\**************************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @msgpack/msgpack */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\"\n          );\n          const API_VERSION = \"0.3.0\";\n          const CHUNK_SIZE = 1024 * 500;\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          function getFunctionInfo(func) {\n            const funcString = func.toString();\n            const nameMatch = funcString.match(/function\\s*(\\w*)/);\n            const name = nameMatch && nameMatch[1] || \"\";\n            const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n            let params = \"\";\n            if (paramsMatch) {\n              params = paramsMatch[1].split(\",\").map((p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n            }\n            let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n            const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n            docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n            const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n            const docstring = docstringBlock || docstringLine;\n            return name && params.length > 0 && {\n              name,\n              sig: params,\n              doc: docstring\n            };\n          }\n          function concatArrayBuffers(buffers) {\n            var buffersLengths = buffers.map(function(b) {\n              return b.byteLength;\n            }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n              return p + c;\n            }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n            buffersLengths.reduce(function(p, c, i) {\n              unit8Arr.set(new Uint8Array(buffers[i]), p);\n              return p + c;\n            }, 0);\n            return unit8Arr.buffer;\n          }\n          class Timer {\n            constructor(timeout, callback, args, label) {\n              this._timeout = timeout;\n              this._callback = callback;\n              this._args = args;\n              this._label = label || \"timer\";\n              this._task = null;\n              this.started = false;\n            }\n            start() {\n              if (this.started) {\n                this.reset();\n              } else {\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            clear() {\n              if (this._task) {\n                clearTimeout(this._task);\n                this._task = null;\n                this.started = false;\n              } else {\n                console.warn(`Clearing a timer (${this._label}) which is not started`);\n              }\n            }\n            reset() {\n              if (this._task) {\n                clearTimeout(this._task);\n              }\n              this._task = setTimeout(() => {\n                this._callback.apply(this, this._args);\n              }, this._timeout * 1e3);\n              this.started = true;\n            }\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, {\n              client_id = null,\n              manager_id = null,\n              default_context = null,\n              name = null,\n              codecs = null,\n              method_timeout = null,\n              max_message_buffer_size = 0,\n              debug = false,\n              workspace = null\n            }) {\n              super(debug);\n              this._codecs = codecs || {};\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n              this._client_id = client_id;\n              this._name = name;\n              this._connection_info = null;\n              this._workspace = null;\n              this._local_workspace = workspace;\n              this.manager_id = manager_id;\n              this.default_context = default_context || {};\n              this._method_annotations = /* @__PURE__ */ new WeakMap();\n              this._manager_service = null;\n              this._max_message_buffer_size = max_message_buffer_size;\n              this._chunk_store = {};\n              this._method_timeout = method_timeout || 30;\n              this._services = {};\n              this._object_store = {\n                services: this._services\n              };\n              if (connection) {\n                this.add_service({\n                  id: \"built-in\",\n                  type: \"built-in\",\n                  name: \"RPC built-in services\",\n                  config: {\n                    require_context: true,\n                    visibility: \"public\"\n                  },\n                  ping: this._ping.bind(this),\n                  get_service: this.get_local_service.bind(this),\n                  register_service: this.register_service.bind(this),\n                  message_cache: {\n                    create: this._create_message.bind(this),\n                    append: this._append_message.bind(this),\n                    process: this._process_message.bind(this),\n                    remove: this._remove_message.bind(this)\n                  }\n                });\n                this.on(\"method\", this._handle_method.bind(this));\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n                this._emit_message = connection.emit_message.bind(connection);\n                connection.on_message(this._on_message.bind(this));\n                this._connection = connection;\n                this._get_connection_info();\n              } else {\n                this._emit_message = function() {\n                  console.log(\"No connection to emit message\");\n                };\n              }\n            }\n            async _get_connection_info() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  this._connection_info = await this._manager_service.get_connection_info();\n                  if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n                    this._local_workspace = this._connection_info.workspace;\n                  }\n                  if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n                    this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n                    const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8;\n                    this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1e3);\n                  }\n                } catch (exp) {\n                  console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n                }\n              }\n            }\n            register_codec(config) {\n              if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n                throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n              } else {\n                if (config.type) {\n                  for (let k of Object.keys(this._codecs)) {\n                    if (this._codecs[k].type === config.type || k === config.name) {\n                      delete this._codecs[k];\n                      console.warn(\"Remove duplicated codec: \" + k);\n                    }\n                  }\n                }\n                this._codecs[config[\"name\"]] = config;\n              }\n            }\n            async _ping(msg, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n              return \"pong\";\n            }\n            async ping(client_id, timeout) {\n              let method = this._generate_remote_method({\n                _rtarget: client_id,\n                _rmethod: \"services.built-in.ping\",\n                _rpromise: true,\n                _rdoc: \"Ping a remote client\",\n                _rsig: \"ping(msg)\"\n              });\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(await method(\"ping\", timeout) == \"pong\");\n            }\n            _create_message(key, heartbeat, overwrite, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              if (!this._object_store[\"message_cache\"]) {\n                this._object_store[\"message_cache\"] = {};\n              }\n              if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n              }\n              this._object_store[\"message_cache\"][key] = [];\n            }\n            _append_message(key, data, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n              cache[key].push(data);\n            }\n            _remove_message(key, context) {\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              delete cache[key];\n            }\n            _process_message(key, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              cache[key] = concatArrayBuffers(cache[key]);\n              console.debug(`Processing message ${key} (size=${cache[key].length})`);\n              let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n              const {\n                done,\n                value\n              } = unpacker.next();\n              const main = value;\n              Object.assign(main, {\n                from: context.from,\n                to: context.to,\n                user: context.user\n              });\n              main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n              Object.assign(main[\"ctx\"], this.default_context);\n              if (!done) {\n                let extra = unpacker.next();\n                Object.assign(main, extra.value);\n              }\n              this._fire(main[\"type\"], main);\n              delete cache[key];\n            }\n            _on_message(message) {\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n                let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n                const {\n                  done,\n                  value\n                } = unpacker.next();\n                const main = value;\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n              } catch (error) {\n                console.error(error);\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._services = {};\n            }\n            async disconnect() {\n              if (this._get_connection_info_task) {\n                clearTimeout(this._get_connection_info_task);\n                this._get_connection_info_task = null;\n              }\n              this._fire(\"disconnect\");\n            }\n            async get_manager_service(timeout) {\n              if (this.manager_id && !this._manager_service) {\n                this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n              }\n            }\n            get_all_local_services() {\n              return this._services;\n            }\n            get_local_service(service_id, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n              const [ws, client_id] = context[\"to\"].split(\"/\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n              const service = this._services[service_id];\n              if (!service) {\n                throw new Error(\"Service not found: \" + service_id);\n              }\n              if (service.config.visibility == \"public\") {\n                return service;\n              }\n              if (context[\"from\"].startsWith(ws + \"/\")) {\n                return service;\n              }\n              throw new Error(\"Permission denied for service: \" + service_id);\n            }\n            async get_remote_service(service_uri, timeout) {\n              timeout = timeout === void 0 ? this._method_timeout : timeout;\n              if (!service_uri && this.manager_id) {\n                service_uri = this.manager_id;\n              } else if (!service_uri.includes(\":\")) {\n                service_uri = this._client_id + \":\" + service_uri;\n              }\n              const provider = service_uri.split(\":\")[0];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n              try {\n                const method = this._generate_remote_method({\n                  _rtarget: provider,\n                  _rmethod: \"services.built-in.get_service\",\n                  _rpromise: true,\n                  _rdoc: \"Get a remote service\",\n                  _rsig: \"get_service(service_id)\"\n                });\n                const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n                svc.id = service_uri;\n                return svc;\n              } catch (e) {\n                console.error(\"Failed to get remote service: \" + service_uri, e);\n                throw e;\n              }\n            }\n            _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n              if (typeof aObject === \"function\") {\n                let method_name = object_id.split(\".\")[1];\n                this._method_annotations.set(aObject, {\n                  require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                  run_in_executor,\n                  method_id: \"services.\" + object_id,\n                  visibility\n                });\n              } else if (aObject instanceof Array || aObject instanceof Object) {\n                for (let key of Object.keys(aObject)) {\n                  let val = aObject[key];\n                  if (typeof val === \"function\" && val.__rpc_object__) {\n                    let client_id = val.__rpc_object__._rtarget;\n                    if (client_id.includes(\"/\")) {\n                      client_id = client_id.split(\"/\")[1];\n                    }\n                    if (this._client_id === client_id) {\n                      if (aObject instanceof Array) {\n                        aObject = aObject.slice();\n                      }\n                      aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n                      val = aObject[key];\n                    } else {\n                      throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n                    }\n                  }\n                  this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n                }\n              }\n            }\n            add_service(api, overwrite) {\n              if (!api || Array.isArray(api))\n                throw new Error(\"Invalid service object\");\n              if (api.constructor === Object) {\n                api = Object.assign({}, api);\n              } else {\n                const normApi = {};\n                const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n                for (let k of props) {\n                  if (k !== \"constructor\") {\n                    if (typeof api[k] === \"function\")\n                      normApi[k] = api[k].bind(api);\n                    else\n                      normApi[k] = api[k];\n                  }\n                }\n                api.id = api.id || \"default\";\n                api = normApi;\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n              if (!api.name) {\n                api.name = api.id;\n              }\n              if (!api.config) {\n                api.config = {};\n              }\n              if (!api.type) {\n                api.type = \"generic\";\n              }\n              let require_context = false, run_in_executor = false;\n              if (api.config.require_context)\n                require_context = api.config.require_context;\n              if (api.config.run_in_executor)\n                run_in_executor = true;\n              const visibility = api.config.visibility || \"protected\";\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n              this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n              if (this._services[api.id]) {\n                if (overwrite) {\n                  delete this._services[api.id];\n                } else {\n                  throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n                }\n              }\n              this._services[api.id] = api;\n              return api;\n            }\n            async register_service(api, overwrite, notify, context) {\n              if (notify === void 0)\n                notify = true;\n              if (context) {\n                const [workspace, client_id] = context[\"to\"].split(\"/\");\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n              }\n              const service = this.add_service(api, overwrite);\n              if (notify) {\n                this._fire(\"service-updated\", {\n                  service_id: service[\"id\"],\n                  api: service,\n                  type: \"add\"\n                });\n                await this._notify_service_update();\n              }\n              return {\n                id: `${this._client_id}:${service[\"id\"]}`,\n                type: service[\"type\"],\n                name: service[\"name\"],\n                description: service[\"description\"] || \"\",\n                config: service[\"config\"]\n              };\n            }\n            async unregister_service(service, notify) {\n              if (service instanceof Object) {\n                service = service.id;\n              }\n              if (!this._services[service]) {\n                throw new Error(`Service not found: ${service}`);\n              }\n              const api = this._services[service];\n              delete this._services[service];\n              this._fire(\"service-updated\", {\n                service_id: service,\n                api,\n                type: \"remove\"\n              });\n              await this._notify_service_update();\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n              let method_id = `${session_id}.${name}`;\n              let encoded = {\n                _rtype: \"method\",\n                _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                _rmethod: method_id,\n                _rpromise: false\n              };\n              const self2 = this;\n              let wrapped_callback = function() {\n                try {\n                  callback.apply(null, Array.prototype.slice.call(arguments));\n                } catch (error) {\n                  console.error(\"Error in callback:\", method_id, error);\n                } finally {\n                  if (clear_after_called && self2._object_store[session_id]) {\n                    delete self2._object_store[session_id];\n                  }\n                  if (timer && timer.started) {\n                    timer.clear();\n                  }\n                }\n              };\n              return [encoded, wrapped_callback];\n            }\n            async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n              let store = this._get_session_store(session_id, true);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n              let encoded = {};\n              if (timer && reject && this._method_timeout) {\n                encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n                encoded.interval = this._method_timeout / 2;\n                store.timer = timer;\n              } else {\n                timer = null;\n              }\n              [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n              [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n              return encoded;\n            }\n            async _send_chunks(data, target_id, session_id) {\n              let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n              let message_cache = remote_services.message_cache;\n              let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n              await message_cache.create(message_id, !!session_id);\n              let total_size = data.length;\n              let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n              for (let idx = 0; idx < chunk_num; idx++) {\n                let start_byte = idx * CHUNK_SIZE;\n                await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id);\n              }\n              await message_cache.process(message_id, !!session_id);\n            }\n            emit(main_message, extra_data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n              let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n              if (extra_data) {\n                const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                message_package = new Uint8Array([...message_package, ...extra]);\n              }\n              const total_size = message_package.length;\n              if (total_size <= CHUNK_SIZE + 1024) {\n                return this._emit_message(message_package);\n              } else {\n                throw new Error(\"Message is too large to send in one go.\");\n              }\n            }\n            _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n              let target_id = encoded_method._rtarget;\n              if (remote_workspace && !target_id.includes(\"/\")) {\n                if (remote_workspace !== target_id) {\n                  target_id = remote_workspace + \"/\" + target_id;\n                }\n                encoded_method._rtarget = target_id;\n              }\n              let method_id = encoded_method._rmethod;\n              let with_promise = encoded_method._rpromise;\n              const self2 = this;\n              function remote_method() {\n                return new Promise(async (resolve, reject) => {\n                  let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  if (local_parent) {\n                    local_session_id = local_parent + \".\" + local_session_id;\n                  }\n                  let store = self2._get_session_store(local_session_id, true);\n                  if (!store) {\n                    reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n                    return;\n                  }\n                  store[\"target_id\"] = target_id;\n                  const args = await self2._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  let main_message = {\n                    type: \"method\",\n                    from: self2._local_workspace ? self2._local_workspace + \"/\" + self2._client_id : self2._client_id,\n                    to: target_id,\n                    method: method_id\n                  };\n                  let extra_data = {};\n                  if (args) {\n                    extra_data[\"args\"] = args;\n                  }\n                  if (withKwargs) {\n                    extra_data[\"with_kwargs\"] = withKwargs;\n                  }\n                  if (remote_parent) {\n                    main_message[\"parent\"] = remote_parent;\n                  }\n                  let timer = null;\n                  if (with_promise) {\n                    main_message[\"session\"] = local_session_id;\n                    let method_name = `${target_id}:${method_id}`;\n                    timer = new Timer(self2._method_timeout, reject, [`Method call time out: ${method_name}`], method_name);\n                    let clear_after_called = true;\n                    for (let arg of args) {\n                      if (typeof arg === \"object\" && arg._rintf === true) {\n                        clear_after_called = false;\n                        break;\n                      }\n                    }\n                    extra_data[\"promise\"] = await self2._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n                  }\n                  let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n                  if (extra_data) {\n                    const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                    message_package = new Uint8Array([...message_package, ...extra]);\n                  }\n                  const total_size = message_package.length;\n                  if (total_size <= CHUNK_SIZE + 1024) {\n                    self2._emit_message(message_package).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  } else {\n                    self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  }\n                });\n              }\n              remote_method.__rpc_object__ = encoded_method;\n              const parts = method_id.split(\".\");\n              remote_method.__name__ = parts[parts.length - 1];\n              remote_method.__doc__ = encoded_method._rdoc;\n              remote_method.__sig__ = encoded_method._rsig;\n              return remote_method;\n            }\n            async _notify_service_update() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  await this._manager_service.update_client_info(this.get_client_info());\n                } catch (exp) {\n                  console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n                }\n              }\n            }\n            get_client_info() {\n              const services = [];\n              for (let service of Object.values(this._services)) {\n                services.push({\n                  id: `${this._client_id}:${service[\"id\"]}`,\n                  type: service[\"type\"],\n                  name: service[\"name\"],\n                  description: service[\"description\"] || \"\",\n                  config: service[\"config\"]\n                });\n              }\n              return {\n                id: this._client_id,\n                services\n              };\n            }\n            async _handle_method(data) {\n              let reject = null;\n              let heartbeat_task = null;\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n                const method_name = data.from + \":\" + data.method;\n                const remote_workspace = data.from.split(\"/\")[0];\n                data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                data[\"ctx\"][\"to\"] = data[\"to\"];\n                const local_workspace = data.to.split(\"/\")[0];\n                const local_parent = data.parent;\n                let resolve, reject2;\n                if (data.promise) {\n                  const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n                  resolve = promise.resolve;\n                  reject2 = promise.reject;\n                  if (promise.heartbeat && promise.interval) {\n                    async function heartbeat() {\n                      try {\n                        await promise.heartbeat();\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                    heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                  }\n                }\n                let method;\n                try {\n                  method = indexObject(this._object_store, data[\"method\"]);\n                } catch (e) {\n                  console.debug(\"Failed to find method\", method_name, e);\n                  throw new Error(`Method not found: ${method_name}`);\n                }\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name);\n                if (this._method_annotations.has(method)) {\n                  if (this._method_annotations.get(method).visibility === \"protected\") {\n                    if (local_workspace !== remote_workspace) {\n                      throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n                    }\n                  }\n                } else {\n                  let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                  if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                    session_target_id = local_workspace + \"/\" + session_target_id;\n                  }\n                  if (session_target_id !== data.from) {\n                    throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n                  }\n                }\n                if (local_parent) {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n                }\n                let args;\n                if (data.args) {\n                  args = await this._decode(data.args, data.session, null, remote_workspace, null);\n                } else {\n                  args = [];\n                }\n                if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                  args.push(data.ctx);\n                }\n                if (data.promise) {\n                  const result = method.apply(null, args);\n                  if (result instanceof Promise) {\n                    result.then((result2) => {\n                      resolve(result2);\n                      clearInterval(heartbeat_task);\n                    }).catch((err) => {\n                      reject2(err);\n                      clearInterval(heartbeat_task);\n                    });\n                  } else {\n                    resolve(result);\n                    clearInterval(heartbeat_task);\n                  }\n                } else {\n                  method.apply(null, args);\n                  clearInterval(heartbeat_task);\n                }\n              } catch (err) {\n                if (reject) {\n                  reject(err);\n                  console.debug(\"Error during calling method: \", err);\n                } else {\n                  console.error(\"Error during calling method: \", err);\n                }\n                clearInterval(heartbeat_task);\n              }\n            }\n            encode(aObject, session_id) {\n              return this._encode(aObject, session_id);\n            }\n            _get_session_store(session_id, create) {\n              let store = this._object_store;\n              const levels = session_id.split(\".\");\n              if (create) {\n                const last_index = levels.length - 1;\n                for (let level of levels.slice(0, last_index)) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                if (!store[levels[last_index]]) {\n                  store[levels[last_index]] = {};\n                }\n                return store[levels[last_index]];\n              } else {\n                for (let level of levels) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                return store;\n              }\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, session_id, local_workspace) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                return aObject;\n              }\n              if (aObject instanceof ArrayBuffer) {\n                return {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject)\n                };\n              }\n              if (aObject.__rpc_object__) {\n                return aObject.__rpc_object__;\n              }\n              let bObject;\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                const temp = aObject._rtype;\n                delete aObject._rtype;\n                bObject = await this._encode(aObject, session_id, local_workspace);\n                bObject._rtype = temp;\n                return bObject;\n              }\n              if (typeof aObject === \"function\") {\n                if (this._method_annotations.has(aObject)) {\n                  let annotation = this._method_annotations.get(aObject);\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: annotation.method_id,\n                    _rpromise: true\n                  };\n                } else {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n                  let object_id;\n                  if (aObject.__name__) {\n                    object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n                  } else {\n                    object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  }\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: true\n                  };\n                  let store = this._get_session_store(session_id, true);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n                  store[object_id] = aObject;\n                }\n                bObject._rdoc = aObject.__doc__;\n                bObject._rsig = aObject.__sig__;\n                if (!bObject._rdoc || !bObject._rsig) {\n                  try {\n                    const funcInfo = getFunctionInfo(aObject);\n                    if (funcInfo && !bObject._rdoc) {\n                      bObject._rdoc = `${funcInfo.doc}`;\n                    }\n                    if (funcInfo && !bObject._rsig) {\n                      bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n                    }\n                  } catch (e) {\n                    console.error(\"Failed to extract function docstring:\", aObject);\n                  }\n                }\n                return bObject;\n              }\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (typeof encodedObj === \"object\") {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(v_buffer.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString(),\n                  _rtrace: aObject.stack\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (aObject instanceof Blob) {\n                let seek = function(pos) {\n                  _current_pos = pos;\n                };\n                let _current_pos = 0;\n                async function read(length) {\n                  let blob;\n                  if (length) {\n                    blob = aObject.slice(_current_pos, _current_pos + length);\n                  } else {\n                    blob = aObject.slice(_current_pos);\n                  }\n                  const ret = new Uint8Array(await blob.arrayBuffer());\n                  _current_pos = _current_pos + ret.byteLength;\n                  return ret;\n                }\n                bObject = {\n                  _rtype: \"iostream\",\n                  _rnative: \"js:blob\",\n                  type: aObject.type,\n                  name: aObject.name,\n                  size: aObject.size,\n                  path: aObject._path || aObject.webkitRelativePath,\n                  read: await this._encode(read, session_id, local_workspace),\n                  seek: await this._encode(seek, session_id, local_workspace)\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: new Uint8Array(aObject.buffer),\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject.buffer)\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                const keys = Object.keys(aObject);\n                for (let k of keys) {\n                  bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n                }\n              } else {\n                throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async decode(aObject) {\n              return await this._decode(aObject);\n            }\n            async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject._rtype) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  aObject._rtype = temp;\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"method\") {\n                  bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                  bObject = new arraytype(buffer);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                } else if (aObject._rtype === \"iostream\") {\n                  if (aObject._rnative === \"js:blob\") {\n                    const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n                    const bytes = await read();\n                    bObject = new Blob([bytes], {\n                      type: aObject.type,\n                      name: aObject.name\n                    });\n                  } else {\n                    bObject = {};\n                    for (let k of Object.keys(aObject)) {\n                      if (!k.startsWith(\"_\")) {\n                        bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n                      }\n                    }\n                  }\n                  bObject[\"__rpc_object__\"] = aObject;\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  bObject._rtype = temp;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              return bObject;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/utils.js\": (\n        /*!****************************!*\\\n          !*** ./src/hypha/utils.js ***!\n          \\****************************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_163997__) {\n          \"use strict\";\n          __nested_webpack_require_163997__.r(__nested_webpack_exports__);\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"assert\", function() {\n            return assert;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"waitFor\", function() {\n            return waitFor;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message || \"Assertion failed\");\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          function waitFor(prom, time, error) {\n            let timer;\n            return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n              rej(error || \"Timeout Error\");\n            }, time * 1e3))]).finally(() => clearTimeout(timer));\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/hypha-rpc.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js":
/*!***********************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js ***!
  \***********************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/socketIOMain.js\");\n    }({\n      /***/\n      \"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js\": (\n        /*!***********************************************************************************!*\\\n          !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!\n          \\***********************************************************************************/\n        /*! exports provided: decode, encode */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n          var lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\n          for (var i = 0; i < chars.length; i++) {\n            lookup[chars.charCodeAt(i)] = i;\n          }\n          var encode = function(arraybuffer) {\n            var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n            for (i2 = 0; i2 < len; i2 += 3) {\n              base64 += chars[bytes[i2] >> 2];\n              base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n              base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n              base64 += chars[bytes[i2 + 2] & 63];\n            }\n            if (len % 3 === 2) {\n              base64 = base64.substring(0, base64.length - 1) + \"=\";\n            } else if (len % 3 === 1) {\n              base64 = base64.substring(0, base64.length - 2) + \"==\";\n            }\n            return base64;\n          };\n          var decode = function(base64) {\n            var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;\n            if (base64[base64.length - 1] === \"=\") {\n              bufferLength--;\n              if (base64[base64.length - 2] === \"=\") {\n                bufferLength--;\n              }\n            }\n            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n            for (i2 = 0; i2 < len; i2 += 4) {\n              encoded1 = lookup[base64.charCodeAt(i2)];\n              encoded2 = lookup[base64.charCodeAt(i2 + 1)];\n              encoded3 = lookup[base64.charCodeAt(i2 + 2)];\n              encoded4 = lookup[base64.charCodeAt(i2 + 3)];\n              bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n              bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n              bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n            }\n            return arraybuffer;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@socket.io/component-emitter/index.mjs\": (\n        /*!*************************************************************!*\\\n          !*** ./node_modules/@socket.io/component-emitter/index.mjs ***!\n          \\*************************************************************/\n        /*! exports provided: Emitter */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Emitter\", function() {\n            return Emitter;\n          });\n          function Emitter(obj) {\n            if (obj)\n              return mixin(obj);\n          }\n          function mixin(obj) {\n            for (var key in Emitter.prototype) {\n              obj[key] = Emitter.prototype[key];\n            }\n            return obj;\n          }\n          Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {\n            this._callbacks = this._callbacks || {};\n            (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn);\n            return this;\n          };\n          Emitter.prototype.once = function(event, fn) {\n            function on() {\n              this.off(event, on);\n              fn.apply(this, arguments);\n            }\n            on.fn = fn;\n            this.on(event, on);\n            return this;\n          };\n          Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {\n            this._callbacks = this._callbacks || {};\n            if (0 == arguments.length) {\n              this._callbacks = {};\n              return this;\n            }\n            var callbacks = this._callbacks[\"$\" + event];\n            if (!callbacks)\n              return this;\n            if (1 == arguments.length) {\n              delete this._callbacks[\"$\" + event];\n              return this;\n            }\n            var cb;\n            for (var i = 0; i < callbacks.length; i++) {\n              cb = callbacks[i];\n              if (cb === fn || cb.fn === fn) {\n                callbacks.splice(i, 1);\n                break;\n              }\n            }\n            if (callbacks.length === 0) {\n              delete this._callbacks[\"$\" + event];\n            }\n            return this;\n          };\n          Emitter.prototype.emit = function(event) {\n            this._callbacks = this._callbacks || {};\n            var args = new Array(arguments.length - 1), callbacks = this._callbacks[\"$\" + event];\n            for (var i = 1; i < arguments.length; i++) {\n              args[i - 1] = arguments[i];\n            }\n            if (callbacks) {\n              callbacks = callbacks.slice(0);\n              for (var i = 0, len = callbacks.length; i < len; ++i) {\n                callbacks[i].apply(this, args);\n              }\n            }\n            return this;\n          };\n          Emitter.prototype.emitReserved = Emitter.prototype.emit;\n          Emitter.prototype.listeners = function(event) {\n            this._callbacks = this._callbacks || {};\n            return this._callbacks[\"$\" + event] || [];\n          };\n          Emitter.prototype.hasListeners = function(event) {\n            return !!this.listeners(event).length;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/base64-js/index.js\": (\n        /*!*****************************************!*\\\n          !*** ./node_modules/base64-js/index.js ***!\n          \\*****************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          exports2.byteLength = byteLength;\n          exports2.toByteArray = toByteArray;\n          exports2.fromByteArray = fromByteArray;\n          var lookup = [];\n          var revLookup = [];\n          var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n          var code2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n          for (var i = 0, len = code2.length; i < len; ++i) {\n            lookup[i] = code2[i];\n            revLookup[code2.charCodeAt(i)] = i;\n          }\n          revLookup[\"-\".charCodeAt(0)] = 62;\n          revLookup[\"_\".charCodeAt(0)] = 63;\n          function getLens(b64) {\n            var len2 = b64.length;\n            if (len2 % 4 > 0) {\n              throw new Error(\"Invalid string. Length must be a multiple of 4\");\n            }\n            var validLen = b64.indexOf(\"=\");\n            if (validLen === -1)\n              validLen = len2;\n            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n            return [validLen, placeHoldersLen];\n          }\n          function byteLength(b64) {\n            var lens = getLens(b64);\n            var validLen = lens[0];\n            var placeHoldersLen = lens[1];\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n          function _byteLength(b64, validLen, placeHoldersLen) {\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n          function toByteArray(b64) {\n            var tmp;\n            var lens = getLens(b64);\n            var validLen = lens[0];\n            var placeHoldersLen = lens[1];\n            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n            var curByte = 0;\n            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n            var i2;\n            for (i2 = 0; i2 < len2; i2 += 4) {\n              tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n              arr[curByte++] = tmp >> 16 & 255;\n              arr[curByte++] = tmp >> 8 & 255;\n              arr[curByte++] = tmp & 255;\n            }\n            if (placeHoldersLen === 2) {\n              tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n              arr[curByte++] = tmp & 255;\n            }\n            if (placeHoldersLen === 1) {\n              tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n              arr[curByte++] = tmp >> 8 & 255;\n              arr[curByte++] = tmp & 255;\n            }\n            return arr;\n          }\n          function tripletToBase64(num) {\n            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n          }\n          function encodeChunk(uint8, start, end) {\n            var tmp;\n            var output = [];\n            for (var i2 = start; i2 < end; i2 += 3) {\n              tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n              output.push(tripletToBase64(tmp));\n            }\n            return output.join(\"\");\n          }\n          function fromByteArray(uint8) {\n            var tmp;\n            var len2 = uint8.length;\n            var extraBytes = len2 % 3;\n            var parts = [];\n            var maxChunkLength = 16383;\n            for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n              parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n            }\n            if (extraBytes === 1) {\n              tmp = uint8[len2 - 1];\n              parts.push(\n                lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n              );\n            } else if (extraBytes === 2) {\n              tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n              parts.push(\n                lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n              );\n            }\n            return parts.join(\"\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/buffer/index.js\": (\n        /*!**************************************!*\\\n          !*** ./node_modules/buffer/index.js ***!\n          \\**************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          (function(global) {\n            /*!\n            * The buffer module from node.js, for the browser.\n            *\n            * @author   Feross Aboukhadijeh <http://feross.org>\n            * @license  MIT\n            */\n            var base64 = __webpack_require__2(\n              /*! base64-js */\n              \"./node_modules/base64-js/index.js\"\n            );\n            var ieee754 = __webpack_require__2(\n              /*! ieee754 */\n              \"./node_modules/ieee754/index.js\"\n            );\n            var isArray = __webpack_require__2(\n              /*! isarray */\n              \"./node_modules/isarray/index.js\"\n            );\n            exports2.Buffer = Buffer;\n            exports2.SlowBuffer = SlowBuffer;\n            exports2.INSPECT_MAX_BYTES = 50;\n            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n            exports2.kMaxLength = kMaxLength();\n            function typedArraySupport() {\n              try {\n                var arr = new Uint8Array(1);\n                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {\n                  return 42;\n                } };\n                return arr.foo() === 42 && // typed array instances can be augmented\n                typeof arr.subarray === \"function\" && // chrome 9-10 lack `subarray`\n                arr.subarray(1, 1).byteLength === 0;\n              } catch (e) {\n                return false;\n              }\n            }\n            function kMaxLength() {\n              return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\n            }\n            function createBuffer(that, length) {\n              if (kMaxLength() < length) {\n                throw new RangeError(\"Invalid typed array length\");\n              }\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                that = new Uint8Array(length);\n                that.__proto__ = Buffer.prototype;\n              } else {\n                if (that === null) {\n                  that = new Buffer(length);\n                }\n                that.length = length;\n              }\n              return that;\n            }\n            function Buffer(arg, encodingOrOffset, length) {\n              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n                return new Buffer(arg, encodingOrOffset, length);\n              }\n              if (typeof arg === \"number\") {\n                if (typeof encodingOrOffset === \"string\") {\n                  throw new Error(\n                    \"If encoding is specified then the first argument must be a string\"\n                  );\n                }\n                return allocUnsafe(this, arg);\n              }\n              return from(this, arg, encodingOrOffset, length);\n            }\n            Buffer.poolSize = 8192;\n            Buffer._augment = function(arr) {\n              arr.__proto__ = Buffer.prototype;\n              return arr;\n            };\n            function from(that, value, encodingOrOffset, length) {\n              if (typeof value === \"number\") {\n                throw new TypeError('\"value\" argument must not be a number');\n              }\n              if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n                return fromArrayBuffer(that, value, encodingOrOffset, length);\n              }\n              if (typeof value === \"string\") {\n                return fromString(that, value, encodingOrOffset);\n              }\n              return fromObject(that, value);\n            }\n            Buffer.from = function(value, encodingOrOffset, length) {\n              return from(null, value, encodingOrOffset, length);\n            };\n            if (Buffer.TYPED_ARRAY_SUPPORT) {\n              Buffer.prototype.__proto__ = Uint8Array.prototype;\n              Buffer.__proto__ = Uint8Array;\n              if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) {\n                Object.defineProperty(Buffer, Symbol.species, {\n                  value: null,\n                  configurable: true\n                });\n              }\n            }\n            function assertSize(size) {\n              if (typeof size !== \"number\") {\n                throw new TypeError('\"size\" argument must be a number');\n              } else if (size < 0) {\n                throw new RangeError('\"size\" argument must not be negative');\n              }\n            }\n            function alloc(that, size, fill, encoding) {\n              assertSize(size);\n              if (size <= 0) {\n                return createBuffer(that, size);\n              }\n              if (fill !== void 0) {\n                return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n              }\n              return createBuffer(that, size);\n            }\n            Buffer.alloc = function(size, fill, encoding) {\n              return alloc(null, size, fill, encoding);\n            };\n            function allocUnsafe(that, size) {\n              assertSize(size);\n              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n              if (!Buffer.TYPED_ARRAY_SUPPORT) {\n                for (var i = 0; i < size; ++i) {\n                  that[i] = 0;\n                }\n              }\n              return that;\n            }\n            Buffer.allocUnsafe = function(size) {\n              return allocUnsafe(null, size);\n            };\n            Buffer.allocUnsafeSlow = function(size) {\n              return allocUnsafe(null, size);\n            };\n            function fromString(that, string, encoding) {\n              if (typeof encoding !== \"string\" || encoding === \"\") {\n                encoding = \"utf8\";\n              }\n              if (!Buffer.isEncoding(encoding)) {\n                throw new TypeError('\"encoding\" must be a valid string encoding');\n              }\n              var length = byteLength(string, encoding) | 0;\n              that = createBuffer(that, length);\n              var actual = that.write(string, encoding);\n              if (actual !== length) {\n                that = that.slice(0, actual);\n              }\n              return that;\n            }\n            function fromArrayLike(that, array) {\n              var length = array.length < 0 ? 0 : checked(array.length) | 0;\n              that = createBuffer(that, length);\n              for (var i = 0; i < length; i += 1) {\n                that[i] = array[i] & 255;\n              }\n              return that;\n            }\n            function fromArrayBuffer(that, array, byteOffset, length) {\n              array.byteLength;\n              if (byteOffset < 0 || array.byteLength < byteOffset) {\n                throw new RangeError(\"'offset' is out of bounds\");\n              }\n              if (array.byteLength < byteOffset + (length || 0)) {\n                throw new RangeError(\"'length' is out of bounds\");\n              }\n              if (byteOffset === void 0 && length === void 0) {\n                array = new Uint8Array(array);\n              } else if (length === void 0) {\n                array = new Uint8Array(array, byteOffset);\n              } else {\n                array = new Uint8Array(array, byteOffset, length);\n              }\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                that = array;\n                that.__proto__ = Buffer.prototype;\n              } else {\n                that = fromArrayLike(that, array);\n              }\n              return that;\n            }\n            function fromObject(that, obj) {\n              if (Buffer.isBuffer(obj)) {\n                var len = checked(obj.length) | 0;\n                that = createBuffer(that, len);\n                if (that.length === 0) {\n                  return that;\n                }\n                obj.copy(that, 0, 0, len);\n                return that;\n              }\n              if (obj) {\n                if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n                  if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                    return createBuffer(that, 0);\n                  }\n                  return fromArrayLike(that, obj);\n                }\n                if (obj.type === \"Buffer\" && isArray(obj.data)) {\n                  return fromArrayLike(that, obj.data);\n                }\n              }\n              throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n            }\n            function checked(length) {\n              if (length >= kMaxLength()) {\n                throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n              }\n              return length | 0;\n            }\n            function SlowBuffer(length) {\n              if (+length != length) {\n                length = 0;\n              }\n              return Buffer.alloc(+length);\n            }\n            Buffer.isBuffer = function isBuffer(b) {\n              return !!(b != null && b._isBuffer);\n            };\n            Buffer.compare = function compare(a, b) {\n              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n                throw new TypeError(\"Arguments must be Buffers\");\n              }\n              if (a === b)\n                return 0;\n              var x = a.length;\n              var y = b.length;\n              for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n                if (a[i] !== b[i]) {\n                  x = a[i];\n                  y = b[i];\n                  break;\n                }\n              }\n              if (x < y)\n                return -1;\n              if (y < x)\n                return 1;\n              return 0;\n            };\n            Buffer.isEncoding = function isEncoding(encoding) {\n              switch (String(encoding).toLowerCase()) {\n                case \"hex\":\n                case \"utf8\":\n                case \"utf-8\":\n                case \"ascii\":\n                case \"latin1\":\n                case \"binary\":\n                case \"base64\":\n                case \"ucs2\":\n                case \"ucs-2\":\n                case \"utf16le\":\n                case \"utf-16le\":\n                  return true;\n                default:\n                  return false;\n              }\n            };\n            Buffer.concat = function concat(list, length) {\n              if (!isArray(list)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n              if (list.length === 0) {\n                return Buffer.alloc(0);\n              }\n              var i;\n              if (length === void 0) {\n                length = 0;\n                for (i = 0; i < list.length; ++i) {\n                  length += list[i].length;\n                }\n              }\n              var buffer = Buffer.allocUnsafe(length);\n              var pos = 0;\n              for (i = 0; i < list.length; ++i) {\n                var buf = list[i];\n                if (!Buffer.isBuffer(buf)) {\n                  throw new TypeError('\"list\" argument must be an Array of Buffers');\n                }\n                buf.copy(buffer, pos);\n                pos += buf.length;\n              }\n              return buffer;\n            };\n            function byteLength(string, encoding) {\n              if (Buffer.isBuffer(string)) {\n                return string.length;\n              }\n              if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n                return string.byteLength;\n              }\n              if (typeof string !== \"string\") {\n                string = \"\" + string;\n              }\n              var len = string.length;\n              if (len === 0)\n                return 0;\n              var loweredCase = false;\n              for (; ; ) {\n                switch (encoding) {\n                  case \"ascii\":\n                  case \"latin1\":\n                  case \"binary\":\n                    return len;\n                  case \"utf8\":\n                  case \"utf-8\":\n                  case void 0:\n                    return utf8ToBytes(string).length;\n                  case \"ucs2\":\n                  case \"ucs-2\":\n                  case \"utf16le\":\n                  case \"utf-16le\":\n                    return len * 2;\n                  case \"hex\":\n                    return len >>> 1;\n                  case \"base64\":\n                    return base64ToBytes(string).length;\n                  default:\n                    if (loweredCase)\n                      return utf8ToBytes(string).length;\n                    encoding = (\"\" + encoding).toLowerCase();\n                    loweredCase = true;\n                }\n              }\n            }\n            Buffer.byteLength = byteLength;\n            function slowToString(encoding, start, end) {\n              var loweredCase = false;\n              if (start === void 0 || start < 0) {\n                start = 0;\n              }\n              if (start > this.length) {\n                return \"\";\n              }\n              if (end === void 0 || end > this.length) {\n                end = this.length;\n              }\n              if (end <= 0) {\n                return \"\";\n              }\n              end >>>= 0;\n              start >>>= 0;\n              if (end <= start) {\n                return \"\";\n              }\n              if (!encoding)\n                encoding = \"utf8\";\n              while (true) {\n                switch (encoding) {\n                  case \"hex\":\n                    return hexSlice(this, start, end);\n                  case \"utf8\":\n                  case \"utf-8\":\n                    return utf8Slice(this, start, end);\n                  case \"ascii\":\n                    return asciiSlice(this, start, end);\n                  case \"latin1\":\n                  case \"binary\":\n                    return latin1Slice(this, start, end);\n                  case \"base64\":\n                    return base64Slice(this, start, end);\n                  case \"ucs2\":\n                  case \"ucs-2\":\n                  case \"utf16le\":\n                  case \"utf-16le\":\n                    return utf16leSlice(this, start, end);\n                  default:\n                    if (loweredCase)\n                      throw new TypeError(\"Unknown encoding: \" + encoding);\n                    encoding = (encoding + \"\").toLowerCase();\n                    loweredCase = true;\n                }\n              }\n            }\n            Buffer.prototype._isBuffer = true;\n            function swap(b, n, m) {\n              var i = b[n];\n              b[n] = b[m];\n              b[m] = i;\n            }\n            Buffer.prototype.swap16 = function swap16() {\n              var len = this.length;\n              if (len % 2 !== 0) {\n                throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n              }\n              for (var i = 0; i < len; i += 2) {\n                swap(this, i, i + 1);\n              }\n              return this;\n            };\n            Buffer.prototype.swap32 = function swap32() {\n              var len = this.length;\n              if (len % 4 !== 0) {\n                throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n              }\n              for (var i = 0; i < len; i += 4) {\n                swap(this, i, i + 3);\n                swap(this, i + 1, i + 2);\n              }\n              return this;\n            };\n            Buffer.prototype.swap64 = function swap64() {\n              var len = this.length;\n              if (len % 8 !== 0) {\n                throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n              }\n              for (var i = 0; i < len; i += 8) {\n                swap(this, i, i + 7);\n                swap(this, i + 1, i + 6);\n                swap(this, i + 2, i + 5);\n                swap(this, i + 3, i + 4);\n              }\n              return this;\n            };\n            Buffer.prototype.toString = function toString() {\n              var length = this.length | 0;\n              if (length === 0)\n                return \"\";\n              if (arguments.length === 0)\n                return utf8Slice(this, 0, length);\n              return slowToString.apply(this, arguments);\n            };\n            Buffer.prototype.equals = function equals(b) {\n              if (!Buffer.isBuffer(b))\n                throw new TypeError(\"Argument must be a Buffer\");\n              if (this === b)\n                return true;\n              return Buffer.compare(this, b) === 0;\n            };\n            Buffer.prototype.inspect = function inspect() {\n              var str = \"\";\n              var max = exports2.INSPECT_MAX_BYTES;\n              if (this.length > 0) {\n                str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n                if (this.length > max)\n                  str += \" ... \";\n              }\n              return \"<Buffer \" + str + \">\";\n            };\n            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n              if (!Buffer.isBuffer(target)) {\n                throw new TypeError(\"Argument must be a Buffer\");\n              }\n              if (start === void 0) {\n                start = 0;\n              }\n              if (end === void 0) {\n                end = target ? target.length : 0;\n              }\n              if (thisStart === void 0) {\n                thisStart = 0;\n              }\n              if (thisEnd === void 0) {\n                thisEnd = this.length;\n              }\n              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n                throw new RangeError(\"out of range index\");\n              }\n              if (thisStart >= thisEnd && start >= end) {\n                return 0;\n              }\n              if (thisStart >= thisEnd) {\n                return -1;\n              }\n              if (start >= end) {\n                return 1;\n              }\n              start >>>= 0;\n              end >>>= 0;\n              thisStart >>>= 0;\n              thisEnd >>>= 0;\n              if (this === target)\n                return 0;\n              var x = thisEnd - thisStart;\n              var y = end - start;\n              var len = Math.min(x, y);\n              var thisCopy = this.slice(thisStart, thisEnd);\n              var targetCopy = target.slice(start, end);\n              for (var i = 0; i < len; ++i) {\n                if (thisCopy[i] !== targetCopy[i]) {\n                  x = thisCopy[i];\n                  y = targetCopy[i];\n                  break;\n                }\n              }\n              if (x < y)\n                return -1;\n              if (y < x)\n                return 1;\n              return 0;\n            };\n            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n              if (buffer.length === 0)\n                return -1;\n              if (typeof byteOffset === \"string\") {\n                encoding = byteOffset;\n                byteOffset = 0;\n              } else if (byteOffset > 2147483647) {\n                byteOffset = 2147483647;\n              } else if (byteOffset < -2147483648) {\n                byteOffset = -2147483648;\n              }\n              byteOffset = +byteOffset;\n              if (isNaN(byteOffset)) {\n                byteOffset = dir ? 0 : buffer.length - 1;\n              }\n              if (byteOffset < 0)\n                byteOffset = buffer.length + byteOffset;\n              if (byteOffset >= buffer.length) {\n                if (dir)\n                  return -1;\n                else\n                  byteOffset = buffer.length - 1;\n              } else if (byteOffset < 0) {\n                if (dir)\n                  byteOffset = 0;\n                else\n                  return -1;\n              }\n              if (typeof val === \"string\") {\n                val = Buffer.from(val, encoding);\n              }\n              if (Buffer.isBuffer(val)) {\n                if (val.length === 0) {\n                  return -1;\n                }\n                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n              } else if (typeof val === \"number\") {\n                val = val & 255;\n                if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n                  if (dir) {\n                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                  } else {\n                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                  }\n                }\n                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n              }\n              throw new TypeError(\"val must be string, number or Buffer\");\n            }\n            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n              var indexSize = 1;\n              var arrLength = arr.length;\n              var valLength = val.length;\n              if (encoding !== void 0) {\n                encoding = String(encoding).toLowerCase();\n                if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n                  if (arr.length < 2 || val.length < 2) {\n                    return -1;\n                  }\n                  indexSize = 2;\n                  arrLength /= 2;\n                  valLength /= 2;\n                  byteOffset /= 2;\n                }\n              }\n              function read(buf, i2) {\n                if (indexSize === 1) {\n                  return buf[i2];\n                } else {\n                  return buf.readUInt16BE(i2 * indexSize);\n                }\n              }\n              var i;\n              if (dir) {\n                var foundIndex = -1;\n                for (i = byteOffset; i < arrLength; i++) {\n                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                    if (foundIndex === -1)\n                      foundIndex = i;\n                    if (i - foundIndex + 1 === valLength)\n                      return foundIndex * indexSize;\n                  } else {\n                    if (foundIndex !== -1)\n                      i -= i - foundIndex;\n                    foundIndex = -1;\n                  }\n                }\n              } else {\n                if (byteOffset + valLength > arrLength)\n                  byteOffset = arrLength - valLength;\n                for (i = byteOffset; i >= 0; i--) {\n                  var found = true;\n                  for (var j = 0; j < valLength; j++) {\n                    if (read(arr, i + j) !== read(val, j)) {\n                      found = false;\n                      break;\n                    }\n                  }\n                  if (found)\n                    return i;\n                }\n              }\n              return -1;\n            }\n            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n              return this.indexOf(val, byteOffset, encoding) !== -1;\n            };\n            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n            };\n            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n            };\n            function hexWrite(buf, string, offset, length) {\n              offset = Number(offset) || 0;\n              var remaining = buf.length - offset;\n              if (!length) {\n                length = remaining;\n              } else {\n                length = Number(length);\n                if (length > remaining) {\n                  length = remaining;\n                }\n              }\n              var strLen = string.length;\n              if (strLen % 2 !== 0)\n                throw new TypeError(\"Invalid hex string\");\n              if (length > strLen / 2) {\n                length = strLen / 2;\n              }\n              for (var i = 0; i < length; ++i) {\n                var parsed = parseInt(string.substr(i * 2, 2), 16);\n                if (isNaN(parsed))\n                  return i;\n                buf[offset + i] = parsed;\n              }\n              return i;\n            }\n            function utf8Write(buf, string, offset, length) {\n              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n            }\n            function asciiWrite(buf, string, offset, length) {\n              return blitBuffer(asciiToBytes(string), buf, offset, length);\n            }\n            function latin1Write(buf, string, offset, length) {\n              return asciiWrite(buf, string, offset, length);\n            }\n            function base64Write(buf, string, offset, length) {\n              return blitBuffer(base64ToBytes(string), buf, offset, length);\n            }\n            function ucs2Write(buf, string, offset, length) {\n              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n            }\n            Buffer.prototype.write = function write(string, offset, length, encoding) {\n              if (offset === void 0) {\n                encoding = \"utf8\";\n                length = this.length;\n                offset = 0;\n              } else if (length === void 0 && typeof offset === \"string\") {\n                encoding = offset;\n                length = this.length;\n                offset = 0;\n              } else if (isFinite(offset)) {\n                offset = offset | 0;\n                if (isFinite(length)) {\n                  length = length | 0;\n                  if (encoding === void 0)\n                    encoding = \"utf8\";\n                } else {\n                  encoding = length;\n                  length = void 0;\n                }\n              } else {\n                throw new Error(\n                  \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n                );\n              }\n              var remaining = this.length - offset;\n              if (length === void 0 || length > remaining)\n                length = remaining;\n              if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n                throw new RangeError(\"Attempt to write outside buffer bounds\");\n              }\n              if (!encoding)\n                encoding = \"utf8\";\n              var loweredCase = false;\n              for (; ; ) {\n                switch (encoding) {\n                  case \"hex\":\n                    return hexWrite(this, string, offset, length);\n                  case \"utf8\":\n                  case \"utf-8\":\n                    return utf8Write(this, string, offset, length);\n                  case \"ascii\":\n                    return asciiWrite(this, string, offset, length);\n                  case \"latin1\":\n                  case \"binary\":\n                    return latin1Write(this, string, offset, length);\n                  case \"base64\":\n                    return base64Write(this, string, offset, length);\n                  case \"ucs2\":\n                  case \"ucs-2\":\n                  case \"utf16le\":\n                  case \"utf-16le\":\n                    return ucs2Write(this, string, offset, length);\n                  default:\n                    if (loweredCase)\n                      throw new TypeError(\"Unknown encoding: \" + encoding);\n                    encoding = (\"\" + encoding).toLowerCase();\n                    loweredCase = true;\n                }\n              }\n            };\n            Buffer.prototype.toJSON = function toJSON() {\n              return {\n                type: \"Buffer\",\n                data: Array.prototype.slice.call(this._arr || this, 0)\n              };\n            };\n            function base64Slice(buf, start, end) {\n              if (start === 0 && end === buf.length) {\n                return base64.fromByteArray(buf);\n              } else {\n                return base64.fromByteArray(buf.slice(start, end));\n              }\n            }\n            function utf8Slice(buf, start, end) {\n              end = Math.min(buf.length, end);\n              var res = [];\n              var i = start;\n              while (i < end) {\n                var firstByte = buf[i];\n                var codePoint = null;\n                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n                if (i + bytesPerSequence <= end) {\n                  var secondByte, thirdByte, fourthByte, tempCodePoint;\n                  switch (bytesPerSequence) {\n                    case 1:\n                      if (firstByte < 128) {\n                        codePoint = firstByte;\n                      }\n                      break;\n                    case 2:\n                      secondByte = buf[i + 1];\n                      if ((secondByte & 192) === 128) {\n                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                        if (tempCodePoint > 127) {\n                          codePoint = tempCodePoint;\n                        }\n                      }\n                      break;\n                    case 3:\n                      secondByte = buf[i + 1];\n                      thirdByte = buf[i + 2];\n                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                          codePoint = tempCodePoint;\n                        }\n                      }\n                      break;\n                    case 4:\n                      secondByte = buf[i + 1];\n                      thirdByte = buf[i + 2];\n                      fourthByte = buf[i + 3];\n                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                          codePoint = tempCodePoint;\n                        }\n                      }\n                  }\n                }\n                if (codePoint === null) {\n                  codePoint = 65533;\n                  bytesPerSequence = 1;\n                } else if (codePoint > 65535) {\n                  codePoint -= 65536;\n                  res.push(codePoint >>> 10 & 1023 | 55296);\n                  codePoint = 56320 | codePoint & 1023;\n                }\n                res.push(codePoint);\n                i += bytesPerSequence;\n              }\n              return decodeCodePointsArray(res);\n            }\n            var MAX_ARGUMENTS_LENGTH = 4096;\n            function decodeCodePointsArray(codePoints) {\n              var len = codePoints.length;\n              if (len <= MAX_ARGUMENTS_LENGTH) {\n                return String.fromCharCode.apply(String, codePoints);\n              }\n              var res = \"\";\n              var i = 0;\n              while (i < len) {\n                res += String.fromCharCode.apply(\n                  String,\n                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n                );\n              }\n              return res;\n            }\n            function asciiSlice(buf, start, end) {\n              var ret = \"\";\n              end = Math.min(buf.length, end);\n              for (var i = start; i < end; ++i) {\n                ret += String.fromCharCode(buf[i] & 127);\n              }\n              return ret;\n            }\n            function latin1Slice(buf, start, end) {\n              var ret = \"\";\n              end = Math.min(buf.length, end);\n              for (var i = start; i < end; ++i) {\n                ret += String.fromCharCode(buf[i]);\n              }\n              return ret;\n            }\n            function hexSlice(buf, start, end) {\n              var len = buf.length;\n              if (!start || start < 0)\n                start = 0;\n              if (!end || end < 0 || end > len)\n                end = len;\n              var out = \"\";\n              for (var i = start; i < end; ++i) {\n                out += toHex(buf[i]);\n              }\n              return out;\n            }\n            function utf16leSlice(buf, start, end) {\n              var bytes = buf.slice(start, end);\n              var res = \"\";\n              for (var i = 0; i < bytes.length; i += 2) {\n                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n              }\n              return res;\n            }\n            Buffer.prototype.slice = function slice(start, end) {\n              var len = this.length;\n              start = ~~start;\n              end = end === void 0 ? len : ~~end;\n              if (start < 0) {\n                start += len;\n                if (start < 0)\n                  start = 0;\n              } else if (start > len) {\n                start = len;\n              }\n              if (end < 0) {\n                end += len;\n                if (end < 0)\n                  end = 0;\n              } else if (end > len) {\n                end = len;\n              }\n              if (end < start)\n                end = start;\n              var newBuf;\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                newBuf = this.subarray(start, end);\n                newBuf.__proto__ = Buffer.prototype;\n              } else {\n                var sliceLen = end - start;\n                newBuf = new Buffer(sliceLen, void 0);\n                for (var i = 0; i < sliceLen; ++i) {\n                  newBuf[i] = this[i + start];\n                }\n              }\n              return newBuf;\n            };\n            function checkOffset(offset, ext, length) {\n              if (offset % 1 !== 0 || offset < 0)\n                throw new RangeError(\"offset is not uint\");\n              if (offset + ext > length)\n                throw new RangeError(\"Trying to access beyond buffer length\");\n            }\n            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert)\n                checkOffset(offset, byteLength2, this.length);\n              var val = this[offset];\n              var mul = 1;\n              var i = 0;\n              while (++i < byteLength2 && (mul *= 256)) {\n                val += this[offset + i] * mul;\n              }\n              return val;\n            };\n            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert) {\n                checkOffset(offset, byteLength2, this.length);\n              }\n              var val = this[offset + --byteLength2];\n              var mul = 1;\n              while (byteLength2 > 0 && (mul *= 256)) {\n                val += this[offset + --byteLength2] * mul;\n              }\n              return val;\n            };\n            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 1, this.length);\n              return this[offset];\n            };\n            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              return this[offset] | this[offset + 1] << 8;\n            };\n            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              return this[offset] << 8 | this[offset + 1];\n            };\n            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n            };\n            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n            };\n            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert)\n                checkOffset(offset, byteLength2, this.length);\n              var val = this[offset];\n              var mul = 1;\n              var i = 0;\n              while (++i < byteLength2 && (mul *= 256)) {\n                val += this[offset + i] * mul;\n              }\n              mul *= 128;\n              if (val >= mul)\n                val -= Math.pow(2, 8 * byteLength2);\n              return val;\n            };\n            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert)\n                checkOffset(offset, byteLength2, this.length);\n              var i = byteLength2;\n              var mul = 1;\n              var val = this[offset + --i];\n              while (i > 0 && (mul *= 256)) {\n                val += this[offset + --i] * mul;\n              }\n              mul *= 128;\n              if (val >= mul)\n                val -= Math.pow(2, 8 * byteLength2);\n              return val;\n            };\n            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 1, this.length);\n              if (!(this[offset] & 128))\n                return this[offset];\n              return (255 - this[offset] + 1) * -1;\n            };\n            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              var val = this[offset] | this[offset + 1] << 8;\n              return val & 32768 ? val | 4294901760 : val;\n            };\n            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              var val = this[offset + 1] | this[offset] << 8;\n              return val & 32768 ? val | 4294901760 : val;\n            };\n            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n            };\n            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n            };\n            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return ieee754.read(this, offset, true, 23, 4);\n            };\n            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return ieee754.read(this, offset, false, 23, 4);\n            };\n            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 8, this.length);\n              return ieee754.read(this, offset, true, 52, 8);\n            };\n            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 8, this.length);\n              return ieee754.read(this, offset, false, 52, 8);\n            };\n            function checkInt(buf, value, offset, ext, max, min) {\n              if (!Buffer.isBuffer(buf))\n                throw new TypeError('\"buffer\" argument must be a Buffer instance');\n              if (value > max || value < min)\n                throw new RangeError('\"value\" argument is out of bounds');\n              if (offset + ext > buf.length)\n                throw new RangeError(\"Index out of range\");\n            }\n            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert) {\n                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n                checkInt(this, value, offset, byteLength2, maxBytes, 0);\n              }\n              var mul = 1;\n              var i = 0;\n              this[offset] = value & 255;\n              while (++i < byteLength2 && (mul *= 256)) {\n                this[offset + i] = value / mul & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert) {\n                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n                checkInt(this, value, offset, byteLength2, maxBytes, 0);\n              }\n              var i = byteLength2 - 1;\n              var mul = 1;\n              this[offset + i] = value & 255;\n              while (--i >= 0 && (mul *= 256)) {\n                this[offset + i] = value / mul & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 1, 255, 0);\n              if (!Buffer.TYPED_ARRAY_SUPPORT)\n                value = Math.floor(value);\n              this[offset] = value & 255;\n              return offset + 1;\n            };\n            function objectWriteUInt16(buf, value, offset, littleEndian) {\n              if (value < 0)\n                value = 65535 + value + 1;\n              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n                buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n              }\n            }\n            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 65535, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value & 255;\n                this[offset + 1] = value >>> 8;\n              } else {\n                objectWriteUInt16(this, value, offset, true);\n              }\n              return offset + 2;\n            };\n            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 65535, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 8;\n                this[offset + 1] = value & 255;\n              } else {\n                objectWriteUInt16(this, value, offset, false);\n              }\n              return offset + 2;\n            };\n            function objectWriteUInt32(buf, value, offset, littleEndian) {\n              if (value < 0)\n                value = 4294967295 + value + 1;\n              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n                buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;\n              }\n            }\n            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 4294967295, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset + 3] = value >>> 24;\n                this[offset + 2] = value >>> 16;\n                this[offset + 1] = value >>> 8;\n                this[offset] = value & 255;\n              } else {\n                objectWriteUInt32(this, value, offset, true);\n              }\n              return offset + 4;\n            };\n            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 4294967295, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 24;\n                this[offset + 1] = value >>> 16;\n                this[offset + 2] = value >>> 8;\n                this[offset + 3] = value & 255;\n              } else {\n                objectWriteUInt32(this, value, offset, false);\n              }\n              return offset + 4;\n            };\n            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert) {\n                var limit = Math.pow(2, 8 * byteLength2 - 1);\n                checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n              }\n              var i = 0;\n              var mul = 1;\n              var sub = 0;\n              this[offset] = value & 255;\n              while (++i < byteLength2 && (mul *= 256)) {\n                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                  sub = 1;\n                }\n                this[offset + i] = (value / mul >> 0) - sub & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert) {\n                var limit = Math.pow(2, 8 * byteLength2 - 1);\n                checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n              }\n              var i = byteLength2 - 1;\n              var mul = 1;\n              var sub = 0;\n              this[offset + i] = value & 255;\n              while (--i >= 0 && (mul *= 256)) {\n                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                  sub = 1;\n                }\n                this[offset + i] = (value / mul >> 0) - sub & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 1, 127, -128);\n              if (!Buffer.TYPED_ARRAY_SUPPORT)\n                value = Math.floor(value);\n              if (value < 0)\n                value = 255 + value + 1;\n              this[offset] = value & 255;\n              return offset + 1;\n            };\n            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 32767, -32768);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value & 255;\n                this[offset + 1] = value >>> 8;\n              } else {\n                objectWriteUInt16(this, value, offset, true);\n              }\n              return offset + 2;\n            };\n            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 32767, -32768);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 8;\n                this[offset + 1] = value & 255;\n              } else {\n                objectWriteUInt16(this, value, offset, false);\n              }\n              return offset + 2;\n            };\n            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 2147483647, -2147483648);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value & 255;\n                this[offset + 1] = value >>> 8;\n                this[offset + 2] = value >>> 16;\n                this[offset + 3] = value >>> 24;\n              } else {\n                objectWriteUInt32(this, value, offset, true);\n              }\n              return offset + 4;\n            };\n            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 2147483647, -2147483648);\n              if (value < 0)\n                value = 4294967295 + value + 1;\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 24;\n                this[offset + 1] = value >>> 16;\n                this[offset + 2] = value >>> 8;\n                this[offset + 3] = value & 255;\n              } else {\n                objectWriteUInt32(this, value, offset, false);\n              }\n              return offset + 4;\n            };\n            function checkIEEE754(buf, value, offset, ext, max, min) {\n              if (offset + ext > buf.length)\n                throw new RangeError(\"Index out of range\");\n              if (offset < 0)\n                throw new RangeError(\"Index out of range\");\n            }\n            function writeFloat(buf, value, offset, littleEndian, noAssert) {\n              if (!noAssert) {\n                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n              }\n              ieee754.write(buf, value, offset, littleEndian, 23, 4);\n              return offset + 4;\n            }\n            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n              return writeFloat(this, value, offset, true, noAssert);\n            };\n            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n              return writeFloat(this, value, offset, false, noAssert);\n            };\n            function writeDouble(buf, value, offset, littleEndian, noAssert) {\n              if (!noAssert) {\n                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n              }\n              ieee754.write(buf, value, offset, littleEndian, 52, 8);\n              return offset + 8;\n            }\n            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n              return writeDouble(this, value, offset, true, noAssert);\n            };\n            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n              return writeDouble(this, value, offset, false, noAssert);\n            };\n            Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n              if (!start)\n                start = 0;\n              if (!end && end !== 0)\n                end = this.length;\n              if (targetStart >= target.length)\n                targetStart = target.length;\n              if (!targetStart)\n                targetStart = 0;\n              if (end > 0 && end < start)\n                end = start;\n              if (end === start)\n                return 0;\n              if (target.length === 0 || this.length === 0)\n                return 0;\n              if (targetStart < 0) {\n                throw new RangeError(\"targetStart out of bounds\");\n              }\n              if (start < 0 || start >= this.length)\n                throw new RangeError(\"sourceStart out of bounds\");\n              if (end < 0)\n                throw new RangeError(\"sourceEnd out of bounds\");\n              if (end > this.length)\n                end = this.length;\n              if (target.length - targetStart < end - start) {\n                end = target.length - targetStart + start;\n              }\n              var len = end - start;\n              var i;\n              if (this === target && start < targetStart && targetStart < end) {\n                for (i = len - 1; i >= 0; --i) {\n                  target[i + targetStart] = this[i + start];\n                }\n              } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {\n                for (i = 0; i < len; ++i) {\n                  target[i + targetStart] = this[i + start];\n                }\n              } else {\n                Uint8Array.prototype.set.call(\n                  target,\n                  this.subarray(start, start + len),\n                  targetStart\n                );\n              }\n              return len;\n            };\n            Buffer.prototype.fill = function fill(val, start, end, encoding) {\n              if (typeof val === \"string\") {\n                if (typeof start === \"string\") {\n                  encoding = start;\n                  start = 0;\n                  end = this.length;\n                } else if (typeof end === \"string\") {\n                  encoding = end;\n                  end = this.length;\n                }\n                if (val.length === 1) {\n                  var code2 = val.charCodeAt(0);\n                  if (code2 < 256) {\n                    val = code2;\n                  }\n                }\n                if (encoding !== void 0 && typeof encoding !== \"string\") {\n                  throw new TypeError(\"encoding must be a string\");\n                }\n                if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n                  throw new TypeError(\"Unknown encoding: \" + encoding);\n                }\n              } else if (typeof val === \"number\") {\n                val = val & 255;\n              }\n              if (start < 0 || this.length < start || this.length < end) {\n                throw new RangeError(\"Out of range index\");\n              }\n              if (end <= start) {\n                return this;\n              }\n              start = start >>> 0;\n              end = end === void 0 ? this.length : end >>> 0;\n              if (!val)\n                val = 0;\n              var i;\n              if (typeof val === \"number\") {\n                for (i = start; i < end; ++i) {\n                  this[i] = val;\n                }\n              } else {\n                var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n                var len = bytes.length;\n                for (i = 0; i < end - start; ++i) {\n                  this[i + start] = bytes[i % len];\n                }\n              }\n              return this;\n            };\n            var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n            function base64clean(str) {\n              str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n              if (str.length < 2)\n                return \"\";\n              while (str.length % 4 !== 0) {\n                str = str + \"=\";\n              }\n              return str;\n            }\n            function stringtrim(str) {\n              if (str.trim)\n                return str.trim();\n              return str.replace(/^\\s+|\\s+$/g, \"\");\n            }\n            function toHex(n) {\n              if (n < 16)\n                return \"0\" + n.toString(16);\n              return n.toString(16);\n            }\n            function utf8ToBytes(string, units) {\n              units = units || Infinity;\n              var codePoint;\n              var length = string.length;\n              var leadSurrogate = null;\n              var bytes = [];\n              for (var i = 0; i < length; ++i) {\n                codePoint = string.charCodeAt(i);\n                if (codePoint > 55295 && codePoint < 57344) {\n                  if (!leadSurrogate) {\n                    if (codePoint > 56319) {\n                      if ((units -= 3) > -1)\n                        bytes.push(239, 191, 189);\n                      continue;\n                    } else if (i + 1 === length) {\n                      if ((units -= 3) > -1)\n                        bytes.push(239, 191, 189);\n                      continue;\n                    }\n                    leadSurrogate = codePoint;\n                    continue;\n                  }\n                  if (codePoint < 56320) {\n                    if ((units -= 3) > -1)\n                      bytes.push(239, 191, 189);\n                    leadSurrogate = codePoint;\n                    continue;\n                  }\n                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n                } else if (leadSurrogate) {\n                  if ((units -= 3) > -1)\n                    bytes.push(239, 191, 189);\n                }\n                leadSurrogate = null;\n                if (codePoint < 128) {\n                  if ((units -= 1) < 0)\n                    break;\n                  bytes.push(codePoint);\n                } else if (codePoint < 2048) {\n                  if ((units -= 2) < 0)\n                    break;\n                  bytes.push(\n                    codePoint >> 6 | 192,\n                    codePoint & 63 | 128\n                  );\n                } else if (codePoint < 65536) {\n                  if ((units -= 3) < 0)\n                    break;\n                  bytes.push(\n                    codePoint >> 12 | 224,\n                    codePoint >> 6 & 63 | 128,\n                    codePoint & 63 | 128\n                  );\n                } else if (codePoint < 1114112) {\n                  if ((units -= 4) < 0)\n                    break;\n                  bytes.push(\n                    codePoint >> 18 | 240,\n                    codePoint >> 12 & 63 | 128,\n                    codePoint >> 6 & 63 | 128,\n                    codePoint & 63 | 128\n                  );\n                } else {\n                  throw new Error(\"Invalid code point\");\n                }\n              }\n              return bytes;\n            }\n            function asciiToBytes(str) {\n              var byteArray = [];\n              for (var i = 0; i < str.length; ++i) {\n                byteArray.push(str.charCodeAt(i) & 255);\n              }\n              return byteArray;\n            }\n            function utf16leToBytes(str, units) {\n              var c, hi, lo;\n              var byteArray = [];\n              for (var i = 0; i < str.length; ++i) {\n                if ((units -= 2) < 0)\n                  break;\n                c = str.charCodeAt(i);\n                hi = c >> 8;\n                lo = c % 256;\n                byteArray.push(lo);\n                byteArray.push(hi);\n              }\n              return byteArray;\n            }\n            function base64ToBytes(str) {\n              return base64.toByteArray(base64clean(str));\n            }\n            function blitBuffer(src, dst, offset, length) {\n              for (var i = 0; i < length; ++i) {\n                if (i + offset >= dst.length || i >= src.length)\n                  break;\n                dst[i + offset] = src[i];\n              }\n              return i;\n            }\n            function isnan(val) {\n              return val !== val;\n            }\n          }).call(this, __webpack_require__2(\n            /*! ./../webpack/buildin/global.js */\n            \"./node_modules/webpack/buildin/global.js\"\n          ));\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/has-cors.js\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/has-cors.js ***!\n          \\*********************************************************************/\n        /*! exports provided: hasCORS */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"hasCORS\", function() {\n            return hasCORS;\n          });\n          let value = false;\n          try {\n            value = typeof XMLHttpRequest !== \"undefined\" && \"withCredentials\" in new XMLHttpRequest();\n          } catch (err) {\n          }\n          const hasCORS = value;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/parseqs.js ***!\n          \\********************************************************************/\n        /*! exports provided: encode, decode */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          function encode(obj) {\n            let str = \"\";\n            for (let i in obj) {\n              if (obj.hasOwnProperty(i)) {\n                if (str.length)\n                  str += \"&\";\n                str += encodeURIComponent(i) + \"=\" + encodeURIComponent(obj[i]);\n              }\n            }\n            return str;\n          }\n          function decode(qs) {\n            let qry = {};\n            let pairs = qs.split(\"&\");\n            for (let i = 0, l = pairs.length; i < l; i++) {\n              let pair = pairs[i].split(\"=\");\n              qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n            }\n            return qry;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/parseuri.js ***!\n          \\*********************************************************************/\n        /*! exports provided: parse */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"parse\", function() {\n            return parse;\n          });\n          const re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n          const parts = [\n            \"source\",\n            \"protocol\",\n            \"authority\",\n            \"userInfo\",\n            \"user\",\n            \"password\",\n            \"host\",\n            \"port\",\n            \"relative\",\n            \"path\",\n            \"directory\",\n            \"file\",\n            \"query\",\n            \"anchor\"\n          ];\n          function parse(str) {\n            const src = str, b = str.indexOf(\"[\"), e = str.indexOf(\"]\");\n            if (b != -1 && e != -1) {\n              str = str.substring(0, b) + str.substring(b, e).replace(/:/g, \";\") + str.substring(e, str.length);\n            }\n            let m = re.exec(str || \"\"), uri = {}, i = 14;\n            while (i--) {\n              uri[parts[i]] = m[i] || \"\";\n            }\n            if (b != -1 && e != -1) {\n              uri.source = src;\n              uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \":\");\n              uri.authority = uri.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\");\n              uri.ipv6uri = true;\n            }\n            uri.pathNames = pathNames(uri, uri[\"path\"]);\n            uri.queryKey = queryKey(uri, uri[\"query\"]);\n            return uri;\n          }\n          function pathNames(obj, path) {\n            const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n            if (path.slice(0, 1) == \"/\" || path.length === 0) {\n              names.splice(0, 1);\n            }\n            if (path.slice(-1) == \"/\") {\n              names.splice(names.length - 1, 1);\n            }\n            return names;\n          }\n          function queryKey(uri, query) {\n            const data = {};\n            query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {\n              if ($1) {\n                data[$1] = $2;\n              }\n            });\n            return data;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/yeast.js ***!\n          \\******************************************************************/\n        /*! exports provided: encode, decode, yeast */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"yeast\", function() {\n            return yeast;\n          });\n          const alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\n          let seed = 0, i = 0, prev;\n          function encode(num) {\n            let encoded = \"\";\n            do {\n              encoded = alphabet[num % length] + encoded;\n              num = Math.floor(num / length);\n            } while (num > 0);\n            return encoded;\n          }\n          function decode(str) {\n            let decoded = 0;\n            for (i = 0; i < str.length; i++) {\n              decoded = decoded * length + map[str.charAt(i)];\n            }\n            return decoded;\n          }\n          function yeast() {\n            const now = encode(+/* @__PURE__ */ new Date());\n            if (now !== prev)\n              return seed = 0, prev = now;\n            return now + \".\" + encode(seed++);\n          }\n          for (; i < length; i++)\n            map[alphabet[i]] = i;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/globalThis.browser.js ***!\n          \\***********************************************************************/\n        /*! exports provided: globalThisShim */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"globalThisShim\", function() {\n            return globalThisShim;\n          });\n          const globalThisShim = (() => {\n            if (typeof self !== \"undefined\") {\n              return self;\n            } else if (typeof window !== \"undefined\") {\n              return window;\n            } else {\n              return Function(\"return this\")();\n            }\n          })();\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: Socket, protocol, Transport, transports, installTimerFunctions, parse, nextTick */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return protocol;\n          });\n          var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./socket.js */\n            \"./node_modules/engine.io-client/build/esm/socket.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return _socket_js__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"];\n          });\n          var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./transport.js */\n            \"./node_modules/engine.io-client/build/esm/transport.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Transport\", function() {\n            return _transport_js__WEBPACK_IMPORTED_MODULE_1__[\"Transport\"];\n          });\n          var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./transports/index.js */\n            \"./node_modules/engine.io-client/build/esm/transports/index.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"transports\", function() {\n            return _transports_index_js__WEBPACK_IMPORTED_MODULE_2__[\"transports\"];\n          });\n          var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"installTimerFunctions\", function() {\n            return _util_js__WEBPACK_IMPORTED_MODULE_3__[\"installTimerFunctions\"];\n          });\n          var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./contrib/parseuri.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"parse\", function() {\n            return _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__[\"parse\"];\n          });\n          var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./transports/websocket-constructor.js */\n            \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"nextTick\", function() {\n            return _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__[\"nextTick\"];\n          });\n          const protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"].protocol;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/socket.js\": (\n        /*!***********************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/socket.js ***!\n          \\***********************************************************/\n        /*! exports provided: Socket */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return Socket;\n          });\n          var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./transports/index.js */\n            \"./node_modules/engine.io-client/build/esm/transports/index.js\"\n          );\n          var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./contrib/parseqs.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\"\n          );\n          var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./contrib/parseuri.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! engine.io-parser */\n            \"./node_modules/engine.io-parser/build/esm/index.js\"\n          );\n          class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__[\"Emitter\"] {\n            /**\n             * Socket constructor.\n             *\n             * @param {String|Object} uri - uri or options\n             * @param {Object} opts - options\n             */\n            constructor(uri, opts = {}) {\n              super();\n              this.writeBuffer = [];\n              if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = null;\n              }\n              if (uri) {\n                uri = Object(_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(uri);\n                opts.hostname = uri.host;\n                opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n                opts.port = uri.port;\n                if (uri.query)\n                  opts.query = uri.query;\n              } else if (opts.host) {\n                opts.hostname = Object(_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(opts.host).host;\n              }\n              Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"installTimerFunctions\"])(this, opts);\n              this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n              if (opts.hostname && !opts.port) {\n                opts.port = this.secure ? \"443\" : \"80\";\n              }\n              this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n              this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : this.secure ? \"443\" : \"80\");\n              this.transports = opts.transports || [\"polling\", \"websocket\"];\n              this.writeBuffer = [];\n              this.prevBufferLen = 0;\n              this.opts = Object.assign({\n                path: \"/engine.io\",\n                agent: false,\n                withCredentials: false,\n                upgrade: true,\n                timestampParam: \"t\",\n                rememberUpgrade: false,\n                addTrailingSlash: true,\n                rejectUnauthorized: true,\n                perMessageDeflate: {\n                  threshold: 1024\n                },\n                transportOptions: {},\n                closeOnBeforeunload: true\n              }, opts);\n              this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\");\n              if (typeof this.opts.query === \"string\") {\n                this.opts.query = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__[\"decode\"])(this.opts.query);\n              }\n              this.id = null;\n              this.upgrades = null;\n              this.pingInterval = null;\n              this.pingTimeout = null;\n              this.pingTimeoutTimer = null;\n              if (typeof addEventListener === \"function\") {\n                if (this.opts.closeOnBeforeunload) {\n                  this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                      this.transport.removeAllListeners();\n                      this.transport.close();\n                    }\n                  };\n                  addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                }\n                if (this.hostname !== \"localhost\") {\n                  this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                      description: \"network connection lost\"\n                    });\n                  };\n                  addEventListener(\"offline\", this.offlineEventListener, false);\n                }\n              }\n              this.open();\n            }\n            /**\n             * Creates transport of the given type.\n             *\n             * @param {String} name - transport name\n             * @return {Transport}\n             * @private\n             */\n            createTransport(name) {\n              const query = Object.assign({}, this.opts.query);\n              query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"protocol\"];\n              query.transport = name;\n              if (this.id)\n                query.sid = this.id;\n              const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n                query,\n                socket: this,\n                hostname: this.hostname,\n                secure: this.secure,\n                port: this.port\n              });\n              return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__[\"transports\"][name](opts);\n            }\n            /**\n             * Initializes transport to use and starts probe.\n             *\n             * @private\n             */\n            open() {\n              let transport;\n              if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) {\n                transport = \"websocket\";\n              } else if (0 === this.transports.length) {\n                this.setTimeoutFn(() => {\n                  this.emitReserved(\"error\", \"No transports available\");\n                }, 0);\n                return;\n              } else {\n                transport = this.transports[0];\n              }\n              this.readyState = \"opening\";\n              try {\n                transport = this.createTransport(transport);\n              } catch (e) {\n                this.transports.shift();\n                this.open();\n                return;\n              }\n              transport.open();\n              this.setTransport(transport);\n            }\n            /**\n             * Sets the current transport. Disables the existing one (if any).\n             *\n             * @private\n             */\n            setTransport(transport) {\n              if (this.transport) {\n                this.transport.removeAllListeners();\n              }\n              this.transport = transport;\n              transport.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n            }\n            /**\n             * Probes a transport.\n             *\n             * @param {String} name - transport name\n             * @private\n             */\n            probe(name) {\n              let transport = this.createTransport(name);\n              let failed = false;\n              Socket.priorWebsocketSuccess = false;\n              const onTransportOpen = () => {\n                if (failed)\n                  return;\n                transport.send([{ type: \"ping\", data: \"probe\" }]);\n                transport.once(\"packet\", (msg) => {\n                  if (failed)\n                    return;\n                  if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                      return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                      if (failed)\n                        return;\n                      if (\"closed\" === this.readyState)\n                        return;\n                      cleanup();\n                      this.setTransport(transport);\n                      transport.send([{ type: \"upgrade\" }]);\n                      this.emitReserved(\"upgrade\", transport);\n                      transport = null;\n                      this.upgrading = false;\n                      this.flush();\n                    });\n                  } else {\n                    const err = new Error(\"probe error\");\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                  }\n                });\n              };\n              function freezeTransport() {\n                if (failed)\n                  return;\n                failed = true;\n                cleanup();\n                transport.close();\n                transport = null;\n              }\n              const onerror = (err) => {\n                const error = new Error(\"probe error: \" + err);\n                error.transport = transport.name;\n                freezeTransport();\n                this.emitReserved(\"upgradeError\", error);\n              };\n              function onTransportClose() {\n                onerror(\"transport closed\");\n              }\n              function onclose() {\n                onerror(\"socket closed\");\n              }\n              function onupgrade(to) {\n                if (transport && to.name !== transport.name) {\n                  freezeTransport();\n                }\n              }\n              const cleanup = () => {\n                transport.removeListener(\"open\", onTransportOpen);\n                transport.removeListener(\"error\", onerror);\n                transport.removeListener(\"close\", onTransportClose);\n                this.off(\"close\", onclose);\n                this.off(\"upgrading\", onupgrade);\n              };\n              transport.once(\"open\", onTransportOpen);\n              transport.once(\"error\", onerror);\n              transport.once(\"close\", onTransportClose);\n              this.once(\"close\", onclose);\n              this.once(\"upgrading\", onupgrade);\n              transport.open();\n            }\n            /**\n             * Called when connection is deemed open.\n             *\n             * @private\n             */\n            onOpen() {\n              this.readyState = \"open\";\n              Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n              this.emitReserved(\"open\");\n              this.flush();\n              if (\"open\" === this.readyState && this.opts.upgrade) {\n                let i = 0;\n                const l = this.upgrades.length;\n                for (; i < l; i++) {\n                  this.probe(this.upgrades[i]);\n                }\n              }\n            }\n            /**\n             * Handles a packet.\n             *\n             * @private\n             */\n            onPacket(packet) {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                this.emitReserved(\"packet\", packet);\n                this.emitReserved(\"heartbeat\");\n                switch (packet.type) {\n                  case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                  case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                  case \"error\":\n                    const err = new Error(\"server error\");\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                  case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n                }\n              } else {\n              }\n            }\n            /**\n             * Called upon handshake completion.\n             *\n             * @param {Object} data - handshake obj\n             * @private\n             */\n            onHandshake(data) {\n              this.emitReserved(\"handshake\", data);\n              this.id = data.sid;\n              this.transport.query.sid = data.sid;\n              this.upgrades = this.filterUpgrades(data.upgrades);\n              this.pingInterval = data.pingInterval;\n              this.pingTimeout = data.pingTimeout;\n              this.maxPayload = data.maxPayload;\n              this.onOpen();\n              if (\"closed\" === this.readyState)\n                return;\n              this.resetPingTimeout();\n            }\n            /**\n             * Sets and resets ping timeout timer based on server pings.\n             *\n             * @private\n             */\n            resetPingTimeout() {\n              this.clearTimeoutFn(this.pingTimeoutTimer);\n              this.pingTimeoutTimer = this.setTimeoutFn(() => {\n                this.onClose(\"ping timeout\");\n              }, this.pingInterval + this.pingTimeout);\n              if (this.opts.autoUnref) {\n                this.pingTimeoutTimer.unref();\n              }\n            }\n            /**\n             * Called on `drain` event\n             *\n             * @private\n             */\n            onDrain() {\n              this.writeBuffer.splice(0, this.prevBufferLen);\n              this.prevBufferLen = 0;\n              if (0 === this.writeBuffer.length) {\n                this.emitReserved(\"drain\");\n              } else {\n                this.flush();\n              }\n            }\n            /**\n             * Flush write buffers.\n             *\n             * @private\n             */\n            flush() {\n              if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n                const packets = this.getWritablePackets();\n                this.transport.send(packets);\n                this.prevBufferLen = packets.length;\n                this.emitReserved(\"flush\");\n              }\n            }\n            /**\n             * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n             * long-polling)\n             *\n             * @private\n             */\n            getWritablePackets() {\n              const shouldCheckPayloadSize = this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1;\n              if (!shouldCheckPayloadSize) {\n                return this.writeBuffer;\n              }\n              let payloadSize = 1;\n              for (let i = 0; i < this.writeBuffer.length; i++) {\n                const data = this.writeBuffer[i].data;\n                if (data) {\n                  payloadSize += Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"byteLength\"])(data);\n                }\n                if (i > 0 && payloadSize > this.maxPayload) {\n                  return this.writeBuffer.slice(0, i);\n                }\n                payloadSize += 2;\n              }\n              return this.writeBuffer;\n            }\n            /**\n             * Sends a message.\n             *\n             * @param {String} msg - message.\n             * @param {Object} options.\n             * @param {Function} callback function.\n             * @return {Socket} for chaining.\n             */\n            write(msg, options, fn) {\n              this.sendPacket(\"message\", msg, options, fn);\n              return this;\n            }\n            send(msg, options, fn) {\n              this.sendPacket(\"message\", msg, options, fn);\n              return this;\n            }\n            /**\n             * Sends a packet.\n             *\n             * @param {String} type: packet type.\n             * @param {String} data.\n             * @param {Object} options.\n             * @param {Function} fn - callback function.\n             * @private\n             */\n            sendPacket(type, data, options, fn) {\n              if (\"function\" === typeof data) {\n                fn = data;\n                data = void 0;\n              }\n              if (\"function\" === typeof options) {\n                fn = options;\n                options = null;\n              }\n              if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n                return;\n              }\n              options = options || {};\n              options.compress = false !== options.compress;\n              const packet = {\n                type,\n                data,\n                options\n              };\n              this.emitReserved(\"packetCreate\", packet);\n              this.writeBuffer.push(packet);\n              if (fn)\n                this.once(\"flush\", fn);\n              this.flush();\n            }\n            /**\n             * Closes the connection.\n             */\n            close() {\n              const close = () => {\n                this.onClose(\"forced close\");\n                this.transport.close();\n              };\n              const cleanupAndClose = () => {\n                this.off(\"upgrade\", cleanupAndClose);\n                this.off(\"upgradeError\", cleanupAndClose);\n                close();\n              };\n              const waitForUpgrade = () => {\n                this.once(\"upgrade\", cleanupAndClose);\n                this.once(\"upgradeError\", cleanupAndClose);\n              };\n              if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.readyState = \"closing\";\n                if (this.writeBuffer.length) {\n                  this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                      waitForUpgrade();\n                    } else {\n                      close();\n                    }\n                  });\n                } else if (this.upgrading) {\n                  waitForUpgrade();\n                } else {\n                  close();\n                }\n              }\n              return this;\n            }\n            /**\n             * Called upon transport error\n             *\n             * @private\n             */\n            onError(err) {\n              Socket.priorWebsocketSuccess = false;\n              this.emitReserved(\"error\", err);\n              this.onClose(\"transport error\", err);\n            }\n            /**\n             * Called upon transport close.\n             *\n             * @private\n             */\n            onClose(reason, description) {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                this.clearTimeoutFn(this.pingTimeoutTimer);\n                this.transport.removeAllListeners(\"close\");\n                this.transport.close();\n                this.transport.removeAllListeners();\n                if (typeof removeEventListener === \"function\") {\n                  removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                  removeEventListener(\"offline\", this.offlineEventListener, false);\n                }\n                this.readyState = \"closed\";\n                this.id = null;\n                this.emitReserved(\"close\", reason, description);\n                this.writeBuffer = [];\n                this.prevBufferLen = 0;\n              }\n            }\n            /**\n             * Filters upgrades, returning only those matching client transports.\n             *\n             * @param {Array} upgrades - server upgrades\n             * @private\n             */\n            filterUpgrades(upgrades) {\n              const filteredUpgrades = [];\n              let i = 0;\n              const j = upgrades.length;\n              for (; i < j; i++) {\n                if (~this.transports.indexOf(upgrades[i]))\n                  filteredUpgrades.push(upgrades[i]);\n              }\n              return filteredUpgrades;\n            }\n          }\n          Socket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"protocol\"];\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transport.js\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transport.js ***!\n          \\**************************************************************/\n        /*! exports provided: Transport */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Transport\", function() {\n            return Transport;\n          });\n          var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! engine.io-parser */\n            \"./node_modules/engine.io-parser/build/esm/index.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          class TransportError extends Error {\n            constructor(reason, description, context) {\n              super(reason);\n              this.description = description;\n              this.context = context;\n              this.type = \"TransportError\";\n            }\n          }\n          class Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__[\"Emitter\"] {\n            /**\n             * Transport abstract constructor.\n             *\n             * @param {Object} opts - options\n             * @protected\n             */\n            constructor(opts) {\n              super();\n              this.writable = false;\n              Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"installTimerFunctions\"])(this, opts);\n              this.opts = opts;\n              this.query = opts.query;\n              this.socket = opts.socket;\n            }\n            /**\n             * Emits an error.\n             *\n             * @param {String} reason\n             * @param description\n             * @param context - the error context\n             * @return {Transport} for chaining\n             * @protected\n             */\n            onError(reason, description, context) {\n              super.emitReserved(\"error\", new TransportError(reason, description, context));\n              return this;\n            }\n            /**\n             * Opens the transport.\n             */\n            open() {\n              this.readyState = \"opening\";\n              this.doOpen();\n              return this;\n            }\n            /**\n             * Closes the transport.\n             */\n            close() {\n              if (this.readyState === \"opening\" || this.readyState === \"open\") {\n                this.doClose();\n                this.onClose();\n              }\n              return this;\n            }\n            /**\n             * Sends multiple packets.\n             *\n             * @param {Array} packets\n             */\n            send(packets) {\n              if (this.readyState === \"open\") {\n                this.write(packets);\n              } else {\n              }\n            }\n            /**\n             * Called upon open\n             *\n             * @protected\n             */\n            onOpen() {\n              this.readyState = \"open\";\n              this.writable = true;\n              super.emitReserved(\"open\");\n            }\n            /**\n             * Called with data.\n             *\n             * @param {String} data\n             * @protected\n             */\n            onData(data) {\n              const packet = Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"decodePacket\"])(data, this.socket.binaryType);\n              this.onPacket(packet);\n            }\n            /**\n             * Called with a decoded packet.\n             *\n             * @protected\n             */\n            onPacket(packet) {\n              super.emitReserved(\"packet\", packet);\n            }\n            /**\n             * Called upon close.\n             *\n             * @protected\n             */\n            onClose(details) {\n              this.readyState = \"closed\";\n              super.emitReserved(\"close\", details);\n            }\n            /**\n             * Pauses the transport, in order not to lose packets during an upgrade.\n             *\n             * @param onPause\n             */\n            pause(onPause) {\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/index.js\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/index.js ***!\n          \\*********************************************************************/\n        /*! exports provided: transports */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"transports\", function() {\n            return transports;\n          });\n          var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./polling.js */\n            \"./node_modules/engine.io-client/build/esm/transports/polling.js\"\n          );\n          var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./websocket.js */\n            \"./node_modules/engine.io-client/build/esm/transports/websocket.js\"\n          );\n          const transports = {\n            websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__[\"WS\"],\n            polling: _polling_js__WEBPACK_IMPORTED_MODULE_0__[\"Polling\"]\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/polling.js\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/polling.js ***!\n          \\***********************************************************************/\n        /*! exports provided: Polling, Request */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Polling\", function() {\n            return Polling;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Request\", function() {\n            return Request;\n          });\n          var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ../transport.js */\n            \"./node_modules/engine.io-client/build/esm/transport.js\"\n          );\n          var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ../contrib/yeast.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\"\n          );\n          var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ../contrib/parseqs.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\"\n          );\n          var engine_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! engine.io-parser */\n            \"./node_modules/engine.io-parser/build/esm/index.js\"\n          );\n          var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./xmlhttprequest.js */\n            \"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ../util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ../globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          function empty() {\n          }\n          const hasXHR2 = function() {\n            const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__[\"XHR\"]({\n              xdomain: false\n            });\n            return null != xhr.responseType;\n          }();\n          class Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__[\"Transport\"] {\n            /**\n             * XHR Polling constructor.\n             *\n             * @param {Object} opts\n             * @package\n             */\n            constructor(opts) {\n              super(opts);\n              this.polling = false;\n              if (typeof location !== \"undefined\") {\n                const isSSL = \"https:\" === location.protocol;\n                let port = location.port;\n                if (!port) {\n                  port = isSSL ? \"443\" : \"80\";\n                }\n                this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n                this.xs = opts.secure !== isSSL;\n              }\n              const forceBase64 = opts && opts.forceBase64;\n              this.supportsBinary = hasXHR2 && !forceBase64;\n            }\n            get name() {\n              return \"polling\";\n            }\n            /**\n             * Opens the socket (triggers polling). We write a PING message to determine\n             * when the transport is open.\n             *\n             * @protected\n             */\n            doOpen() {\n              this.poll();\n            }\n            /**\n             * Pauses polling.\n             *\n             * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n             * @package\n             */\n            pause(onPause) {\n              this.readyState = \"pausing\";\n              const pause = () => {\n                this.readyState = \"paused\";\n                onPause();\n              };\n              if (this.polling || !this.writable) {\n                let total = 0;\n                if (this.polling) {\n                  total++;\n                  this.once(\"pollComplete\", function() {\n                    --total || pause();\n                  });\n                }\n                if (!this.writable) {\n                  total++;\n                  this.once(\"drain\", function() {\n                    --total || pause();\n                  });\n                }\n              } else {\n                pause();\n              }\n            }\n            /**\n             * Starts polling cycle.\n             *\n             * @private\n             */\n            poll() {\n              this.polling = true;\n              this.doPoll();\n              this.emitReserved(\"poll\");\n            }\n            /**\n             * Overloads onData to detect payloads.\n             *\n             * @protected\n             */\n            onData(data) {\n              const callback = (packet) => {\n                if (\"opening\" === this.readyState && packet.type === \"open\") {\n                  this.onOpen();\n                }\n                if (\"close\" === packet.type) {\n                  this.onClose({ description: \"transport closed by the server\" });\n                  return false;\n                }\n                this.onPacket(packet);\n              };\n              Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"decodePayload\"])(data, this.socket.binaryType).forEach(callback);\n              if (\"closed\" !== this.readyState) {\n                this.polling = false;\n                this.emitReserved(\"pollComplete\");\n                if (\"open\" === this.readyState) {\n                  this.poll();\n                } else {\n                }\n              }\n            }\n            /**\n             * For polling, send a close packet.\n             *\n             * @protected\n             */\n            doClose() {\n              const close = () => {\n                this.write([{ type: \"close\" }]);\n              };\n              if (\"open\" === this.readyState) {\n                close();\n              } else {\n                this.once(\"open\", close);\n              }\n            }\n            /**\n             * Writes a packets payload.\n             *\n             * @param {Array} packets - data packets\n             * @protected\n             */\n            write(packets) {\n              this.writable = false;\n              Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"encodePayload\"])(packets, (data) => {\n                this.doWrite(data, () => {\n                  this.writable = true;\n                  this.emitReserved(\"drain\");\n                });\n              });\n            }\n            /**\n             * Generates uri for connection.\n             *\n             * @private\n             */\n            uri() {\n              let query = this.query || {};\n              const schema = this.opts.secure ? \"https\" : \"http\";\n              let port = \"\";\n              if (false !== this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = Object(_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__[\"yeast\"])();\n              }\n              if (!this.supportsBinary && !query.sid) {\n                query.b64 = 1;\n              }\n              if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n                port = \":\" + this.opts.port;\n              }\n              const encodedQuery = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__[\"encode\"])(query);\n              const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n              return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n            }\n            /**\n             * Creates a request.\n             *\n             * @param {String} method\n             * @private\n             */\n            request(opts = {}) {\n              Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n              return new Request(this.uri(), opts);\n            }\n            /**\n             * Sends data.\n             *\n             * @param {String} data to send.\n             * @param {Function} called upon flush.\n             * @private\n             */\n            doWrite(data, fn) {\n              const req = this.request({\n                method: \"POST\",\n                data\n              });\n              req.on(\"success\", fn);\n              req.on(\"error\", (xhrStatus, context) => {\n                this.onError(\"xhr post error\", xhrStatus, context);\n              });\n            }\n            /**\n             * Starts a poll cycle.\n             *\n             * @private\n             */\n            doPoll() {\n              const req = this.request();\n              req.on(\"data\", this.onData.bind(this));\n              req.on(\"error\", (xhrStatus, context) => {\n                this.onError(\"xhr poll error\", xhrStatus, context);\n              });\n              this.pollXhr = req;\n            }\n          }\n          class Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__[\"Emitter\"] {\n            /**\n             * Request constructor\n             *\n             * @param {Object} options\n             * @package\n             */\n            constructor(uri, opts) {\n              super();\n              Object(_util_js__WEBPACK_IMPORTED_MODULE_6__[\"installTimerFunctions\"])(this, opts);\n              this.opts = opts;\n              this.method = opts.method || \"GET\";\n              this.uri = uri;\n              this.async = false !== opts.async;\n              this.data = void 0 !== opts.data ? opts.data : null;\n              this.create();\n            }\n            /**\n             * Creates the XHR object and sends the request.\n             *\n             * @private\n             */\n            create() {\n              const opts = Object(_util_js__WEBPACK_IMPORTED_MODULE_6__[\"pick\"])(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n              opts.xdomain = !!this.opts.xd;\n              opts.xscheme = !!this.opts.xs;\n              const xhr = this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__[\"XHR\"](opts);\n              try {\n                xhr.open(this.method, this.uri, this.async);\n                try {\n                  if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                      if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                        xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                      }\n                    }\n                  }\n                } catch (e) {\n                }\n                if (\"POST\" === this.method) {\n                  try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                  } catch (e) {\n                  }\n                }\n                try {\n                  xhr.setRequestHeader(\"Accept\", \"*/*\");\n                } catch (e) {\n                }\n                if (\"withCredentials\" in xhr) {\n                  xhr.withCredentials = this.opts.withCredentials;\n                }\n                if (this.opts.requestTimeout) {\n                  xhr.timeout = this.opts.requestTimeout;\n                }\n                xhr.onreadystatechange = () => {\n                  if (4 !== xhr.readyState)\n                    return;\n                  if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                  } else {\n                    this.setTimeoutFn(() => {\n                      this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                  }\n                };\n                xhr.send(this.data);\n              } catch (e) {\n                this.setTimeoutFn(() => {\n                  this.onError(e);\n                }, 0);\n                return;\n              }\n              if (typeof document !== \"undefined\") {\n                this.index = Request.requestsCount++;\n                Request.requests[this.index] = this;\n              }\n            }\n            /**\n             * Called upon error.\n             *\n             * @private\n             */\n            onError(err) {\n              this.emitReserved(\"error\", err, this.xhr);\n              this.cleanup(true);\n            }\n            /**\n             * Cleans up house.\n             *\n             * @private\n             */\n            cleanup(fromError) {\n              if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n                return;\n              }\n              this.xhr.onreadystatechange = empty;\n              if (fromError) {\n                try {\n                  this.xhr.abort();\n                } catch (e) {\n                }\n              }\n              if (typeof document !== \"undefined\") {\n                delete Request.requests[this.index];\n              }\n              this.xhr = null;\n            }\n            /**\n             * Called upon load.\n             *\n             * @private\n             */\n            onLoad() {\n              const data = this.xhr.responseText;\n              if (data !== null) {\n                this.emitReserved(\"data\", data);\n                this.emitReserved(\"success\");\n                this.cleanup();\n              }\n            }\n            /**\n             * Aborts the request.\n             *\n             * @package\n             */\n            abort() {\n              this.cleanup();\n            }\n          }\n          Request.requestsCount = 0;\n          Request.requests = {};\n          if (typeof document !== \"undefined\") {\n            if (typeof attachEvent === \"function\") {\n              attachEvent(\"onunload\", unloadHandler);\n            } else if (typeof addEventListener === \"function\") {\n              const terminationEvent = \"onpagehide\" in _globalThis_js__WEBPACK_IMPORTED_MODULE_7__[\"globalThisShim\"] ? \"pagehide\" : \"unload\";\n              addEventListener(terminationEvent, unloadHandler, false);\n            }\n          }\n          function unloadHandler() {\n            for (let i in Request.requests) {\n              if (Request.requests.hasOwnProperty(i)) {\n                Request.requests[i].abort();\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\": (\n        /*!*********************************************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js ***!\n          \\*********************************************************************************************/\n        /*! exports provided: nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"nextTick\", function() {\n            return nextTick;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"WebSocket\", function() {\n            return WebSocket;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"usingBrowserWebSocket\", function() {\n            return usingBrowserWebSocket;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"defaultBinaryType\", function() {\n            return defaultBinaryType;\n          });\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ../globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          const nextTick = (() => {\n            const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n            if (isPromiseAvailable) {\n              return (cb) => Promise.resolve().then(cb);\n            } else {\n              return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n            }\n          })();\n          const WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].MozWebSocket;\n          const usingBrowserWebSocket = true;\n          const defaultBinaryType = \"arraybuffer\";\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/websocket.js\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/websocket.js ***!\n          \\*************************************************************************/\n        /*! exports provided: WS */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          (function(Buffer) {\n            __webpack_require__2.d(__webpack_exports__2, \"WS\", function() {\n              return WS;\n            });\n            var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ../transport.js */\n              \"./node_modules/engine.io-client/build/esm/transport.js\"\n            );\n            var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ../contrib/parseqs.js */\n              \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\"\n            );\n            var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! ../contrib/yeast.js */\n              \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\"\n            );\n            var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! ../util.js */\n              \"./node_modules/engine.io-client/build/esm/util.js\"\n            );\n            var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n              /*! ./websocket-constructor.js */\n              \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\"\n            );\n            var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n              /*! engine.io-parser */\n              \"./node_modules/engine.io-parser/build/esm/index.js\"\n            );\n            const isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\n            class WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__[\"Transport\"] {\n              /**\n               * WebSocket transport constructor.\n               *\n               * @param {Object} opts - connection options\n               * @protected\n               */\n              constructor(opts) {\n                super(opts);\n                this.supportsBinary = !opts.forceBase64;\n              }\n              get name() {\n                return \"websocket\";\n              }\n              doOpen() {\n                if (!this.check()) {\n                  return;\n                }\n                const uri = this.uri();\n                const protocols = this.opts.protocols;\n                const opts = isReactNative ? {} : Object(_util_js__WEBPACK_IMPORTED_MODULE_3__[\"pick\"])(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n                if (this.opts.extraHeaders) {\n                  opts.headers = this.opts.extraHeaders;\n                }\n                try {\n                  this.ws = _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"] && !isReactNative ? protocols ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri, protocols) : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri) : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri, protocols, opts);\n                } catch (err) {\n                  return this.emitReserved(\"error\", err);\n                }\n                this.ws.binaryType = this.socket.binaryType || _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"defaultBinaryType\"];\n                this.addEventListeners();\n              }\n              /**\n               * Adds event listeners to the socket\n               *\n               * @private\n               */\n              addEventListeners() {\n                this.ws.onopen = () => {\n                  if (this.opts.autoUnref) {\n                    this.ws._socket.unref();\n                  }\n                  this.onOpen();\n                };\n                this.ws.onclose = (closeEvent) => this.onClose({\n                  description: \"websocket connection closed\",\n                  context: closeEvent\n                });\n                this.ws.onmessage = (ev) => this.onData(ev.data);\n                this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n              }\n              write(packets) {\n                this.writable = false;\n                for (let i = 0; i < packets.length; i++) {\n                  const packet = packets[i];\n                  const lastPacket = i === packets.length - 1;\n                  Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"encodePacket\"])(packet, this.supportsBinary, (data) => {\n                    const opts = {};\n                    if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"]) {\n                      if (packet.options) {\n                        opts.compress = packet.options.compress;\n                      }\n                      if (this.opts.perMessageDeflate) {\n                        const len = (\n                          // @ts-ignore\n                          \"string\" === typeof data ? Buffer.byteLength(data) : data.length\n                        );\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                          opts.compress = false;\n                        }\n                      }\n                    }\n                    try {\n                      if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"]) {\n                        this.ws.send(data);\n                      } else {\n                        this.ws.send(data, opts);\n                      }\n                    } catch (e) {\n                    }\n                    if (lastPacket) {\n                      Object(_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"nextTick\"])(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                      }, this.setTimeoutFn);\n                    }\n                  });\n                }\n              }\n              doClose() {\n                if (typeof this.ws !== \"undefined\") {\n                  this.ws.close();\n                  this.ws = null;\n                }\n              }\n              /**\n               * Generates uri for connection.\n               *\n               * @private\n               */\n              uri() {\n                let query = this.query || {};\n                const schema = this.opts.secure ? \"wss\" : \"ws\";\n                let port = \"\";\n                if (this.opts.port && (\"wss\" === schema && Number(this.opts.port) !== 443 || \"ws\" === schema && Number(this.opts.port) !== 80)) {\n                  port = \":\" + this.opts.port;\n                }\n                if (this.opts.timestampRequests) {\n                  query[this.opts.timestampParam] = Object(_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__[\"yeast\"])();\n                }\n                if (!this.supportsBinary) {\n                  query.b64 = 1;\n                }\n                const encodedQuery = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(query);\n                const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n                return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n              }\n              /**\n               * Feature detection for WebSocket.\n               *\n               * @return {Boolean} whether this transport is available.\n               * @private\n               */\n              check() {\n                return !!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"];\n              }\n            }\n          }).call(this, __webpack_require__2(\n            /*! ./../../../../buffer/index.js */\n            \"./node_modules/buffer/index.js\"\n          ).Buffer);\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\": (\n        /*!**************************************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js ***!\n          \\**************************************************************************************/\n        /*! exports provided: XHR */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"XHR\", function() {\n            return XHR;\n          });\n          var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ../contrib/has-cors.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/has-cors.js\"\n          );\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ../globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          function XHR(opts) {\n            const xdomain = opts.xdomain;\n            try {\n              if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__[\"hasCORS\"])) {\n                return new XMLHttpRequest();\n              }\n            } catch (e) {\n            }\n            if (!xdomain) {\n              try {\n                return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__[\"globalThisShim\"][[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n              } catch (e) {\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/util.js\": (\n        /*!*********************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/util.js ***!\n          \\*********************************************************/\n        /*! exports provided: pick, installTimerFunctions, byteLength */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"pick\", function() {\n            return pick;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"installTimerFunctions\", function() {\n            return installTimerFunctions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"byteLength\", function() {\n            return byteLength;\n          });\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          function pick(obj, ...attr) {\n            return attr.reduce((acc, k) => {\n              if (obj.hasOwnProperty(k)) {\n                acc[k] = obj[k];\n              }\n              return acc;\n            }, {});\n          }\n          const NATIVE_SET_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].setTimeout;\n          const NATIVE_CLEAR_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].clearTimeout;\n          function installTimerFunctions(obj, opts) {\n            if (opts.useNativeTimers) {\n              obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n              obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n            } else {\n              obj.setTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n              obj.clearTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n            }\n          }\n          const BASE64_OVERHEAD = 1.33;\n          function byteLength(obj) {\n            if (typeof obj === \"string\") {\n              return utf8Length(obj);\n            }\n            return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n          }\n          function utf8Length(str) {\n            let c = 0, length = 0;\n            for (let i = 0, l = str.length; i < l; i++) {\n              c = str.charCodeAt(i);\n              if (c < 128) {\n                length += 1;\n              } else if (c < 2048) {\n                length += 2;\n              } else if (c < 55296 || c >= 57344) {\n                length += 3;\n              } else {\n                i++;\n                length += 4;\n              }\n            }\n            return length;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/commons.js\": (\n        /*!************************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/commons.js ***!\n          \\************************************************************/\n        /*! exports provided: PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"PACKET_TYPES\", function() {\n            return PACKET_TYPES;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"PACKET_TYPES_REVERSE\", function() {\n            return PACKET_TYPES_REVERSE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ERROR_PACKET\", function() {\n            return ERROR_PACKET;\n          });\n          const PACKET_TYPES = /* @__PURE__ */ Object.create(null);\n          PACKET_TYPES[\"open\"] = \"0\";\n          PACKET_TYPES[\"close\"] = \"1\";\n          PACKET_TYPES[\"ping\"] = \"2\";\n          PACKET_TYPES[\"pong\"] = \"3\";\n          PACKET_TYPES[\"message\"] = \"4\";\n          PACKET_TYPES[\"upgrade\"] = \"5\";\n          PACKET_TYPES[\"noop\"] = \"6\";\n          const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\n          Object.keys(PACKET_TYPES).forEach((key) => {\n            PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n          });\n          const ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!\n          \\*************************************************************************/\n        /*! exports provided: default */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./commons.js */\n            \"./node_modules/engine.io-parser/build/esm/commons.js\"\n          );\n          var _socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @socket.io/base64-arraybuffer */\n            \"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js\"\n          );\n          const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n          const decodePacket = (encodedPacket, binaryType) => {\n            if (typeof encodedPacket !== \"string\") {\n              return {\n                type: \"message\",\n                data: mapBinary(encodedPacket, binaryType)\n              };\n            }\n            const type = encodedPacket.charAt(0);\n            if (type === \"b\") {\n              return {\n                type: \"message\",\n                data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n              };\n            }\n            const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type];\n            if (!packetType) {\n              return _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"ERROR_PACKET\"];\n            }\n            return encodedPacket.length > 1 ? {\n              type: _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type],\n              data: encodedPacket.substring(1)\n            } : {\n              type: _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type]\n            };\n          };\n          const decodeBase64Packet = (data, binaryType) => {\n            if (withNativeArrayBuffer) {\n              const decoded = Object(_socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(data);\n              return mapBinary(decoded, binaryType);\n            } else {\n              return { base64: true, data };\n            }\n          };\n          const mapBinary = (data, binaryType) => {\n            switch (binaryType) {\n              case \"blob\":\n                return data instanceof ArrayBuffer ? new Blob([data]) : data;\n              case \"arraybuffer\":\n              default:\n                return data;\n            }\n          };\n          __webpack_exports__2[\"default\"] = decodePacket;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!\n          \\*************************************************************************/\n        /*! exports provided: default */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./commons.js */\n            \"./node_modules/engine.io-parser/build/esm/commons.js\"\n          );\n          const withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\";\n          const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n          const isView = (obj) => {\n            return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;\n          };\n          const encodePacket = ({ type, data }, supportsBinary, callback) => {\n            if (withNativeBlob && data instanceof Blob) {\n              if (supportsBinary) {\n                return callback(data);\n              } else {\n                return encodeBlobAsBase64(data, callback);\n              }\n            } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {\n              if (supportsBinary) {\n                return callback(data);\n              } else {\n                return encodeBlobAsBase64(new Blob([data]), callback);\n              }\n            }\n            return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES\"][type] + (data || \"\"));\n          };\n          const encodeBlobAsBase64 = (data, callback) => {\n            const fileReader = new FileReader();\n            fileReader.onload = function() {\n              const content = fileReader.result.split(\",\")[1];\n              callback(\"b\" + content);\n            };\n            return fileReader.readAsDataURL(data);\n          };\n          __webpack_exports__2[\"default\"] = encodePacket;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: protocol, encodePacket, encodePayload, decodePacket, decodePayload */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return protocol;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodePayload\", function() {\n            return encodePayload;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodePayload\", function() {\n            return decodePayload;\n          });\n          var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encodePacket.js */\n            \"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encodePacket\", function() {\n            return _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n          });\n          var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decodePacket.js */\n            \"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodePacket\", function() {\n            return _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n          });\n          const SEPARATOR = String.fromCharCode(30);\n          const encodePayload = (packets, callback) => {\n            const length = packets.length;\n            const encodedPackets = new Array(length);\n            let count = 0;\n            packets.forEach((packet, i) => {\n              Object(_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(packet, false, (encodedPacket) => {\n                encodedPackets[i] = encodedPacket;\n                if (++count === length) {\n                  callback(encodedPackets.join(SEPARATOR));\n                }\n              });\n            });\n          };\n          const decodePayload = (encodedPayload, binaryType) => {\n            const encodedPackets = encodedPayload.split(SEPARATOR);\n            const packets = [];\n            for (let i = 0; i < encodedPackets.length; i++) {\n              const decodedPacket = Object(_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(encodedPackets[i], binaryType);\n              packets.push(decodedPacket);\n              if (decodedPacket.type === \"error\") {\n                break;\n              }\n            }\n            return packets;\n          };\n          const protocol = 4;\n        }\n      ),\n      /***/\n      \"./node_modules/ieee754/index.js\": (\n        /*!***************************************!*\\\n          !*** ./node_modules/ieee754/index.js ***!\n          \\***************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2) {\n          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n          exports2.read = function(buffer, offset, isLE, mLen, nBytes) {\n            var e, m;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var nBits = -7;\n            var i = isLE ? nBytes - 1 : 0;\n            var d = isLE ? -1 : 1;\n            var s = buffer[offset + i];\n            i += d;\n            e = s & (1 << -nBits) - 1;\n            s >>= -nBits;\n            nBits += eLen;\n            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n            }\n            m = e & (1 << -nBits) - 1;\n            e >>= -nBits;\n            nBits += mLen;\n            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n            }\n            if (e === 0) {\n              e = 1 - eBias;\n            } else if (e === eMax) {\n              return m ? NaN : (s ? -1 : 1) * Infinity;\n            } else {\n              m = m + Math.pow(2, mLen);\n              e = e - eBias;\n            }\n            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n          };\n          exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n            var e, m, c;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n            var i = isLE ? 0 : nBytes - 1;\n            var d = isLE ? 1 : -1;\n            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n            value = Math.abs(value);\n            if (isNaN(value) || value === Infinity) {\n              m = isNaN(value) ? 1 : 0;\n              e = eMax;\n            } else {\n              e = Math.floor(Math.log(value) / Math.LN2);\n              if (value * (c = Math.pow(2, -e)) < 1) {\n                e--;\n                c *= 2;\n              }\n              if (e + eBias >= 1) {\n                value += rt / c;\n              } else {\n                value += rt * Math.pow(2, 1 - eBias);\n              }\n              if (value * c >= 2) {\n                e++;\n                c /= 2;\n              }\n              if (e + eBias >= eMax) {\n                m = 0;\n                e = eMax;\n              } else if (e + eBias >= 1) {\n                m = (value * c - 1) * Math.pow(2, mLen);\n                e = e + eBias;\n              } else {\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n                e = 0;\n              }\n            }\n            for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n            }\n            e = e << mLen | m;\n            eLen += mLen;\n            for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n            }\n            buffer[offset + i - d] |= s * 128;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/isarray/index.js\": (\n        /*!***************************************!*\\\n          !*** ./node_modules/isarray/index.js ***!\n          \\***************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2) {\n          var toString = {}.toString;\n          module2.exports = Array.isArray || function(arr) {\n            return toString.call(arr) == \"[object Array]\";\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/contrib/backo2.js\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/contrib/backo2.js ***!\n          \\*******************************************************************/\n        /*! exports provided: Backoff */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Backoff\", function() {\n            return Backoff;\n          });\n          function Backoff(opts) {\n            opts = opts || {};\n            this.ms = opts.min || 100;\n            this.max = opts.max || 1e4;\n            this.factor = opts.factor || 2;\n            this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n            this.attempts = 0;\n          }\n          Backoff.prototype.duration = function() {\n            var ms = this.ms * Math.pow(this.factor, this.attempts++);\n            if (this.jitter) {\n              var rand = Math.random();\n              var deviation = Math.floor(rand * this.jitter * ms);\n              ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n            }\n            return Math.min(ms, this.max) | 0;\n          };\n          Backoff.prototype.reset = function() {\n            this.attempts = 0;\n          };\n          Backoff.prototype.setMin = function(min) {\n            this.ms = min;\n          };\n          Backoff.prototype.setMax = function(max) {\n            this.max = max;\n          };\n          Backoff.prototype.setJitter = function(jitter) {\n            this.jitter = jitter;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: protocol, Manager, Socket, io, connect, default */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"io\", function() {\n            return lookup;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"connect\", function() {\n            return lookup;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"default\", function() {\n            return lookup;\n          });\n          var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./url.js */\n            \"./node_modules/socket.io-client/build/esm/url.js\"\n          );\n          var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./manager.js */\n            \"./node_modules/socket.io-client/build/esm/manager.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Manager\", function() {\n            return _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"];\n          });\n          var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./socket.js */\n            \"./node_modules/socket.io-client/build/esm/socket.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"];\n          });\n          var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! socket.io-parser */\n            \"./node_modules/socket.io-parser/build/esm/index.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return socket_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"protocol\"];\n          });\n          const cache = {};\n          function lookup(uri, opts) {\n            if (typeof uri === \"object\") {\n              opts = uri;\n              uri = void 0;\n            }\n            opts = opts || {};\n            const parsed = Object(_url_js__WEBPACK_IMPORTED_MODULE_0__[\"url\"])(uri, opts.path || \"/socket.io\");\n            const source = parsed.source;\n            const id = parsed.id;\n            const path = parsed.path;\n            const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n            const newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n            let io;\n            if (newConnection) {\n              io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"](source, opts);\n            } else {\n              if (!cache[id]) {\n                cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"](source, opts);\n              }\n              io = cache[id];\n            }\n            if (parsed.query && !opts.query) {\n              opts.query = parsed.queryKey;\n            }\n            return io.socket(parsed.path, opts);\n          }\n          Object.assign(lookup, {\n            Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"],\n            Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"],\n            io: lookup,\n            connect: lookup\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/manager.js\": (\n        /*!************************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/manager.js ***!\n          \\************************************************************/\n        /*! exports provided: Manager */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Manager\", function() {\n            return Manager;\n          });\n          var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! engine.io-client */\n            \"./node_modules/engine.io-client/build/esm/index.js\"\n          );\n          var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./socket.js */\n            \"./node_modules/socket.io-client/build/esm/socket.js\"\n          );\n          var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! socket.io-parser */\n            \"./node_modules/socket.io-parser/build/esm/index.js\"\n          );\n          var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./on.js */\n            \"./node_modules/socket.io-client/build/esm/on.js\"\n          );\n          var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./contrib/backo2.js */\n            \"./node_modules/socket.io-client/build/esm/contrib/backo2.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          class Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__[\"Emitter\"] {\n            constructor(uri, opts) {\n              var _a;\n              super();\n              this.nsps = {};\n              this.subs = [];\n              if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = void 0;\n              }\n              opts = opts || {};\n              opts.path = opts.path || \"/socket.io\";\n              this.opts = opts;\n              Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"installTimerFunctions\"])(this, opts);\n              this.reconnection(opts.reconnection !== false);\n              this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n              this.reconnectionDelay(opts.reconnectionDelay || 1e3);\n              this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);\n              this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n              this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__[\"Backoff\"]({\n                min: this.reconnectionDelay(),\n                max: this.reconnectionDelayMax(),\n                jitter: this.randomizationFactor()\n              });\n              this.timeout(null == opts.timeout ? 2e4 : opts.timeout);\n              this._readyState = \"closed\";\n              this.uri = uri;\n              const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;\n              this.encoder = new _parser.Encoder();\n              this.decoder = new _parser.Decoder();\n              this._autoConnect = opts.autoConnect !== false;\n              if (this._autoConnect)\n                this.open();\n            }\n            reconnection(v) {\n              if (!arguments.length)\n                return this._reconnection;\n              this._reconnection = !!v;\n              return this;\n            }\n            reconnectionAttempts(v) {\n              if (v === void 0)\n                return this._reconnectionAttempts;\n              this._reconnectionAttempts = v;\n              return this;\n            }\n            reconnectionDelay(v) {\n              var _a;\n              if (v === void 0)\n                return this._reconnectionDelay;\n              this._reconnectionDelay = v;\n              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n              return this;\n            }\n            randomizationFactor(v) {\n              var _a;\n              if (v === void 0)\n                return this._randomizationFactor;\n              this._randomizationFactor = v;\n              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n              return this;\n            }\n            reconnectionDelayMax(v) {\n              var _a;\n              if (v === void 0)\n                return this._reconnectionDelayMax;\n              this._reconnectionDelayMax = v;\n              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n              return this;\n            }\n            timeout(v) {\n              if (!arguments.length)\n                return this._timeout;\n              this._timeout = v;\n              return this;\n            }\n            /**\n             * Starts trying to reconnect if reconnection is enabled and we have not\n             * started reconnecting yet\n             *\n             * @private\n             */\n            maybeReconnectOnOpen() {\n              if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n                this.reconnect();\n              }\n            }\n            /**\n             * Sets the current transport `socket`.\n             *\n             * @param {Function} fn - optional, callback\n             * @return self\n             * @public\n             */\n            open(fn) {\n              if (~this._readyState.indexOf(\"open\"))\n                return this;\n              this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"](this.uri, this.opts);\n              const socket = this.engine;\n              const self2 = this;\n              this._readyState = \"opening\";\n              this.skipReconnect = false;\n              const openSubDestroy = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"open\", function() {\n                self2.onopen();\n                fn && fn();\n              });\n              const errorSub = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"error\", (err) => {\n                self2.cleanup();\n                self2._readyState = \"closed\";\n                this.emitReserved(\"error\", err);\n                if (fn) {\n                  fn(err);\n                } else {\n                  self2.maybeReconnectOnOpen();\n                }\n              });\n              if (false !== this._timeout) {\n                const timeout = this._timeout;\n                if (timeout === 0) {\n                  openSubDestroy();\n                }\n                const timer = this.setTimeoutFn(() => {\n                  openSubDestroy();\n                  socket.close();\n                  socket.emit(\"error\", new Error(\"timeout\"));\n                }, timeout);\n                if (this.opts.autoUnref) {\n                  timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                  clearTimeout(timer);\n                });\n              }\n              this.subs.push(openSubDestroy);\n              this.subs.push(errorSub);\n              return this;\n            }\n            /**\n             * Alias for open()\n             *\n             * @return self\n             * @public\n             */\n            connect(fn) {\n              return this.open(fn);\n            }\n            /**\n             * Called upon transport open.\n             *\n             * @private\n             */\n            onopen() {\n              this.cleanup();\n              this._readyState = \"open\";\n              this.emitReserved(\"open\");\n              const socket = this.engine;\n              this.subs.push(Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"ping\", this.onping.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"data\", this.ondata.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"error\", this.onerror.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"close\", this.onclose.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n            }\n            /**\n             * Called upon a ping.\n             *\n             * @private\n             */\n            onping() {\n              this.emitReserved(\"ping\");\n            }\n            /**\n             * Called with data.\n             *\n             * @private\n             */\n            ondata(data) {\n              try {\n                this.decoder.add(data);\n              } catch (e) {\n                this.onclose(\"parse error\", e);\n              }\n            }\n            /**\n             * Called when parser fully decodes a packet.\n             *\n             * @private\n             */\n            ondecoded(packet) {\n              Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"nextTick\"])(() => {\n                this.emitReserved(\"packet\", packet);\n              }, this.setTimeoutFn);\n            }\n            /**\n             * Called upon socket error.\n             *\n             * @private\n             */\n            onerror(err) {\n              this.emitReserved(\"error\", err);\n            }\n            /**\n             * Creates a new socket for the given `nsp`.\n             *\n             * @return {Socket}\n             * @public\n             */\n            socket(nsp, opts) {\n              let socket = this.nsps[nsp];\n              if (!socket) {\n                socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__[\"Socket\"](this, nsp, opts);\n                this.nsps[nsp] = socket;\n              } else if (this._autoConnect && !socket.active) {\n                socket.connect();\n              }\n              return socket;\n            }\n            /**\n             * Called upon a socket close.\n             *\n             * @param socket\n             * @private\n             */\n            _destroy(socket) {\n              const nsps = Object.keys(this.nsps);\n              for (const nsp of nsps) {\n                const socket2 = this.nsps[nsp];\n                if (socket2.active) {\n                  return;\n                }\n              }\n              this._close();\n            }\n            /**\n             * Writes a packet.\n             *\n             * @param packet\n             * @private\n             */\n            _packet(packet) {\n              const encodedPackets = this.encoder.encode(packet);\n              for (let i = 0; i < encodedPackets.length; i++) {\n                this.engine.write(encodedPackets[i], packet.options);\n              }\n            }\n            /**\n             * Clean up transport subscriptions and packet buffer.\n             *\n             * @private\n             */\n            cleanup() {\n              this.subs.forEach((subDestroy) => subDestroy());\n              this.subs.length = 0;\n              this.decoder.destroy();\n            }\n            /**\n             * Close the current socket.\n             *\n             * @private\n             */\n            _close() {\n              this.skipReconnect = true;\n              this._reconnecting = false;\n              this.onclose(\"forced close\");\n              if (this.engine)\n                this.engine.close();\n            }\n            /**\n             * Alias for close()\n             *\n             * @private\n             */\n            disconnect() {\n              return this._close();\n            }\n            /**\n             * Called upon engine close.\n             *\n             * @private\n             */\n            onclose(reason, description) {\n              this.cleanup();\n              this.backoff.reset();\n              this._readyState = \"closed\";\n              this.emitReserved(\"close\", reason, description);\n              if (this._reconnection && !this.skipReconnect) {\n                this.reconnect();\n              }\n            }\n            /**\n             * Attempt a reconnection.\n             *\n             * @private\n             */\n            reconnect() {\n              if (this._reconnecting || this.skipReconnect)\n                return this;\n              const self2 = this;\n              if (this.backoff.attempts >= this._reconnectionAttempts) {\n                this.backoff.reset();\n                this.emitReserved(\"reconnect_failed\");\n                this._reconnecting = false;\n              } else {\n                const delay = this.backoff.duration();\n                this._reconnecting = true;\n                const timer = this.setTimeoutFn(() => {\n                  if (self2.skipReconnect)\n                    return;\n                  this.emitReserved(\"reconnect_attempt\", self2.backoff.attempts);\n                  if (self2.skipReconnect)\n                    return;\n                  self2.open((err) => {\n                    if (err) {\n                      self2._reconnecting = false;\n                      self2.reconnect();\n                      this.emitReserved(\"reconnect_error\", err);\n                    } else {\n                      self2.onreconnect();\n                    }\n                  });\n                }, delay);\n                if (this.opts.autoUnref) {\n                  timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                  clearTimeout(timer);\n                });\n              }\n            }\n            /**\n             * Called upon successful reconnect.\n             *\n             * @private\n             */\n            onreconnect() {\n              const attempt = this.backoff.attempts;\n              this._reconnecting = false;\n              this.backoff.reset();\n              this.emitReserved(\"reconnect\", attempt);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/on.js\": (\n        /*!*******************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/on.js ***!\n          \\*******************************************************/\n        /*! exports provided: on */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"on\", function() {\n            return on;\n          });\n          function on(obj, ev, fn) {\n            obj.on(ev, fn);\n            return function subDestroy() {\n              obj.off(ev, fn);\n            };\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/socket.js\": (\n        /*!***********************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/socket.js ***!\n          \\***********************************************************/\n        /*! exports provided: Socket */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return Socket;\n          });\n          var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! socket.io-parser */\n            \"./node_modules/socket.io-parser/build/esm/index.js\"\n          );\n          var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./on.js */\n            \"./node_modules/socket.io-client/build/esm/on.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          const RESERVED_EVENTS = Object.freeze({\n            connect: 1,\n            connect_error: 1,\n            disconnect: 1,\n            disconnecting: 1,\n            // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n            newListener: 1,\n            removeListener: 1\n          });\n          class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__[\"Emitter\"] {\n            /**\n             * `Socket` constructor.\n             */\n            constructor(io, nsp, opts) {\n              super();\n              this.connected = false;\n              this.recovered = false;\n              this.receiveBuffer = [];\n              this.sendBuffer = [];\n              this._queue = [];\n              this._queueSeq = 0;\n              this.ids = 0;\n              this.acks = {};\n              this.flags = {};\n              this.io = io;\n              this.nsp = nsp;\n              if (opts && opts.auth) {\n                this.auth = opts.auth;\n              }\n              this._opts = Object.assign({}, opts);\n              if (this.io._autoConnect)\n                this.open();\n            }\n            /**\n             * Whether the socket is currently disconnected\n             *\n             * @example\n             * const socket = io();\n             *\n             * socket.on(\"connect\", () => {\n             *   console.log(socket.disconnected); // false\n             * });\n             *\n             * socket.on(\"disconnect\", () => {\n             *   console.log(socket.disconnected); // true\n             * });\n             */\n            get disconnected() {\n              return !this.connected;\n            }\n            /**\n             * Subscribe to open, close and packet events\n             *\n             * @private\n             */\n            subEvents() {\n              if (this.subs)\n                return;\n              const io = this.io;\n              this.subs = [\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"open\", this.onopen.bind(this)),\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"packet\", this.onpacket.bind(this)),\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"error\", this.onerror.bind(this)),\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"close\", this.onclose.bind(this))\n              ];\n            }\n            /**\n             * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n             *\n             * @example\n             * const socket = io();\n             *\n             * console.log(socket.active); // true\n             *\n             * socket.on(\"disconnect\", (reason) => {\n             *   if (reason === \"io server disconnect\") {\n             *     // the disconnection was initiated by the server, you need to manually reconnect\n             *     console.log(socket.active); // false\n             *   }\n             *   // else the socket will automatically try to reconnect\n             *   console.log(socket.active); // true\n             * });\n             */\n            get active() {\n              return !!this.subs;\n            }\n            /**\n             * \"Opens\" the socket.\n             *\n             * @example\n             * const socket = io({\n             *   autoConnect: false\n             * });\n             *\n             * socket.connect();\n             */\n            connect() {\n              if (this.connected)\n                return this;\n              this.subEvents();\n              if (!this.io[\"_reconnecting\"])\n                this.io.open();\n              if (\"open\" === this.io._readyState)\n                this.onopen();\n              return this;\n            }\n            /**\n             * Alias for {@link connect()}.\n             */\n            open() {\n              return this.connect();\n            }\n            /**\n             * Sends a `message` event.\n             *\n             * This method mimics the WebSocket.send() method.\n             *\n             * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n             *\n             * @example\n             * socket.send(\"hello\");\n             *\n             * // this is equivalent to\n             * socket.emit(\"message\", \"hello\");\n             *\n             * @return self\n             */\n            send(...args) {\n              args.unshift(\"message\");\n              this.emit.apply(this, args);\n              return this;\n            }\n            /**\n             * Override `emit`.\n             * If the event is in `events`, it's emitted normally.\n             *\n             * @example\n             * socket.emit(\"hello\", \"world\");\n             *\n             * // all serializable datastructures are supported (no need to call JSON.stringify)\n             * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n             *\n             * // with an acknowledgement from the server\n             * socket.emit(\"hello\", \"world\", (val) => {\n             *   // ...\n             * });\n             *\n             * @return self\n             */\n            emit(ev, ...args) {\n              if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n                throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n              }\n              args.unshift(ev);\n              if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n                this._addToQueue(args);\n                return this;\n              }\n              const packet = {\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].EVENT,\n                data: args\n              };\n              packet.options = {};\n              packet.options.compress = this.flags.compress !== false;\n              if (\"function\" === typeof args[args.length - 1]) {\n                const id = this.ids++;\n                const ack = args.pop();\n                this._registerAckCallback(id, ack);\n                packet.id = id;\n              }\n              const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n              const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n              if (discardPacket) {\n              } else if (this.connected) {\n                this.notifyOutgoingListeners(packet);\n                this.packet(packet);\n              } else {\n                this.sendBuffer.push(packet);\n              }\n              this.flags = {};\n              return this;\n            }\n            /**\n             * @private\n             */\n            _registerAckCallback(id, ack) {\n              var _a;\n              const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n              if (timeout === void 0) {\n                this.acks[id] = ack;\n                return;\n              }\n              const timer = this.io.setTimeoutFn(() => {\n                delete this.acks[id];\n                for (let i = 0; i < this.sendBuffer.length; i++) {\n                  if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                  }\n                }\n                ack.call(this, new Error(\"operation has timed out\"));\n              }, timeout);\n              this.acks[id] = (...args) => {\n                this.io.clearTimeoutFn(timer);\n                ack.apply(this, [null, ...args]);\n              };\n            }\n            /**\n             * Emits an event and waits for an acknowledgement\n             *\n             * @example\n             * // without timeout\n             * const response = await socket.emitWithAck(\"hello\", \"world\");\n             *\n             * // with a specific timeout\n             * try {\n             *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n             * } catch (err) {\n             *   // the server did not acknowledge the event in the given delay\n             * }\n             *\n             * @return a Promise that will be fulfilled when the server acknowledges the event\n             */\n            emitWithAck(ev, ...args) {\n              const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;\n              return new Promise((resolve, reject) => {\n                args.push((arg1, arg2) => {\n                  if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                  } else {\n                    return resolve(arg1);\n                  }\n                });\n                this.emit(ev, ...args);\n              });\n            }\n            /**\n             * Add the packet to the queue.\n             * @param args\n             * @private\n             */\n            _addToQueue(args) {\n              let ack;\n              if (typeof args[args.length - 1] === \"function\") {\n                ack = args.pop();\n              }\n              const packet = {\n                id: this._queueSeq++,\n                tryCount: 0,\n                pending: false,\n                args,\n                flags: Object.assign({ fromQueue: true }, this.flags)\n              };\n              args.push((err, ...responseArgs) => {\n                if (packet !== this._queue[0]) {\n                  return;\n                }\n                const hasError = err !== null;\n                if (hasError) {\n                  if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                      ack(err);\n                    }\n                  }\n                } else {\n                  this._queue.shift();\n                  if (ack) {\n                    ack(null, ...responseArgs);\n                  }\n                }\n                packet.pending = false;\n                return this._drainQueue();\n              });\n              this._queue.push(packet);\n              this._drainQueue();\n            }\n            /**\n             * Send the first packet of the queue, and wait for an acknowledgement from the server.\n             * @param force - whether to resend a packet that has not been acknowledged yet\n             *\n             * @private\n             */\n            _drainQueue(force = false) {\n              if (!this.connected || this._queue.length === 0) {\n                return;\n              }\n              const packet = this._queue[0];\n              if (packet.pending && !force) {\n                return;\n              }\n              packet.pending = true;\n              packet.tryCount++;\n              this.flags = packet.flags;\n              this.emit.apply(this, packet.args);\n            }\n            /**\n             * Sends a packet.\n             *\n             * @param packet\n             * @private\n             */\n            packet(packet) {\n              packet.nsp = this.nsp;\n              this.io._packet(packet);\n            }\n            /**\n             * Called upon engine `open`.\n             *\n             * @private\n             */\n            onopen() {\n              if (typeof this.auth == \"function\") {\n                this.auth((data) => {\n                  this._sendConnectPacket(data);\n                });\n              } else {\n                this._sendConnectPacket(this.auth);\n              }\n            }\n            /**\n             * Sends a CONNECT packet to initiate the Socket.IO session.\n             *\n             * @param data\n             * @private\n             */\n            _sendConnectPacket(data) {\n              this.packet({\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT,\n                data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data\n              });\n            }\n            /**\n             * Called upon engine or manager `error`.\n             *\n             * @param err\n             * @private\n             */\n            onerror(err) {\n              if (!this.connected) {\n                this.emitReserved(\"connect_error\", err);\n              }\n            }\n            /**\n             * Called upon engine `close`.\n             *\n             * @param reason\n             * @param description\n             * @private\n             */\n            onclose(reason, description) {\n              this.connected = false;\n              delete this.id;\n              this.emitReserved(\"disconnect\", reason, description);\n            }\n            /**\n             * Called with socket packet.\n             *\n             * @param packet\n             * @private\n             */\n            onpacket(packet) {\n              const sameNamespace = packet.nsp === this.nsp;\n              if (!sameNamespace)\n                return;\n              switch (packet.type) {\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT:\n                  if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                  } else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                  }\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].EVENT:\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].BINARY_EVENT:\n                  this.onevent(packet);\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].ACK:\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].BINARY_ACK:\n                  this.onack(packet);\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].DISCONNECT:\n                  this.ondisconnect();\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT_ERROR:\n                  this.destroy();\n                  const err = new Error(packet.data.message);\n                  err.data = packet.data.data;\n                  this.emitReserved(\"connect_error\", err);\n                  break;\n              }\n            }\n            /**\n             * Called upon a server event.\n             *\n             * @param packet\n             * @private\n             */\n            onevent(packet) {\n              const args = packet.data || [];\n              if (null != packet.id) {\n                args.push(this.ack(packet.id));\n              }\n              if (this.connected) {\n                this.emitEvent(args);\n              } else {\n                this.receiveBuffer.push(Object.freeze(args));\n              }\n            }\n            emitEvent(args) {\n              if (this._anyListeners && this._anyListeners.length) {\n                const listeners = this._anyListeners.slice();\n                for (const listener of listeners) {\n                  listener.apply(this, args);\n                }\n              }\n              super.emit.apply(this, args);\n              if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n                this._lastOffset = args[args.length - 1];\n              }\n            }\n            /**\n             * Produces an ack callback to emit with an event.\n             *\n             * @private\n             */\n            ack(id) {\n              const self2 = this;\n              let sent = false;\n              return function(...args) {\n                if (sent)\n                  return;\n                sent = true;\n                self2.packet({\n                  type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].ACK,\n                  id,\n                  data: args\n                });\n              };\n            }\n            /**\n             * Called upon a server acknowlegement.\n             *\n             * @param packet\n             * @private\n             */\n            onack(packet) {\n              const ack = this.acks[packet.id];\n              if (\"function\" === typeof ack) {\n                ack.apply(this, packet.data);\n                delete this.acks[packet.id];\n              } else {\n              }\n            }\n            /**\n             * Called upon server connect.\n             *\n             * @private\n             */\n            onconnect(id, pid) {\n              this.id = id;\n              this.recovered = pid && this._pid === pid;\n              this._pid = pid;\n              this.connected = true;\n              this.emitBuffered();\n              this.emitReserved(\"connect\");\n              this._drainQueue(true);\n            }\n            /**\n             * Emit buffered events (received and emitted).\n             *\n             * @private\n             */\n            emitBuffered() {\n              this.receiveBuffer.forEach((args) => this.emitEvent(args));\n              this.receiveBuffer = [];\n              this.sendBuffer.forEach((packet) => {\n                this.notifyOutgoingListeners(packet);\n                this.packet(packet);\n              });\n              this.sendBuffer = [];\n            }\n            /**\n             * Called upon server disconnect.\n             *\n             * @private\n             */\n            ondisconnect() {\n              this.destroy();\n              this.onclose(\"io server disconnect\");\n            }\n            /**\n             * Called upon forced client/server side disconnections,\n             * this method ensures the manager stops tracking us and\n             * that reconnections don't get triggered for this.\n             *\n             * @private\n             */\n            destroy() {\n              if (this.subs) {\n                this.subs.forEach((subDestroy) => subDestroy());\n                this.subs = void 0;\n              }\n              this.io[\"_destroy\"](this);\n            }\n            /**\n             * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n             *\n             * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n             *\n             * @example\n             * const socket = io();\n             *\n             * socket.on(\"disconnect\", (reason) => {\n             *   // console.log(reason); prints \"io client disconnect\"\n             * });\n             *\n             * socket.disconnect();\n             *\n             * @return self\n             */\n            disconnect() {\n              if (this.connected) {\n                this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].DISCONNECT });\n              }\n              this.destroy();\n              if (this.connected) {\n                this.onclose(\"io client disconnect\");\n              }\n              return this;\n            }\n            /**\n             * Alias for {@link disconnect()}.\n             *\n             * @return self\n             */\n            close() {\n              return this.disconnect();\n            }\n            /**\n             * Sets the compress flag.\n             *\n             * @example\n             * socket.compress(false).emit(\"hello\");\n             *\n             * @param compress - if `true`, compresses the sending data\n             * @return self\n             */\n            compress(compress) {\n              this.flags.compress = compress;\n              return this;\n            }\n            /**\n             * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n             * ready to send messages.\n             *\n             * @example\n             * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n             *\n             * @returns self\n             */\n            get volatile() {\n              this.flags.volatile = true;\n              return this;\n            }\n            /**\n             * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n             * given number of milliseconds have elapsed without an acknowledgement from the server:\n             *\n             * @example\n             * socket.timeout(5000).emit(\"my-event\", (err) => {\n             *   if (err) {\n             *     // the server did not acknowledge the event in the given delay\n             *   }\n             * });\n             *\n             * @returns self\n             */\n            timeout(timeout) {\n              this.flags.timeout = timeout;\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback.\n             *\n             * @example\n             * socket.onAny((event, ...args) => {\n             *   console.log(`got ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            onAny(listener) {\n              this._anyListeners = this._anyListeners || [];\n              this._anyListeners.push(listener);\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback. The listener is added to the beginning of the listeners array.\n             *\n             * @example\n             * socket.prependAny((event, ...args) => {\n             *   console.log(`got event ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            prependAny(listener) {\n              this._anyListeners = this._anyListeners || [];\n              this._anyListeners.unshift(listener);\n              return this;\n            }\n            /**\n             * Removes the listener that will be fired when any event is emitted.\n             *\n             * @example\n             * const catchAllListener = (event, ...args) => {\n             *   console.log(`got event ${event}`);\n             * }\n             *\n             * socket.onAny(catchAllListener);\n             *\n             * // remove a specific listener\n             * socket.offAny(catchAllListener);\n             *\n             * // or remove all listeners\n             * socket.offAny();\n             *\n             * @param listener\n             */\n            offAny(listener) {\n              if (!this._anyListeners) {\n                return this;\n              }\n              if (listener) {\n                const listeners = this._anyListeners;\n                for (let i = 0; i < listeners.length; i++) {\n                  if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                  }\n                }\n              } else {\n                this._anyListeners = [];\n              }\n              return this;\n            }\n            /**\n             * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n             * e.g. to remove listeners.\n             */\n            listenersAny() {\n              return this._anyListeners || [];\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback.\n             *\n             * Note: acknowledgements sent to the server are not included.\n             *\n             * @example\n             * socket.onAnyOutgoing((event, ...args) => {\n             *   console.log(`sent event ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            onAnyOutgoing(listener) {\n              this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n              this._anyOutgoingListeners.push(listener);\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback. The listener is added to the beginning of the listeners array.\n             *\n             * Note: acknowledgements sent to the server are not included.\n             *\n             * @example\n             * socket.prependAnyOutgoing((event, ...args) => {\n             *   console.log(`sent event ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            prependAnyOutgoing(listener) {\n              this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n              this._anyOutgoingListeners.unshift(listener);\n              return this;\n            }\n            /**\n             * Removes the listener that will be fired when any event is emitted.\n             *\n             * @example\n             * const catchAllListener = (event, ...args) => {\n             *   console.log(`sent event ${event}`);\n             * }\n             *\n             * socket.onAnyOutgoing(catchAllListener);\n             *\n             * // remove a specific listener\n             * socket.offAnyOutgoing(catchAllListener);\n             *\n             * // or remove all listeners\n             * socket.offAnyOutgoing();\n             *\n             * @param [listener] - the catch-all listener (optional)\n             */\n            offAnyOutgoing(listener) {\n              if (!this._anyOutgoingListeners) {\n                return this;\n              }\n              if (listener) {\n                const listeners = this._anyOutgoingListeners;\n                for (let i = 0; i < listeners.length; i++) {\n                  if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                  }\n                }\n              } else {\n                this._anyOutgoingListeners = [];\n              }\n              return this;\n            }\n            /**\n             * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n             * e.g. to remove listeners.\n             */\n            listenersAnyOutgoing() {\n              return this._anyOutgoingListeners || [];\n            }\n            /**\n             * Notify the listeners for each packet sent\n             *\n             * @param packet\n             *\n             * @private\n             */\n            notifyOutgoingListeners(packet) {\n              if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n                const listeners = this._anyOutgoingListeners.slice();\n                for (const listener of listeners) {\n                  listener.apply(this, packet.data);\n                }\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/url.js\": (\n        /*!********************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/url.js ***!\n          \\********************************************************/\n        /*! exports provided: url */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"url\", function() {\n            return url;\n          });\n          var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! engine.io-client */\n            \"./node_modules/engine.io-client/build/esm/index.js\"\n          );\n          function url(uri, path = \"\", loc) {\n            let obj = uri;\n            loc = loc || typeof location !== \"undefined\" && location;\n            if (null == uri)\n              uri = loc.protocol + \"//\" + loc.host;\n            if (typeof uri === \"string\") {\n              if (\"/\" === uri.charAt(0)) {\n                if (\"/\" === uri.charAt(1)) {\n                  uri = loc.protocol + uri;\n                } else {\n                  uri = loc.host + uri;\n                }\n              }\n              if (!/^(https?|wss?):\\/\\//.test(uri)) {\n                if (\"undefined\" !== typeof loc) {\n                  uri = loc.protocol + \"//\" + uri;\n                } else {\n                  uri = \"https://\" + uri;\n                }\n              }\n              obj = Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"parse\"])(uri);\n            }\n            if (!obj.port) {\n              if (/^(http|ws)$/.test(obj.protocol)) {\n                obj.port = \"80\";\n              } else if (/^(http|ws)s$/.test(obj.protocol)) {\n                obj.port = \"443\";\n              }\n            }\n            obj.path = obj.path || \"/\";\n            const ipv6 = obj.host.indexOf(\":\") !== -1;\n            const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n            obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n            obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n            return obj;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-parser/build/esm/binary.js\": (\n        /*!***********************************************************!*\\\n          !*** ./node_modules/socket.io-parser/build/esm/binary.js ***!\n          \\***********************************************************/\n        /*! exports provided: deconstructPacket, reconstructPacket */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"deconstructPacket\", function() {\n            return deconstructPacket;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"reconstructPacket\", function() {\n            return reconstructPacket;\n          });\n          var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./is-binary.js */\n            \"./node_modules/socket.io-parser/build/esm/is-binary.js\"\n          );\n          function deconstructPacket(packet) {\n            const buffers = [];\n            const packetData = packet.data;\n            const pack = packet;\n            pack.data = _deconstructPacket(packetData, buffers);\n            pack.attachments = buffers.length;\n            return { packet: pack, buffers };\n          }\n          function _deconstructPacket(data, buffers) {\n            if (!data)\n              return data;\n            if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_0__[\"isBinary\"])(data)) {\n              const placeholder = { _placeholder: true, num: buffers.length };\n              buffers.push(data);\n              return placeholder;\n            } else if (Array.isArray(data)) {\n              const newData = new Array(data.length);\n              for (let i = 0; i < data.length; i++) {\n                newData[i] = _deconstructPacket(data[i], buffers);\n              }\n              return newData;\n            } else if (typeof data === \"object\" && !(data instanceof Date)) {\n              const newData = {};\n              for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                  newData[key] = _deconstructPacket(data[key], buffers);\n                }\n              }\n              return newData;\n            }\n            return data;\n          }\n          function reconstructPacket(packet, buffers) {\n            packet.data = _reconstructPacket(packet.data, buffers);\n            delete packet.attachments;\n            return packet;\n          }\n          function _reconstructPacket(data, buffers) {\n            if (!data)\n              return data;\n            if (data && data._placeholder === true) {\n              const isIndexValid = typeof data.num === \"number\" && data.num >= 0 && data.num < buffers.length;\n              if (isIndexValid) {\n                return buffers[data.num];\n              } else {\n                throw new Error(\"illegal attachments\");\n              }\n            } else if (Array.isArray(data)) {\n              for (let i = 0; i < data.length; i++) {\n                data[i] = _reconstructPacket(data[i], buffers);\n              }\n            } else if (typeof data === \"object\") {\n              for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                  data[key] = _reconstructPacket(data[key], buffers);\n                }\n              }\n            }\n            return data;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-parser/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/socket.io-parser/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: protocol, PacketType, Encoder, Decoder */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return protocol;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"PacketType\", function() {\n            return PacketType;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./binary.js */\n            \"./node_modules/socket.io-parser/build/esm/binary.js\"\n          );\n          var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./is-binary.js */\n            \"./node_modules/socket.io-parser/build/esm/is-binary.js\"\n          );\n          const RESERVED_EVENTS = [\n            \"connect\",\n            \"connect_error\",\n            \"disconnect\",\n            \"disconnecting\",\n            \"newListener\",\n            \"removeListener\"\n            // used by the Node.js EventEmitter\n          ];\n          const protocol = 5;\n          var PacketType;\n          (function(PacketType2) {\n            PacketType2[PacketType2[\"CONNECT\"] = 0] = \"CONNECT\";\n            PacketType2[PacketType2[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n            PacketType2[PacketType2[\"EVENT\"] = 2] = \"EVENT\";\n            PacketType2[PacketType2[\"ACK\"] = 3] = \"ACK\";\n            PacketType2[PacketType2[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n            PacketType2[PacketType2[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n            PacketType2[PacketType2[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n          })(PacketType || (PacketType = {}));\n          class Encoder {\n            /**\n             * Encoder constructor\n             *\n             * @param {function} replacer - custom replacer to pass down to JSON.parse\n             */\n            constructor(replacer) {\n              this.replacer = replacer;\n            }\n            /**\n             * Encode a packet as a single string if non-binary, or as a\n             * buffer sequence, depending on packet type.\n             *\n             * @param {Object} obj - packet object\n             */\n            encode(obj) {\n              if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n                if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__[\"hasBinary\"])(obj)) {\n                  return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id\n                  });\n                }\n              }\n              return [this.encodeAsString(obj)];\n            }\n            /**\n             * Encode packet as string.\n             */\n            encodeAsString(obj) {\n              let str = \"\" + obj.type;\n              if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {\n                str += obj.attachments + \"-\";\n              }\n              if (obj.nsp && \"/\" !== obj.nsp) {\n                str += obj.nsp + \",\";\n              }\n              if (null != obj.id) {\n                str += obj.id;\n              }\n              if (null != obj.data) {\n                str += JSON.stringify(obj.data, this.replacer);\n              }\n              return str;\n            }\n            /**\n             * Encode packet as 'buffer sequence' by removing blobs, and\n             * deconstructing packet into object with placeholders and\n             * a list of buffers.\n             */\n            encodeAsBinary(obj) {\n              const deconstruction = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__[\"deconstructPacket\"])(obj);\n              const pack = this.encodeAsString(deconstruction.packet);\n              const buffers = deconstruction.buffers;\n              buffers.unshift(pack);\n              return buffers;\n            }\n          }\n          function isObject(value) {\n            return Object.prototype.toString.call(value) === \"[object Object]\";\n          }\n          class Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__[\"Emitter\"] {\n            /**\n             * Decoder constructor\n             *\n             * @param {function} reviver - custom reviver to pass down to JSON.stringify\n             */\n            constructor(reviver) {\n              super();\n              this.reviver = reviver;\n            }\n            /**\n             * Decodes an encoded packet string into packet JSON.\n             *\n             * @param {String} obj - encoded packet\n             */\n            add(obj) {\n              let packet;\n              if (typeof obj === \"string\") {\n                if (this.reconstructor) {\n                  throw new Error(\"got plaintext data when reconstructing a packet\");\n                }\n                packet = this.decodeString(obj);\n                const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n                if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                  packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                  this.reconstructor = new BinaryReconstructor(packet);\n                  if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                  }\n                } else {\n                  super.emitReserved(\"decoded\", packet);\n                }\n              } else if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__[\"isBinary\"])(obj) || obj.base64) {\n                if (!this.reconstructor) {\n                  throw new Error(\"got binary data when not reconstructing a packet\");\n                } else {\n                  packet = this.reconstructor.takeBinaryData(obj);\n                  if (packet) {\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                  }\n                }\n              } else {\n                throw new Error(\"Unknown type: \" + obj);\n              }\n            }\n            /**\n             * Decode a packet String (JSON data)\n             *\n             * @param {String} str\n             * @return {Object} packet\n             */\n            decodeString(str) {\n              let i = 0;\n              const p = {\n                type: Number(str.charAt(0))\n              };\n              if (PacketType[p.type] === void 0) {\n                throw new Error(\"unknown packet type \" + p.type);\n              }\n              if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {\n                const start = i + 1;\n                while (str.charAt(++i) !== \"-\" && i != str.length) {\n                }\n                const buf = str.substring(start, i);\n                if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                  throw new Error(\"Illegal attachments\");\n                }\n                p.attachments = Number(buf);\n              }\n              if (\"/\" === str.charAt(i + 1)) {\n                const start = i + 1;\n                while (++i) {\n                  const c = str.charAt(i);\n                  if (\",\" === c)\n                    break;\n                  if (i === str.length)\n                    break;\n                }\n                p.nsp = str.substring(start, i);\n              } else {\n                p.nsp = \"/\";\n              }\n              const next = str.charAt(i + 1);\n              if (\"\" !== next && Number(next) == next) {\n                const start = i + 1;\n                while (++i) {\n                  const c = str.charAt(i);\n                  if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                  }\n                  if (i === str.length)\n                    break;\n                }\n                p.id = Number(str.substring(start, i + 1));\n              }\n              if (str.charAt(++i)) {\n                const payload = this.tryParse(str.substr(i));\n                if (Decoder.isPayloadValid(p.type, payload)) {\n                  p.data = payload;\n                } else {\n                  throw new Error(\"invalid payload\");\n                }\n              }\n              return p;\n            }\n            tryParse(str) {\n              try {\n                return JSON.parse(str, this.reviver);\n              } catch (e) {\n                return false;\n              }\n            }\n            static isPayloadValid(type, payload) {\n              switch (type) {\n                case PacketType.CONNECT:\n                  return isObject(payload);\n                case PacketType.DISCONNECT:\n                  return payload === void 0;\n                case PacketType.CONNECT_ERROR:\n                  return typeof payload === \"string\" || isObject(payload);\n                case PacketType.EVENT:\n                case PacketType.BINARY_EVENT:\n                  return Array.isArray(payload) && (typeof payload[0] === \"number\" || typeof payload[0] === \"string\" && RESERVED_EVENTS.indexOf(payload[0]) === -1);\n                case PacketType.ACK:\n                case PacketType.BINARY_ACK:\n                  return Array.isArray(payload);\n              }\n            }\n            /**\n             * Deallocates a parser's resources\n             */\n            destroy() {\n              if (this.reconstructor) {\n                this.reconstructor.finishedReconstruction();\n                this.reconstructor = null;\n              }\n            }\n          }\n          class BinaryReconstructor {\n            constructor(packet) {\n              this.packet = packet;\n              this.buffers = [];\n              this.reconPack = packet;\n            }\n            /**\n             * Method to be called when binary data received from connection\n             * after a BINARY_EVENT packet.\n             *\n             * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n             * @return {null | Object} returns null if more binary data is expected or\n             *   a reconstructed packet object if all buffers have been received.\n             */\n            takeBinaryData(binData) {\n              this.buffers.push(binData);\n              if (this.buffers.length === this.reconPack.attachments) {\n                const packet = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__[\"reconstructPacket\"])(this.reconPack, this.buffers);\n                this.finishedReconstruction();\n                return packet;\n              }\n              return null;\n            }\n            /**\n             * Cleans up binary packet reconstruction variables.\n             */\n            finishedReconstruction() {\n              this.reconPack = null;\n              this.buffers = [];\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-parser/build/esm/is-binary.js\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/socket.io-parser/build/esm/is-binary.js ***!\n          \\**************************************************************/\n        /*! exports provided: isBinary, hasBinary */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isBinary\", function() {\n            return isBinary;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"hasBinary\", function() {\n            return hasBinary;\n          });\n          const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n          const isView = (obj) => {\n            return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n          };\n          const toString = Object.prototype.toString;\n          const withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\n          const withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\n          function isBinary(obj) {\n            return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n          }\n          function hasBinary(obj, toJSON) {\n            if (!obj || typeof obj !== \"object\") {\n              return false;\n            }\n            if (Array.isArray(obj)) {\n              for (let i = 0, l = obj.length; i < l; i++) {\n                if (hasBinary(obj[i])) {\n                  return true;\n                }\n              }\n              return false;\n            }\n            if (isBinary(obj)) {\n              return true;\n            }\n            if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) {\n              return hasBinary(obj.toJSON(), true);\n            }\n            for (const key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n                return true;\n              }\n            }\n            return false;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/webpack/buildin/global.js\": (\n        /*!***********************************!*\\\n          !*** (webpack)/buildin/global.js ***!\n          \\***********************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2) {\n          var g;\n          g = function() {\n            return this;\n          }();\n          try {\n            g = g || new Function(\"return this\")();\n          } catch (e) {\n            if (typeof window === \"object\")\n              g = window;\n          }\n          module2.exports = g;\n        }\n      ),\n      /***/\n      \"./node_modules/worker-loader/dist/workers/InlineWorker.js\": (\n        /*!*****************************************************************!*\\\n          !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!\n          \\*****************************************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          var URL2 = window.URL || window.webkitURL;\n          module2.exports = function(content, url) {\n            try {\n              try {\n                var blob;\n                try {\n                  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n                  blob = new BlobBuilder();\n                  blob.append(content);\n                  blob = blob.getBlob();\n                } catch (e) {\n                  blob = new Blob([content]);\n                }\n                return new Worker(URL2.createObjectURL(blob));\n              } catch (e) {\n                return new Worker(\"data:application/javascript,\" + encodeURIComponent(content));\n              }\n            } catch (e) {\n              if (!url) {\n                throw Error(\"Inline worker is not supported\");\n              }\n              return new Worker(url);\n            }\n          };\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/main.js\": (\n        /*!*********************!*\\\n          !*** ./src/main.js ***!\n          \\*********************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"waitForInitialization\", function() {\n            return waitForInitialization;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setupRPC\", function() {\n            return setupRPC;\n          });\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./plugin.webworker.js */\n            \"./src/plugin.webworker.js\"\n          );\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n          var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./pluginIframe.js */\n            \"./src/pluginIframe.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"loadRequirements\"];\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"API_VERSION\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_4__[\"version\"];\n          });\n          function _inIframe() {\n            try {\n              return window.self !== window.top;\n            } catch (e) {\n              return true;\n            }\n          }\n          function _inWebWorker2() {\n            return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          }\n          function setupWebWorker(config) {\n            if (!config.allow_execution)\n              throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n            let broadcastChannel = null;\n            if (config.broadcastChannel) {\n              broadcastChannel = new BroadcastChannel(config.broadcastChannel);\n            }\n            const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a();\n            const fallbackTimeout = setTimeout(function() {\n              worker.terminate();\n              console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n              Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n            }, 2e3);\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            worker.addEventListener(\"message\", function(e) {\n              let transferables = void 0;\n              const m = e.data;\n              if (m.type === \"worker-ready\") {\n                worker.postMessage({\n                  type: \"connectRPC\",\n                  config\n                });\n                clearTimeout(fallbackTimeout);\n                return;\n              } else if (m.type === \"initialized\") {\n                m.config = Object.assign({}, config, m.config);\n                m.origin = globalThis.location.origin;\n                m.peer_id = peer_id;\n              } else if (m.type === \"imjoy_remote_api_ready\") {\n                globalThis.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: null\n                }));\n              } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n                cache_requirements(m.requirements);\n              } else if (m.type === \"disconnect\") {\n                worker.terminate();\n              } else {\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n              }\n              if (broadcastChannel)\n                broadcastChannel.postMessage(m);\n              else\n                parent.postMessage(m, config.target_origin || \"*\", transferables);\n            });\n            (broadcastChannel || window).addEventListener(\"message\", function(e) {\n              if (e.type === \"message\" && (broadcastChannel || config.target_origin === \"*\" || e.origin === config.target_origin)) {\n                let transferables = void 0;\n                const m = e.data;\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n                if (m.peer_id === peer_id) {\n                  worker.postMessage(m, transferables);\n                } else if (config.debug) {\n                  console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n                }\n              }\n            });\n          }\n          function waitForInitialization(config) {\n            if (_inWebWorker2()) {\n              globalThis.parent = self;\n            }\n            config = config || {};\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n              config.enable_service_worker = false;\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            const targetOrigin = config.target_origin || \"*\";\n            if (config.credential_required && typeof config.verify_credential !== \"function\") {\n              throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n            }\n            if (config.credential_required && targetOrigin === \"*\") {\n              throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n            }\n            const done = () => {\n              globalThis.removeEventListener(\"message\", handleEvent);\n            };\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            const handleEvent = (e) => {\n              if (e.type === \"message\" && (!e.origin || targetOrigin === \"*\" || e.origin === targetOrigin)) {\n                if (e.data.type === \"initialize\") {\n                  done();\n                  if (e.data.peer_id !== peer_id) {\n                    console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n                  }\n                  const cfg = e.data.config;\n                  if (targetOrigin !== \"*\") {\n                    cfg.target_origin = targetOrigin;\n                  }\n                  if (config.credential_required) {\n                    config.verify_credential(cfg.credential).then((result) => {\n                      if (result && result.auth && !result.error) {\n                        cfg.auth = result.auth;\n                        setupRPC(cfg).then(() => {\n                          console.log(\"ImJoy RPC loaded successfully!\");\n                        });\n                      } else {\n                        throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n                      }\n                    });\n                  } else {\n                    setupRPC(cfg).then(() => {\n                      console.log(\"ImJoy RPC loaded successfully!\");\n                    });\n                  }\n                } else {\n                  throw new Error(`unrecognized message: ${e.data}`);\n                }\n              }\n            };\n            globalThis.addEventListener(\"message\", handleEvent);\n            if (_inWebWorker2()) {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              });\n            } else {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              }, \"*\");\n            }\n          }\n          function setupRPC(config) {\n            config = config || {};\n            config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"normalizeConfig\"])(config);\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            return new Promise((resolve, reject) => {\n              const handleEvent = (e) => {\n                const api = e.detail;\n                if (config.expose_api_globally) {\n                  globalThis.api = api;\n                }\n                resolve(api);\n                globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              };\n              if (_inIframe()) {\n                if (config.type === \"web-worker\") {\n                  try {\n                    setupWebWorker(config);\n                  } catch (e) {\n                    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                  }\n                } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n                  Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                } else {\n                  console.error(\"Unsupported plugin type: \" + config.type);\n                  reject(\"Unsupported plugin type: \" + config.type);\n                  return;\n                }\n                globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              } else if (_inWebWorker2()) {\n                Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n              } else {\n                reject(new Error(\"imjoy-rpc should only run inside an iframe or a webworker.\"));\n              }\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/plugin.webworker.js\": (\n        /*!*********************************!*\\\n          !*** ./src/plugin.webworker.js ***!\n          \\*********************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          module2.exports = function() {\n            return __webpack_require__2(\n              /*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */\n              \"./node_modules/worker-loader/dist/workers/InlineWorker.js\"\n            )('/******/ (function(modules) { // webpackBootstrap\\n/******/ \t// The module cache\\n/******/ \tvar installedModules = {};\\n/******/\\n/******/ \t// The require function\\n/******/ \tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \t\t// Check if module is in cache\\n/******/ \t\tif(installedModules[moduleId]) {\\n/******/ \t\t\treturn installedModules[moduleId].exports;\\n/******/ \t\t}\\n/******/ \t\t// Create a new module (and put it into the cache)\\n/******/ \t\tvar module = installedModules[moduleId] = {\\n/******/ \t\t\ti: moduleId,\\n/******/ \t\t\tl: false,\\n/******/ \t\t\texports: {}\\n/******/ \t\t};\\n/******/\\n/******/ \t\t// Execute the module function\\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \t\t// Flag the module as loaded\\n/******/ \t\tmodule.l = true;\\n/******/\\n/******/ \t\t// Return the exports of the module\\n/******/ \t\treturn module.exports;\\n/******/ \t}\\n/******/\\n/******/\\n/******/ \t// expose the modules object (__webpack_modules__)\\n/******/ \t__webpack_require__.m = modules;\\n/******/\\n/******/ \t// expose the module cache\\n/******/ \t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \t// define getter function for harmony exports\\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \t\t}\\n/******/ \t};\\n/******/\\n/******/ \t// define __esModule on exports\\n/******/ \t__webpack_require__.r = function(exports) {\\n/******/ \t\tif(typeof Symbol !== \\'undefined\\' && Symbol.toStringTag) {\\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \\'Module\\' });\\n/******/ \t\t}\\n/******/ \t\tObject.defineProperty(exports, \\'__esModule\\', { value: true });\\n/******/ \t};\\n/******/\\n/******/ \t// create a fake namespace object\\n/******/ \t// mode & 1: value is a module id, require it\\n/******/ \t// mode & 2: merge all properties of value into the ns\\n/******/ \t// mode & 4: return value when already ns object\\n/******/ \t// mode & 8|1: behave like require\\n/******/ \t__webpack_require__.t = function(value, mode) {\\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \t\tif(mode & 8) return value;\\n/******/ \t\tif((mode & 4) && typeof value === \\'object\\' && value && value.__esModule) return value;\\n/******/ \t\tvar ns = Object.create(null);\\n/******/ \t\t__webpack_require__.r(ns);\\n/******/ \t\tObject.defineProperty(ns, \\'default\\', { enumerable: true, value: value });\\n/******/ \t\tif(mode & 2 && typeof value != \\'string\\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \t\treturn ns;\\n/******/ \t};\\n/******/\\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \t__webpack_require__.n = function(module) {\\n/******/ \t\tvar getter = module && module.__esModule ?\\n/******/ \t\t\tfunction getDefault() { return module[\\'default\\']; } :\\n/******/ \t\t\tfunction getModuleExports() { return module; };\\n/******/ \t\t__webpack_require__.d(getter, \\'a\\', getter);\\n/******/ \t\treturn getter;\\n/******/ \t};\\n/******/\\n/******/ \t// Object.prototype.hasOwnProperty.call\\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \t// __webpack_public_path__\\n/******/ \t__webpack_require__.p = \"\";\\n/******/\\n/******/\\n/******/ \t// Load entry module and return exports\\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/plugin.webworker.js\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \"./src/plugin.webworker.js\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \"undefined\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\"This script can only loaded in a webworker\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\"message\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \"initialized\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\"beforeDisconnect\");\\n    self.close();\\n    this._fire(\"disconnected\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \"requirements\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWebworker\"])(code.requirements);\\n    } else if (code.type === \"script\") {\\n      try {\\n        if (code.attrs.type === \"module\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \"unsupported code type.\";\\n    }\\n    if (code.type === \"requirements\") {\\n      self.postMessage({\\n        type: \"cacheRequirements\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \"web-worker\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \"javascript\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\"connectRPC\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \"worker-ready\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \"./src/pluginCore.js\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\\n  rpc.on(\"getInterface\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\"remoteReady\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\"Remove duplicated codec: \" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\"name\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \"imjoy_remote_api_ready\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \"function\") {\\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/rpc.js\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \"0.2.3\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\"undefined index\");\\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\"remoteIdle\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\"remoteBusy\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \"initialized\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\"interfaceAvailable\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\"interfaceSetAsRemote\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\"interface is not set.\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \"setInterface\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(`Object (id=${objectId}) not found.`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\"disposed\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \"disposeObject\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\"Invalid object\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\"init\", this.init);\\n\\n    this._connection.on(\"execute\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \"executed\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"executed\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\"method\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\".\")) {\\n          const tmp = data.name.split(\".\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"callback\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"disposeObject\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \"disposed\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"disposed\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"setInterface\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\"getInterface\", () => {\\n      this._fire(\"getInterface\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\"interfaceAvailable\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"interfaceSetAsRemote\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\"interfaceSetAsRemote\");\\n    });\\n\\n    this._connection.on(\"disconnect\", () => {\\n      this._fire(\"beforeDisconnect\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\"disconnected\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \"getInterface\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \"dtype doesn\\'t match the type of the array: \" + _dtype + \" != \" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \"ndarray\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\"remoteReady\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \"method\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \"interfaceSetAsRemote\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \"function\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\"objectId is not specified.\");\\n        bObject = {\\n          _rtype: \"interface\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \"callback\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \"error\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \"blob\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\\n      bObject = {\\n        _rtype: \"typedarray\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"memoryview\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \"set\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \"orderedmap\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\"Please instantiate the class before exportting it.\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\"Unsupported interface type\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \"constructor\") continue;\\n\\n          if (k.startsWith(\"_\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \"function\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \"function\") {\\n          aObject.on(\"close\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \"object\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n\\n      for (let k of keys) {\\n        if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \"imjoy-rpc: Unsupported data type:\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\"Failed to encode object\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\"_rtype\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \"callback\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \"interface\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \"ndarray\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \"undefined\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \"error\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \"file\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \"typedarray\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \"memoryview\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \"blob\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \"orderedmap\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \"set\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\"Failed to decode object\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \"callback\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \"callback\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \"disconnect\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/utils.js\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\"script\");\\n      scriptTag.src = url;\\n      scriptTag.type = \"text/javascript\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n            if (requirements[i].startsWith(\"css:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\"link\");\\n            link_node.rel = \"stylesheet\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\"mjs:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n            if (requirements[i].startsWith(\"js:\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"http\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n          } else {\\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \"unsupported requirements definition\";\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n          throw \"unable to import css in a webworker\";\\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n          if (requirements[i].startsWith(\"js:\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"http\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n        } else {\\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \"0.1.0\";\\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\\n  config.type = config.type || \"rpc-window\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \"*\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \"function\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \"int8\",\\n  Int16Array: \"int16\",\\n  Int32Array: \"int32\",\\n  Uint8Array: \"uint8\",\\n  Uint16Array: \"uint16\",\\n  Uint32Array: \"uint32\",\\n  Float32Array: \"float32\",\\n  Float64Array: \"float64\",\\n  Array: \"array\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \"add\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\"Service worker is not supported.\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\"Service worker controller is not available\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\"js:\")) req = req.slice(3);\\n    if (req.startsWith(\"css:\")) req = req.slice(4);\\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\\n    if (!req.startsWith(\"http\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\"serviceWorker\" in navigator) {\\n    baseUrl = baseUrl || \"/\";\\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\"ServiceWorker registration failed: \", err);\\n    });\\n    targetOrigin = targetOrigin || \"*\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\\n      throw new Error(\"config.cache_requirements must be a function\");\\n    }\\n\\n    window.addEventListener(\"message\", function (e) {\\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \"cacheRequirements\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\"/\").replace(/[\\\\/]+/g, \"/\").replace(/^(.+):\\\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\\\/(\\\\?|&|#[^!])/g, \"$1\").replace(/\\\\?/g, \"&\").replace(\"&\", \"?\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\"emit is not implemented\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\"unhandled event\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map', null);\n          };\n        }\n      ),\n      /***/\n      \"./src/pluginCore.js\": (\n        /*!***************************!*\\\n          !*** ./src/pluginCore.js ***!\n          \\***************************/\n        /*! exports provided: connectRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"connectRPC\", function() {\n            return connectRPC;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          function connectRPC(connection, config) {\n            config = config || {};\n            const codecs = {};\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n            rpc.on(\"getInterface\", function() {\n              launchConnected();\n            });\n            rpc.on(\"remoteReady\", function() {\n              const api = rpc.getRemote() || {};\n              api.registerCodec = function(config2) {\n                if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                  throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n                } else {\n                  if (config2.type) {\n                    for (let k of Object.keys(codecs)) {\n                      if (codecs[k].type === config2.type || k === config2.name) {\n                        delete codecs[k];\n                        console.warn(\"Remove duplicated codec: \" + k);\n                      }\n                    }\n                  }\n                  codecs[config2[\"name\"]] = config2;\n                }\n              };\n              api.init = function(config2) {\n                rpc.setInterface({\n                  setup() {\n                  }\n                }, config2);\n              };\n              api.disposeObject = function(obj) {\n                rpc.disposeObject(obj);\n              };\n              api.export = function(_interface, config2) {\n                rpc.setInterface(_interface, config2);\n              };\n              api.onLoad = function(handler) {\n                handler = checkHandler(handler);\n                if (connected) {\n                  handler();\n                } else {\n                  connectedHandlers.push(handler);\n                }\n              };\n              api.dispose = function(_interface) {\n                rpc.disconnect();\n              };\n              api._rpc = rpc;\n              if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n                self.api = api;\n                self.postMessage({\n                  type: \"imjoy_remote_api_ready\"\n                });\n                self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              } else if (typeof window) {\n                window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              }\n            });\n            let connected = false;\n            const connectedHandlers = [];\n            const launchConnected = function() {\n              if (!connected) {\n                connected = true;\n                let handler;\n                while (handler = connectedHandlers.pop()) {\n                  handler();\n                }\n              }\n            };\n            const checkHandler = function(handler) {\n              const type = typeof handler;\n              if (type !== \"function\") {\n                const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n                throw new Error(msg);\n              }\n              return handler;\n            };\n            return rpc;\n          }\n        }\n      ),\n      /***/\n      \"./src/pluginIframe.js\": (\n        /*!*****************************!*\\\n          !*** ./src/pluginIframe.js ***!\n          \\*****************************/\n        /*! exports provided: Connection, default */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_305242__) {\n          \"use strict\";\n          __nested_webpack_require_305242__.r(__nested_webpack_exports__);\n          __nested_webpack_require_305242__.d(__nested_webpack_exports__, \"Connection\", function() {\n            return Connection;\n          });\n          __nested_webpack_require_305242__.d(__nested_webpack_exports__, \"default\", function() {\n            return setupIframe;\n          });\n          var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_305242__(\n            /*! ./pluginCore.js */\n            \"./src/pluginCore.js\"\n          );\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_305242__(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_305242__(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          function _htmlToElement(html) {\n            var template = document.createElement(\"template\");\n            html = html.trim();\n            template.innerHTML = html;\n            return template.content.firstChild;\n          }\n          const _inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          async function executeEsModule(content) {\n            const dataUri = \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\n            await import(\n              /* webpackIgnore: true */\n              dataUri\n            );\n          }\n          class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n            constructor(config) {\n              super(config && config.debug);\n              this.config = config || {};\n              this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n            }\n            connect() {\n              this.config.target_origin = this.config.target_origin || \"*\";\n              if (this.config.broadcastChannel) {\n                this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);\n              } else {\n                this.broadcastChannel = null;\n              }\n              if (this.broadcastChannel)\n                this.broadcastChannel.addEventListener(\"message\", this);\n              else\n                globalThis.addEventListener(\"message\", this);\n              this.emit({\n                type: \"initialized\",\n                config: this.config,\n                origin: globalThis.location.origin,\n                peer_id: this.peer_id\n              });\n              this._fire(\"connected\");\n            }\n            handleEvent(e) {\n              if (e.type === \"message\" && (this.broadcastChannel || this.config.target_origin === \"*\" || !e.origin || e.origin === this.config.target_origin)) {\n                if (e.data.peer_id === this.peer_id) {\n                  this._fire(e.data.type, e.data);\n                } else if (this.config.debug) {\n                  console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n                }\n              }\n            }\n            disconnect() {\n              this._fire(\"beforeDisconnect\");\n              globalThis.removeEventListener(\"message\", this);\n              this._fire(\"disconnected\");\n            }\n            emit(data) {\n              let transferables;\n              if (this.broadcastChannel)\n                this.broadcastChannel.postMessage(data);\n              else {\n                if (data.__transferables__) {\n                  transferables = data.__transferables__;\n                  delete data.__transferables__;\n                } else if (_inWebWorker)\n                  self.postMessage(data, transferables);\n                else\n                  parent.postMessage(data, this.config.target_origin, transferables);\n              }\n            }\n            async execute(code) {\n              try {\n                if (code.type === \"requirements\") {\n                  await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWindow\"])(code.requirements);\n                } else if (code.type === \"script\") {\n                  if (code.src) {\n                    var script_node = document.createElement(\"script\");\n                    script_node.setAttribute(\"type\", code.attrs.type);\n                    script_node.setAttribute(\"src\", code.src);\n                    document.head.appendChild(script_node);\n                  } else {\n                    if (code.content && code.attrs.lang === \"javascript\") {\n                      if (code.attrs.type === \"module\") {\n                        await executeEsModule(code.content);\n                      } else {\n                        eval(code.content);\n                      }\n                    } else {\n                      var node = document.createElement(\"script\");\n                      for (let k in code.attrs) {\n                        node.setAttribute(k, code.attrs[k]);\n                      }\n                      node.appendChild(document.createTextNode(code.content));\n                      document.body.appendChild(node);\n                    }\n                  }\n                } else if (code.type === \"style\") {\n                  const style_node = document.createElement(\"style\");\n                  if (code.src) {\n                    style_node.src = code.src;\n                  }\n                  style_node.innerHTML = code.content;\n                  document.head.appendChild(style_node);\n                } else if (code.type === \"link\") {\n                  const link_node_ = document.createElement(\"link\");\n                  if (code.rel) {\n                    link_node_.rel = code.rel;\n                  }\n                  if (code.href) {\n                    link_node_.href = code.href;\n                  }\n                  if (code.attrs && code.attrs.type) {\n                    link_node_.type = code.attrs.type;\n                  }\n                  document.head.appendChild(link_node_);\n                } else if (code.type === \"html\") {\n                  document.body.appendChild(_htmlToElement(code.content));\n                } else {\n                  throw \"unsupported code type.\";\n                }\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\"\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\"\n                  }, this.config.target_origin);\n              } catch (e) {\n                console.error(\"failed to execute scripts: \", code, e);\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  }, this.config.target_origin);\n              }\n            }\n          }\n          function setupIframe(config) {\n            config = config || {};\n            config.dedicated_thread = false;\n            config.lang = \"javascript\";\n            config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n            const conn = new Connection(config);\n            Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n            conn.connect();\n          }\n        }\n      ),\n      /***/\n      \"./src/rpc.js\": (\n        /*!********************!*\\\n          !*** ./src/rpc.js ***!\n          \\********************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          const API_VERSION = \"0.2.3\";\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, config, codecs) {\n              super(config && config.debug);\n              this._connection = connection;\n              this.config = config || {};\n              this._codecs = codecs || {};\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._remote_set = false;\n              const name = this.config.name;\n              this._connection.execute = this._connection.execute || function() {\n                throw new Error(`connection.execute not implemented (in \"${name}\")`);\n              };\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n              this._method_refs.onReady(() => {\n                this._fire(\"remoteIdle\");\n              });\n              this._method_refs.onBusy(() => {\n                this._fire(\"remoteBusy\");\n              });\n              this._setupMessageHanlders();\n            }\n            init() {\n              this._connection.emit({\n                type: \"initialized\",\n                config: this.config,\n                peer_id: this._connection.peer_id\n              });\n            }\n            setConfig(config) {\n              if (config)\n                for (const k of Object.keys(config)) {\n                  this.config[k] = config[k];\n                }\n            }\n            /**\n             * Set a handler to be called when received a responce from the\n             * remote site reporting that the previously provided interface\n             * has been successfully set as remote for that site\n             *\n             * @param {Function} handler\n             */\n            getRemoteCallStack() {\n              return this._method_refs.getStack();\n            }\n            /**\n             * @returns {Object} set of remote interface methods\n             */\n            getRemote() {\n              return this._remote_interface;\n            }\n            /**\n             * Sets the interface of this site making it available to the\n             * remote site by sending a message with a set of methods names\n             *\n             * @param {Object} _interface to set\n             */\n            setInterface(_interface, config) {\n              config = config || {};\n              this.config.name = config.name || this.config.name;\n              this.config.description = config.description || this.config.description;\n              if (this.config.forwarding_functions) {\n                for (let func_name of this.config.forwarding_functions) {\n                  const _remote = this._remote_interface;\n                  if (_remote[func_name]) {\n                    if (_interface.constructor === Object) {\n                      if (!_interface[func_name]) {\n                        _interface[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    } else if (_interface.constructor.constructor === Function) {\n                      if (!_interface.constructor.prototype[func_name]) {\n                        _interface.constructor.prototype[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    }\n                  }\n                }\n              }\n              this._local_api = _interface;\n              if (!this._remote_set)\n                this._fire(\"interfaceAvailable\");\n              else\n                this.sendInterface();\n              return new Promise((resolve) => {\n                this.once(\"interfaceSetAsRemote\", resolve);\n              });\n            }\n            /**\n             * Sends the actual interface to the remote site upon it was\n             * updated or by a special request of the remote site\n             */\n            sendInterface() {\n              if (!this._local_api) {\n                throw new Error(\"interface is not set.\");\n              }\n              this._encode(this._local_api, true).then((api) => {\n                this._connection.emit({\n                  type: \"setInterface\",\n                  api\n                });\n              });\n            }\n            _disposeObject(objectId) {\n              if (this._object_store[objectId]) {\n                delete this._object_store[objectId];\n              } else {\n                throw new Error(`Object (id=${objectId}) not found.`);\n              }\n            }\n            disposeObject(obj) {\n              return new Promise((resolve, reject) => {\n                if (this._object_weakmap.has(obj)) {\n                  const objectId = this._object_weakmap.get(obj);\n                  this._connection.once(\"disposed\", (data) => {\n                    if (data.error)\n                      reject(new Error(data.error));\n                    else\n                      resolve();\n                  });\n                  this._connection.emit({\n                    type: \"disposeObject\",\n                    object_id: objectId\n                  });\n                } else {\n                  throw new Error(\"Invalid object\");\n                }\n              });\n            }\n            /**\n             * Handles a message from the remote site\n             */\n            _setupMessageHanlders() {\n              this._connection.on(\"init\", this.init);\n              this._connection.on(\"execute\", (data) => {\n                Promise.resolve(this._connection.execute(data.code)).then(() => {\n                  this._connection.emit({\n                    type: \"executed\"\n                  });\n                }).catch((e) => {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"executed\",\n                    error: String(e)\n                  });\n                });\n              });\n              this._connection.on(\"method\", async (data) => {\n                let resolve, reject, method, method_this, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  const _interface = this._object_store[data.object_id];\n                  method = indexObject(_interface, data.name);\n                  if (data.name.includes(\".\")) {\n                    const tmp = data.name.split(\".\");\n                    const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\n                    method_this = indexObject(_interface, intf_index);\n                  } else {\n                    method_this = _interface;\n                  }\n                  args = await this._unwrap(data.args, true);\n                  if (data.promise) {\n                    result = method.apply(method_this, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method.apply(method_this, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"callback\", async (data) => {\n                let resolve, reject, method, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  if (data.promise) {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    result = method.apply(null, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    method.apply(null, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"disposeObject\", (data) => {\n                try {\n                  this._disposeObject(data.object_id);\n                  this._connection.emit({\n                    type: \"disposed\"\n                  });\n                } catch (e) {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"disposed\",\n                    error: String(e)\n                  });\n                }\n              });\n              this._connection.on(\"setInterface\", (data) => {\n                this._setRemoteInterface(data.api);\n              });\n              this._connection.on(\"getInterface\", () => {\n                this._fire(\"getInterface\");\n                if (this._local_api) {\n                  this.sendInterface();\n                } else {\n                  this.once(\"interfaceAvailable\", () => {\n                    this.sendInterface();\n                  });\n                }\n              });\n              this._connection.on(\"interfaceSetAsRemote\", () => {\n                this._remote_set = true;\n                this._fire(\"interfaceSetAsRemote\");\n              });\n              this._connection.on(\"disconnect\", () => {\n                this._fire(\"beforeDisconnect\");\n                this._connection.disconnect();\n                this._fire(\"disconnected\");\n              });\n            }\n            /**\n             * Sends a requests to the remote site asking it to provide its\n             * current interface\n             */\n            requestRemote() {\n              this._connection.emit({\n                type: \"getInterface\"\n              });\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            /**\n             * Sets the new remote interface provided by the other site\n             *\n             * @param {Array} names list of function names\n             */\n            _setRemoteInterface(api) {\n              this._decode(api).then((intf) => {\n                if (this._remote_interface) {\n                  for (let k in this._remote_interface)\n                    delete this._remote_interface[k];\n                  Object.assign(this._remote_interface, intf);\n                } else\n                  this._remote_interface = intf;\n                this._fire(\"remoteReady\");\n                this._reportRemoteSet();\n              });\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * method. When the generated function is called, it will send the\n             * corresponding message to the remote site asking it to execute\n             * the particular method of its interface\n             *\n             * @param {String} name of the remote method\n             *\n             * @returns {Function} wrapped remote method\n             */\n            _genRemoteMethod(targetId, name, objectId) {\n              const me = this;\n              const remoteMethod = function() {\n                return new Promise(async (resolve, reject) => {\n                  let id = null;\n                  try {\n                    id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n                    const wrapped_resolve = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return resolve.apply(this, arguments);\n                    };\n                    const wrapped_reject = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return reject.apply(this, arguments);\n                    };\n                    const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]);\n                    wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n                    let args = Array.prototype.slice.call(arguments);\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\n                      args = await me._wrap(args, true);\n                    } else {\n                      args = await me._wrap(args);\n                    }\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    me._connection.emit({\n                      type: \"method\",\n                      target_id: targetId,\n                      name,\n                      object_id: objectId,\n                      args,\n                      promise: encodedPromise,\n                      with_kwargs: withKwargs\n                    }, transferables);\n                  } catch (e) {\n                    if (id)\n                      me._method_refs.fetch(id);\n                    reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n                  }\n                });\n              };\n              remoteMethod.__remote_method = true;\n              return remoteMethod;\n            }\n            /**\n             * Sends a responce reporting that interface just provided by the\n             * remote site was successfully set by this site as remote\n             */\n            _reportRemoteSet() {\n              this._connection.emit({\n                type: \"interfaceSetAsRemote\"\n              });\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, asInterface, objectId) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof ArrayBuffer) {\n                return aObject;\n              }\n              let bObject;\n              if (typeof aObject === \"function\") {\n                if (asInterface) {\n                  if (!objectId)\n                    throw new Error(\"objectId is not specified.\");\n                  bObject = {\n                    _rtype: \"interface\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rintf: objectId,\n                    _rvalue: asInterface\n                  };\n                  this._method_weakmap.set(aObject, bObject);\n                } else if (this._method_weakmap.has(aObject)) {\n                  bObject = this._method_weakmap.get(aObject);\n                } else {\n                  const cid = this._store.put(aObject);\n                  bObject = {\n                    _rtype: \"callback\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rname: aObject.constructor && aObject.constructor.name || cid,\n                    _rvalue: cid\n                  };\n                }\n                return bObject;\n              }\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                if (aObject._rintf) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._encode(aObject, asInterface, objectId);\n                  bObject._rtype = temp;\n                } else {\n                  bObject = aObject;\n                }\n                return bObject;\n              }\n              const transferables = [];\n              const _transfer = aObject._transfer;\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (encodedObj && encodedObj._rintf) {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, asInterface, objectId);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                if (aObject._transfer || _transfer) {\n                  transferables.push(v_buffer.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: v_buffer.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.selection.data.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: aObject.selection.data.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString()\n                };\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rname: aObject.name,\n                  _rmime: aObject.type,\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject instanceof Blob) {\n                bObject = {\n                  _rtype: \"blob\",\n                  _rvalue: aObject\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: aObject.buffer,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: aObject.buffer\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                let keys;\n                if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  keys = Object.keys(aObject);\n                } else if (aObject.constructor === Function) {\n                  throw new Error(\"Please instantiate the class before exportting it.\");\n                } else if (aObject.constructor.constructor === Function) {\n                  keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                  asInterface = true;\n                } else {\n                  throw Error(\"Unsupported interface type\");\n                }\n                let hasFunction = false;\n                if (aObject._rintf || asInterface) {\n                  if (!objectId) {\n                    if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\n                      objectId = aObject._rintf;\n                    } else {\n                      objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                    }\n                    if (this._object_store[objectId])\n                      console.warn(`Overwritting interface object with the same id: ${objectId}`);\n                    this._object_store[objectId] = aObject;\n                  }\n                  for (let k of keys) {\n                    if (k === \"constructor\")\n                      continue;\n                    if (k.startsWith(\"_\")) {\n                      continue;\n                    }\n                    bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n                    if (typeof aObject[k] === \"function\") {\n                      hasFunction = true;\n                    }\n                  }\n                  if (hasFunction)\n                    bObject._rintf = objectId;\n                  if (aObject.on && typeof aObject.on === \"function\") {\n                    aObject.on(\"close\", () => {\n                      delete this._object_store[objectId];\n                    });\n                  }\n                } else {\n                  for (let k of keys) {\n                    if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                      continue;\n                    bObject[k] = await this._encode(aObject[k]);\n                  }\n                }\n              } else if (typeof aObject === \"object\") {\n                const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                const objectId2 = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                for (let k of keys) {\n                  if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                    continue;\n                  bObject[k] = await this._encode(aObject[k], k, bObject);\n                }\n                bObject._rintf = objectId2;\n              } else {\n                throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n              }\n              if (transferables.length > 0) {\n                bObject.__transferables__ = transferables;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async _decode(aObject, withPromise) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject[\"_rtype\"]) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    aObject = await this._decode(aObject, withPromise);\n                    aObject._rtype = temp;\n                  }\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"callback\") {\n                  bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n                } else if (aObject._rtype === \"interface\") {\n                  bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(aObject._rvalue);\n                } else if (aObject._rtype === \"file\") {\n                  if (aObject._rvalue instanceof File) {\n                    bObject = aObject._rvalue;\n                    bObject._path = aObject._rpath;\n                  } else {\n                    bObject = new File([aObject._rvalue], aObject._rname, {\n                      type: aObject._rmime\n                    });\n                    bObject._path = aObject._rpath;\n                  }\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  bObject = new arraytype(aObject._rvalue);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = new DataView(aObject._rvalue);\n                } else if (aObject._rtype === \"blob\") {\n                  if (aObject._rvalue instanceof Blob) {\n                    bObject = aObject._rvalue;\n                  } else {\n                    bObject = new Blob([aObject._rvalue], {\n                      type: aObject._rmime\n                    });\n                  }\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, withPromise));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, withPromise));\n                } else {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    bObject = await this._decode(aObject, withPromise);\n                    bObject._rtype = temp;\n                  } else\n                    bObject = aObject;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, withPromise);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              if (aObject._rintf) {\n                this._object_weakmap.set(bObject, aObject._rintf);\n              }\n              return bObject;\n            }\n            async _wrap(args, asInterface) {\n              return await this._encode(args, asInterface);\n            }\n            /**\n             * Unwraps the set of arguments delivered from the remote site,\n             * replaces all callback identifiers with a function which will\n             * initiate sending that callback identifier back to other site\n             *\n             * @param {Object} args to unwrap\n             *\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Array} unwrapped args\n             */\n            async _unwrap(args, withPromise) {\n              return await this._decode(args, withPromise);\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * callback. When the generated function is called, it will send\n             * the corresponding message to the remote site asking it to\n             * execute the particular callback previously saved during a call\n             * by the remote site a method from the interface of this site\n             *\n             * @param {Number} id of the remote callback to execute\n             * @param {Number} argNum argument index of the callback\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Function} wrapped remote callback\n             */\n            _genRemoteCallback(targetId, cid, withPromise) {\n              const me = this;\n              let remoteCallback;\n              if (withPromise) {\n                remoteCallback = function() {\n                  return new Promise(async (resolve, reject) => {\n                    const args = await me._wrap(Array.prototype.slice.call(arguments));\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    const encodedPromise = await me._wrap([resolve, reject]);\n                    resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    reject.__promise_pair = encodedPromise[0]._rvalue;\n                    try {\n                      me._connection.emit({\n                        type: \"callback\",\n                        target_id: targetId,\n                        id: cid,\n                        args,\n                        promise: encodedPromise,\n                        with_kwargs: withKwargs\n                      }, transferables);\n                    } catch (e) {\n                      reject(`Failed to exectue remote callback ( id: ${cid}).`);\n                    }\n                  });\n                };\n                return remoteCallback;\n              } else {\n                remoteCallback = async function() {\n                  const args = await me._wrap(Array.prototype.slice.call(arguments));\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  const transferables = args.__transferables__;\n                  if (transferables)\n                    delete args.__transferables__;\n                  return me._connection.emit({\n                    type: \"callback\",\n                    target_id: targetId,\n                    id: cid,\n                    args,\n                    with_kwargs: withKwargs\n                  }, transferables);\n                };\n                return remoteCallback;\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._remote_interface = null;\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n            }\n            /**\n             * Sends the notification message and breaks the connection\n             */\n            disconnect() {\n              this._connection.emit({\n                type: \"disconnect\"\n              });\n              this.reset();\n              setTimeout(() => {\n                this._connection.disconnect();\n              }, 2e3);\n            }\n          }\n          class ReferenceStore {\n            constructor() {\n              this._store = {};\n              this._indices = [0];\n              this._readyHandler = function() {\n              };\n              this._busyHandler = function() {\n              };\n              this._readyHandler();\n            }\n            /**\n             * call handler when the store is empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onReady(readyHandler) {\n              this._readyHandler = readyHandler || function() {\n              };\n            }\n            /**\n             * call handler when the store is not empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onBusy(busyHandler) {\n              this._busyHandler = busyHandler || function() {\n              };\n            }\n            /**\n             * get the length of the store\n             *\n             */\n            getStack() {\n              return Object.keys(this._store).length;\n            }\n            /**\n             * @function _genId() generates the new reference id\n             *\n             * @returns {Number} smallest available id and reserves it\n             */\n            _genId() {\n              let id;\n              if (this._indices.length === 1) {\n                id = this._indices[0]++;\n              } else {\n                id = this._indices.shift();\n              }\n              return id;\n            }\n            /**\n             * Releases the given reference id so that it will be available by\n             * another object stored\n             *\n             * @param {Number} id to release\n             */\n            _releaseId(id) {\n              for (let i = 0; i < this._indices.length; i++) {\n                if (id < this._indices[i]) {\n                  this._indices.splice(i, 0, id);\n                  break;\n                }\n              }\n              for (let i = this._indices.length - 1; i >= 0; i--) {\n                if (this._indices[i] - 1 === this._indices[i - 1]) {\n                  this._indices.pop();\n                } else {\n                  break;\n                }\n              }\n            }\n            /**\n             * Stores the given object and returns the refernce id instead\n             *\n             * @param {Object} obj to store\n             *\n             * @returns {Number} reference id of the stored object\n             */\n            put(obj) {\n              if (this._busyHandler && Object.keys(this._store).length === 0) {\n                this._busyHandler();\n              }\n              const id = this._genId();\n              this._store[id] = obj;\n              return id;\n            }\n            /**\n             * Retrieves previously stored object and releases its reference\n             *\n             * @param {Number} id of an object to retrieve\n             */\n            fetch(id) {\n              const obj = this._store[id];\n              if (obj && !obj.__remote_method) {\n                delete this._store[id];\n                this._releaseId(id);\n                if (this._readyHandler && Object.keys(this._store).length === 0) {\n                  this._readyHandler();\n                }\n              }\n              if (obj && obj.__promise_pair) {\n                this.fetch(obj.__promise_pair);\n              }\n              return obj;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/socketIOMain.js\": (\n        /*!*****************************!*\\\n          !*** ./src/socketIOMain.js ***!\n          \\*****************************/\n        /*! exports provided: setupRPC, waitForInitialization, VERSION, RPC, API_VERSION, loadRequirements, Connection, connectToServer */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Connection\", function() {\n            return Connection2;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"connectToServer\", function() {\n            return connectToServer;\n          });\n          var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__2 = __webpack_require__2(\n            /*! ./pluginCore.js */\n            \"./src/pluginCore.js\"\n          );\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_1__2 = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_1__2[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_1__2[\"API_VERSION\"];\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"loadRequirements\"];\n          });\n          var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! socket.io-client */\n            \"./node_modules/socket.io-client/build/esm/index.js\"\n          );\n          var _main_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./main.js */\n            \"./src/main.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"setupRPC\", function() {\n            return _main_js__WEBPACK_IMPORTED_MODULE_4__[\"setupRPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"waitForInitialization\", function() {\n            return _main_js__WEBPACK_IMPORTED_MODULE_4__[\"waitForInitialization\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"];\n          });\n          class Connection2 extends _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"MessageEmitter\"] {\n            constructor(config) {\n              super(config && config.debug);\n              this.config = config || {};\n              this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            }\n            init() {\n              return new Promise((resolve, reject) => {\n                const config = this.config;\n                const url = config.server_url;\n                const extraHeaders = {};\n                if (config.token) {\n                  extraHeaders.Authorization = \"Bearer \" + config.token;\n                }\n                const basePath = new URL(url).pathname;\n                const socket = Object(socket_io_client__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(url, {\n                  withCredentials: true,\n                  extraHeaders,\n                  path: (basePath.endsWith(\"/\") ? basePath.slice(0, -1) : basePath) + \"/socket.io\"\n                });\n                let connected = false;\n                socket.on(\"connect\", () => {\n                  if (connected) {\n                    console.warn(\"Skipping reconnect to the server\");\n                    return;\n                  }\n                  socket.emit(\"register_plugin\", config, (result) => {\n                    if (!result.success) {\n                      console.error(result.detail);\n                      reject(result.detail);\n                      return;\n                    }\n                    connected = true;\n                    this.plugin_id = result.plugin_id;\n                    socket.on(\"plugin_message\", (data) => {\n                      if (data.peer_id === this.peer_id) {\n                        this._fire(data.type, data);\n                      } else if (this.config.debug) {\n                        console.log(`connection peer id mismatch ${data.peer_id} !== ${this.peer_id}`);\n                      }\n                    });\n                    this.once(\"initialize\", () => {\n                      if (!this.rpc) {\n                        this.rpc = Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__2[\"connectRPC\"])(this, config);\n                      } else {\n                        this.rpc.once(\"remoteReady\", () => {\n                          this.rpc.sendInterface();\n                        });\n                      }\n                      this.connect();\n                      resolve();\n                    });\n                    this.emit({\n                      type: \"imjoyRPCReady\",\n                      config,\n                      peer_id: this.peer_id\n                    });\n                  });\n                  this._disconnected = false;\n                });\n                socket.on(\"connect_error\", () => {\n                  reject(\"connection error\");\n                  this._fire(\"connectFailure\");\n                });\n                socket.on(\"disconnect\", () => {\n                  reject(\"disconnected\");\n                  this.disconnect();\n                  this._fire(\"disconnected\");\n                });\n                this.socket = socket;\n              });\n            }\n            connect() {\n              this.emit({\n                type: \"initialized\",\n                config: this.config,\n                origin: globalThis.location.origin,\n                peer_id: this.peer_id\n              });\n              this._fire(\"connected\");\n            }\n            reset() {\n              this._event_handlers = {};\n              this._once_handlers = {};\n            }\n            execute() {\n              throw new Error(\"Execution is not allowed for socketio connection\");\n            }\n            disconnect() {\n              this._fire(\"beforeDisconnect\");\n              this.socket.disconnect();\n              this.init();\n              this._fire(\"disconnected\");\n            }\n            emit(data) {\n              data.plugin_id = this.plugin_id;\n              this.socket.emit(\"plugin_message\", data, (result) => {\n                if (!result.success)\n                  this._fire(\"error\", data.detail);\n              });\n            }\n          }\n          function connectToServer(config) {\n            config = config || {};\n            if (!config.server_url)\n              throw new Error(\"Server URL is not specified.\");\n            config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"normalizeConfig\"])(config);\n            return new Promise((resolve, reject) => {\n              const handleEvent = (e) => {\n                const api = e.detail;\n                if (config.expose_api_globally) {\n                  globalThis.api = api;\n                }\n                resolve(api);\n                globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              };\n              globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              config = config || {};\n              config.dedicated_thread = false;\n              config.lang = \"javascript\";\n              config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__2[\"API_VERSION\"];\n              const conn = new Connection2(config);\n              conn.init().catch(reject);\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/utils.js\": (\n        /*!**********************!*\\\n          !*** ./src/utils.js ***!\n          \\**********************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_362459__) {\n          \"use strict\";\n          __nested_webpack_require_362459__.r(__nested_webpack_exports__);\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/imjoy-rpc.js":
/*!**************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/imjoy-rpc.js ***!
  \**************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/main.js\");\n    }({\n      /***/\n      \"./node_modules/worker-loader/dist/workers/InlineWorker.js\": (\n        /*!*****************************************************************!*\\\n          !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!\n          \\*****************************************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          var URL = window.URL || window.webkitURL;\n          module2.exports = function(content, url) {\n            try {\n              try {\n                var blob;\n                try {\n                  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n                  blob = new BlobBuilder();\n                  blob.append(content);\n                  blob = blob.getBlob();\n                } catch (e) {\n                  blob = new Blob([content]);\n                }\n                return new Worker(URL.createObjectURL(blob));\n              } catch (e) {\n                return new Worker(\"data:application/javascript,\" + encodeURIComponent(content));\n              }\n            } catch (e) {\n              if (!url) {\n                throw Error(\"Inline worker is not supported\");\n              }\n              return new Worker(url);\n            }\n          };\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/main.js\": (\n        /*!*********************!*\\\n          !*** ./src/main.js ***!\n          \\*********************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"waitForInitialization\", function() {\n            return waitForInitialization;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setupRPC\", function() {\n            return setupRPC;\n          });\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./plugin.webworker.js */\n            \"./src/plugin.webworker.js\"\n          );\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n          var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./pluginIframe.js */\n            \"./src/pluginIframe.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"loadRequirements\"];\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"API_VERSION\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_4__[\"version\"];\n          });\n          function _inIframe() {\n            try {\n              return window.self !== window.top;\n            } catch (e) {\n              return true;\n            }\n          }\n          function _inWebWorker2() {\n            return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          }\n          function setupWebWorker(config) {\n            if (!config.allow_execution)\n              throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n            let broadcastChannel = null;\n            if (config.broadcastChannel) {\n              broadcastChannel = new BroadcastChannel(config.broadcastChannel);\n            }\n            const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a();\n            const fallbackTimeout = setTimeout(function() {\n              worker.terminate();\n              console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n              Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n            }, 2e3);\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            worker.addEventListener(\"message\", function(e) {\n              let transferables = void 0;\n              const m = e.data;\n              if (m.type === \"worker-ready\") {\n                worker.postMessage({\n                  type: \"connectRPC\",\n                  config\n                });\n                clearTimeout(fallbackTimeout);\n                return;\n              } else if (m.type === \"initialized\") {\n                m.config = Object.assign({}, config, m.config);\n                m.origin = globalThis.location.origin;\n                m.peer_id = peer_id;\n              } else if (m.type === \"imjoy_remote_api_ready\") {\n                globalThis.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: null\n                }));\n              } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n                cache_requirements(m.requirements);\n              } else if (m.type === \"disconnect\") {\n                worker.terminate();\n              } else {\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n              }\n              if (broadcastChannel)\n                broadcastChannel.postMessage(m);\n              else\n                parent.postMessage(m, config.target_origin || \"*\", transferables);\n            });\n            (broadcastChannel || window).addEventListener(\"message\", function(e) {\n              if (e.type === \"message\" && (broadcastChannel || config.target_origin === \"*\" || e.origin === config.target_origin)) {\n                let transferables = void 0;\n                const m = e.data;\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n                if (m.peer_id === peer_id) {\n                  worker.postMessage(m, transferables);\n                } else if (config.debug) {\n                  console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n                }\n              }\n            });\n          }\n          function waitForInitialization(config) {\n            if (_inWebWorker2()) {\n              globalThis.parent = self;\n            }\n            config = config || {};\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n              config.enable_service_worker = false;\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            const targetOrigin = config.target_origin || \"*\";\n            if (config.credential_required && typeof config.verify_credential !== \"function\") {\n              throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n            }\n            if (config.credential_required && targetOrigin === \"*\") {\n              throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n            }\n            const done = () => {\n              globalThis.removeEventListener(\"message\", handleEvent);\n            };\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            const handleEvent = (e) => {\n              if (e.type === \"message\" && (!e.origin || targetOrigin === \"*\" || e.origin === targetOrigin)) {\n                if (e.data.type === \"initialize\") {\n                  done();\n                  if (e.data.peer_id !== peer_id) {\n                    console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n                  }\n                  const cfg = e.data.config;\n                  if (targetOrigin !== \"*\") {\n                    cfg.target_origin = targetOrigin;\n                  }\n                  if (config.credential_required) {\n                    config.verify_credential(cfg.credential).then((result) => {\n                      if (result && result.auth && !result.error) {\n                        cfg.auth = result.auth;\n                        setupRPC(cfg).then(() => {\n                          console.log(\"ImJoy RPC loaded successfully!\");\n                        });\n                      } else {\n                        throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n                      }\n                    });\n                  } else {\n                    setupRPC(cfg).then(() => {\n                      console.log(\"ImJoy RPC loaded successfully!\");\n                    });\n                  }\n                } else {\n                  throw new Error(`unrecognized message: ${e.data}`);\n                }\n              }\n            };\n            globalThis.addEventListener(\"message\", handleEvent);\n            if (_inWebWorker2()) {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              });\n            } else {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              }, \"*\");\n            }\n          }\n          function setupRPC(config) {\n            config = config || {};\n            config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"normalizeConfig\"])(config);\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            return new Promise((resolve, reject) => {\n              const handleEvent = (e) => {\n                const api = e.detail;\n                if (config.expose_api_globally) {\n                  globalThis.api = api;\n                }\n                resolve(api);\n                globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              };\n              if (_inIframe()) {\n                if (config.type === \"web-worker\") {\n                  try {\n                    setupWebWorker(config);\n                  } catch (e) {\n                    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                  }\n                } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n                  Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                } else {\n                  console.error(\"Unsupported plugin type: \" + config.type);\n                  reject(\"Unsupported plugin type: \" + config.type);\n                  return;\n                }\n                globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              } else if (_inWebWorker2()) {\n                Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n              } else {\n                reject(new Error(\"imjoy-rpc should only run inside an iframe or a webworker.\"));\n              }\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/plugin.webworker.js\": (\n        /*!*********************************!*\\\n          !*** ./src/plugin.webworker.js ***!\n          \\*********************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          module2.exports = function() {\n            return __webpack_require__2(\n              /*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */\n              \"./node_modules/worker-loader/dist/workers/InlineWorker.js\"\n            )('/******/ (function(modules) { // webpackBootstrap\\n/******/ \t// The module cache\\n/******/ \tvar installedModules = {};\\n/******/\\n/******/ \t// The require function\\n/******/ \tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \t\t// Check if module is in cache\\n/******/ \t\tif(installedModules[moduleId]) {\\n/******/ \t\t\treturn installedModules[moduleId].exports;\\n/******/ \t\t}\\n/******/ \t\t// Create a new module (and put it into the cache)\\n/******/ \t\tvar module = installedModules[moduleId] = {\\n/******/ \t\t\ti: moduleId,\\n/******/ \t\t\tl: false,\\n/******/ \t\t\texports: {}\\n/******/ \t\t};\\n/******/\\n/******/ \t\t// Execute the module function\\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \t\t// Flag the module as loaded\\n/******/ \t\tmodule.l = true;\\n/******/\\n/******/ \t\t// Return the exports of the module\\n/******/ \t\treturn module.exports;\\n/******/ \t}\\n/******/\\n/******/\\n/******/ \t// expose the modules object (__webpack_modules__)\\n/******/ \t__webpack_require__.m = modules;\\n/******/\\n/******/ \t// expose the module cache\\n/******/ \t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \t// define getter function for harmony exports\\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \t\t}\\n/******/ \t};\\n/******/\\n/******/ \t// define __esModule on exports\\n/******/ \t__webpack_require__.r = function(exports) {\\n/******/ \t\tif(typeof Symbol !== \\'undefined\\' && Symbol.toStringTag) {\\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \\'Module\\' });\\n/******/ \t\t}\\n/******/ \t\tObject.defineProperty(exports, \\'__esModule\\', { value: true });\\n/******/ \t};\\n/******/\\n/******/ \t// create a fake namespace object\\n/******/ \t// mode & 1: value is a module id, require it\\n/******/ \t// mode & 2: merge all properties of value into the ns\\n/******/ \t// mode & 4: return value when already ns object\\n/******/ \t// mode & 8|1: behave like require\\n/******/ \t__webpack_require__.t = function(value, mode) {\\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \t\tif(mode & 8) return value;\\n/******/ \t\tif((mode & 4) && typeof value === \\'object\\' && value && value.__esModule) return value;\\n/******/ \t\tvar ns = Object.create(null);\\n/******/ \t\t__webpack_require__.r(ns);\\n/******/ \t\tObject.defineProperty(ns, \\'default\\', { enumerable: true, value: value });\\n/******/ \t\tif(mode & 2 && typeof value != \\'string\\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \t\treturn ns;\\n/******/ \t};\\n/******/\\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \t__webpack_require__.n = function(module) {\\n/******/ \t\tvar getter = module && module.__esModule ?\\n/******/ \t\t\tfunction getDefault() { return module[\\'default\\']; } :\\n/******/ \t\t\tfunction getModuleExports() { return module; };\\n/******/ \t\t__webpack_require__.d(getter, \\'a\\', getter);\\n/******/ \t\treturn getter;\\n/******/ \t};\\n/******/\\n/******/ \t// Object.prototype.hasOwnProperty.call\\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \t// __webpack_public_path__\\n/******/ \t__webpack_require__.p = \"\";\\n/******/\\n/******/\\n/******/ \t// Load entry module and return exports\\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/plugin.webworker.js\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \"./src/plugin.webworker.js\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \"undefined\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\"This script can only loaded in a webworker\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\"message\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \"initialized\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\"beforeDisconnect\");\\n    self.close();\\n    this._fire(\"disconnected\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \"requirements\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWebworker\"])(code.requirements);\\n    } else if (code.type === \"script\") {\\n      try {\\n        if (code.attrs.type === \"module\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \"unsupported code type.\";\\n    }\\n    if (code.type === \"requirements\") {\\n      self.postMessage({\\n        type: \"cacheRequirements\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \"web-worker\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \"javascript\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\"connectRPC\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \"worker-ready\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \"./src/pluginCore.js\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\\n  rpc.on(\"getInterface\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\"remoteReady\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\"Remove duplicated codec: \" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\"name\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \"imjoy_remote_api_ready\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \"function\") {\\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/rpc.js\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \"0.2.3\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\"undefined index\");\\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\"remoteIdle\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\"remoteBusy\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \"initialized\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\"interfaceAvailable\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\"interfaceSetAsRemote\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\"interface is not set.\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \"setInterface\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(`Object (id=${objectId}) not found.`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\"disposed\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \"disposeObject\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\"Invalid object\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\"init\", this.init);\\n\\n    this._connection.on(\"execute\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \"executed\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"executed\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\"method\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\".\")) {\\n          const tmp = data.name.split(\".\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"callback\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"disposeObject\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \"disposed\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"disposed\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"setInterface\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\"getInterface\", () => {\\n      this._fire(\"getInterface\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\"interfaceAvailable\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"interfaceSetAsRemote\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\"interfaceSetAsRemote\");\\n    });\\n\\n    this._connection.on(\"disconnect\", () => {\\n      this._fire(\"beforeDisconnect\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\"disconnected\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \"getInterface\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \"dtype doesn\\'t match the type of the array: \" + _dtype + \" != \" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \"ndarray\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\"remoteReady\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \"method\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \"interfaceSetAsRemote\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \"function\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\"objectId is not specified.\");\\n        bObject = {\\n          _rtype: \"interface\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \"callback\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \"error\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \"blob\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\\n      bObject = {\\n        _rtype: \"typedarray\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"memoryview\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \"set\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \"orderedmap\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\"Please instantiate the class before exportting it.\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\"Unsupported interface type\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \"constructor\") continue;\\n\\n          if (k.startsWith(\"_\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \"function\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \"function\") {\\n          aObject.on(\"close\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \"object\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n\\n      for (let k of keys) {\\n        if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \"imjoy-rpc: Unsupported data type:\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\"Failed to encode object\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\"_rtype\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \"callback\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \"interface\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \"ndarray\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \"undefined\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \"error\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \"file\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \"typedarray\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \"memoryview\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \"blob\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \"orderedmap\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \"set\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\"Failed to decode object\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \"callback\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \"callback\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \"disconnect\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/utils.js\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\"script\");\\n      scriptTag.src = url;\\n      scriptTag.type = \"text/javascript\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n            if (requirements[i].startsWith(\"css:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\"link\");\\n            link_node.rel = \"stylesheet\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\"mjs:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n            if (requirements[i].startsWith(\"js:\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"http\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n          } else {\\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \"unsupported requirements definition\";\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n          throw \"unable to import css in a webworker\";\\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n          if (requirements[i].startsWith(\"js:\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"http\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n        } else {\\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \"0.1.0\";\\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\\n  config.type = config.type || \"rpc-window\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \"*\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \"function\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \"int8\",\\n  Int16Array: \"int16\",\\n  Int32Array: \"int32\",\\n  Uint8Array: \"uint8\",\\n  Uint16Array: \"uint16\",\\n  Uint32Array: \"uint32\",\\n  Float32Array: \"float32\",\\n  Float64Array: \"float64\",\\n  Array: \"array\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \"add\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\"Service worker is not supported.\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\"Service worker controller is not available\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\"js:\")) req = req.slice(3);\\n    if (req.startsWith(\"css:\")) req = req.slice(4);\\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\\n    if (!req.startsWith(\"http\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\"serviceWorker\" in navigator) {\\n    baseUrl = baseUrl || \"/\";\\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\"ServiceWorker registration failed: \", err);\\n    });\\n    targetOrigin = targetOrigin || \"*\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\\n      throw new Error(\"config.cache_requirements must be a function\");\\n    }\\n\\n    window.addEventListener(\"message\", function (e) {\\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \"cacheRequirements\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\"/\").replace(/[\\\\/]+/g, \"/\").replace(/^(.+):\\\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\\\/(\\\\?|&|#[^!])/g, \"$1\").replace(/\\\\?/g, \"&\").replace(\"&\", \"?\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\"emit is not implemented\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\"unhandled event\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map', null);\n          };\n        }\n      ),\n      /***/\n      \"./src/pluginCore.js\": (\n        /*!***************************!*\\\n          !*** ./src/pluginCore.js ***!\n          \\***************************/\n        /*! exports provided: connectRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"connectRPC\", function() {\n            return connectRPC;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          function connectRPC(connection, config) {\n            config = config || {};\n            const codecs = {};\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n            rpc.on(\"getInterface\", function() {\n              launchConnected();\n            });\n            rpc.on(\"remoteReady\", function() {\n              const api = rpc.getRemote() || {};\n              api.registerCodec = function(config2) {\n                if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                  throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n                } else {\n                  if (config2.type) {\n                    for (let k of Object.keys(codecs)) {\n                      if (codecs[k].type === config2.type || k === config2.name) {\n                        delete codecs[k];\n                        console.warn(\"Remove duplicated codec: \" + k);\n                      }\n                    }\n                  }\n                  codecs[config2[\"name\"]] = config2;\n                }\n              };\n              api.init = function(config2) {\n                rpc.setInterface({\n                  setup() {\n                  }\n                }, config2);\n              };\n              api.disposeObject = function(obj) {\n                rpc.disposeObject(obj);\n              };\n              api.export = function(_interface, config2) {\n                rpc.setInterface(_interface, config2);\n              };\n              api.onLoad = function(handler) {\n                handler = checkHandler(handler);\n                if (connected) {\n                  handler();\n                } else {\n                  connectedHandlers.push(handler);\n                }\n              };\n              api.dispose = function(_interface) {\n                rpc.disconnect();\n              };\n              api._rpc = rpc;\n              if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n                self.api = api;\n                self.postMessage({\n                  type: \"imjoy_remote_api_ready\"\n                });\n                self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              } else if (typeof window) {\n                window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              }\n            });\n            let connected = false;\n            const connectedHandlers = [];\n            const launchConnected = function() {\n              if (!connected) {\n                connected = true;\n                let handler;\n                while (handler = connectedHandlers.pop()) {\n                  handler();\n                }\n              }\n            };\n            const checkHandler = function(handler) {\n              const type = typeof handler;\n              if (type !== \"function\") {\n                const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n                throw new Error(msg);\n              }\n              return handler;\n            };\n            return rpc;\n          }\n        }\n      ),\n      /***/\n      \"./src/pluginIframe.js\": (\n        /*!*****************************!*\\\n          !*** ./src/pluginIframe.js ***!\n          \\*****************************/\n        /*! exports provided: Connection, default */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_82604__) {\n          \"use strict\";\n          __nested_webpack_require_82604__.r(__nested_webpack_exports__);\n          __nested_webpack_require_82604__.d(__nested_webpack_exports__, \"Connection\", function() {\n            return Connection;\n          });\n          __nested_webpack_require_82604__.d(__nested_webpack_exports__, \"default\", function() {\n            return setupIframe;\n          });\n          var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_82604__(\n            /*! ./pluginCore.js */\n            \"./src/pluginCore.js\"\n          );\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_82604__(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_82604__(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          function _htmlToElement(html) {\n            var template = document.createElement(\"template\");\n            html = html.trim();\n            template.innerHTML = html;\n            return template.content.firstChild;\n          }\n          const _inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          async function executeEsModule(content) {\n            const dataUri = \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\n            await import(\n              /* webpackIgnore: true */\n              dataUri\n            );\n          }\n          class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n            constructor(config) {\n              super(config && config.debug);\n              this.config = config || {};\n              this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n            }\n            connect() {\n              this.config.target_origin = this.config.target_origin || \"*\";\n              if (this.config.broadcastChannel) {\n                this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);\n              } else {\n                this.broadcastChannel = null;\n              }\n              if (this.broadcastChannel)\n                this.broadcastChannel.addEventListener(\"message\", this);\n              else\n                globalThis.addEventListener(\"message\", this);\n              this.emit({\n                type: \"initialized\",\n                config: this.config,\n                origin: globalThis.location.origin,\n                peer_id: this.peer_id\n              });\n              this._fire(\"connected\");\n            }\n            handleEvent(e) {\n              if (e.type === \"message\" && (this.broadcastChannel || this.config.target_origin === \"*\" || !e.origin || e.origin === this.config.target_origin)) {\n                if (e.data.peer_id === this.peer_id) {\n                  this._fire(e.data.type, e.data);\n                } else if (this.config.debug) {\n                  console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n                }\n              }\n            }\n            disconnect() {\n              this._fire(\"beforeDisconnect\");\n              globalThis.removeEventListener(\"message\", this);\n              this._fire(\"disconnected\");\n            }\n            emit(data) {\n              let transferables;\n              if (this.broadcastChannel)\n                this.broadcastChannel.postMessage(data);\n              else {\n                if (data.__transferables__) {\n                  transferables = data.__transferables__;\n                  delete data.__transferables__;\n                } else if (_inWebWorker)\n                  self.postMessage(data, transferables);\n                else\n                  parent.postMessage(data, this.config.target_origin, transferables);\n              }\n            }\n            async execute(code) {\n              try {\n                if (code.type === \"requirements\") {\n                  await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWindow\"])(code.requirements);\n                } else if (code.type === \"script\") {\n                  if (code.src) {\n                    var script_node = document.createElement(\"script\");\n                    script_node.setAttribute(\"type\", code.attrs.type);\n                    script_node.setAttribute(\"src\", code.src);\n                    document.head.appendChild(script_node);\n                  } else {\n                    if (code.content && code.attrs.lang === \"javascript\") {\n                      if (code.attrs.type === \"module\") {\n                        await executeEsModule(code.content);\n                      } else {\n                        eval(code.content);\n                      }\n                    } else {\n                      var node = document.createElement(\"script\");\n                      for (let k in code.attrs) {\n                        node.setAttribute(k, code.attrs[k]);\n                      }\n                      node.appendChild(document.createTextNode(code.content));\n                      document.body.appendChild(node);\n                    }\n                  }\n                } else if (code.type === \"style\") {\n                  const style_node = document.createElement(\"style\");\n                  if (code.src) {\n                    style_node.src = code.src;\n                  }\n                  style_node.innerHTML = code.content;\n                  document.head.appendChild(style_node);\n                } else if (code.type === \"link\") {\n                  const link_node_ = document.createElement(\"link\");\n                  if (code.rel) {\n                    link_node_.rel = code.rel;\n                  }\n                  if (code.href) {\n                    link_node_.href = code.href;\n                  }\n                  if (code.attrs && code.attrs.type) {\n                    link_node_.type = code.attrs.type;\n                  }\n                  document.head.appendChild(link_node_);\n                } else if (code.type === \"html\") {\n                  document.body.appendChild(_htmlToElement(code.content));\n                } else {\n                  throw \"unsupported code type.\";\n                }\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\"\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\"\n                  }, this.config.target_origin);\n              } catch (e) {\n                console.error(\"failed to execute scripts: \", code, e);\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  }, this.config.target_origin);\n              }\n            }\n          }\n          function setupIframe(config) {\n            config = config || {};\n            config.dedicated_thread = false;\n            config.lang = \"javascript\";\n            config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n            const conn = new Connection(config);\n            Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n            conn.connect();\n          }\n        }\n      ),\n      /***/\n      \"./src/rpc.js\": (\n        /*!********************!*\\\n          !*** ./src/rpc.js ***!\n          \\********************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          const API_VERSION = \"0.2.3\";\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, config, codecs) {\n              super(config && config.debug);\n              this._connection = connection;\n              this.config = config || {};\n              this._codecs = codecs || {};\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._remote_set = false;\n              const name = this.config.name;\n              this._connection.execute = this._connection.execute || function() {\n                throw new Error(`connection.execute not implemented (in \"${name}\")`);\n              };\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n              this._method_refs.onReady(() => {\n                this._fire(\"remoteIdle\");\n              });\n              this._method_refs.onBusy(() => {\n                this._fire(\"remoteBusy\");\n              });\n              this._setupMessageHanlders();\n            }\n            init() {\n              this._connection.emit({\n                type: \"initialized\",\n                config: this.config,\n                peer_id: this._connection.peer_id\n              });\n            }\n            setConfig(config) {\n              if (config)\n                for (const k of Object.keys(config)) {\n                  this.config[k] = config[k];\n                }\n            }\n            /**\n             * Set a handler to be called when received a responce from the\n             * remote site reporting that the previously provided interface\n             * has been successfully set as remote for that site\n             *\n             * @param {Function} handler\n             */\n            getRemoteCallStack() {\n              return this._method_refs.getStack();\n            }\n            /**\n             * @returns {Object} set of remote interface methods\n             */\n            getRemote() {\n              return this._remote_interface;\n            }\n            /**\n             * Sets the interface of this site making it available to the\n             * remote site by sending a message with a set of methods names\n             *\n             * @param {Object} _interface to set\n             */\n            setInterface(_interface, config) {\n              config = config || {};\n              this.config.name = config.name || this.config.name;\n              this.config.description = config.description || this.config.description;\n              if (this.config.forwarding_functions) {\n                for (let func_name of this.config.forwarding_functions) {\n                  const _remote = this._remote_interface;\n                  if (_remote[func_name]) {\n                    if (_interface.constructor === Object) {\n                      if (!_interface[func_name]) {\n                        _interface[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    } else if (_interface.constructor.constructor === Function) {\n                      if (!_interface.constructor.prototype[func_name]) {\n                        _interface.constructor.prototype[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    }\n                  }\n                }\n              }\n              this._local_api = _interface;\n              if (!this._remote_set)\n                this._fire(\"interfaceAvailable\");\n              else\n                this.sendInterface();\n              return new Promise((resolve) => {\n                this.once(\"interfaceSetAsRemote\", resolve);\n              });\n            }\n            /**\n             * Sends the actual interface to the remote site upon it was\n             * updated or by a special request of the remote site\n             */\n            sendInterface() {\n              if (!this._local_api) {\n                throw new Error(\"interface is not set.\");\n              }\n              this._encode(this._local_api, true).then((api) => {\n                this._connection.emit({\n                  type: \"setInterface\",\n                  api\n                });\n              });\n            }\n            _disposeObject(objectId) {\n              if (this._object_store[objectId]) {\n                delete this._object_store[objectId];\n              } else {\n                throw new Error(`Object (id=${objectId}) not found.`);\n              }\n            }\n            disposeObject(obj) {\n              return new Promise((resolve, reject) => {\n                if (this._object_weakmap.has(obj)) {\n                  const objectId = this._object_weakmap.get(obj);\n                  this._connection.once(\"disposed\", (data) => {\n                    if (data.error)\n                      reject(new Error(data.error));\n                    else\n                      resolve();\n                  });\n                  this._connection.emit({\n                    type: \"disposeObject\",\n                    object_id: objectId\n                  });\n                } else {\n                  throw new Error(\"Invalid object\");\n                }\n              });\n            }\n            /**\n             * Handles a message from the remote site\n             */\n            _setupMessageHanlders() {\n              this._connection.on(\"init\", this.init);\n              this._connection.on(\"execute\", (data) => {\n                Promise.resolve(this._connection.execute(data.code)).then(() => {\n                  this._connection.emit({\n                    type: \"executed\"\n                  });\n                }).catch((e) => {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"executed\",\n                    error: String(e)\n                  });\n                });\n              });\n              this._connection.on(\"method\", async (data) => {\n                let resolve, reject, method, method_this, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  const _interface = this._object_store[data.object_id];\n                  method = indexObject(_interface, data.name);\n                  if (data.name.includes(\".\")) {\n                    const tmp = data.name.split(\".\");\n                    const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\n                    method_this = indexObject(_interface, intf_index);\n                  } else {\n                    method_this = _interface;\n                  }\n                  args = await this._unwrap(data.args, true);\n                  if (data.promise) {\n                    result = method.apply(method_this, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method.apply(method_this, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"callback\", async (data) => {\n                let resolve, reject, method, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  if (data.promise) {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    result = method.apply(null, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    method.apply(null, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"disposeObject\", (data) => {\n                try {\n                  this._disposeObject(data.object_id);\n                  this._connection.emit({\n                    type: \"disposed\"\n                  });\n                } catch (e) {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"disposed\",\n                    error: String(e)\n                  });\n                }\n              });\n              this._connection.on(\"setInterface\", (data) => {\n                this._setRemoteInterface(data.api);\n              });\n              this._connection.on(\"getInterface\", () => {\n                this._fire(\"getInterface\");\n                if (this._local_api) {\n                  this.sendInterface();\n                } else {\n                  this.once(\"interfaceAvailable\", () => {\n                    this.sendInterface();\n                  });\n                }\n              });\n              this._connection.on(\"interfaceSetAsRemote\", () => {\n                this._remote_set = true;\n                this._fire(\"interfaceSetAsRemote\");\n              });\n              this._connection.on(\"disconnect\", () => {\n                this._fire(\"beforeDisconnect\");\n                this._connection.disconnect();\n                this._fire(\"disconnected\");\n              });\n            }\n            /**\n             * Sends a requests to the remote site asking it to provide its\n             * current interface\n             */\n            requestRemote() {\n              this._connection.emit({\n                type: \"getInterface\"\n              });\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            /**\n             * Sets the new remote interface provided by the other site\n             *\n             * @param {Array} names list of function names\n             */\n            _setRemoteInterface(api) {\n              this._decode(api).then((intf) => {\n                if (this._remote_interface) {\n                  for (let k in this._remote_interface)\n                    delete this._remote_interface[k];\n                  Object.assign(this._remote_interface, intf);\n                } else\n                  this._remote_interface = intf;\n                this._fire(\"remoteReady\");\n                this._reportRemoteSet();\n              });\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * method. When the generated function is called, it will send the\n             * corresponding message to the remote site asking it to execute\n             * the particular method of its interface\n             *\n             * @param {String} name of the remote method\n             *\n             * @returns {Function} wrapped remote method\n             */\n            _genRemoteMethod(targetId, name, objectId) {\n              const me = this;\n              const remoteMethod = function() {\n                return new Promise(async (resolve, reject) => {\n                  let id = null;\n                  try {\n                    id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n                    const wrapped_resolve = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return resolve.apply(this, arguments);\n                    };\n                    const wrapped_reject = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return reject.apply(this, arguments);\n                    };\n                    const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]);\n                    wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n                    let args = Array.prototype.slice.call(arguments);\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\n                      args = await me._wrap(args, true);\n                    } else {\n                      args = await me._wrap(args);\n                    }\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    me._connection.emit({\n                      type: \"method\",\n                      target_id: targetId,\n                      name,\n                      object_id: objectId,\n                      args,\n                      promise: encodedPromise,\n                      with_kwargs: withKwargs\n                    }, transferables);\n                  } catch (e) {\n                    if (id)\n                      me._method_refs.fetch(id);\n                    reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n                  }\n                });\n              };\n              remoteMethod.__remote_method = true;\n              return remoteMethod;\n            }\n            /**\n             * Sends a responce reporting that interface just provided by the\n             * remote site was successfully set by this site as remote\n             */\n            _reportRemoteSet() {\n              this._connection.emit({\n                type: \"interfaceSetAsRemote\"\n              });\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, asInterface, objectId) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof ArrayBuffer) {\n                return aObject;\n              }\n              let bObject;\n              if (typeof aObject === \"function\") {\n                if (asInterface) {\n                  if (!objectId)\n                    throw new Error(\"objectId is not specified.\");\n                  bObject = {\n                    _rtype: \"interface\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rintf: objectId,\n                    _rvalue: asInterface\n                  };\n                  this._method_weakmap.set(aObject, bObject);\n                } else if (this._method_weakmap.has(aObject)) {\n                  bObject = this._method_weakmap.get(aObject);\n                } else {\n                  const cid = this._store.put(aObject);\n                  bObject = {\n                    _rtype: \"callback\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rname: aObject.constructor && aObject.constructor.name || cid,\n                    _rvalue: cid\n                  };\n                }\n                return bObject;\n              }\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                if (aObject._rintf) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._encode(aObject, asInterface, objectId);\n                  bObject._rtype = temp;\n                } else {\n                  bObject = aObject;\n                }\n                return bObject;\n              }\n              const transferables = [];\n              const _transfer = aObject._transfer;\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (encodedObj && encodedObj._rintf) {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, asInterface, objectId);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                if (aObject._transfer || _transfer) {\n                  transferables.push(v_buffer.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: v_buffer.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.selection.data.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: aObject.selection.data.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString()\n                };\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rname: aObject.name,\n                  _rmime: aObject.type,\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject instanceof Blob) {\n                bObject = {\n                  _rtype: \"blob\",\n                  _rvalue: aObject\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: aObject.buffer,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: aObject.buffer\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                let keys;\n                if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  keys = Object.keys(aObject);\n                } else if (aObject.constructor === Function) {\n                  throw new Error(\"Please instantiate the class before exportting it.\");\n                } else if (aObject.constructor.constructor === Function) {\n                  keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                  asInterface = true;\n                } else {\n                  throw Error(\"Unsupported interface type\");\n                }\n                let hasFunction = false;\n                if (aObject._rintf || asInterface) {\n                  if (!objectId) {\n                    if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\n                      objectId = aObject._rintf;\n                    } else {\n                      objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                    }\n                    if (this._object_store[objectId])\n                      console.warn(`Overwritting interface object with the same id: ${objectId}`);\n                    this._object_store[objectId] = aObject;\n                  }\n                  for (let k of keys) {\n                    if (k === \"constructor\")\n                      continue;\n                    if (k.startsWith(\"_\")) {\n                      continue;\n                    }\n                    bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n                    if (typeof aObject[k] === \"function\") {\n                      hasFunction = true;\n                    }\n                  }\n                  if (hasFunction)\n                    bObject._rintf = objectId;\n                  if (aObject.on && typeof aObject.on === \"function\") {\n                    aObject.on(\"close\", () => {\n                      delete this._object_store[objectId];\n                    });\n                  }\n                } else {\n                  for (let k of keys) {\n                    if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                      continue;\n                    bObject[k] = await this._encode(aObject[k]);\n                  }\n                }\n              } else if (typeof aObject === \"object\") {\n                const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                const objectId2 = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                for (let k of keys) {\n                  if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                    continue;\n                  bObject[k] = await this._encode(aObject[k], k, bObject);\n                }\n                bObject._rintf = objectId2;\n              } else {\n                throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n              }\n              if (transferables.length > 0) {\n                bObject.__transferables__ = transferables;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async _decode(aObject, withPromise) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject[\"_rtype\"]) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    aObject = await this._decode(aObject, withPromise);\n                    aObject._rtype = temp;\n                  }\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"callback\") {\n                  bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n                } else if (aObject._rtype === \"interface\") {\n                  bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(aObject._rvalue);\n                } else if (aObject._rtype === \"file\") {\n                  if (aObject._rvalue instanceof File) {\n                    bObject = aObject._rvalue;\n                    bObject._path = aObject._rpath;\n                  } else {\n                    bObject = new File([aObject._rvalue], aObject._rname, {\n                      type: aObject._rmime\n                    });\n                    bObject._path = aObject._rpath;\n                  }\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  bObject = new arraytype(aObject._rvalue);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = new DataView(aObject._rvalue);\n                } else if (aObject._rtype === \"blob\") {\n                  if (aObject._rvalue instanceof Blob) {\n                    bObject = aObject._rvalue;\n                  } else {\n                    bObject = new Blob([aObject._rvalue], {\n                      type: aObject._rmime\n                    });\n                  }\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, withPromise));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, withPromise));\n                } else {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    bObject = await this._decode(aObject, withPromise);\n                    bObject._rtype = temp;\n                  } else\n                    bObject = aObject;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, withPromise);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              if (aObject._rintf) {\n                this._object_weakmap.set(bObject, aObject._rintf);\n              }\n              return bObject;\n            }\n            async _wrap(args, asInterface) {\n              return await this._encode(args, asInterface);\n            }\n            /**\n             * Unwraps the set of arguments delivered from the remote site,\n             * replaces all callback identifiers with a function which will\n             * initiate sending that callback identifier back to other site\n             *\n             * @param {Object} args to unwrap\n             *\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Array} unwrapped args\n             */\n            async _unwrap(args, withPromise) {\n              return await this._decode(args, withPromise);\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * callback. When the generated function is called, it will send\n             * the corresponding message to the remote site asking it to\n             * execute the particular callback previously saved during a call\n             * by the remote site a method from the interface of this site\n             *\n             * @param {Number} id of the remote callback to execute\n             * @param {Number} argNum argument index of the callback\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Function} wrapped remote callback\n             */\n            _genRemoteCallback(targetId, cid, withPromise) {\n              const me = this;\n              let remoteCallback;\n              if (withPromise) {\n                remoteCallback = function() {\n                  return new Promise(async (resolve, reject) => {\n                    const args = await me._wrap(Array.prototype.slice.call(arguments));\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    const encodedPromise = await me._wrap([resolve, reject]);\n                    resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    reject.__promise_pair = encodedPromise[0]._rvalue;\n                    try {\n                      me._connection.emit({\n                        type: \"callback\",\n                        target_id: targetId,\n                        id: cid,\n                        args,\n                        promise: encodedPromise,\n                        with_kwargs: withKwargs\n                      }, transferables);\n                    } catch (e) {\n                      reject(`Failed to exectue remote callback ( id: ${cid}).`);\n                    }\n                  });\n                };\n                return remoteCallback;\n              } else {\n                remoteCallback = async function() {\n                  const args = await me._wrap(Array.prototype.slice.call(arguments));\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  const transferables = args.__transferables__;\n                  if (transferables)\n                    delete args.__transferables__;\n                  return me._connection.emit({\n                    type: \"callback\",\n                    target_id: targetId,\n                    id: cid,\n                    args,\n                    with_kwargs: withKwargs\n                  }, transferables);\n                };\n                return remoteCallback;\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._remote_interface = null;\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n            }\n            /**\n             * Sends the notification message and breaks the connection\n             */\n            disconnect() {\n              this._connection.emit({\n                type: \"disconnect\"\n              });\n              this.reset();\n              setTimeout(() => {\n                this._connection.disconnect();\n              }, 2e3);\n            }\n          }\n          class ReferenceStore {\n            constructor() {\n              this._store = {};\n              this._indices = [0];\n              this._readyHandler = function() {\n              };\n              this._busyHandler = function() {\n              };\n              this._readyHandler();\n            }\n            /**\n             * call handler when the store is empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onReady(readyHandler) {\n              this._readyHandler = readyHandler || function() {\n              };\n            }\n            /**\n             * call handler when the store is not empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onBusy(busyHandler) {\n              this._busyHandler = busyHandler || function() {\n              };\n            }\n            /**\n             * get the length of the store\n             *\n             */\n            getStack() {\n              return Object.keys(this._store).length;\n            }\n            /**\n             * @function _genId() generates the new reference id\n             *\n             * @returns {Number} smallest available id and reserves it\n             */\n            _genId() {\n              let id;\n              if (this._indices.length === 1) {\n                id = this._indices[0]++;\n              } else {\n                id = this._indices.shift();\n              }\n              return id;\n            }\n            /**\n             * Releases the given reference id so that it will be available by\n             * another object stored\n             *\n             * @param {Number} id to release\n             */\n            _releaseId(id) {\n              for (let i = 0; i < this._indices.length; i++) {\n                if (id < this._indices[i]) {\n                  this._indices.splice(i, 0, id);\n                  break;\n                }\n              }\n              for (let i = this._indices.length - 1; i >= 0; i--) {\n                if (this._indices[i] - 1 === this._indices[i - 1]) {\n                  this._indices.pop();\n                } else {\n                  break;\n                }\n              }\n            }\n            /**\n             * Stores the given object and returns the refernce id instead\n             *\n             * @param {Object} obj to store\n             *\n             * @returns {Number} reference id of the stored object\n             */\n            put(obj) {\n              if (this._busyHandler && Object.keys(this._store).length === 0) {\n                this._busyHandler();\n              }\n              const id = this._genId();\n              this._store[id] = obj;\n              return id;\n            }\n            /**\n             * Retrieves previously stored object and releases its reference\n             *\n             * @param {Number} id of an object to retrieve\n             */\n            fetch(id) {\n              const obj = this._store[id];\n              if (obj && !obj.__remote_method) {\n                delete this._store[id];\n                this._releaseId(id);\n                if (this._readyHandler && Object.keys(this._store).length === 0) {\n                  this._readyHandler();\n                }\n              }\n              if (obj && obj.__promise_pair) {\n                this.fetch(obj.__promise_pair);\n              }\n              return obj;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/utils.js\": (\n        /*!**********************!*\\\n          !*** ./src/utils.js ***!\n          \\**********************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_131535__) {\n          \"use strict\";\n          __nested_webpack_require_131535__.r(__nested_webpack_exports__);\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/imjoy-rpc.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/imjoy-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { imjoyRPC: __webpack_require__(/*! ./dist/imjoy-rpc.js */ \"./node_modules/imjoy-rpc/dist/imjoy-rpc.js\"), imjoyRPCSocketIO: __webpack_require__(/*! ./dist/imjoy-rpc-socketio.js */ \"./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js\"), hyphaRPC: __webpack_require__(/*! ./dist/hypha-rpc.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc.js\"), hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js\"), hyphaSSEClient: __webpack_require__(/*! ./dist/hypha-rpc-sse.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js\") };\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/index.js?");

/***/ })

}]);