/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs\");\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\nclass CachedKeyDecoder {\n    constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n        this.hit = 0;\n        this.miss = 0;\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (let i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    canBeCached(byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    }\n    find(bytes, inputOffset, byteLength) {\n        const records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (const record of records) {\n            const recordBytes = record.bytes;\n            for (let j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    }\n    store(bytes, value) {\n        const records = this.caches[bytes.length - 1];\n        const record = { bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    }\n    decode(bytes, inputOffset, byteLength) {\n        const cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        const str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    }\n}\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nclass DecodeError extends Error {\n    constructor(message) {\n        super(message);\n        // fix the prototype chain in a cross-platform way\n        const proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(this, proto);\n        Object.defineProperty(this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n    }\n}\n//# sourceMappingURL=DecodeError.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs\");\n\n\n\n\n\n\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\nconst mapKeyConverter = (key) => {\n    if (typeof key === \"string\" || typeof key === \"number\") {\n        return key;\n    }\n    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\nclass StackPool {\n    constructor() {\n        this.stack = [];\n        this.stackHeadPosition = -1;\n    }\n    get length() {\n        return this.stackHeadPosition + 1;\n    }\n    top() {\n        return this.stack[this.stackHeadPosition];\n    }\n    pushArrayState(size) {\n        const state = this.getUninitializedStateFromPool();\n        state.type = STATE_ARRAY;\n        state.position = 0;\n        state.size = size;\n        state.array = new Array(size);\n    }\n    pushMapState(size) {\n        const state = this.getUninitializedStateFromPool();\n        state.type = STATE_MAP_KEY;\n        state.readCount = 0;\n        state.size = size;\n        state.map = {};\n    }\n    getUninitializedStateFromPool() {\n        this.stackHeadPosition++;\n        if (this.stackHeadPosition === this.stack.length) {\n            const partialState = {\n                type: undefined,\n                size: 0,\n                array: undefined,\n                position: 0,\n                readCount: 0,\n                map: undefined,\n                key: null,\n            };\n            this.stack.push(partialState);\n        }\n        return this.stack[this.stackHeadPosition];\n    }\n    release(state) {\n        const topStackState = this.stack[this.stackHeadPosition];\n        if (topStackState !== state) {\n            throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n        }\n        if (state.type === STATE_ARRAY) {\n            const partialState = state;\n            partialState.size = 0;\n            partialState.array = undefined;\n            partialState.position = 0;\n            partialState.type = undefined;\n        }\n        if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n            const partialState = state;\n            partialState.size = 0;\n            partialState.map = undefined;\n            partialState.readCount = 0;\n            partialState.type = undefined;\n        }\n        this.stackHeadPosition--;\n    }\n    reset() {\n        this.stack.length = 0;\n        this.stackHeadPosition = -1;\n    }\n}\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n}\ncatch (e) {\n    if (!(e instanceof RangeError)) {\n        throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n    }\n}\nconst MORE_DATA = new RangeError(\"Insufficient data\");\nconst sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_1__.CachedKeyDecoder();\nclass Decoder {\n    constructor(options) {\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = new StackPool();\n        this.entered = false;\n        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_2__.ExtensionCodec.defaultCodec;\n        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = options?.useBigInt64 ?? false;\n        this.rawStrings = options?.rawStrings ?? false;\n        this.maxStrLength = options?.maxStrLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;\n        this.maxBinLength = options?.maxBinLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;\n        this.maxArrayLength = options?.maxArrayLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;\n        this.maxMapLength = options?.maxMapLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;\n        this.maxExtLength = options?.maxExtLength ?? _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.UINT32_MAX;\n        this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n        this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n    }\n    clone() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Decoder({\n            extensionCodec: this.extensionCodec,\n            context: this.context,\n            useBigInt64: this.useBigInt64,\n            rawStrings: this.rawStrings,\n            maxStrLength: this.maxStrLength,\n            maxBinLength: this.maxBinLength,\n            maxArrayLength: this.maxArrayLength,\n            maxMapLength: this.maxMapLength,\n            maxExtLength: this.maxExtLength,\n            keyDecoder: this.keyDecoder,\n        });\n    }\n    reinitializeState() {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.reset();\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    }\n    setBuffer(buffer) {\n        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);\n        this.bytes = bytes;\n        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n        this.pos = 0;\n    }\n    appendBuffer(buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            const remainingData = this.bytes.subarray(this.pos);\n            const newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            const newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    }\n    hasRemaining(size) {\n        return this.view.byteLength - this.pos >= size;\n    }\n    createExtraByteError(posToShow) {\n        const { view, pos } = this;\n        return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n    }\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    decode(buffer) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.decode(buffer);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.setBuffer(buffer);\n            const object = this.doDecodeSync();\n            if (this.hasRemaining(1)) {\n                throw this.createExtraByteError(this.pos);\n            }\n            return object;\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    *decodeMulti(buffer) {\n        if (this.entered) {\n            const instance = this.clone();\n            yield* instance.decodeMulti(buffer);\n            return;\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.setBuffer(buffer);\n            while (this.hasRemaining(1)) {\n                yield this.doDecodeSync();\n            }\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    async decodeAsync(stream) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.decodeAsync(stream);\n        }\n        try {\n            this.entered = true;\n            let decoded = false;\n            let object;\n            for await (const buffer of stream) {\n                if (decoded) {\n                    this.entered = false;\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                this.appendBuffer(buffer);\n                try {\n                    object = this.doDecodeSync();\n                    decoded = true;\n                }\n                catch (e) {\n                    if (!(e instanceof RangeError)) {\n                        throw e; // rethrow\n                    }\n                    // fallthrough\n                }\n                this.totalPos += this.pos;\n            }\n            if (decoded) {\n                if (this.hasRemaining(1)) {\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                return object;\n            }\n            const { headByte, pos, totalPos } = this;\n            throw new RangeError(`Insufficient data in parsing ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)} at ${totalPos} (${pos} in the current buffer)`);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    decodeArrayStream(stream) {\n        return this.decodeMultiAsync(stream, true);\n    }\n    decodeStream(stream) {\n        return this.decodeMultiAsync(stream, false);\n    }\n    async *decodeMultiAsync(stream, isArray) {\n        if (this.entered) {\n            const instance = this.clone();\n            yield* instance.decodeMultiAsync(stream, isArray);\n            return;\n        }\n        try {\n            this.entered = true;\n            let isArrayHeaderRequired = isArray;\n            let arrayItemsLeft = -1;\n            for await (const buffer of stream) {\n                if (isArray && arrayItemsLeft === 0) {\n                    throw this.createExtraByteError(this.totalPos);\n                }\n                this.appendBuffer(buffer);\n                if (isArrayHeaderRequired) {\n                    arrayItemsLeft = this.readArraySize();\n                    isArrayHeaderRequired = false;\n                    this.complete();\n                }\n                try {\n                    while (true) {\n                        yield this.doDecodeSync();\n                        if (--arrayItemsLeft === 0) {\n                            break;\n                        }\n                    }\n                }\n                catch (e) {\n                    if (!(e instanceof RangeError)) {\n                        throw e; // rethrow\n                    }\n                    // fallthrough\n                }\n                this.totalPos += this.pos;\n            }\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    doDecodeSync() {\n        DECODE: while (true) {\n            const headByte = this.readHeadByte();\n            let object;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    const size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    const size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    const byteLength = headByte - 0xa0;\n                    object = this.decodeString(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                if (this.useBigInt64) {\n                    object = this.readU64AsBigInt();\n                }\n                else {\n                    object = this.readU64();\n                }\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                if (this.useBigInt64) {\n                    object = this.readI64AsBigInt();\n                }\n                else {\n                    object = this.readI64();\n                }\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                const byteLength = this.lookU8();\n                object = this.decodeString(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                const byteLength = this.lookU16();\n                object = this.decodeString(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                const byteLength = this.lookU32();\n                object = this.decodeString(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                const size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                const size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                const size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                const size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                const size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                const size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                const size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                const size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)}`);\n            }\n            this.complete();\n            const stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                const state = stack.top();\n                if (state.type === STATE_ARRAY) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        object = state.array;\n                        stack.release(state);\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === STATE_MAP_KEY) {\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = this.mapKeyConverter(object);\n                    state.type = STATE_MAP_VALUE;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        object = state.map;\n                        stack.release(state);\n                    }\n                    else {\n                        state.key = null;\n                        state.type = STATE_MAP_KEY;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    }\n    readHeadByte() {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    }\n    complete() {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    }\n    readArraySize() {\n        const headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Unrecognized array type byte: ${(0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_5__.prettyByte)(headByte)}`);\n                }\n            }\n        }\n    }\n    pushMapState(size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n        }\n        this.stack.pushMapState(size);\n    }\n    pushArrayState(size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n        }\n        this.stack.pushArrayState(size);\n    }\n    decodeString(byteLength, headerOffset) {\n        if (!this.rawStrings || this.stateIsMapKey()) {\n            return this.decodeUtf8String(byteLength, headerOffset);\n        }\n        return this.decodeBinary(byteLength, headerOffset);\n    }\n    /**\n     * @throws {@link RangeError}\n     */\n    decodeUtf8String(byteLength, headerOffset) {\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headerOffset;\n        let object;\n        if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8Decode)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    }\n    stateIsMapKey() {\n        if (this.stack.length > 0) {\n            const state = this.stack.top();\n            return state.type === STATE_MAP_KEY;\n        }\n        return false;\n    }\n    /**\n     * @throws {@link RangeError}\n     */\n    decodeBinary(byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        const offset = this.pos + headOffset;\n        const object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    }\n    decodeExtension(size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__.DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n        }\n        const extType = this.view.getInt8(this.pos + headOffset);\n        const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    }\n    lookU8() {\n        return this.view.getUint8(this.pos);\n    }\n    lookU16() {\n        return this.view.getUint16(this.pos);\n    }\n    lookU32() {\n        return this.view.getUint32(this.pos);\n    }\n    readU8() {\n        const value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readI8() {\n        const value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    }\n    readU16() {\n        const value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readI16() {\n        const value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readI32() {\n        const value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readU64() {\n        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64() {\n        const value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readU64AsBigInt() {\n        const value = this.view.getBigUint64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readI64AsBigInt() {\n        const value = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n    readF32() {\n        const value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    }\n    readF64() {\n        const value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    }\n}\n//# sourceMappingURL=Decoder.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs\");\n\n\n\n\nconst DEFAULT_MAX_DEPTH = 100;\nconst DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nclass Encoder {\n    constructor(options) {\n        this.entered = false;\n        this.extensionCodec = options?.extensionCodec ?? _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;\n        this.context = options?.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = options?.useBigInt64 ?? false;\n        this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n        this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n        this.sortKeys = options?.sortKeys ?? false;\n        this.forceFloat32 = options?.forceFloat32 ?? false;\n        this.ignoreUndefined = options?.ignoreUndefined ?? false;\n        this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    clone() {\n        // Because of slightly special argument `context`,\n        // type assertion is needed.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        return new Encoder({\n            extensionCodec: this.extensionCodec,\n            context: this.context,\n            useBigInt64: this.useBigInt64,\n            maxDepth: this.maxDepth,\n            initialBufferSize: this.initialBufferSize,\n            sortKeys: this.sortKeys,\n            forceFloat32: this.forceFloat32,\n            ignoreUndefined: this.ignoreUndefined,\n            forceIntegerToFloat: this.forceIntegerToFloat,\n        });\n    }\n    reinitializeState() {\n        this.pos = 0;\n    }\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    encodeSharedRef(object) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.encodeSharedRef(object);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.doEncode(object, 1);\n            return this.bytes.subarray(0, this.pos);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    encode(object) {\n        if (this.entered) {\n            const instance = this.clone();\n            return instance.encode(object);\n        }\n        try {\n            this.entered = true;\n            this.reinitializeState();\n            this.doEncode(object, 1);\n            return this.bytes.slice(0, this.pos);\n        }\n        finally {\n            this.entered = false;\n        }\n    }\n    doEncode(object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(`Too deep objects in depth ${depth}`);\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            if (!this.forceIntegerToFloat) {\n                this.encodeNumber(object);\n            }\n            else {\n                this.encodeNumberAsFloat(object);\n            }\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else if (this.useBigInt64 && typeof object === \"bigint\") {\n            this.encodeBigInt64(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    }\n    ensureBufferSizeToWrite(sizeToWrite) {\n        const requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    }\n    resizeBuffer(newSize) {\n        const newBuffer = new ArrayBuffer(newSize);\n        const newBytes = new Uint8Array(newBuffer);\n        const newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    }\n    encodeNil() {\n        this.writeU8(0xc0);\n    }\n    encodeBoolean(object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    }\n    encodeNumber(object) {\n        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n        }\n        else {\n            this.encodeNumberAsFloat(object);\n        }\n    }\n    encodeNumberAsFloat(object) {\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        }\n        else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    }\n    encodeBigInt64(object) {\n        if (object >= BigInt(0)) {\n            // uint 64\n            this.writeU8(0xcf);\n            this.writeBigUint64(object);\n        }\n        else {\n            // int 64\n            this.writeU8(0xd3);\n            this.writeBigInt64(object);\n        }\n    }\n    writeStringHeader(byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n        }\n    }\n    encodeString(object) {\n        const maxHeaderSize = 1 + 4;\n        const byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n        this.writeStringHeader(byteLength);\n        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Encode)(object, this.bytes, this.pos);\n        this.pos += byteLength;\n    }\n    encodeObject(object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        const ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n        }\n    }\n    encodeBinary(object) {\n        const size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large binary: ${size}`);\n        }\n        const bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    }\n    encodeArray(object, depth) {\n        const size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large array: ${size}`);\n        }\n        for (const item of object) {\n            this.doEncode(item, depth + 1);\n        }\n    }\n    countWithoutUndefined(object, keys) {\n        let count = 0;\n        for (const key of keys) {\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    }\n    encodeMap(object, depth) {\n        const keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large map object: ${size}`);\n        }\n        for (const key of keys) {\n            const value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    }\n    encodeExtension(ext) {\n        if (typeof ext.data === \"function\") {\n            const data = ext.data(this.pos + 6);\n            const size = data.length;\n            if (size >= 0x100000000) {\n                throw new Error(`Too large extension object: ${size}`);\n            }\n            this.writeU8(0xc9);\n            this.writeU32(size);\n            this.writeI8(ext.type);\n            this.writeU8a(data);\n            return;\n        }\n        const size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(`Too large extension object: ${size}`);\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    }\n    writeU8(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    }\n    writeU8a(values) {\n        const size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    }\n    writeI8(value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    }\n    writeU16(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    }\n    writeI16(value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    }\n    writeU32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    }\n    writeI32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    }\n    writeF32(value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    }\n    writeF64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    }\n    writeU64(value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    }\n    writeI64(value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    }\n    writeBigUint64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigUint64(this.pos, value);\n        this.pos += 8;\n    }\n    writeBigInt64(value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    }\n}\n//# sourceMappingURL=Encoder.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nclass ExtData {\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n}\n//# sourceMappingURL=ExtData.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nclass ExtensionCodec {\n    constructor() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    register({ type, encode, decode, }) {\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            const index = -1 - type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    }\n    tryToEncode(object, context) {\n        // built-in extensions\n        for (let i = 0; i < this.builtInEncoders.length; i++) {\n            const encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                const data = encodeExt(object, context);\n                if (data != null) {\n                    const type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (let i = 0; i < this.encoders.length; i++) {\n            const encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                const data = encodeExt(object, context);\n                if (data != null) {\n                    const type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    }\n    decode(data, type, context) {\n        const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    }\n}\nExtensionCodec.defaultCodec = new ExtensionCodec();\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/encode.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/encode.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs\");\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    const encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/encode.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nconst EXT_TIMESTAMP = -1;\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp({ sec, nsec }) {\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            const rv = new Uint8Array(4);\n            const view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            const secHigh = sec / 0x100000000;\n            const secLow = sec & 0xffffffff;\n            const rv = new Uint8Array(8);\n            const view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        const rv = new Uint8Array(12);\n        const view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    const msec = date.getTime();\n    const sec = Math.floor(msec / 1e3);\n    const nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    const nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        const timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            const sec = view.getUint32(0);\n            const nsec = 0;\n            return { sec, nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            const nsec30AndSecHigh2 = view.getUint32(0);\n            const secLow32 = view.getUint32(4);\n            const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            const nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec, nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            const sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            const nsec = view.getUint32(0);\n            return { sec, nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n    }\n}\nfunction decodeTimestampExtension(data) {\n    const timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nconst timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nconst UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    const high = value / 4294967296;\n    const low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    const high = Math.floor(value / 4294967296);\n    const low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    const high = view.getInt32(offset);\n    const low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    const high = view.getUint32(offset);\n    const low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction isArrayBufferLike(buffer) {\n    return (buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \"undefined\" && buffer instanceof SharedArrayBuffer));\n}\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (isArrayBufferLike(buffer)) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\nfunction utf8Count(str) {\n    const strLength = str.length;\n    let byteLength = 0;\n    let pos = 0;\n    while (pos < strLength) {\n        let value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    const extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    const strLength = str.length;\n    let offset = outputOffset;\n    let pos = 0;\n    while (pos < strLength) {\n        let value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    const extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nconst sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\nfunction utf8EncodeTE(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nfunction utf8Encode(str, output, outputOffset) {\n    if (str.length > TEXT_ENCODER_THRESHOLD) {\n        utf8EncodeTE(str, output, outputOffset);\n    }\n    else {\n        utf8EncodeJs(str, output, outputOffset);\n    }\n}\nconst CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    let offset = inputOffset;\n    const end = offset + byteLength;\n    const units = [];\n    let result = \"\";\n    while (offset < end) {\n        const byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            const byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = bytes[offset++] & 0x3f;\n            const byte3 = bytes[offset++] & 0x3f;\n            const byte4 = bytes[offset++] & 0x3f;\n            let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode(...units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode(...units);\n    }\n    return result;\n}\nconst sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\nfunction utf8Decode(bytes, inputOffset, byteLength) {\n    if (byteLength > TEXT_DECODER_THRESHOLD) {\n        return utf8DecodeTD(bytes, inputOffset, byteLength);\n    }\n    else {\n        return utf8DecodeJs(bytes, inputOffset, byteLength);\n    }\n}\n//# sourceMappingURL=utf8.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs?");

/***/ }),

/***/ "./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else // removed by dead control flow\n{}\n})(this, () => {\n  return (\n    /******/\n    (() => {\n      \"use strict\";\n      var __webpack_modules__ = {\n        /***/\n        \"./src/rpc.js\": (\n          /*!********************!*\\\n            !*** ./src/rpc.js ***!\n            \\********************/\n          /***/\n          (__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              API_VERSION: () => (\n                /* binding */\n                API_VERSION\n              ),\n              /* harmony export */\n              RPC: () => (\n                /* binding */\n                RPC\n              )\n              /* harmony export */\n            });\n            var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./utils */\n              \"./src/utils/index.js\"\n            );\n            var _utils_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./utils/schema */\n              \"./src/utils/schema.js\"\n            );\n            var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! @msgpack/msgpack */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n            );\n            var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! @msgpack/msgpack */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n            );\n            const API_VERSION = 3;\n            const CHUNK_SIZE = 1024 * 256;\n            const CONCURRENCY_LIMIT = 30;\n            const ArrayBufferView = Object.getPrototypeOf(\n              Object.getPrototypeOf(new Uint8Array())\n            ).constructor;\n            function _appendBuffer(buffer1, buffer2) {\n              const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n              tmp.set(new Uint8Array(buffer1), 0);\n              tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n              return tmp.buffer;\n            }\n            function indexObject(obj, is) {\n              if (!is)\n                throw new Error(\"undefined index\");\n              if (typeof is === \"string\")\n                return indexObject(obj, is.split(\".\"));\n              else if (is.length === 0)\n                return obj;\n              else\n                return indexObject(obj[is[0]], is.slice(1));\n            }\n            function _get_schema(obj, name2 = null, skipContext = false) {\n              if (Array.isArray(obj)) {\n                return obj.map((v, i) => _get_schema(v, null, skipContext));\n              } else if (typeof obj === \"object\" && obj !== null) {\n                let schema = {};\n                for (let k in obj) {\n                  schema[k] = _get_schema(obj[k], k, skipContext);\n                }\n                return schema;\n              } else if (typeof obj === \"function\") {\n                if (obj.__schema__) {\n                  const schema = JSON.parse(JSON.stringify(obj.__schema__));\n                  if (name2) {\n                    schema.name = name2;\n                    obj.__schema__.name = name2;\n                  }\n                  if (skipContext) {\n                    if (schema.parameters && schema.parameters.properties) {\n                      delete schema.parameters.properties[\"context\"];\n                    }\n                  }\n                  return { type: \"function\", function: schema };\n                } else {\n                  return { type: \"function\" };\n                }\n              } else if (typeof obj === \"number\") {\n                return { type: \"number\" };\n              } else if (typeof obj === \"string\") {\n                return { type: \"string\" };\n              } else if (typeof obj === \"boolean\") {\n                return { type: \"boolean\" };\n              } else if (obj === null) {\n                return { type: \"null\" };\n              } else {\n                return {};\n              }\n            }\n            function _annotate_service(service, serviceTypeInfo) {\n              function validateKeys(serviceDict, schemaDict, path = \"root\") {\n                for (let key in schemaDict) {\n                  if (!serviceDict.hasOwnProperty(key)) {\n                    throw new Error(`Missing key '${key}' in service at path '${path}'`);\n                  }\n                }\n                for (let key in serviceDict) {\n                  if (key !== \"type\" && !schemaDict.hasOwnProperty(key)) {\n                    throw new Error(`Unexpected key '${key}' in service at path '${path}'`);\n                  }\n                }\n              }\n              function annotateRecursive(newService, schemaInfo, path = \"root\") {\n                if (typeof newService === \"object\" && !Array.isArray(newService)) {\n                  validateKeys(newService, schemaInfo, path);\n                  for (let k in newService) {\n                    let v = newService[k];\n                    let newPath = `${path}.${k}`;\n                    if (typeof v === \"object\" && !Array.isArray(v)) {\n                      annotateRecursive(v, schemaInfo[k], newPath);\n                    } else if (typeof v === \"function\") {\n                      if (schemaInfo.hasOwnProperty(k)) {\n                        newService[k] = (0, _utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n                          name: schemaInfo[k][\"name\"],\n                          description: schemaInfo[k].description || \"\",\n                          parameters: schemaInfo[k][\"parameters\"]\n                        });\n                      } else {\n                        throw new Error(\n                          `Missing schema for function '${k}' at path '${newPath}'`\n                        );\n                      }\n                    }\n                  }\n                } else if (Array.isArray(newService)) {\n                  if (newService.length !== schemaInfo.length) {\n                    throw new Error(`Length mismatch at path '${path}'`);\n                  }\n                  newService.forEach((v, i) => {\n                    let newPath = `${path}[${i}]`;\n                    if (typeof v === \"object\" && !Array.isArray(v)) {\n                      annotateRecursive(v, schemaInfo[i], newPath);\n                    } else if (typeof v === \"function\") {\n                      if (schemaInfo.hasOwnProperty(i)) {\n                        newService[i] = (0, _utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n                          name: schemaInfo[i][\"name\"],\n                          description: schemaInfo[i].description || \"\",\n                          parameters: schemaInfo[i][\"parameters\"]\n                        });\n                      } else {\n                        throw new Error(\n                          `Missing schema for function at index ${i} in path '${newPath}'`\n                        );\n                      }\n                    }\n                  });\n                }\n              }\n              validateKeys(service, serviceTypeInfo[\"definition\"]);\n              annotateRecursive(service, serviceTypeInfo[\"definition\"]);\n              return service;\n            }\n            function getFunctionInfo(func) {\n              const funcString = func.toString();\n              const nameMatch = funcString.match(/function\\s*(\\w*)/);\n              const name2 = nameMatch && nameMatch[1] || \"\";\n              const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n              let params = \"\";\n              if (paramsMatch) {\n                params = paramsMatch[1].split(\",\").map(\n                  (p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")\n                ).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n              }\n              let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n              const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n              docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n              const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n              const docstring = docstringBlock || docstringLine;\n              return name2 && params.length > 0 && {\n                name: name2,\n                sig: params,\n                doc: docstring\n              };\n            }\n            function concatArrayBuffers(buffers) {\n              var buffersLengths = buffers.map(function(b) {\n                return b.byteLength;\n              }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n                return p + c;\n              }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n              buffersLengths.reduce(function(p, c, i) {\n                unit8Arr.set(new Uint8Array(buffers[i]), p);\n                return p + c;\n              }, 0);\n              return unit8Arr.buffer;\n            }\n            class Timer {\n              constructor(timeout, callback, args, label) {\n                this._timeout = timeout;\n                this._callback = callback;\n                this._args = args;\n                this._label = label || \"timer\";\n                this._task = null;\n                this.started = false;\n              }\n              start() {\n                if (this.started) {\n                  this.reset();\n                } else {\n                  this._task = setTimeout(() => {\n                    this._callback.apply(this, this._args);\n                  }, this._timeout * 1e3);\n                  this.started = true;\n                }\n              }\n              clear() {\n                if (this._task && this.started) {\n                  clearTimeout(this._task);\n                  this._task = null;\n                  this.started = false;\n                } else {\n                  console.warn(`Clearing a timer (${this._label}) which is not started`);\n                }\n              }\n              reset() {\n                if (this._task) {\n                  clearTimeout(this._task);\n                }\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            class RemoteService extends Object {\n            }\n            class RPC extends _utils__WEBPACK_IMPORTED_MODULE_0__.MessageEmitter {\n              constructor(connection, {\n                client_id: client_id2 = null,\n                default_context = null,\n                name: name2 = null,\n                codecs = null,\n                method_timeout: method_timeout2 = null,\n                max_message_buffer_size = 0,\n                debug = false,\n                workspace: workspace2 = null,\n                silent = false,\n                app_id = null,\n                server_base_url = null,\n                long_message_chunk_size = null\n              }) {\n                super(debug);\n                this._codecs = codecs || {};\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id2 && typeof client_id2 === \"string\");\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id2, \"client_id is required\");\n                this._client_id = client_id2;\n                this._name = name2;\n                this._app_id = app_id || \"*\";\n                this._local_workspace = workspace2;\n                this._silent = silent;\n                this.default_context = default_context || {};\n                this._method_annotations = /* @__PURE__ */ new WeakMap();\n                this._max_message_buffer_size = max_message_buffer_size;\n                this._chunk_store = {};\n                this._method_timeout = method_timeout2 || 30;\n                this._server_base_url = server_base_url;\n                this._long_message_chunk_size = long_message_chunk_size || CHUNK_SIZE;\n                this._services = {};\n                this._object_store = {\n                  services: this._services\n                };\n                if (connection) {\n                  this.add_service({\n                    id: \"built-in\",\n                    type: \"built-in\",\n                    name: `Built-in services for ${this._local_workspace}/${this._client_id}`,\n                    config: {\n                      require_context: true,\n                      visibility: \"public\",\n                      api_version: API_VERSION\n                    },\n                    ping: this._ping.bind(this),\n                    get_service: this.get_local_service.bind(this),\n                    message_cache: {\n                      create: this._create_message.bind(this),\n                      append: this._append_message.bind(this),\n                      set: this._set_message.bind(this),\n                      process: this._process_message.bind(this),\n                      remove: this._remove_message.bind(this)\n                    }\n                  });\n                  this.on(\"method\", this._handle_method.bind(this));\n                  this.on(\"error\", console.error);\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(connection.emit_message && connection.on_message);\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    connection.manager_id !== void 0,\n                    \"Connection must have manager_id\"\n                  );\n                  this._emit_message = connection.emit_message.bind(connection);\n                  connection.on_message(this._on_message.bind(this));\n                  this._connection = connection;\n                  const onConnected = async (connectionInfo) => {\n                    if (!this._silent && this._connection.manager_id) {\n                      console.debug(\"Connection established, reporting services...\");\n                      try {\n                        const manager = await this.get_manager_service({\n                          timeout: 10,\n                          case_conversion: \"camel\"\n                        });\n                        const services = Object.values(this._services);\n                        const servicesCount = services.length;\n                        let registeredCount = 0;\n                        for (let service of services) {\n                          try {\n                            const serviceInfo = this._extract_service_info(service);\n                            await manager.registerService(serviceInfo);\n                            registeredCount++;\n                          } catch (serviceError) {\n                            console.error(\n                              `Failed to register service ${service.id || \"unknown\"}: ${serviceError}`\n                            );\n                          }\n                        }\n                        if (registeredCount === servicesCount) {\n                          console.info(\n                            `Successfully registered all ${registeredCount} services with the server`\n                          );\n                        } else {\n                          console.warn(\n                            `Only registered ${registeredCount} out of ${servicesCount} services with the server`\n                          );\n                        }\n                      } catch (managerError) {\n                        console.error(\n                          `Failed to get manager service for registering services: ${managerError}`\n                        );\n                      }\n                    } else {\n                    }\n                    if (connectionInfo) {\n                      if (connectionInfo.public_base_url) {\n                        this._server_base_url = connectionInfo.public_base_url;\n                      }\n                      this._fire(\"connected\", connectionInfo);\n                    }\n                  };\n                  connection.on_connected(onConnected);\n                  onConnected();\n                } else {\n                  this._emit_message = function() {\n                    console.log(\"No connection to emit message\");\n                  };\n                }\n              }\n              register_codec(config2) {\n                if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                  throw new Error(\n                    \"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\"\n                  );\n                } else {\n                  if (config2.type) {\n                    for (let k of Object.keys(this._codecs)) {\n                      if (this._codecs[k].type === config2.type || k === config2.name) {\n                        delete this._codecs[k];\n                        console.warn(\"Remove duplicated codec: \" + k);\n                      }\n                    }\n                  }\n                  this._codecs[config2[\"name\"]] = config2;\n                }\n              }\n              async _ping(msg, context2) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(msg == \"ping\");\n                return \"pong\";\n              }\n              async ping(client_id2, timeout) {\n                let method = this._generate_remote_method({\n                  _rserver: this._server_base_url,\n                  _rtarget: client_id2,\n                  _rmethod: \"services.built-in.ping\",\n                  _rpromise: true,\n                  _rdoc: \"Ping a remote client\"\n                });\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(await method(\"ping\", timeout) == \"pong\");\n              }\n              _create_message(key, heartbeat, overwrite, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                if (!this._object_store[\"message_cache\"]) {\n                  this._object_store[\"message_cache\"] = {};\n                }\n                if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                  throw new Error(\n                    `Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`\n                  );\n                }\n                this._object_store[\"message_cache\"][key] = [];\n              }\n              _append_message(key, data, heartbeat, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                const cache = this._object_store[\"message_cache\"];\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n                cache[key].push(data);\n              }\n              _set_message(key, index, data, heartbeat, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                const cache = this._object_store[\"message_cache\"];\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n                cache[key][index] = data;\n              }\n              _remove_message(key, context2) {\n                const cache = this._object_store[\"message_cache\"];\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                delete cache[key];\n              }\n              _process_message(key, heartbeat, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                const cache = this._object_store[\"message_cache\"];\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!context2, \"Context is required\");\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                cache[key] = concatArrayBuffers(cache[key]);\n                let unpacker = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(cache[key]);\n                const { done, value } = unpacker.next();\n                const main = value;\n                Object.assign(main, {\n                  from: context2.from,\n                  to: context2.to,\n                  ws: context2.ws,\n                  user: context2.user\n                });\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n                delete cache[key];\n              }\n              _on_message(message) {\n                if (typeof message === \"string\") {\n                  const main = JSON.parse(message);\n                  this._fire(main[\"type\"], main);\n                } else if (message instanceof ArrayBuffer) {\n                  let unpacker = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(message);\n                  const { done, value } = unpacker.next();\n                  const main = value;\n                  main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                  Object.assign(main[\"ctx\"], this.default_context);\n                  if (!done) {\n                    let extra = unpacker.next();\n                    Object.assign(main, extra.value);\n                  }\n                  this._fire(main[\"type\"], main);\n                } else if (typeof message === \"object\") {\n                  this._fire(message[\"type\"], message);\n                } else {\n                  throw new Error(\"Invalid message format\");\n                }\n              }\n              reset() {\n                this._event_handlers = {};\n                this._services = {};\n              }\n              close() {\n                for (const session_id in this._object_store) {\n                  if (this._object_store.hasOwnProperty(session_id)) {\n                    const session = this._object_store[session_id];\n                    if (session && session.heartbeat_task) {\n                      clearInterval(session.heartbeat_task);\n                    }\n                    if (session && session.timer) {\n                      session.timer.clear();\n                    }\n                  }\n                }\n                this._fire(\"disconnected\");\n              }\n              async disconnect() {\n                this.close();\n                await this._connection.disconnect();\n              }\n              async get_manager_service(config2) {\n                config2 = config2 || {};\n                const maxRetries = 20;\n                const retryDelay = 500;\n                for (let attempt = 0; attempt < maxRetries; attempt++) {\n                  if (!this._connection.manager_id) {\n                    if (attempt < maxRetries - 1) {\n                      console.warn(\n                        `Manager ID not set, retrying in ${retryDelay}ms (attempt ${attempt + 1}/${maxRetries})`\n                      );\n                      await new Promise((resolve2) => setTimeout(resolve2, retryDelay));\n                      continue;\n                    } else {\n                      throw new Error(\"Manager ID not set after maximum retries\");\n                    }\n                  }\n                  try {\n                    const svc = await this.get_remote_service(\n                      `*/${this._connection.manager_id}:default`,\n                      config2\n                    );\n                    return svc;\n                  } catch (e) {\n                    if (attempt < maxRetries - 1) {\n                      console.warn(\n                        `Failed to get manager service, retrying in ${retryDelay}ms: ${e.message}`\n                      );\n                      await new Promise((resolve2) => setTimeout(resolve2, retryDelay));\n                    } else {\n                      throw e;\n                    }\n                  }\n                }\n              }\n              get_all_local_services() {\n                return this._services;\n              }\n              get_local_service(service_id, context2) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(service_id);\n                const [ws, client_id2] = context2[\"to\"].split(\"/\");\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  client_id2 === this._client_id,\n                  \"Services can only be accessed locally\"\n                );\n                const service = this._services[service_id];\n                if (!service) {\n                  throw new Error(\"Service not found: \" + service_id);\n                }\n                service.config[\"workspace\"] = context2[\"ws\"];\n                if (service.config.visibility == \"public\") {\n                  return service;\n                }\n                if (context2[\"ws\"] === ws) {\n                  return service;\n                }\n                throw new Error(\n                  `Permission denied for getting protected service: ${service_id}, workspace mismatch: ${ws} != ${context2[\"ws\"]}`\n                );\n              }\n              async get_remote_service(service_uri, config2) {\n                let { timeout, case_conversion, kwargs_expansion } = config2 || {};\n                timeout = timeout === void 0 ? this._method_timeout : timeout;\n                if (!service_uri && this._connection.manager_id) {\n                  service_uri = \"*/\" + this._connection.manager_id;\n                } else if (!service_uri.includes(\":\")) {\n                  service_uri = this._client_id + \":\" + service_uri;\n                }\n                const provider = service_uri.split(\":\")[0];\n                let service_id = service_uri.split(\":\")[1];\n                if (service_id.includes(\"@\")) {\n                  service_id = service_id.split(\"@\")[0];\n                  const app_id = service_uri.split(\"@\")[1];\n                  if (this._app_id && this._app_id !== \"*\")\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      app_id === this._app_id,\n                      `Invalid app id: ${app_id} != ${this._app_id}`\n                    );\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, `Invalid service uri: ${service_uri}`);\n                try {\n                  const method = this._generate_remote_method({\n                    _rserver: this._server_base_url,\n                    _rtarget: provider,\n                    _rmethod: \"services.built-in.get_service\",\n                    _rpromise: true,\n                    _rdoc: \"Get a remote service\"\n                  });\n                  let svc = await (0, _utils__WEBPACK_IMPORTED_MODULE_0__.waitFor)(\n                    method(service_id),\n                    timeout,\n                    \"Timeout Error: Failed to get remote service: \" + service_uri\n                  );\n                  svc.id = `${provider}:${service_id}`;\n                  if (kwargs_expansion) {\n                    svc = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.expandKwargs)(svc);\n                  }\n                  if (case_conversion)\n                    return Object.assign(\n                      new RemoteService(),\n                      (0, _utils__WEBPACK_IMPORTED_MODULE_0__.convertCase)(svc, case_conversion)\n                    );\n                  else\n                    return Object.assign(new RemoteService(), svc);\n                } catch (e) {\n                  console.warn(\"Failed to get remote service: \" + service_uri, e);\n                  throw e;\n                }\n              }\n              _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n                if (typeof aObject === \"function\") {\n                  let method_name = object_id.split(\".\")[1];\n                  this._method_annotations.set(aObject, {\n                    require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                    run_in_executor,\n                    method_id: \"services.\" + object_id,\n                    visibility\n                  });\n                } else if (aObject instanceof Array || aObject instanceof Object) {\n                  for (let key of Object.keys(aObject)) {\n                    let val = aObject[key];\n                    if (typeof val === \"function\" && val.__rpc_object__) {\n                      let client_id2 = val.__rpc_object__._rtarget;\n                      if (client_id2.includes(\"/\")) {\n                        client_id2 = client_id2.split(\"/\")[1];\n                      }\n                      if (this._client_id === client_id2) {\n                        if (aObject instanceof Array) {\n                          aObject = aObject.slice();\n                        }\n                        aObject[key] = indexObject(\n                          this._object_store,\n                          val.__rpc_object__._rmethod\n                        );\n                        val = aObject[key];\n                      } else {\n                        throw new Error(\n                          `Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id2}`\n                        );\n                      }\n                    }\n                    this._annotate_service_methods(\n                      val,\n                      object_id + \".\" + key,\n                      require_context,\n                      run_in_executor,\n                      visibility\n                    );\n                  }\n                }\n              }\n              add_service(api, overwrite) {\n                if (!api || Array.isArray(api))\n                  throw new Error(\"Invalid service object\");\n                if (api.constructor === Object) {\n                  api = Object.assign({}, api);\n                } else {\n                  const normApi = {};\n                  const props = Object.getOwnPropertyNames(api).concat(\n                    Object.getOwnPropertyNames(Object.getPrototypeOf(api))\n                  );\n                  for (let k of props) {\n                    if (k !== \"constructor\") {\n                      if (typeof api[k] === \"function\")\n                        normApi[k] = api[k].bind(api);\n                      else\n                        normApi[k] = api[k];\n                    }\n                  }\n                  api.id = api.id || \"default\";\n                  api = normApi;\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  api.id && typeof api.id === \"string\",\n                  `Service id not found: ${api}`\n                );\n                if (!api.name) {\n                  api.name = api.id;\n                }\n                if (!api.config) {\n                  api.config = {};\n                }\n                if (!api.type) {\n                  api.type = \"generic\";\n                }\n                let require_context = false, run_in_executor = false;\n                if (api.config.require_context)\n                  require_context = api.config.require_context;\n                if (api.config.run_in_executor)\n                  run_in_executor = true;\n                const visibility = api.config.visibility || \"protected\";\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)([\"protected\", \"public\"].includes(visibility));\n                this._annotate_service_methods(\n                  api,\n                  api[\"id\"],\n                  require_context,\n                  run_in_executor,\n                  visibility\n                );\n                if (this._services[api.id]) {\n                  if (overwrite) {\n                    delete this._services[api.id];\n                  } else {\n                    throw new Error(\n                      `Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`\n                    );\n                  }\n                }\n                this._services[api.id] = api;\n                return api;\n              }\n              _extract_service_info(service) {\n                const config2 = service.config || {};\n                config2.workspace = config2.workspace || this._local_workspace || this._connection.workspace;\n                const skipContext = config2.require_context;\n                const serviceSchema = _get_schema(service, null, skipContext);\n                const serviceInfo = {\n                  config: config2,\n                  id: `${config2.workspace}/${this._client_id}:${service[\"id\"]}`,\n                  name: service.name || service[\"id\"],\n                  description: service.description || \"\",\n                  type: service.type || \"generic\",\n                  docs: service.docs || null,\n                  app_id: this._app_id,\n                  service_schema: serviceSchema\n                };\n                return serviceInfo;\n              }\n              async get_service_schema(service) {\n                const skipContext = service.config.require_context;\n                return _get_schema(service, null, skipContext);\n              }\n              async register_service(api, config2) {\n                let { check_type, notify, overwrite } = config2 || {};\n                notify = notify === void 0 ? true : notify;\n                let manager;\n                if (check_type && api.type) {\n                  try {\n                    manager = await this.get_manager_service({\n                      timeout: 10,\n                      case_conversion: \"camel\"\n                    });\n                    const type_info = await manager.get_service_type(api.type);\n                    api = _annotate_service(api, type_info);\n                  } catch (e) {\n                    throw new Error(`Failed to get service type ${api.type}, error: ${e}`);\n                  }\n                }\n                const service = this.add_service(api, overwrite);\n                const serviceInfo = this._extract_service_info(service);\n                if (notify) {\n                  try {\n                    manager = manager || await this.get_manager_service({\n                      timeout: 10,\n                      case_conversion: \"camel\"\n                    });\n                    await manager.registerService(serviceInfo);\n                  } catch (e) {\n                    throw new Error(`Failed to notify workspace manager: ${e}`);\n                  }\n                }\n                return serviceInfo;\n              }\n              async unregister_service(service, notify) {\n                notify = notify === void 0 ? true : notify;\n                let service_id;\n                if (typeof service === \"string\") {\n                  service_id = service;\n                } else {\n                  service_id = service.id;\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  service_id && typeof service_id === \"string\",\n                  `Invalid service id: ${service_id}`\n                );\n                if (service_id.includes(\":\")) {\n                  service_id = service_id.split(\":\")[1];\n                }\n                if (service_id.includes(\"@\")) {\n                  service_id = service_id.split(\"@\")[0];\n                }\n                if (!this._services[service_id]) {\n                  throw new Error(`Service not found: ${service_id}`);\n                }\n                if (notify) {\n                  const manager = await this.get_manager_service({\n                    timeout: 10,\n                    case_conversion: \"camel\"\n                  });\n                  await manager.unregisterService(service_id);\n                }\n                delete this._services[service_id];\n              }\n              _ndarray(typedArray, shape, dtype) {\n                const _dtype = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(typedArray);\n                if (dtype && dtype !== _dtype) {\n                  throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n                }\n                shape = shape || [typedArray.length];\n                return {\n                  _rtype: \"ndarray\",\n                  _rvalue: typedArray.buffer,\n                  _rshape: shape,\n                  _rdtype: _dtype\n                };\n              }\n              _encode_callback(name2, callback, session_id, clear_after_called, timer, local_workspace, description) {\n                let method_id = `${session_id}.${name2}`;\n                let encoded = {\n                  _rtype: \"method\",\n                  _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                  _rmethod: method_id,\n                  _rpromise: false\n                };\n                const self2 = this;\n                let wrapped_callback = function() {\n                  try {\n                    callback.apply(null, Array.prototype.slice.call(arguments));\n                  } catch (error) {\n                    console.error(\n                      `Error in callback(${method_id}, ${description}): ${error}`\n                    );\n                  } finally {\n                    if (timer && timer.started) {\n                      timer.clear();\n                    }\n                    if (clear_after_called && self2._object_store[session_id]) {\n                      self2._cleanup_session_if_needed(session_id, name2);\n                    }\n                  }\n                };\n                wrapped_callback.__name__ = `callback(${method_id})`;\n                return [encoded, wrapped_callback];\n              }\n              // Clean session management - all logic in one place\n              _cleanup_session_if_needed(session_id, callback_name) {\n                const store = this._get_session_store(session_id, false);\n                if (!store)\n                  return;\n                if (store._promise_manager) {\n                  if (store._promise_manager.should_cleanup_on_callback(callback_name)) {\n                    store._promise_manager.settle();\n                    delete this._object_store[session_id];\n                  }\n                  return;\n                }\n                delete this._object_store[session_id];\n              }\n              // Clean helper to identify promise method calls by session type\n              _is_promise_method_call(method_path) {\n                const session_id = method_path.split(\".\")[0];\n                const session = this._get_session_store(session_id, false);\n                return session && session._promise_manager;\n              }\n              // Clean Promise Manager - encapsulates all promise lifecycle logic\n              _create_promise_manager() {\n                return {\n                  settled: false,\n                  settle() {\n                    this.settled = true;\n                  },\n                  is_settled() {\n                    return this.settled;\n                  },\n                  should_cleanup_on_callback(callback_name) {\n                    return callback_name === \"resolve\" || callback_name === \"reject\";\n                  }\n                };\n              }\n              async _encode_promise(resolve2, reject2, session_id, clear_after_called, timer, local_workspace, description) {\n                let store = this._get_session_store(session_id, true);\n                if (!store) {\n                  console.warn(\n                    `Failed to create session store ${session_id}, session management may be impaired`\n                  );\n                  store = {};\n                }\n                let encoded = {};\n                store._promise_manager = this._create_promise_manager();\n                if (timer && reject2 && this._method_timeout) {\n                  [encoded.heartbeat, store.heartbeat] = this._encode_callback(\n                    \"heartbeat\",\n                    timer.reset.bind(timer),\n                    session_id,\n                    false,\n                    null,\n                    local_workspace\n                  );\n                  store.timer = timer;\n                  encoded.interval = this._method_timeout / 2;\n                }\n                [encoded.resolve, store.resolve] = this._encode_callback(\n                  \"resolve\",\n                  resolve2,\n                  session_id,\n                  clear_after_called,\n                  timer,\n                  local_workspace,\n                  `resolve (${description})`\n                );\n                [encoded.reject, store.reject] = this._encode_callback(\n                  \"reject\",\n                  reject2,\n                  session_id,\n                  clear_after_called,\n                  timer,\n                  local_workspace,\n                  `reject (${description})`\n                );\n                return encoded;\n              }\n              async _send_chunks(data, target_id, session_id) {\n                const remote_services = await this.get_remote_service(\n                  `${target_id}:built-in`\n                );\n                if (!remote_services.message_cache) {\n                  throw new Error(\n                    \"Remote client does not support message caching for large messages.\"\n                  );\n                }\n                const message_cache = remote_services.message_cache;\n                const message_id = session_id || (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                const total_size = data.length;\n                const start_time = Date.now();\n                const chunk_num = Math.ceil(total_size / this._long_message_chunk_size);\n                if (remote_services.config.api_version >= 3) {\n                  await message_cache.create(message_id, !!session_id);\n                  const semaphore = new _utils__WEBPACK_IMPORTED_MODULE_0__.Semaphore(CONCURRENCY_LIMIT);\n                  const tasks = [];\n                  for (let idx = 0; idx < chunk_num; idx++) {\n                    const startByte = idx * this._long_message_chunk_size;\n                    const chunk = data.slice(\n                      startByte,\n                      startByte + this._long_message_chunk_size\n                    );\n                    const taskFn = async () => {\n                      await message_cache.set(message_id, idx, chunk, !!session_id);\n                      console.debug(\n                        `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`\n                      );\n                    };\n                    tasks.push(semaphore.run(taskFn));\n                  }\n                  try {\n                    await Promise.all(tasks);\n                  } catch (error) {\n                    try {\n                      await message_cache.remove(message_id);\n                    } catch (cleanupError) {\n                      console.error(\n                        `Failed to clean up message cache after error: ${cleanupError}`\n                      );\n                    }\n                    throw error;\n                  }\n                } else {\n                  await message_cache.create(message_id, !!session_id);\n                  for (let idx = 0; idx < chunk_num; idx++) {\n                    const startByte = idx * this._long_message_chunk_size;\n                    const chunk = data.slice(\n                      startByte,\n                      startByte + this._long_message_chunk_size\n                    );\n                    await message_cache.append(message_id, chunk, !!session_id);\n                    console.debug(\n                      `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`\n                    );\n                  }\n                }\n                await message_cache.process(message_id, !!session_id);\n                const durationSec = ((Date.now() - start_time) / 1e3).toFixed(2);\n                console.debug(`All chunks (${total_size} bytes) sent in ${durationSec} s`);\n              }\n              emit(main_message, extra_data) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  typeof main_message === \"object\" && main_message.type,\n                  \"Invalid message, must be an object with a `type` fields.\"\n                );\n                if (!main_message.to) {\n                  this._fire(main_message.type, main_message);\n                  return;\n                }\n                let message_package = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n                if (extra_data) {\n                  const extra = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n                  message_package = new Uint8Array([...message_package, ...extra]);\n                }\n                const total_size = message_package.length;\n                if (total_size > this._long_message_chunk_size + 1024) {\n                  console.warn(`Sending large message (size=${total_size})`);\n                }\n                return this._emit_message(message_package);\n              }\n              _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n                let target_id = encoded_method._rtarget;\n                if (remote_workspace && !target_id.includes(\"/\")) {\n                  if (remote_workspace !== target_id) {\n                    target_id = remote_workspace + \"/\" + target_id;\n                  }\n                  encoded_method._rtarget = target_id;\n                }\n                let method_id = encoded_method._rmethod;\n                let with_promise = encoded_method._rpromise || false;\n                const description = `method: ${method_id}, docs: ${encoded_method._rdoc}`;\n                const self2 = this;\n                function remote_method() {\n                  return new Promise(async (resolve2, reject2) => {\n                    let local_session_id = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                    if (local_parent) {\n                      local_session_id = local_parent + \".\" + local_session_id;\n                    }\n                    let store = self2._get_session_store(local_session_id, true);\n                    if (!store) {\n                      reject2(\n                        new Error(\n                          `Runtime Error: Failed to get session store ${local_session_id} (context: ${description})`\n                        )\n                      );\n                      return;\n                    }\n                    store[\"target_id\"] = target_id;\n                    const args = await self2._encode(\n                      Array.prototype.slice.call(arguments),\n                      local_session_id,\n                      local_workspace\n                    );\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    let from_client;\n                    if (!self2._local_workspace) {\n                      from_client = self2._client_id;\n                    } else {\n                      from_client = self2._local_workspace + \"/\" + self2._client_id;\n                    }\n                    let main_message = {\n                      type: \"method\",\n                      from: from_client,\n                      to: target_id,\n                      method: method_id\n                    };\n                    let extra_data = {};\n                    if (args) {\n                      extra_data[\"args\"] = args;\n                    }\n                    if (withKwargs) {\n                      extra_data[\"with_kwargs\"] = withKwargs;\n                    }\n                    if (remote_parent) {\n                      main_message[\"parent\"] = remote_parent;\n                    }\n                    let timer = null;\n                    if (with_promise) {\n                      let hasInterfaceObject = function(obj) {\n                        if (!obj || typeof obj !== \"object\")\n                          return false;\n                        if (obj._rintf === true)\n                          return true;\n                        if (Array.isArray(obj)) {\n                          return obj.some((item) => hasInterfaceObject(item));\n                        }\n                        if (obj.constructor === Object) {\n                          return Object.values(obj).some(\n                            (value) => hasInterfaceObject(value)\n                          );\n                        }\n                        return false;\n                      };\n                      main_message[\"session\"] = local_session_id;\n                      let method_name = `${target_id}:${method_id}`;\n                      timer = new Timer(\n                        self2._method_timeout,\n                        reject2,\n                        [`Method call time out: ${method_name}, context: ${description}`],\n                        method_name\n                      );\n                      let clear_after_called = !hasInterfaceObject(args);\n                      const promiseData = await self2._encode_promise(\n                        resolve2,\n                        reject2,\n                        local_session_id,\n                        clear_after_called,\n                        timer,\n                        local_workspace,\n                        description\n                      );\n                      if (with_promise === true) {\n                        extra_data[\"promise\"] = promiseData;\n                      } else if (with_promise === \"*\") {\n                        extra_data[\"promise\"] = \"*\";\n                        extra_data[\"t\"] = self2._method_timeout / 2;\n                      } else {\n                        throw new Error(`Unsupported promise type: ${with_promise}`);\n                      }\n                    }\n                    let message_package = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n                    if (extra_data) {\n                      const extra = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n                      message_package = new Uint8Array([...message_package, ...extra]);\n                    }\n                    const total_size = message_package.length;\n                    if (total_size <= self2._long_message_chunk_size + 1024 || remote_method.__no_chunk__) {\n                      self2._emit_message(message_package).then(function() {\n                        if (timer) {\n                          timer.reset();\n                        }\n                      }).catch(function(err) {\n                        console.error(\"Failed to send message\", err);\n                        reject2(err);\n                        if (timer) {\n                          timer.clear();\n                        }\n                      });\n                    } else {\n                      self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                        if (timer) {\n                          timer.reset();\n                        }\n                      }).catch(function(err) {\n                        console.error(\"Failed to send message\", err);\n                        reject2(err);\n                        if (timer) {\n                          timer.clear();\n                        }\n                      });\n                    }\n                  });\n                }\n                remote_method.__rpc_object__ = encoded_method;\n                const parts = method_id.split(\".\");\n                remote_method.__name__ = encoded_method._rname || parts[parts.length - 1];\n                if (remote_method.__name__.includes(\"#\")) {\n                  remote_method.__name__ = remote_method.__name__.split(\"#\")[1];\n                }\n                remote_method.__doc__ = encoded_method._rdoc || `Remote method: ${method_id}`;\n                remote_method.__schema__ = encoded_method._rschema;\n                remote_method.__no_chunk__ = encoded_method._rmethod === \"services.built-in.message_cache.append\";\n                return remote_method;\n              }\n              get_client_info() {\n                const services = [];\n                for (let service of Object.values(this._services)) {\n                  services.push(this._extract_service_info(service));\n                }\n                return {\n                  id: this._client_id,\n                  services\n                };\n              }\n              async _handle_method(data) {\n                let reject2 = null;\n                let heartbeat_task = null;\n                try {\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data.method && data.ctx && data.from);\n                  const method_name = data.from + \":\" + data.method;\n                  const remote_workspace = data.from.split(\"/\")[0];\n                  const remote_client_id = data.from.split(\"/\")[1];\n                  data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                  data[\"ctx\"][\"to\"] = data[\"to\"];\n                  let local_workspace;\n                  if (!this._local_workspace) {\n                    local_workspace = data[\"to\"].split(\"/\")[0];\n                  } else {\n                    if (this._local_workspace && this._local_workspace !== \"*\") {\n                      (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                        data[\"to\"].split(\"/\")[0] === this._local_workspace,\n                        \"Workspace mismatch: \" + data[\"to\"].split(\"/\")[0] + \" != \" + this._local_workspace\n                      );\n                    }\n                    local_workspace = this._local_workspace;\n                  }\n                  const local_parent = data.parent;\n                  let resolve2, reject3;\n                  if (data.promise) {\n                    const promise = await this._decode(\n                      data.promise === \"*\" ? this._expand_promise(data) : data.promise,\n                      data.session,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    resolve2 = promise.resolve;\n                    reject3 = promise.reject;\n                    if (promise.heartbeat && promise.interval) {\n                      async function heartbeat() {\n                        try {\n                          await promise.heartbeat();\n                        } catch (err) {\n                          console.error(err);\n                        }\n                      }\n                      heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                      if (data.session) {\n                        const session_store = this._get_session_store(data.session, false);\n                        if (session_store) {\n                          session_store.heartbeat_task = heartbeat_task;\n                        }\n                      }\n                    }\n                  }\n                  let method;\n                  try {\n                    method = indexObject(this._object_store, data[\"method\"]);\n                  } catch (e) {\n                    if (this._is_promise_method_call(data[\"method\"])) {\n                      console.debug(\n                        `Promise method ${data[\"method\"]} not available (session settled or cleaned up), ignoring: ${method_name}`\n                      );\n                      return;\n                    }\n                    throw new Error(\n                      `Method not found: ${method_name} at ${this._client_id}`\n                    );\n                  }\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    method && typeof method === \"function\",\n                    \"Invalid method: \" + method_name\n                  );\n                  if (this._method_annotations.has(method)) {\n                    if (this._method_annotations.get(method).visibility === \"protected\") {\n                      if (local_workspace !== remote_workspace && (remote_workspace !== \"*\" || remote_client_id !== this._connection.manager_id)) {\n                        throw new Error(\n                          \"Permission denied for invoking protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace\n                        );\n                      }\n                    }\n                  } else {\n                    let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                    if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                      session_target_id = local_workspace + \"/\" + session_target_id;\n                    }\n                    if (session_target_id !== data.from) {\n                      throw new Error(\n                        \"Access denied for method call (\" + method_name + \") from \" + data.from + \" to target \" + session_target_id\n                      );\n                    }\n                  }\n                  if (local_parent) {\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      this._get_session_store(local_parent, true) !== null,\n                      \"Parent session was closed: \" + local_parent\n                    );\n                  }\n                  let args;\n                  if (data.args) {\n                    args = await this._decode(\n                      data.args,\n                      data.session,\n                      null,\n                      remote_workspace,\n                      null\n                    );\n                  } else {\n                    args = [];\n                  }\n                  if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                    if (args.length + 1 < method.length) {\n                      for (let i = args.length; i < method.length - 1; i++) {\n                        args.push(void 0);\n                      }\n                    }\n                    args.push(data.ctx);\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      args.length === method.length,\n                      `Runtime Error: Invalid number of arguments for method ${method_name}, expected ${method.length} but got ${args.length}`\n                    );\n                  }\n                  if (data.promise) {\n                    const result = method.apply(null, args);\n                    if (result instanceof Promise) {\n                      result.then((result2) => {\n                        resolve2(result2);\n                        clearInterval(heartbeat_task);\n                      }).catch((err) => {\n                        reject3(err);\n                        clearInterval(heartbeat_task);\n                      });\n                    } else {\n                      resolve2(result);\n                      clearInterval(heartbeat_task);\n                    }\n                  } else {\n                    method.apply(null, args);\n                    clearInterval(heartbeat_task);\n                  }\n                  if (data.session) {\n                    const session_store = this._get_session_store(data.session, false);\n                    if (session_store) {\n                      delete session_store.heartbeat_task;\n                    }\n                  }\n                } catch (err) {\n                  if (reject2) {\n                    reject2(err);\n                  } else {\n                    console.error(\"Error during calling method: \", err);\n                  }\n                  clearInterval(heartbeat_task);\n                }\n              }\n              encode(aObject, session_id) {\n                return this._encode(aObject, session_id);\n              }\n              _get_session_store(session_id, create) {\n                let store = this._object_store;\n                const levels = session_id.split(\".\");\n                if (create) {\n                  const last_index = levels.length - 1;\n                  for (let level of levels.slice(0, last_index)) {\n                    if (!store[level]) {\n                      store[level] = {};\n                    }\n                    store = store[level];\n                  }\n                  if (!store[levels[last_index]]) {\n                    store[levels[last_index]] = {};\n                  }\n                  return store[levels[last_index]];\n                } else {\n                  for (let level of levels) {\n                    if (!store[level]) {\n                      return null;\n                    }\n                    store = store[level];\n                  }\n                  return store;\n                }\n              }\n              /**\n               * Prepares the provided set of remote method arguments for\n               * sending to the remote site, replaces all the callbacks with\n               * identifiers\n               *\n               * @param {Array} args to wrap\n               *\n               * @returns {Array} wrapped arguments\n               */\n              async _encode(aObject, session_id, local_workspace) {\n                const aType = typeof aObject;\n                if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                  return aObject;\n                }\n                if (aObject instanceof ArrayBuffer) {\n                  return {\n                    _rtype: \"memoryview\",\n                    _rvalue: new Uint8Array(aObject)\n                  };\n                }\n                if (aObject.__rpc_object__) {\n                  const _server = aObject.__rpc_object__._rserver || this._server_base_url;\n                  if (_server === this._server_base_url) {\n                    return aObject.__rpc_object__;\n                  }\n                }\n                let bObject;\n                if (aObject.constructor instanceof Object && aObject._rtype) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._encode(aObject, session_id, local_workspace);\n                  bObject._rtype = temp;\n                  return bObject;\n                }\n                if ((0, _utils__WEBPACK_IMPORTED_MODULE_0__.isGenerator)(aObject) || (0, _utils__WEBPACK_IMPORTED_MODULE_0__.isAsyncGenerator)(aObject)) {\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    session_id && typeof session_id === \"string\",\n                    \"Session ID is required for generator encoding\"\n                  );\n                  const object_id = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                  const store = this._get_session_store(session_id, true);\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    store !== null,\n                    `Failed to create session store ${session_id} due to invalid parent`\n                  );\n                  const isAsync = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.isAsyncGenerator)(aObject);\n                  const nextItemMethod = async () => {\n                    if (isAsync) {\n                      const iterator = aObject;\n                      const result = await iterator.next();\n                      if (result.done) {\n                        delete store[object_id];\n                        return { _rtype: \"stop_iteration\" };\n                      }\n                      return result.value;\n                    } else {\n                      const iterator = aObject;\n                      const result = iterator.next();\n                      if (result.done) {\n                        delete store[object_id];\n                        return { _rtype: \"stop_iteration\" };\n                      }\n                      return result.value;\n                    }\n                  };\n                  store[object_id] = nextItemMethod;\n                  bObject = {\n                    _rtype: \"generator\",\n                    _rserver: this._server_base_url,\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: \"*\",\n                    _rdoc: \"Remote generator\"\n                  };\n                  return bObject;\n                } else if (typeof aObject === \"function\") {\n                  if (this._method_annotations.has(aObject)) {\n                    let annotation = this._method_annotations.get(aObject);\n                    bObject = {\n                      _rtype: \"method\",\n                      _rserver: this._server_base_url,\n                      _rtarget: this._client_id,\n                      _rmethod: annotation.method_id,\n                      _rpromise: \"*\",\n                      _rname: aObject.name\n                    };\n                  } else {\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof session_id === \"string\");\n                    let object_id;\n                    if (aObject.__name__) {\n                      object_id = `${(0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)()}#${aObject.__name__}`;\n                    } else {\n                      object_id = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                    }\n                    bObject = {\n                      _rtype: \"method\",\n                      _rserver: this._server_base_url,\n                      _rtarget: this._client_id,\n                      _rmethod: `${session_id}.${object_id}`,\n                      _rpromise: \"*\",\n                      _rname: aObject.name\n                    };\n                    let store = this._get_session_store(session_id, true);\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      store !== null,\n                      `Failed to create session store ${session_id} due to invalid parent`\n                    );\n                    store[object_id] = aObject;\n                  }\n                  bObject._rdoc = aObject.__doc__;\n                  if (!bObject._rdoc) {\n                    try {\n                      const funcInfo = getFunctionInfo(aObject);\n                      if (funcInfo && !bObject._rdoc) {\n                        bObject._rdoc = `${funcInfo.doc}`;\n                      }\n                    } catch (e) {\n                      console.error(\"Failed to extract function docstring:\", aObject);\n                    }\n                  }\n                  bObject._rschema = aObject.__schema__;\n                  return bObject;\n                }\n                const isarray = Array.isArray(aObject);\n                for (let tp of Object.keys(this._codecs)) {\n                  const codec = this._codecs[tp];\n                  if (codec.encoder && aObject instanceof codec.type) {\n                    let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                    if (encodedObj && !encodedObj._rtype)\n                      encodedObj._rtype = codec.name;\n                    if (typeof encodedObj === \"object\") {\n                      const temp = encodedObj._rtype;\n                      delete encodedObj._rtype;\n                      encodedObj = await this._encode(\n                        encodedObj,\n                        session_id,\n                        local_workspace\n                      );\n                      encodedObj._rtype = temp;\n                    }\n                    bObject = encodedObj;\n                    return bObject;\n                  }\n                }\n                if (\n                  /*global tf*/\n                  typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n                ) {\n                  const v_buffer = aObject.dataSync();\n                  bObject = {\n                    _rtype: \"ndarray\",\n                    _rvalue: new Uint8Array(v_buffer.buffer),\n                    _rshape: aObject.shape,\n                    _rdtype: aObject.dtype\n                  };\n                } else if (\n                  /*global nj*/\n                  typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n                ) {\n                  if (!aObject.selection || !aObject.selection.data) {\n                    throw new Error(\"Invalid NumJS array: missing selection or data\");\n                  }\n                  const dtype = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject.selection.data);\n                  bObject = {\n                    _rtype: \"ndarray\",\n                    _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                    _rshape: aObject.shape,\n                    _rdtype: dtype\n                  };\n                } else if (aObject instanceof Error) {\n                  console.error(aObject);\n                  bObject = {\n                    _rtype: \"error\",\n                    _rvalue: aObject.toString(),\n                    _rtrace: aObject.stack\n                  };\n                } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                  bObject = aObject;\n                } else if (aObject instanceof Blob) {\n                  let seek = function(pos) {\n                    _current_pos = pos;\n                  };\n                  let _current_pos = 0;\n                  async function read(length) {\n                    let blob;\n                    if (length) {\n                      blob = aObject.slice(_current_pos, _current_pos + length);\n                    } else {\n                      blob = aObject.slice(_current_pos);\n                    }\n                    const ret = new Uint8Array(await blob.arrayBuffer());\n                    _current_pos = _current_pos + ret.byteLength;\n                    return ret;\n                  }\n                  bObject = {\n                    _rtype: \"iostream\",\n                    _rnative: \"js:blob\",\n                    type: aObject.type,\n                    name: aObject.name,\n                    size: aObject.size,\n                    path: aObject._path || aObject.webkitRelativePath,\n                    read: await this._encode(read, session_id, local_workspace),\n                    seek: await this._encode(seek, session_id, local_workspace)\n                  };\n                } else if (aObject instanceof ArrayBufferView) {\n                  const dtype = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject);\n                  bObject = {\n                    _rtype: \"typedarray\",\n                    _rvalue: new Uint8Array(aObject.buffer),\n                    _rdtype: dtype\n                  };\n                } else if (aObject instanceof DataView) {\n                  bObject = {\n                    _rtype: \"memoryview\",\n                    _rvalue: new Uint8Array(aObject.buffer)\n                  };\n                } else if (aObject instanceof Set) {\n                  bObject = {\n                    _rtype: \"set\",\n                    _rvalue: await this._encode(\n                      Array.from(aObject),\n                      session_id,\n                      local_workspace\n                    )\n                  };\n                } else if (aObject instanceof Map) {\n                  bObject = {\n                    _rtype: \"orderedmap\",\n                    _rvalue: await this._encode(\n                      Array.from(aObject),\n                      session_id,\n                      local_workspace\n                    )\n                  };\n                } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  bObject = isarray ? [] : {};\n                  const keys = Object.keys(aObject);\n                  for (let k of keys) {\n                    bObject[k] = await this._encode(\n                      aObject[k],\n                      session_id,\n                      local_workspace\n                    );\n                  }\n                } else {\n                  throw `hypha-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n                }\n                if (!bObject) {\n                  throw new Error(\"Failed to encode object\");\n                }\n                return bObject;\n              }\n              async decode(aObject) {\n                return await this._decode(aObject);\n              }\n              async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n                if (!aObject) {\n                  return aObject;\n                }\n                let bObject;\n                if (aObject._rtype) {\n                  if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    aObject = await this._decode(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    aObject._rtype = temp;\n                    bObject = await Promise.resolve(\n                      this._codecs[aObject._rtype].decoder(aObject)\n                    );\n                  } else if (aObject._rtype === \"method\") {\n                    bObject = this._generate_remote_method(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                  } else if (aObject._rtype === \"generator\") {\n                    const gen_method = this._generate_remote_method(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    async function* asyncGeneratorProxy() {\n                      while (true) {\n                        try {\n                          const next_item = await gen_method();\n                          if (next_item && next_item._rtype === \"stop_iteration\") {\n                            break;\n                          }\n                          yield next_item;\n                        } catch (error) {\n                          console.error(\"Error in generator:\", error);\n                          throw error;\n                        }\n                      }\n                    }\n                    bObject = asyncGeneratorProxy();\n                  } else if (aObject._rtype === \"ndarray\") {\n                    if (typeof nj !== \"undefined\" && nj.array) {\n                      if (Array.isArray(aObject._rvalue)) {\n                        aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                      }\n                      bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                    } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                      if (Array.isArray(aObject._rvalue)) {\n                        aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                      }\n                      const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n                      bObject = tf.tensor(\n                        new arraytype(aObject._rvalue),\n                        aObject._rshape,\n                        aObject._rdtype\n                      );\n                    } else {\n                      bObject = aObject;\n                    }\n                  } else if (aObject._rtype === \"error\") {\n                    bObject = new Error(\n                      \"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\")\n                    );\n                  } else if (aObject._rtype === \"typedarray\") {\n                    const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n                    if (!arraytype)\n                      throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                    const buffer = aObject._rvalue.buffer.slice(\n                      aObject._rvalue.byteOffset,\n                      aObject._rvalue.byteOffset + aObject._rvalue.byteLength\n                    );\n                    bObject = new arraytype(buffer);\n                  } else if (aObject._rtype === \"memoryview\") {\n                    bObject = aObject._rvalue.buffer.slice(\n                      aObject._rvalue.byteOffset,\n                      aObject._rvalue.byteOffset + aObject._rvalue.byteLength\n                    );\n                  } else if (aObject._rtype === \"iostream\") {\n                    if (aObject._rnative === \"js:blob\") {\n                      const read = await this._generate_remote_method(\n                        aObject.read,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      );\n                      const bytes = await read();\n                      bObject = new Blob([bytes], {\n                        type: aObject.type,\n                        name: aObject.name\n                      });\n                    } else {\n                      bObject = {};\n                      for (let k of Object.keys(aObject)) {\n                        if (!k.startsWith(\"_\")) {\n                          bObject[k] = await this._decode(\n                            aObject[k],\n                            remote_parent,\n                            local_parent,\n                            remote_workspace,\n                            local_workspace\n                          );\n                        }\n                      }\n                    }\n                    bObject[\"__rpc_object__\"] = aObject;\n                  } else if (aObject._rtype === \"orderedmap\") {\n                    bObject = new Map(\n                      await this._decode(\n                        aObject._rvalue,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      )\n                    );\n                  } else if (aObject._rtype === \"set\") {\n                    bObject = new Set(\n                      await this._decode(\n                        aObject._rvalue,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      )\n                    );\n                  } else {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    bObject = await this._decode(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    bObject._rtype = temp;\n                  }\n                } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  const isarray = Array.isArray(aObject);\n                  bObject = isarray ? [] : {};\n                  for (let k of Object.keys(aObject)) {\n                    if (isarray || aObject.hasOwnProperty(k)) {\n                      const v = aObject[k];\n                      bObject[k] = await this._decode(\n                        v,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      );\n                    }\n                  }\n                } else {\n                  bObject = aObject;\n                }\n                if (bObject === void 0) {\n                  throw new Error(\"Failed to decode object\");\n                }\n                return bObject;\n              }\n              _expand_promise(data) {\n                return {\n                  heartbeat: {\n                    _rtype: \"method\",\n                    _rtarget: data.from.split(\"/\")[1],\n                    _rmethod: data.session + \".heartbeat\",\n                    _rdoc: `heartbeat callback for method: ${data.method}`\n                  },\n                  resolve: {\n                    _rtype: \"method\",\n                    _rtarget: data.from.split(\"/\")[1],\n                    _rmethod: data.session + \".resolve\",\n                    _rdoc: `resolve callback for method: ${data.method}`\n                  },\n                  reject: {\n                    _rtype: \"method\",\n                    _rtarget: data.from.split(\"/\")[1],\n                    _rmethod: data.session + \".reject\",\n                    _rdoc: `reject callback for method: ${data.method}`\n                  },\n                  interval: data.t\n                };\n              }\n            }\n          }\n        ),\n        /***/\n        \"./src/utils/index.js\": (\n          /*!****************************!*\\\n            !*** ./src/utils/index.js ***!\n            \\****************************/\n          /***/\n          (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_84003__) => {\n            __nested_webpack_require_84003__.r(__nested_webpack_exports__);\n            __nested_webpack_require_84003__.d(__nested_webpack_exports__, {\n              /* harmony export */\n              MessageEmitter: () => (\n                /* binding */\n                MessageEmitter\n              ),\n              /* harmony export */\n              Semaphore: () => (\n                /* binding */\n                Semaphore\n              ),\n              /* harmony export */\n              assert: () => (\n                /* binding */\n                assert\n              ),\n              /* harmony export */\n              cacheRequirements: () => (\n                /* binding */\n                cacheRequirements\n              ),\n              /* harmony export */\n              convertCase: () => (\n                /* binding */\n                convertCase\n              ),\n              /* harmony export */\n              dtypeToTypedArray: () => (\n                /* binding */\n                dtypeToTypedArray\n              ),\n              /* harmony export */\n              expandKwargs: () => (\n                /* binding */\n                expandKwargs\n              ),\n              /* harmony export */\n              isAsyncGenerator: () => (\n                /* binding */\n                isAsyncGenerator\n              ),\n              /* harmony export */\n              isGenerator: () => (\n                /* binding */\n                isGenerator\n              ),\n              /* harmony export */\n              loadRequirements: () => (\n                /* binding */\n                loadRequirements\n              ),\n              /* harmony export */\n              loadRequirementsInWebworker: () => (\n                /* binding */\n                loadRequirementsInWebworker\n              ),\n              /* harmony export */\n              loadRequirementsInWindow: () => (\n                /* binding */\n                loadRequirementsInWindow\n              ),\n              /* harmony export */\n              normalizeConfig: () => (\n                /* binding */\n                normalizeConfig\n              ),\n              /* harmony export */\n              parseServiceUrl: () => (\n                /* binding */\n                parseServiceUrl\n              ),\n              /* harmony export */\n              randId: () => (\n                /* binding */\n                randId\n              ),\n              /* harmony export */\n              toCamelCase: () => (\n                /* binding */\n                toCamelCase\n              ),\n              /* harmony export */\n              toSnakeCase: () => (\n                /* binding */\n                toSnakeCase\n              ),\n              /* harmony export */\n              typedArrayToDtype: () => (\n                /* binding */\n                typedArrayToDtype\n              ),\n              /* harmony export */\n              typedArrayToDtypeMapping: () => (\n                /* binding */\n                typedArrayToDtypeMapping\n              ),\n              /* harmony export */\n              urlJoin: () => (\n                /* binding */\n                urlJoin\n              ),\n              /* harmony export */\n              waitFor: () => (\n                /* binding */\n                waitFor\n              )\n              /* harmony export */\n            });\n            function randId() {\n              return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n            }\n            function toCamelCase(str) {\n              if (!str.includes(\"_\")) {\n                return str;\n              }\n              return str.replace(/_./g, (match) => match[1].toUpperCase());\n            }\n            function toSnakeCase(str) {\n              return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n            }\n            function expandKwargs(obj) {\n              if (typeof obj !== \"object\" || obj === null) {\n                return obj;\n              }\n              const newObj = Array.isArray(obj) ? [] : {};\n              for (const key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                  const value = obj[key];\n                  if (typeof value === \"function\") {\n                    newObj[key] = (...args) => {\n                      if (args.length === 0) {\n                        throw new Error(`Function \"${key}\" expects at least one argument.`);\n                      }\n                      const lastArg = args[args.length - 1];\n                      let kwargs = {};\n                      if (typeof lastArg === \"object\" && lastArg !== null && !Array.isArray(lastArg)) {\n                        kwargs = { ...lastArg, _rkwarg: true };\n                        args = args.slice(0, -1);\n                      }\n                      return value(...args, kwargs);\n                    };\n                    newObj[key].__name__ = key;\n                    if (value.__schema__) {\n                      newObj[key].__schema__ = { ...value.__schema__ };\n                      newObj[key].__schema__.name = key;\n                    }\n                  } else {\n                    newObj[key] = expandKwargs(value);\n                  }\n                }\n              }\n              return newObj;\n            }\n            function convertCase(obj, caseType) {\n              if (typeof obj !== \"object\" || obj === null || !caseType) {\n                return obj;\n              }\n              const newObj = Array.isArray(obj) ? [] : {};\n              for (const key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                  const value = obj[key];\n                  const camelKey = toCamelCase(key);\n                  const snakeKey = toSnakeCase(key);\n                  if (caseType === \"camel\") {\n                    newObj[camelKey] = convertCase(value, caseType);\n                    if (typeof value === \"function\") {\n                      newObj[camelKey].__name__ = camelKey;\n                      if (value.__schema__) {\n                        newObj[camelKey].__schema__ = { ...value.__schema__ };\n                        newObj[camelKey].__schema__.name = camelKey;\n                      }\n                    }\n                  } else if (caseType === \"snake\") {\n                    newObj[snakeKey] = convertCase(value, caseType);\n                    if (typeof value === \"function\") {\n                      newObj[snakeKey].__name__ = snakeKey;\n                      if (value.__schema__) {\n                        newObj[snakeKey].__schema__ = { ...value.__schema__ };\n                        newObj[snakeKey].__schema__.name = snakeKey;\n                      }\n                    }\n                  } else {\n                    if (caseType.includes(\"camel\")) {\n                      newObj[camelKey] = convertCase(value, \"camel\");\n                    }\n                    if (caseType.includes(\"snake\")) {\n                      newObj[snakeKey] = convertCase(value, \"snake\");\n                    }\n                  }\n                }\n              }\n              return newObj;\n            }\n            function parseServiceUrl(url) {\n              url = url.replace(/\\/$/, \"\");\n              const pattern = new RegExp(\n                \"^(https?:\\\\/\\\\/[^/]+)\\\\/([a-z0-9_-]+)\\\\/services\\\\/(?:(?<clientId>[a-zA-Z0-9_-]+):)?(?<serviceId>[a-zA-Z0-9_-]+)(?:@(?<appId>[a-zA-Z0-9_-]+))?\"\n                // optional app_id\n              );\n              const match = url.match(pattern);\n              if (!match) {\n                throw new Error(\"URL does not match the expected pattern\");\n              }\n              const serverUrl = match[1];\n              const workspace2 = match[2];\n              const clientId = match.groups?.clientId || \"*\";\n              const serviceId = match.groups?.serviceId;\n              const appId = match.groups?.appId || \"*\";\n              return { serverUrl, workspace: workspace2, clientId, serviceId, appId };\n            }\n            const dtypeToTypedArray = {\n              int8: Int8Array,\n              int16: Int16Array,\n              int32: Int32Array,\n              uint8: Uint8Array,\n              uint16: Uint16Array,\n              uint32: Uint32Array,\n              float32: Float32Array,\n              float64: Float64Array,\n              array: Array\n            };\n            async function loadRequirementsInWindow(requirements) {\n              function _importScript(url) {\n                return new Promise((resolve2, reject2) => {\n                  var scriptTag = document.createElement(\"script\");\n                  scriptTag.src = url;\n                  scriptTag.type = \"text/javascript\";\n                  scriptTag.onload = resolve2;\n                  scriptTag.onreadystatechange = function() {\n                    if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                      resolve2();\n                    }\n                  };\n                  scriptTag.onerror = reject2;\n                  document.head.appendChild(scriptTag);\n                });\n              }\n              async function importScripts2() {\n                var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n                for (; i2 < len; i2++) {\n                  await _importScript(args[i2]);\n                }\n              }\n              if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n                try {\n                  var link_node;\n                  requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                  if (Array.isArray(requirements)) {\n                    for (var i = 0; i < requirements.length; i++) {\n                      if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                        if (requirements[i].startsWith(\"css:\")) {\n                          requirements[i] = requirements[i].slice(4);\n                        }\n                        link_node = document.createElement(\"link\");\n                        link_node.rel = \"stylesheet\";\n                        link_node.href = requirements[i];\n                        document.head.appendChild(link_node);\n                      } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                        if (requirements[i].startsWith(\"mjs:\")) {\n                          requirements[i] = requirements[i].slice(4);\n                        }\n                        await import(\n                          /* webpackIgnore: true */\n                          requirements[i]\n                        );\n                      } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                        if (requirements[i].startsWith(\"js:\")) {\n                          requirements[i] = requirements[i].slice(3);\n                        }\n                        await importScripts2(requirements[i]);\n                      } else if (requirements[i].startsWith(\"http\")) {\n                        await importScripts2(requirements[i]);\n                      } else if (requirements[i].startsWith(\"cache:\")) {\n                      } else {\n                        console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                      }\n                    }\n                  } else {\n                    throw \"unsupported requirements definition\";\n                  }\n                } catch (e) {\n                  throw \"failed to import required scripts: \" + requirements.toString();\n                }\n              }\n            }\n            async function loadRequirementsInWebworker(requirements) {\n              if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n                try {\n                  if (!Array.isArray(requirements)) {\n                    requirements = [requirements];\n                  }\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      throw \"unable to import css in a webworker\";\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      importScripts(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      importScripts(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } catch (e) {\n                  throw \"failed to import required scripts: \" + requirements.toString();\n                }\n              }\n            }\n            function loadRequirements(requirements) {\n              if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n                return loadRequirementsInWebworker(requirements);\n              } else {\n                return loadRequirementsInWindow(requirements);\n              }\n            }\n            function normalizeConfig(config2) {\n              config2.version = config2.version || \"0.1.0\";\n              config2.description = config2.description || `[TODO: add description for ${config2.name} ]`;\n              config2.type = config2.type || \"rpc-window\";\n              config2.id = config2.id || randId();\n              config2.target_origin = config2.target_origin || \"*\";\n              config2.allow_execution = config2.allow_execution || false;\n              config2 = Object.keys(config2).reduce((p, c) => {\n                if (typeof config2[c] !== \"function\")\n                  p[c] = config2[c];\n                return p;\n              }, {});\n              return config2;\n            }\n            const typedArrayToDtypeMapping = {\n              Int8Array: \"int8\",\n              Int16Array: \"int16\",\n              Int32Array: \"int32\",\n              Uint8Array: \"uint8\",\n              Uint16Array: \"uint16\",\n              Uint32Array: \"uint32\",\n              Float32Array: \"float32\",\n              Float64Array: \"float64\",\n              Array: \"array\"\n            };\n            const typedArrayToDtypeKeys = [];\n            for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n              typedArrayToDtypeKeys.push(eval(arrType));\n            }\n            function typedArrayToDtype(obj) {\n              let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n              if (!dtype) {\n                const pt = Object.getPrototypeOf(obj);\n                for (const arrType2 of typedArrayToDtypeKeys) {\n                  if (pt instanceof arrType2) {\n                    dtype = typedArrayToDtypeMapping[arrType2.name];\n                    break;\n                  }\n                }\n              }\n              return dtype;\n            }\n            function cacheUrlInServiceWorker(url) {\n              return new Promise(function(resolve2, reject2) {\n                const message = {\n                  command: \"add\",\n                  url\n                };\n                if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                  reject2(\"Service worker is not supported.\");\n                  return;\n                }\n                const messageChannel = new MessageChannel();\n                messageChannel.port1.onmessage = function(event2) {\n                  if (event2.data && event2.data.error) {\n                    reject2(event2.data.error);\n                  } else {\n                    resolve2(event2.data && event2.data.result);\n                  }\n                };\n                if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                  navigator.serviceWorker.controller.postMessage(message, [\n                    messageChannel.port2\n                  ]);\n                } else {\n                  reject2(\"Service worker controller is not available\");\n                }\n              });\n            }\n            async function cacheRequirements(requirements) {\n              requirements = requirements || [];\n              if (!Array.isArray(requirements)) {\n                requirements = [requirements];\n              }\n              for (let req of requirements) {\n                if (req.startsWith(\"js:\"))\n                  req = req.slice(3);\n                if (req.startsWith(\"css:\"))\n                  req = req.slice(4);\n                if (req.startsWith(\"cache:\"))\n                  req = req.slice(6);\n                if (!req.startsWith(\"http\"))\n                  continue;\n                await cacheUrlInServiceWorker(req).catch((e) => {\n                  console.error(e);\n                });\n              }\n            }\n            function assert(condition, message) {\n              if (!condition) {\n                throw new Error(message || \"Assertion failed\");\n              }\n            }\n            function urlJoin(...args) {\n              return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n            }\n            function waitFor(prom, time, error) {\n              let timer;\n              return Promise.race([\n                prom,\n                new Promise(\n                  (_r, rej) => timer = setTimeout(() => {\n                    rej(error || \"Timeout Error\");\n                  }, time * 1e3)\n                )\n              ]).finally(() => clearTimeout(timer));\n            }\n            class MessageEmitter {\n              constructor(debug) {\n                this._event_handlers = {};\n                this._once_handlers = {};\n                this._debug = debug;\n              }\n              emit() {\n                throw new Error(\"emit is not implemented\");\n              }\n              on(event2, handler) {\n                if (!this._event_handlers[event2]) {\n                  this._event_handlers[event2] = [];\n                }\n                this._event_handlers[event2].push(handler);\n              }\n              once(event2, handler) {\n                handler.___event_run_once = true;\n                this.on(event2, handler);\n              }\n              off(event2, handler) {\n                if (!event2 && !handler) {\n                  this._event_handlers = {};\n                } else if (event2 && !handler) {\n                  if (this._event_handlers[event2])\n                    this._event_handlers[event2] = [];\n                } else {\n                  if (this._event_handlers[event2]) {\n                    const idx = this._event_handlers[event2].indexOf(handler);\n                    if (idx >= 0) {\n                      this._event_handlers[event2].splice(idx, 1);\n                    }\n                  }\n                }\n              }\n              _fire(event2, data) {\n                if (this._event_handlers[event2]) {\n                  var i = this._event_handlers[event2].length;\n                  while (i--) {\n                    const handler = this._event_handlers[event2][i];\n                    try {\n                      handler(data);\n                    } catch (e) {\n                      console.error(e);\n                    } finally {\n                      if (handler.___event_run_once) {\n                        this._event_handlers[event2].splice(i, 1);\n                      }\n                    }\n                  }\n                } else {\n                  if (this._debug) {\n                    console.warn(\"unhandled event\", event2, data);\n                  }\n                }\n              }\n              waitFor(event2, timeout) {\n                return new Promise((resolve2, reject2) => {\n                  const handler = (data) => {\n                    clearTimeout(timer);\n                    resolve2(data);\n                  };\n                  this.once(event2, handler);\n                  const timer = setTimeout(() => {\n                    this.off(event2, handler);\n                    reject2(new Error(\"Timeout\"));\n                  }, timeout);\n                });\n              }\n            }\n            class Semaphore {\n              constructor(max) {\n                this.max = max;\n                this.queue = [];\n                this.current = 0;\n              }\n              async run(task) {\n                if (this.current >= this.max) {\n                  await new Promise((resolve2) => this.queue.push(resolve2));\n                }\n                this.current++;\n                try {\n                  return await task();\n                } finally {\n                  this.current--;\n                  if (this.queue.length > 0) {\n                    this.queue.shift()();\n                  }\n                }\n              }\n            }\n            function isGenerator(obj) {\n              if (!obj)\n                return false;\n              return typeof obj === \"object\" && typeof obj.next === \"function\" && typeof obj.throw === \"function\" && typeof obj.return === \"function\";\n            }\n            function isAsyncGenerator(obj) {\n              if (!obj)\n                return false;\n              return typeof obj === \"object\" && typeof obj.next === \"function\" && typeof obj.throw === \"function\" && typeof obj.return === \"function\" && Symbol.asyncIterator in Object(obj) && obj[Symbol.toStringTag] === \"AsyncGenerator\";\n            }\n          }\n        ),\n        /***/\n        \"./src/utils/schema.js\": (\n          /*!*****************************!*\\\n            !*** ./src/utils/schema.js ***!\n            \\*****************************/\n          /***/\n          (__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              schemaFunction: () => (\n                /* binding */\n                schemaFunction\n              )\n              /* harmony export */\n            });\n            var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! . */\n              \"./src/utils/index.js\"\n            );\n            function schemaFunction(func, { schema_type = \"auto\", name: name2 = null, description = null, parameters = null }) {\n              if (!func || typeof func !== \"function\") {\n                throw Error(\"func should be a function\");\n              }\n              (0, ___WEBPACK_IMPORTED_MODULE_0__.assert)(schema_type === \"auto\", \"schema_type should be auto\");\n              (0, ___WEBPACK_IMPORTED_MODULE_0__.assert)(name2, \"name should not be null\");\n              (0, ___WEBPACK_IMPORTED_MODULE_0__.assert)(\n                parameters && parameters.type === \"object\",\n                \"parameters should be an object\"\n              );\n              func.__schema__ = {\n                name: name2,\n                description,\n                parameters: parameters || []\n              };\n              return func;\n            }\n          }\n        ),\n        /***/\n        \"./src/webrtc-client.js\": (\n          /*!******************************!*\\\n            !*** ./src/webrtc-client.js ***!\n            \\******************************/\n          /***/\n          (__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              getRTCService: () => (\n                /* binding */\n                getRTCService\n              ),\n              /* harmony export */\n              registerRTCService: () => (\n                /* binding */\n                registerRTCService\n              )\n              /* harmony export */\n            });\n            var _rpc_js__WEBPACK_IMPORTED_MODULE_0__2 = __webpack_require__2(\n              /*! ./rpc.js */\n              \"./src/rpc.js\"\n            );\n            var _utils__WEBPACK_IMPORTED_MODULE_1__2 = __webpack_require__2(\n              /*! ./utils */\n              \"./src/utils/index.js\"\n            );\n            var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n              /*! ./utils/schema.js */\n              \"./src/utils/schema.js\"\n            );\n            class WebRTCConnection {\n              constructor(channel) {\n                this._data_channel = channel;\n                this._handle_message = null;\n                this._reconnection_token = null;\n                this._handle_disconnected = null;\n                this._handle_connected = () => {\n                };\n                this.manager_id = null;\n                this._last_message = null;\n                this._data_channel.onopen = async () => {\n                  if (this._last_message) {\n                    console.info(\"Resending last message after connection established\");\n                    this._data_channel.send(this._last_message);\n                    this._last_message = null;\n                  }\n                  this._handle_connected && this._handle_connected({ channel: this._data_channel });\n                };\n                this._data_channel.onmessage = async (event2) => {\n                  let data = event2.data;\n                  if (data instanceof Blob) {\n                    data = await data.arrayBuffer();\n                  }\n                  this._handle_message(data);\n                };\n                const self2 = this;\n                this._data_channel.onclose = function() {\n                  if (this._handle_disconnected)\n                    this._handle_disconnected(\"closed\");\n                  console.log(\"websocket closed\");\n                  self2._data_channel = null;\n                };\n              }\n              on_disconnected(handler) {\n                this._handle_disconnected = handler;\n              }\n              on_connected(handler) {\n                this._handle_connected = handler;\n              }\n              on_message(handler) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(handler, \"handler is required\");\n                this._handle_message = handler;\n              }\n              async emit_message(data) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(this._handle_message, \"No handler for message\");\n                try {\n                  this._last_message = data;\n                  this._data_channel.send(data);\n                  this._last_message = null;\n                } catch (exp) {\n                  console.error(`Failed to send data, error: ${exp}`);\n                  throw exp;\n                }\n              }\n              async disconnect(reason) {\n                this._last_message = null;\n                this._data_channel = null;\n                console.info(`data channel connection disconnected (${reason})`);\n              }\n            }\n            async function _setupRPC(config2) {\n              (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(config2.channel, \"No channel provided\");\n              (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(config2.workspace, \"No workspace provided\");\n              const channel = config2.channel;\n              const clientId = config2.client_id || (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.randId)();\n              const connection = new WebRTCConnection(channel);\n              config2.context = config2.context || {};\n              config2.context.connection_type = \"webrtc\";\n              config2.context.ws = config2.workspace;\n              const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__2.RPC(connection, {\n                client_id: clientId,\n                default_context: config2.context,\n                name: config2.name,\n                method_timeout: config2.method_timeout || 10,\n                workspace: config2.workspace,\n                app_id: config2.app_id,\n                long_message_chunk_size: config2.long_message_chunk_size\n              });\n              return rpc;\n            }\n            async function _createOffer(params, server2, config2, onInit, context2) {\n              config2 = config2 || {};\n              let offer = new RTCSessionDescription({\n                sdp: params.sdp,\n                type: params.type\n              });\n              let pc = new RTCPeerConnection({\n                iceServers: config2.ice_servers || [\n                  { urls: [\"stun:stun.l.google.com:19302\"] }\n                ],\n                sdpSemantics: \"unified-plan\"\n              });\n              if (server2) {\n                pc.addEventListener(\"datachannel\", async (event2) => {\n                  const channel = event2.channel;\n                  let ctx = null;\n                  if (context2 && context2.user)\n                    ctx = { user: context2.user, ws: context2.ws };\n                  const rpc = await _setupRPC({\n                    channel,\n                    client_id: channel.label,\n                    workspace: server2.config.workspace,\n                    context: ctx\n                  });\n                  rpc._services = server2.rpc._services;\n                });\n              }\n              if (onInit) {\n                await onInit(pc);\n              }\n              await pc.setRemoteDescription(offer);\n              let answer = await pc.createAnswer();\n              await pc.setLocalDescription(answer);\n              await new Promise((resolveIce) => {\n                if (pc.iceGatheringState === \"complete\") {\n                  resolveIce();\n                } else {\n                  pc.addEventListener(\"icegatheringstatechange\", () => {\n                    if (pc.iceGatheringState === \"complete\") {\n                      resolveIce();\n                    }\n                  });\n                  setTimeout(resolveIce, 5e3);\n                }\n              });\n              return {\n                sdp: pc.localDescription.sdp,\n                type: pc.localDescription.type,\n                workspace: server2.config.workspace\n              };\n            }\n            async function getRTCService(server2, service_id, config2) {\n              config2 = config2 || {};\n              config2.peer_id = config2.peer_id || (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.randId)();\n              const pc = new RTCPeerConnection({\n                iceServers: config2.ice_servers || [\n                  { urls: [\"stun:stun.l.google.com:19302\"] }\n                ],\n                sdpSemantics: \"unified-plan\"\n              });\n              return new Promise(async (resolve2, reject2) => {\n                let resolved = false;\n                const timeout = setTimeout(() => {\n                  if (!resolved) {\n                    resolved = true;\n                    pc.close();\n                    reject2(new Error(\"WebRTC Connection timeout\"));\n                  }\n                }, 3e4);\n                try {\n                  pc.addEventListener(\n                    \"connectionstatechange\",\n                    () => {\n                      console.log(\"WebRTC Connection state: \", pc.connectionState);\n                      if (pc.connectionState === \"failed\") {\n                        if (!resolved) {\n                          resolved = true;\n                          clearTimeout(timeout);\n                          pc.close();\n                          reject2(new Error(\"WebRTC Connection failed\"));\n                        }\n                      } else if (pc.connectionState === \"closed\") {\n                        if (!resolved) {\n                          resolved = true;\n                          clearTimeout(timeout);\n                          reject2(new Error(\"WebRTC Connection closed\"));\n                        }\n                      } else if (pc.connectionState === \"connected\") {\n                        console.log(\"WebRTC Connection established successfully\");\n                      }\n                    },\n                    false\n                  );\n                  pc.addEventListener(\"iceconnectionstatechange\", () => {\n                    console.log(\"ICE Connection state: \", pc.iceConnectionState);\n                    if (pc.iceConnectionState === \"failed\") {\n                      if (!resolved) {\n                        resolved = true;\n                        clearTimeout(timeout);\n                        pc.close();\n                        reject2(new Error(\"ICE Connection failed\"));\n                      }\n                    }\n                  });\n                  if (config2.on_init) {\n                    await config2.on_init(pc);\n                    delete config2.on_init;\n                  }\n                  let channel = pc.createDataChannel(config2.peer_id, { ordered: true });\n                  channel.binaryType = \"arraybuffer\";\n                  const offer = await pc.createOffer();\n                  await pc.setLocalDescription(offer);\n                  await new Promise((resolveIce) => {\n                    if (pc.iceGatheringState === \"complete\") {\n                      resolveIce();\n                    } else {\n                      pc.addEventListener(\"icegatheringstatechange\", () => {\n                        if (pc.iceGatheringState === \"complete\") {\n                          resolveIce();\n                        }\n                      });\n                      setTimeout(resolveIce, 5e3);\n                    }\n                  });\n                  const svc = await server2.getService(service_id);\n                  const answer = await svc.offer({\n                    sdp: pc.localDescription.sdp,\n                    type: pc.localDescription.type\n                  });\n                  channel.onopen = () => {\n                    config2.channel = channel;\n                    config2.workspace = answer.workspace;\n                    setTimeout(async () => {\n                      if (!resolved) {\n                        try {\n                          const rpc = await _setupRPC(config2);\n                          pc.rpc = rpc;\n                          async function get_service(name2, ...args) {\n                            (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(\n                              !name2.includes(\":\"),\n                              \"WebRTC service name should not contain ':'\"\n                            );\n                            (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(\n                              !name2.includes(\"/\"),\n                              \"WebRTC service name should not contain '/'\"\n                            );\n                            return await rpc.get_remote_service(\n                              config2.workspace + \"/\" + config2.peer_id + \":\" + name2,\n                              ...args\n                            );\n                          }\n                          async function disconnect() {\n                            await rpc.disconnect();\n                            pc.close();\n                          }\n                          pc.getService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2.schemaFunction)(get_service, {\n                            name: \"getService\",\n                            description: \"Get a remote service via webrtc\",\n                            parameters: {\n                              type: \"object\",\n                              properties: {\n                                service_id: {\n                                  type: \"string\",\n                                  description: \"Service ID. This should be a service id in the format: 'workspace/service_id', 'workspace/client_id:service_id' or 'workspace/client_id:service_id@app_id'\"\n                                },\n                                config: {\n                                  type: \"object\",\n                                  description: \"Options for the service\"\n                                }\n                              },\n                              required: [\"id\"]\n                            }\n                          });\n                          pc.disconnect = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2.schemaFunction)(disconnect, {\n                            name: \"disconnect\",\n                            description: \"Disconnect from the webrtc connection via webrtc\",\n                            parameters: { type: \"object\", properties: {} }\n                          });\n                          pc.registerCodec = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2.schemaFunction)(rpc.register_codec, {\n                            name: \"registerCodec\",\n                            description: \"Register a codec for the webrtc connection\",\n                            parameters: {\n                              type: \"object\",\n                              properties: {\n                                codec: {\n                                  type: \"object\",\n                                  description: \"Codec to register\",\n                                  properties: {\n                                    name: { type: \"string\" },\n                                    type: {},\n                                    encoder: { type: \"function\" },\n                                    decoder: { type: \"function\" }\n                                  }\n                                }\n                              }\n                            }\n                          });\n                          resolved = true;\n                          clearTimeout(timeout);\n                          resolve2(pc);\n                        } catch (e) {\n                          if (!resolved) {\n                            resolved = true;\n                            clearTimeout(timeout);\n                            reject2(e);\n                          }\n                        }\n                      }\n                    }, 1e3);\n                  };\n                  channel.onclose = () => {\n                    if (!resolved) {\n                      resolved = true;\n                      clearTimeout(timeout);\n                      reject2(new Error(\"Data channel closed\"));\n                    }\n                  };\n                  channel.onerror = (error) => {\n                    if (!resolved) {\n                      resolved = true;\n                      clearTimeout(timeout);\n                      reject2(new Error(`Data channel error: ${error}`));\n                    }\n                  };\n                  await pc.setRemoteDescription(\n                    new RTCSessionDescription({\n                      sdp: answer.sdp,\n                      type: answer.type\n                    })\n                  );\n                } catch (e) {\n                  if (!resolved) {\n                    resolved = true;\n                    clearTimeout(timeout);\n                    reject2(e);\n                  }\n                }\n              });\n            }\n            async function registerRTCService(server2, service_id, config2) {\n              config2 = config2 || {\n                visibility: \"protected\",\n                require_context: true\n              };\n              const onInit = config2.on_init;\n              delete config2.on_init;\n              return await server2.registerService({\n                id: service_id,\n                config: config2,\n                offer: (params, context2) => _createOffer(params, server2, config2, onInit, context2)\n              });\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n          /*!*************************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n            \\*************************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              CachedKeyDecoder: () => (\n                /* binding */\n                CachedKeyDecoder\n              )\n              /* harmony export */\n            });\n            var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./utils/utf8.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n            );\n            var DEFAULT_MAX_KEY_LENGTH = 16;\n            var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n            var CachedKeyDecoder = (\n              /** @class */\n              function() {\n                function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                  if (maxKeyLength === void 0) {\n                    maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                  }\n                  if (maxLengthPerKey === void 0) {\n                    maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                  }\n                  this.maxKeyLength = maxKeyLength;\n                  this.maxLengthPerKey = maxLengthPerKey;\n                  this.hit = 0;\n                  this.miss = 0;\n                  this.caches = [];\n                  for (var i = 0; i < this.maxKeyLength; i++) {\n                    this.caches.push([]);\n                  }\n                }\n                CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                  return byteLength > 0 && byteLength <= this.maxKeyLength;\n                };\n                CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                  var records = this.caches[byteLength - 1];\n                  FIND_CHUNK:\n                    for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                      var record = records_1[_i];\n                      var recordBytes = record.bytes;\n                      for (var j = 0; j < byteLength; j++) {\n                        if (recordBytes[j] !== bytes[inputOffset + j]) {\n                          continue FIND_CHUNK;\n                        }\n                      }\n                      return record.str;\n                    }\n                  return null;\n                };\n                CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                  var records = this.caches[bytes.length - 1];\n                  var record = { bytes, str: value };\n                  if (records.length >= this.maxLengthPerKey) {\n                    records[Math.random() * records.length | 0] = record;\n                  } else {\n                    records.push(record);\n                  }\n                };\n                CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                  var cachedValue = this.find(bytes, inputOffset, byteLength);\n                  if (cachedValue != null) {\n                    this.hit++;\n                    return cachedValue;\n                  }\n                  this.miss++;\n                  var str = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n                  var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                  this.store(slicedCopyOfBytes, str);\n                  return str;\n                };\n                return CachedKeyDecoder2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n          /*!********************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n            \\********************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              DecodeError: () => (\n                /* binding */\n                DecodeError\n              )\n              /* harmony export */\n            });\n            var __extends = /* @__PURE__ */ function() {\n              var extendStatics = function(d, b) {\n                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                  d2.__proto__ = b2;\n                } || function(d2, b2) {\n                  for (var p in b2)\n                    if (Object.prototype.hasOwnProperty.call(b2, p))\n                      d2[p] = b2[p];\n                };\n                return extendStatics(d, b);\n              };\n              return function(d, b) {\n                if (typeof b !== \"function\" && b !== null)\n                  throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                extendStatics(d, b);\n                function __() {\n                  this.constructor = d;\n                }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n              };\n            }();\n            var DecodeError = (\n              /** @class */\n              function(_super) {\n                __extends(DecodeError2, _super);\n                function DecodeError2(message) {\n                  var _this = _super.call(this, message) || this;\n                  var proto = Object.create(DecodeError2.prototype);\n                  Object.setPrototypeOf(_this, proto);\n                  Object.defineProperty(_this, \"name\", {\n                    configurable: true,\n                    enumerable: false,\n                    value: DecodeError2.name\n                  });\n                  return _this;\n                }\n                return DecodeError2;\n              }(Error)\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n          /*!****************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n            \\****************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              DataViewIndexOutOfBoundsError: () => (\n                /* binding */\n                DataViewIndexOutOfBoundsError\n              ),\n              /* harmony export */\n              Decoder: () => (\n                /* binding */\n                Decoder\n              )\n              /* harmony export */\n            });\n            var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n              /*! ./utils/prettyByte.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n            );\n            var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./ExtensionCodec.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n            );\n            var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! ./utils/int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n              /*! ./utils/utf8.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n            );\n            var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! ./utils/typedArrays.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n            );\n            var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./CachedKeyDecoder.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n            );\n            var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n              /*! ./DecodeError.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n            );\n            var __awaiter = function(thisArg, _arguments, P, generator) {\n              function adopt(value) {\n                return value instanceof P ? value : new P(function(resolve2) {\n                  resolve2(value);\n                });\n              }\n              return new (P || (P = Promise))(function(resolve2, reject2) {\n                function fulfilled(value) {\n                  try {\n                    step(generator.next(value));\n                  } catch (e) {\n                    reject2(e);\n                  }\n                }\n                function rejected(value) {\n                  try {\n                    step(generator[\"throw\"](value));\n                  } catch (e) {\n                    reject2(e);\n                  }\n                }\n                function step(result) {\n                  result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n                }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n              });\n            };\n            var __generator = function(thisArg, body) {\n              var _ = { label: 0, sent: function() {\n                if (t[0] & 1)\n                  throw t[1];\n                return t[1];\n              }, trys: [], ops: [] }, f, y, t, g;\n              return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n                return this;\n              }), g;\n              function verb(n) {\n                return function(v) {\n                  return step([n, v]);\n                };\n              }\n              function step(op) {\n                if (f)\n                  throw new TypeError(\"Generator is already executing.\");\n                while (_)\n                  try {\n                    if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                      return t;\n                    if (y = 0, t)\n                      op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                      case 0:\n                      case 1:\n                        t = op;\n                        break;\n                      case 4:\n                        _.label++;\n                        return { value: op[1], done: false };\n                      case 5:\n                        _.label++;\n                        y = op[1];\n                        op = [0];\n                        continue;\n                      case 7:\n                        op = _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                      default:\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                          _ = 0;\n                          continue;\n                        }\n                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                          _.label = op[1];\n                          break;\n                        }\n                        if (op[0] === 6 && _.label < t[1]) {\n                          _.label = t[1];\n                          t = op;\n                          break;\n                        }\n                        if (t && _.label < t[2]) {\n                          _.label = t[2];\n                          _.ops.push(op);\n                          break;\n                        }\n                        if (t[2])\n                          _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                    }\n                    op = body.call(thisArg, _);\n                  } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                  } finally {\n                    f = t = 0;\n                  }\n                if (op[0] & 5)\n                  throw op[1];\n                return { value: op[0] ? op[1] : void 0, done: true };\n              }\n            };\n            var __asyncValues = function(o) {\n              if (!Symbol.asyncIterator)\n                throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n              var m = o[Symbol.asyncIterator], i;\n              return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n                return this;\n              }, i);\n              function verb(n) {\n                i[n] = o[n] && function(v) {\n                  return new Promise(function(resolve2, reject2) {\n                    v = o[n](v), settle(resolve2, reject2, v.done, v.value);\n                  });\n                };\n              }\n              function settle(resolve2, reject2, d, v) {\n                Promise.resolve(v).then(function(v2) {\n                  resolve2({ value: v2, done: d });\n                }, reject2);\n              }\n            };\n            var __await = function(v) {\n              return this instanceof __await ? (this.v = v, this) : new __await(v);\n            };\n            var __asyncGenerator = function(thisArg, _arguments, generator) {\n              if (!Symbol.asyncIterator)\n                throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n              var g = generator.apply(thisArg, _arguments || []), i, q = [];\n              return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n                return this;\n              }, i;\n              function verb(n) {\n                if (g[n])\n                  i[n] = function(v) {\n                    return new Promise(function(a, b) {\n                      q.push([n, v, a, b]) > 1 || resume(n, v);\n                    });\n                  };\n              }\n              function resume(n, v) {\n                try {\n                  step(g[n](v));\n                } catch (e) {\n                  settle(q[0][3], e);\n                }\n              }\n              function step(r) {\n                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);\n              }\n              function fulfill(value) {\n                resume(\"next\", value);\n              }\n              function reject2(value) {\n                resume(\"throw\", value);\n              }\n              function settle(f, v) {\n                if (f(v), q.shift(), q.length)\n                  resume(q[0][0], q[0][1]);\n              }\n            };\n            var isValidMapKeyType = function(key) {\n              var keyType = typeof key;\n              return keyType === \"string\" || keyType === \"number\";\n            };\n            var HEAD_BYTE_REQUIRED = -1;\n            var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n            var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n            var DataViewIndexOutOfBoundsError = function() {\n              try {\n                EMPTY_VIEW.getInt8(0);\n              } catch (e) {\n                return e.constructor;\n              }\n              throw new Error(\"never reached\");\n            }();\n            var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n            var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\n            var Decoder = (\n              /** @class */\n              function() {\n                function Decoder2(extensionCodec, context2, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                  if (extensionCodec === void 0) {\n                    extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n                  }\n                  if (context2 === void 0) {\n                    context2 = void 0;\n                  }\n                  if (maxStrLength === void 0) {\n                    maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxBinLength === void 0) {\n                    maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxArrayLength === void 0) {\n                    maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxMapLength === void 0) {\n                    maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxExtLength === void 0) {\n                    maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (keyDecoder === void 0) {\n                    keyDecoder = sharedCachedKeyDecoder;\n                  }\n                  this.extensionCodec = extensionCodec;\n                  this.context = context2;\n                  this.maxStrLength = maxStrLength;\n                  this.maxBinLength = maxBinLength;\n                  this.maxArrayLength = maxArrayLength;\n                  this.maxMapLength = maxMapLength;\n                  this.maxExtLength = maxExtLength;\n                  this.keyDecoder = keyDecoder;\n                  this.totalPos = 0;\n                  this.pos = 0;\n                  this.view = EMPTY_VIEW;\n                  this.bytes = EMPTY_BYTES;\n                  this.headByte = HEAD_BYTE_REQUIRED;\n                  this.stack = [];\n                }\n                Decoder2.prototype.reinitializeState = function() {\n                  this.totalPos = 0;\n                  this.headByte = HEAD_BYTE_REQUIRED;\n                  this.stack.length = 0;\n                };\n                Decoder2.prototype.setBuffer = function(buffer) {\n                  this.bytes = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n                  this.view = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n                  this.pos = 0;\n                };\n                Decoder2.prototype.appendBuffer = function(buffer) {\n                  if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                    this.setBuffer(buffer);\n                  } else {\n                    var remainingData = this.bytes.subarray(this.pos);\n                    var newData = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n                    var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                    newBuffer.set(remainingData);\n                    newBuffer.set(newData, remainingData.length);\n                    this.setBuffer(newBuffer);\n                  }\n                };\n                Decoder2.prototype.hasRemaining = function(size) {\n                  return this.view.byteLength - this.pos >= size;\n                };\n                Decoder2.prototype.createExtraByteError = function(posToShow) {\n                  var _a = this, view = _a.view, pos = _a.pos;\n                  return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n                };\n                Decoder2.prototype.decode = function(buffer) {\n                  this.reinitializeState();\n                  this.setBuffer(buffer);\n                  var object = this.doDecodeSync();\n                  if (this.hasRemaining(1)) {\n                    throw this.createExtraByteError(this.pos);\n                  }\n                  return object;\n                };\n                Decoder2.prototype.decodeMulti = function(buffer) {\n                  return __generator(this, function(_a) {\n                    switch (_a.label) {\n                      case 0:\n                        this.reinitializeState();\n                        this.setBuffer(buffer);\n                        _a.label = 1;\n                      case 1:\n                        if (!this.hasRemaining(1))\n                          return [3, 3];\n                        return [4, this.doDecodeSync()];\n                      case 2:\n                        _a.sent();\n                        return [3, 1];\n                      case 3:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                };\n                Decoder2.prototype.decodeAsync = function(stream) {\n                  var stream_1, stream_1_1;\n                  var e_1, _a;\n                  return __awaiter(this, void 0, void 0, function() {\n                    var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                    return __generator(this, function(_c) {\n                      switch (_c.label) {\n                        case 0:\n                          decoded = false;\n                          _c.label = 1;\n                        case 1:\n                          _c.trys.push([1, 6, 7, 12]);\n                          stream_1 = __asyncValues(stream);\n                          _c.label = 2;\n                        case 2:\n                          return [4, stream_1.next()];\n                        case 3:\n                          if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                            return [3, 5];\n                          buffer = stream_1_1.value;\n                          if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          this.appendBuffer(buffer);\n                          try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                          } catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                              throw e;\n                            }\n                          }\n                          this.totalPos += this.pos;\n                          _c.label = 4;\n                        case 4:\n                          return [3, 2];\n                        case 5:\n                          return [3, 12];\n                        case 6:\n                          e_1_1 = _c.sent();\n                          e_1 = { error: e_1_1 };\n                          return [3, 12];\n                        case 7:\n                          _c.trys.push([7, , 10, 11]);\n                          if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                            return [3, 9];\n                          return [4, _a.call(stream_1)];\n                        case 8:\n                          _c.sent();\n                          _c.label = 9;\n                        case 9:\n                          return [3, 11];\n                        case 10:\n                          if (e_1)\n                            throw e_1.error;\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 11:\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 12:\n                          if (decoded) {\n                            if (this.hasRemaining(1)) {\n                              throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2, object];\n                          }\n                          _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                          throw new RangeError(\"Insufficient data in parsing \".concat((0, _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                      }\n                    });\n                  });\n                };\n                Decoder2.prototype.decodeArrayStream = function(stream) {\n                  return this.decodeMultiAsync(stream, true);\n                };\n                Decoder2.prototype.decodeStream = function(stream) {\n                  return this.decodeMultiAsync(stream, false);\n                };\n                Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                  return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                    var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                    var e_3, _a;\n                    return __generator(this, function(_b) {\n                      switch (_b.label) {\n                        case 0:\n                          isArrayHeaderRequired = isArray;\n                          arrayItemsLeft = -1;\n                          _b.label = 1;\n                        case 1:\n                          _b.trys.push([1, 13, 14, 19]);\n                          stream_2 = __asyncValues(stream);\n                          _b.label = 2;\n                        case 2:\n                          return [4, __await(stream_2.next())];\n                        case 3:\n                          if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                            return [3, 12];\n                          buffer = stream_2_1.value;\n                          if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          this.appendBuffer(buffer);\n                          if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                          }\n                          _b.label = 4;\n                        case 4:\n                          _b.trys.push([4, 9, , 10]);\n                          _b.label = 5;\n                        case 5:\n                          if (false) // removed by dead control flow\n{}\n                          return [4, __await(this.doDecodeSync())];\n                        case 6:\n                          return [4, _b.sent()];\n                        case 7:\n                          _b.sent();\n                          if (--arrayItemsLeft === 0) {\n                            return [3, 8];\n                          }\n                          return [3, 5];\n                        case 8:\n                          return [3, 10];\n                        case 9:\n                          e_2 = _b.sent();\n                          if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2;\n                          }\n                          return [3, 10];\n                        case 10:\n                          this.totalPos += this.pos;\n                          _b.label = 11;\n                        case 11:\n                          return [3, 2];\n                        case 12:\n                          return [3, 19];\n                        case 13:\n                          e_3_1 = _b.sent();\n                          e_3 = { error: e_3_1 };\n                          return [3, 19];\n                        case 14:\n                          _b.trys.push([14, , 17, 18]);\n                          if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                            return [3, 16];\n                          return [4, __await(_a.call(stream_2))];\n                        case 15:\n                          _b.sent();\n                          _b.label = 16;\n                        case 16:\n                          return [3, 18];\n                        case 17:\n                          if (e_3)\n                            throw e_3.error;\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 18:\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 19:\n                          return [\n                            2\n                            /*return*/\n                          ];\n                      }\n                    });\n                  });\n                };\n                Decoder2.prototype.doDecodeSync = function() {\n                  DECODE:\n                    while (true) {\n                      var headByte = this.readHeadByte();\n                      var object = void 0;\n                      if (headByte >= 224) {\n                        object = headByte - 256;\n                      } else if (headByte < 192) {\n                        if (headByte < 128) {\n                          object = headByte;\n                        } else if (headByte < 144) {\n                          var size = headByte - 128;\n                          if (size !== 0) {\n                            this.pushMapState(size);\n                            this.complete();\n                            continue DECODE;\n                          } else {\n                            object = {};\n                          }\n                        } else if (headByte < 160) {\n                          var size = headByte - 144;\n                          if (size !== 0) {\n                            this.pushArrayState(size);\n                            this.complete();\n                            continue DECODE;\n                          } else {\n                            object = [];\n                          }\n                        } else {\n                          var byteLength = headByte - 160;\n                          object = this.decodeUtf8String(byteLength, 0);\n                        }\n                      } else if (headByte === 192) {\n                        object = null;\n                      } else if (headByte === 194) {\n                        object = false;\n                      } else if (headByte === 195) {\n                        object = true;\n                      } else if (headByte === 202) {\n                        object = this.readF32();\n                      } else if (headByte === 203) {\n                        object = this.readF64();\n                      } else if (headByte === 204) {\n                        object = this.readU8();\n                      } else if (headByte === 205) {\n                        object = this.readU16();\n                      } else if (headByte === 206) {\n                        object = this.readU32();\n                      } else if (headByte === 207) {\n                        object = this.readU64();\n                      } else if (headByte === 208) {\n                        object = this.readI8();\n                      } else if (headByte === 209) {\n                        object = this.readI16();\n                      } else if (headByte === 210) {\n                        object = this.readI32();\n                      } else if (headByte === 211) {\n                        object = this.readI64();\n                      } else if (headByte === 217) {\n                        var byteLength = this.lookU8();\n                        object = this.decodeUtf8String(byteLength, 1);\n                      } else if (headByte === 218) {\n                        var byteLength = this.lookU16();\n                        object = this.decodeUtf8String(byteLength, 2);\n                      } else if (headByte === 219) {\n                        var byteLength = this.lookU32();\n                        object = this.decodeUtf8String(byteLength, 4);\n                      } else if (headByte === 220) {\n                        var size = this.readU16();\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else if (headByte === 221) {\n                        var size = this.readU32();\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else if (headByte === 222) {\n                        var size = this.readU16();\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte === 223) {\n                        var size = this.readU32();\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte === 196) {\n                        var size = this.lookU8();\n                        object = this.decodeBinary(size, 1);\n                      } else if (headByte === 197) {\n                        var size = this.lookU16();\n                        object = this.decodeBinary(size, 2);\n                      } else if (headByte === 198) {\n                        var size = this.lookU32();\n                        object = this.decodeBinary(size, 4);\n                      } else if (headByte === 212) {\n                        object = this.decodeExtension(1, 0);\n                      } else if (headByte === 213) {\n                        object = this.decodeExtension(2, 0);\n                      } else if (headByte === 214) {\n                        object = this.decodeExtension(4, 0);\n                      } else if (headByte === 215) {\n                        object = this.decodeExtension(8, 0);\n                      } else if (headByte === 216) {\n                        object = this.decodeExtension(16, 0);\n                      } else if (headByte === 199) {\n                        var size = this.lookU8();\n                        object = this.decodeExtension(size, 1);\n                      } else if (headByte === 200) {\n                        var size = this.lookU16();\n                        object = this.decodeExtension(size, 2);\n                      } else if (headByte === 201) {\n                        var size = this.lookU32();\n                        object = this.decodeExtension(size, 4);\n                      } else {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0, _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                      }\n                      this.complete();\n                      var stack = this.stack;\n                      while (stack.length > 0) {\n                        var state = stack[stack.length - 1];\n                        if (state.type === 0) {\n                          state.array[state.position] = object;\n                          state.position++;\n                          if (state.position === state.size) {\n                            stack.pop();\n                            object = state.array;\n                          } else {\n                            continue DECODE;\n                          }\n                        } else if (state.type === 1) {\n                          if (!isValidMapKeyType(object)) {\n                            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                          }\n                          if (object === \"__proto__\") {\n                            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                          }\n                          state.key = object;\n                          state.type = 2;\n                          continue DECODE;\n                        } else {\n                          state.map[state.key] = object;\n                          state.readCount++;\n                          if (state.readCount === state.size) {\n                            stack.pop();\n                            object = state.map;\n                          } else {\n                            state.key = null;\n                            state.type = 1;\n                            continue DECODE;\n                          }\n                        }\n                      }\n                      return object;\n                    }\n                };\n                Decoder2.prototype.readHeadByte = function() {\n                  if (this.headByte === HEAD_BYTE_REQUIRED) {\n                    this.headByte = this.readU8();\n                  }\n                  return this.headByte;\n                };\n                Decoder2.prototype.complete = function() {\n                  this.headByte = HEAD_BYTE_REQUIRED;\n                };\n                Decoder2.prototype.readArraySize = function() {\n                  var headByte = this.readHeadByte();\n                  switch (headByte) {\n                    case 220:\n                      return this.readU16();\n                    case 221:\n                      return this.readU32();\n                    default: {\n                      if (headByte < 160) {\n                        return headByte - 144;\n                      } else {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0, _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                      }\n                    }\n                  }\n                };\n                Decoder2.prototype.pushMapState = function(size) {\n                  if (size > this.maxMapLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n                  }\n                  this.stack.push({\n                    type: 1,\n                    size,\n                    key: null,\n                    readCount: 0,\n                    map: {}\n                  });\n                };\n                Decoder2.prototype.pushArrayState = function(size) {\n                  if (size > this.maxArrayLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n                  }\n                  this.stack.push({\n                    type: 0,\n                    size,\n                    array: new Array(size),\n                    position: 0\n                  });\n                };\n                Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                  var _a;\n                  if (byteLength > this.maxStrLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n                  }\n                  if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                    throw MORE_DATA;\n                  }\n                  var offset = this.pos + headerOffset;\n                  var object;\n                  if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                    object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                  } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.TEXT_DECODER_THRESHOLD) {\n                    object = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeTD)(this.bytes, offset, byteLength);\n                  } else {\n                    object = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeJs)(this.bytes, offset, byteLength);\n                  }\n                  this.pos += headerOffset + byteLength;\n                  return object;\n                };\n                Decoder2.prototype.stateIsMapKey = function() {\n                  if (this.stack.length > 0) {\n                    var state = this.stack[this.stack.length - 1];\n                    return state.type === 1;\n                  }\n                  return false;\n                };\n                Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                  if (byteLength > this.maxBinLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n                  }\n                  if (!this.hasRemaining(byteLength + headOffset)) {\n                    throw MORE_DATA;\n                  }\n                  var offset = this.pos + headOffset;\n                  var object = this.bytes.subarray(offset, offset + byteLength);\n                  this.pos += headOffset + byteLength;\n                  return object;\n                };\n                Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                  if (size > this.maxExtLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n                  }\n                  var extType = this.view.getInt8(this.pos + headOffset);\n                  var data = this.decodeBinary(\n                    size,\n                    headOffset + 1\n                    /* extType */\n                  );\n                  return this.extensionCodec.decode(data, extType, this.context);\n                };\n                Decoder2.prototype.lookU8 = function() {\n                  return this.view.getUint8(this.pos);\n                };\n                Decoder2.prototype.lookU16 = function() {\n                  return this.view.getUint16(this.pos);\n                };\n                Decoder2.prototype.lookU32 = function() {\n                  return this.view.getUint32(this.pos);\n                };\n                Decoder2.prototype.readU8 = function() {\n                  var value = this.view.getUint8(this.pos);\n                  this.pos++;\n                  return value;\n                };\n                Decoder2.prototype.readI8 = function() {\n                  var value = this.view.getInt8(this.pos);\n                  this.pos++;\n                  return value;\n                };\n                Decoder2.prototype.readU16 = function() {\n                  var value = this.view.getUint16(this.pos);\n                  this.pos += 2;\n                  return value;\n                };\n                Decoder2.prototype.readI16 = function() {\n                  var value = this.view.getInt16(this.pos);\n                  this.pos += 2;\n                  return value;\n                };\n                Decoder2.prototype.readU32 = function() {\n                  var value = this.view.getUint32(this.pos);\n                  this.pos += 4;\n                  return value;\n                };\n                Decoder2.prototype.readI32 = function() {\n                  var value = this.view.getInt32(this.pos);\n                  this.pos += 4;\n                  return value;\n                };\n                Decoder2.prototype.readU64 = function() {\n                  var value = (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n                  this.pos += 8;\n                  return value;\n                };\n                Decoder2.prototype.readI64 = function() {\n                  var value = (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n                  this.pos += 8;\n                  return value;\n                };\n                Decoder2.prototype.readF32 = function() {\n                  var value = this.view.getFloat32(this.pos);\n                  this.pos += 4;\n                  return value;\n                };\n                Decoder2.prototype.readF64 = function() {\n                  var value = this.view.getFloat64(this.pos);\n                  this.pos += 8;\n                  return value;\n                };\n                return Decoder2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n          /*!****************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n            \\****************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              DEFAULT_INITIAL_BUFFER_SIZE: () => (\n                /* binding */\n                DEFAULT_INITIAL_BUFFER_SIZE\n              ),\n              /* harmony export */\n              DEFAULT_MAX_DEPTH: () => (\n                /* binding */\n                DEFAULT_MAX_DEPTH\n              ),\n              /* harmony export */\n              Encoder: () => (\n                /* binding */\n                Encoder\n              )\n              /* harmony export */\n            });\n            var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./utils/utf8.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n            );\n            var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./ExtensionCodec.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n            );\n            var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! ./utils/int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! ./utils/typedArrays.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n            );\n            var DEFAULT_MAX_DEPTH = 100;\n            var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n            var Encoder = (\n              /** @class */\n              function() {\n                function Encoder2(extensionCodec, context2, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                  if (extensionCodec === void 0) {\n                    extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;\n                  }\n                  if (context2 === void 0) {\n                    context2 = void 0;\n                  }\n                  if (maxDepth === void 0) {\n                    maxDepth = DEFAULT_MAX_DEPTH;\n                  }\n                  if (initialBufferSize === void 0) {\n                    initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                  }\n                  if (sortKeys === void 0) {\n                    sortKeys = false;\n                  }\n                  if (forceFloat32 === void 0) {\n                    forceFloat32 = false;\n                  }\n                  if (ignoreUndefined === void 0) {\n                    ignoreUndefined = false;\n                  }\n                  if (forceIntegerToFloat === void 0) {\n                    forceIntegerToFloat = false;\n                  }\n                  this.extensionCodec = extensionCodec;\n                  this.context = context2;\n                  this.maxDepth = maxDepth;\n                  this.initialBufferSize = initialBufferSize;\n                  this.sortKeys = sortKeys;\n                  this.forceFloat32 = forceFloat32;\n                  this.ignoreUndefined = ignoreUndefined;\n                  this.forceIntegerToFloat = forceIntegerToFloat;\n                  this.pos = 0;\n                  this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                  this.bytes = new Uint8Array(this.view.buffer);\n                }\n                Encoder2.prototype.reinitializeState = function() {\n                  this.pos = 0;\n                };\n                Encoder2.prototype.encodeSharedRef = function(object) {\n                  this.reinitializeState();\n                  this.doEncode(object, 1);\n                  return this.bytes.subarray(0, this.pos);\n                };\n                Encoder2.prototype.encode = function(object) {\n                  this.reinitializeState();\n                  this.doEncode(object, 1);\n                  return this.bytes.slice(0, this.pos);\n                };\n                Encoder2.prototype.doEncode = function(object, depth) {\n                  if (depth > this.maxDepth) {\n                    throw new Error(\"Too deep objects in depth \".concat(depth));\n                  }\n                  if (object == null) {\n                    this.encodeNil();\n                  } else if (typeof object === \"boolean\") {\n                    this.encodeBoolean(object);\n                  } else if (typeof object === \"number\") {\n                    this.encodeNumber(object);\n                  } else if (typeof object === \"string\") {\n                    this.encodeString(object);\n                  } else {\n                    this.encodeObject(object, depth);\n                  }\n                };\n                Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                  var requiredSize = this.pos + sizeToWrite;\n                  if (this.view.byteLength < requiredSize) {\n                    this.resizeBuffer(requiredSize * 2);\n                  }\n                };\n                Encoder2.prototype.resizeBuffer = function(newSize) {\n                  var newBuffer = new ArrayBuffer(newSize);\n                  var newBytes = new Uint8Array(newBuffer);\n                  var newView = new DataView(newBuffer);\n                  newBytes.set(this.bytes);\n                  this.view = newView;\n                  this.bytes = newBytes;\n                };\n                Encoder2.prototype.encodeNil = function() {\n                  this.writeU8(192);\n                };\n                Encoder2.prototype.encodeBoolean = function(object) {\n                  if (object === false) {\n                    this.writeU8(194);\n                  } else {\n                    this.writeU8(195);\n                  }\n                };\n                Encoder2.prototype.encodeNumber = function(object) {\n                  if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                    if (object >= 0) {\n                      if (object < 128) {\n                        this.writeU8(object);\n                      } else if (object < 256) {\n                        this.writeU8(204);\n                        this.writeU8(object);\n                      } else if (object < 65536) {\n                        this.writeU8(205);\n                        this.writeU16(object);\n                      } else if (object < 4294967296) {\n                        this.writeU8(206);\n                        this.writeU32(object);\n                      } else {\n                        this.writeU8(207);\n                        this.writeU64(object);\n                      }\n                    } else {\n                      if (object >= -32) {\n                        this.writeU8(224 | object + 32);\n                      } else if (object >= -128) {\n                        this.writeU8(208);\n                        this.writeI8(object);\n                      } else if (object >= -32768) {\n                        this.writeU8(209);\n                        this.writeI16(object);\n                      } else if (object >= -2147483648) {\n                        this.writeU8(210);\n                        this.writeI32(object);\n                      } else {\n                        this.writeU8(211);\n                        this.writeI64(object);\n                      }\n                    }\n                  } else {\n                    if (this.forceFloat32) {\n                      this.writeU8(202);\n                      this.writeF32(object);\n                    } else {\n                      this.writeU8(203);\n                      this.writeF64(object);\n                    }\n                  }\n                };\n                Encoder2.prototype.writeStringHeader = function(byteLength) {\n                  if (byteLength < 32) {\n                    this.writeU8(160 + byteLength);\n                  } else if (byteLength < 256) {\n                    this.writeU8(217);\n                    this.writeU8(byteLength);\n                  } else if (byteLength < 65536) {\n                    this.writeU8(218);\n                    this.writeU16(byteLength);\n                  } else if (byteLength < 4294967296) {\n                    this.writeU8(219);\n                    this.writeU32(byteLength);\n                  } else {\n                    throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n                  }\n                };\n                Encoder2.prototype.encodeString = function(object) {\n                  var maxHeaderSize = 1 + 4;\n                  var strLength = object.length;\n                  if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER_THRESHOLD) {\n                    var byteLength = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n                    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                    this.writeStringHeader(byteLength);\n                    (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeTE)(object, this.bytes, this.pos);\n                    this.pos += byteLength;\n                  } else {\n                    var byteLength = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n                    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                    this.writeStringHeader(byteLength);\n                    (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeJs)(object, this.bytes, this.pos);\n                    this.pos += byteLength;\n                  }\n                };\n                Encoder2.prototype.encodeObject = function(object, depth) {\n                  var ext = this.extensionCodec.tryToEncode(object, this.context);\n                  if (ext != null) {\n                    this.encodeExtension(ext);\n                  } else if (Array.isArray(object)) {\n                    this.encodeArray(object, depth);\n                  } else if (ArrayBuffer.isView(object)) {\n                    this.encodeBinary(object);\n                  } else if (typeof object === \"object\") {\n                    this.encodeMap(object, depth);\n                  } else {\n                    throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n                  }\n                };\n                Encoder2.prototype.encodeBinary = function(object) {\n                  var size = object.byteLength;\n                  if (size < 256) {\n                    this.writeU8(196);\n                    this.writeU8(size);\n                  } else if (size < 65536) {\n                    this.writeU8(197);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(198);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large binary: \".concat(size));\n                  }\n                  var bytes = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n                  this.writeU8a(bytes);\n                };\n                Encoder2.prototype.encodeArray = function(object, depth) {\n                  var size = object.length;\n                  if (size < 16) {\n                    this.writeU8(144 + size);\n                  } else if (size < 65536) {\n                    this.writeU8(220);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(221);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large array: \".concat(size));\n                  }\n                  for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                    var item = object_1[_i];\n                    this.doEncode(item, depth + 1);\n                  }\n                };\n                Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                  var count = 0;\n                  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                    var key = keys_1[_i];\n                    if (object[key] !== void 0) {\n                      count++;\n                    }\n                  }\n                  return count;\n                };\n                Encoder2.prototype.encodeMap = function(object, depth) {\n                  var keys = Object.keys(object);\n                  if (this.sortKeys) {\n                    keys.sort();\n                  }\n                  var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                  if (size < 16) {\n                    this.writeU8(128 + size);\n                  } else if (size < 65536) {\n                    this.writeU8(222);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(223);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large map object: \".concat(size));\n                  }\n                  for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                    var key = keys_2[_i];\n                    var value = object[key];\n                    if (!(this.ignoreUndefined && value === void 0)) {\n                      this.encodeString(key);\n                      this.doEncode(value, depth + 1);\n                    }\n                  }\n                };\n                Encoder2.prototype.encodeExtension = function(ext) {\n                  var size = ext.data.length;\n                  if (size === 1) {\n                    this.writeU8(212);\n                  } else if (size === 2) {\n                    this.writeU8(213);\n                  } else if (size === 4) {\n                    this.writeU8(214);\n                  } else if (size === 8) {\n                    this.writeU8(215);\n                  } else if (size === 16) {\n                    this.writeU8(216);\n                  } else if (size < 256) {\n                    this.writeU8(199);\n                    this.writeU8(size);\n                  } else if (size < 65536) {\n                    this.writeU8(200);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(201);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large extension object: \".concat(size));\n                  }\n                  this.writeI8(ext.type);\n                  this.writeU8a(ext.data);\n                };\n                Encoder2.prototype.writeU8 = function(value) {\n                  this.ensureBufferSizeToWrite(1);\n                  this.view.setUint8(this.pos, value);\n                  this.pos++;\n                };\n                Encoder2.prototype.writeU8a = function(values) {\n                  var size = values.length;\n                  this.ensureBufferSizeToWrite(size);\n                  this.bytes.set(values, this.pos);\n                  this.pos += size;\n                };\n                Encoder2.prototype.writeI8 = function(value) {\n                  this.ensureBufferSizeToWrite(1);\n                  this.view.setInt8(this.pos, value);\n                  this.pos++;\n                };\n                Encoder2.prototype.writeU16 = function(value) {\n                  this.ensureBufferSizeToWrite(2);\n                  this.view.setUint16(this.pos, value);\n                  this.pos += 2;\n                };\n                Encoder2.prototype.writeI16 = function(value) {\n                  this.ensureBufferSizeToWrite(2);\n                  this.view.setInt16(this.pos, value);\n                  this.pos += 2;\n                };\n                Encoder2.prototype.writeU32 = function(value) {\n                  this.ensureBufferSizeToWrite(4);\n                  this.view.setUint32(this.pos, value);\n                  this.pos += 4;\n                };\n                Encoder2.prototype.writeI32 = function(value) {\n                  this.ensureBufferSizeToWrite(4);\n                  this.view.setInt32(this.pos, value);\n                  this.pos += 4;\n                };\n                Encoder2.prototype.writeF32 = function(value) {\n                  this.ensureBufferSizeToWrite(4);\n                  this.view.setFloat32(this.pos, value);\n                  this.pos += 4;\n                };\n                Encoder2.prototype.writeF64 = function(value) {\n                  this.ensureBufferSizeToWrite(8);\n                  this.view.setFloat64(this.pos, value);\n                  this.pos += 8;\n                };\n                Encoder2.prototype.writeU64 = function(value) {\n                  this.ensureBufferSizeToWrite(8);\n                  (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n                  this.pos += 8;\n                };\n                Encoder2.prototype.writeI64 = function(value) {\n                  this.ensureBufferSizeToWrite(8);\n                  (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n                  this.pos += 8;\n                };\n                return Encoder2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n          /*!****************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n            \\****************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              ExtData: () => (\n                /* binding */\n                ExtData\n              )\n              /* harmony export */\n            });\n            var ExtData = (\n              /** @class */\n              /* @__PURE__ */ function() {\n                function ExtData2(type2, data) {\n                  this.type = type2;\n                  this.data = data;\n                }\n                return ExtData2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n          /*!***********************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n            \\***********************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              ExtensionCodec: () => (\n                /* binding */\n                ExtensionCodec\n              )\n              /* harmony export */\n            });\n            var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./ExtData.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n            );\n            var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./timestamp.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n            );\n            var ExtensionCodec = (\n              /** @class */\n              function() {\n                function ExtensionCodec2() {\n                  this.builtInEncoders = [];\n                  this.builtInDecoders = [];\n                  this.encoders = [];\n                  this.decoders = [];\n                  this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n                }\n                ExtensionCodec2.prototype.register = function(_a) {\n                  var type2 = _a.type, encode = _a.encode, decode = _a.decode;\n                  if (type2 >= 0) {\n                    this.encoders[type2] = encode;\n                    this.decoders[type2] = decode;\n                  } else {\n                    var index = 1 + type2;\n                    this.builtInEncoders[index] = encode;\n                    this.builtInDecoders[index] = decode;\n                  }\n                };\n                ExtensionCodec2.prototype.tryToEncode = function(object, context2) {\n                  for (var i = 0; i < this.builtInEncoders.length; i++) {\n                    var encodeExt = this.builtInEncoders[i];\n                    if (encodeExt != null) {\n                      var data = encodeExt(object, context2);\n                      if (data != null) {\n                        var type2 = -1 - i;\n                        return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type2, data);\n                      }\n                    }\n                  }\n                  for (var i = 0; i < this.encoders.length; i++) {\n                    var encodeExt = this.encoders[i];\n                    if (encodeExt != null) {\n                      var data = encodeExt(object, context2);\n                      if (data != null) {\n                        var type2 = i;\n                        return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type2, data);\n                      }\n                    }\n                  }\n                  if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n                    return object;\n                  }\n                  return null;\n                };\n                ExtensionCodec2.prototype.decode = function(data, type2, context2) {\n                  var decodeExt = type2 < 0 ? this.builtInDecoders[-1 - type2] : this.decoders[type2];\n                  if (decodeExt) {\n                    return decodeExt(data, type2, context2);\n                  } else {\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type2, data);\n                  }\n                };\n                ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n                return ExtensionCodec2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n          /*!***************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n            \\***************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              decode: () => (\n                /* binding */\n                decode\n              ),\n              /* harmony export */\n              decodeMulti: () => (\n                /* binding */\n                decodeMulti\n              ),\n              /* harmony export */\n              defaultDecodeOptions: () => (\n                /* binding */\n                defaultDecodeOptions\n              )\n              /* harmony export */\n            });\n            var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./Decoder.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n            );\n            var defaultDecodeOptions = {};\n            function decode(buffer, options) {\n              if (options === void 0) {\n                options = defaultDecodeOptions;\n              }\n              var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n              return decoder.decode(buffer);\n            }\n            function decodeMulti(buffer, options) {\n              if (options === void 0) {\n                options = defaultDecodeOptions;\n              }\n              var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n              return decoder.decodeMulti(buffer);\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n          /*!***************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n            \\***************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              encode: () => (\n                /* binding */\n                encode\n              )\n              /* harmony export */\n            });\n            var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./Encoder.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n            );\n            var defaultEncodeOptions = {};\n            function encode(value, options) {\n              if (options === void 0) {\n                options = defaultEncodeOptions;\n              }\n              var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n              return encoder.encodeSharedRef(value);\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n          /*!******************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n            \\******************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              EXT_TIMESTAMP: () => (\n                /* binding */\n                EXT_TIMESTAMP\n              ),\n              /* harmony export */\n              decodeTimestampExtension: () => (\n                /* binding */\n                decodeTimestampExtension\n              ),\n              /* harmony export */\n              decodeTimestampToTimeSpec: () => (\n                /* binding */\n                decodeTimestampToTimeSpec\n              ),\n              /* harmony export */\n              encodeDateToTimeSpec: () => (\n                /* binding */\n                encodeDateToTimeSpec\n              ),\n              /* harmony export */\n              encodeTimeSpecToTimestamp: () => (\n                /* binding */\n                encodeTimeSpecToTimestamp\n              ),\n              /* harmony export */\n              encodeTimestampExtension: () => (\n                /* binding */\n                encodeTimestampExtension\n              ),\n              /* harmony export */\n              timestampExtension: () => (\n                /* binding */\n                timestampExtension\n              )\n              /* harmony export */\n            });\n            var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./DecodeError.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n            );\n            var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./utils/int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var EXT_TIMESTAMP = -1;\n            var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n            var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n            function encodeTimeSpecToTimestamp(_a) {\n              var sec = _a.sec, nsec = _a.nsec;\n              if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n                if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                  var rv = new Uint8Array(4);\n                  var view = new DataView(rv.buffer);\n                  view.setUint32(0, sec);\n                  return rv;\n                } else {\n                  var secHigh = sec / 4294967296;\n                  var secLow = sec & 4294967295;\n                  var rv = new Uint8Array(8);\n                  var view = new DataView(rv.buffer);\n                  view.setUint32(0, nsec << 2 | secHigh & 3);\n                  view.setUint32(4, secLow);\n                  return rv;\n                }\n              } else {\n                var rv = new Uint8Array(12);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec);\n                (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n                return rv;\n              }\n            }\n            function encodeDateToTimeSpec(date) {\n              var msec = date.getTime();\n              var sec = Math.floor(msec / 1e3);\n              var nsec = (msec - sec * 1e3) * 1e6;\n              var nsecInSec = Math.floor(nsec / 1e9);\n              return {\n                sec: sec + nsecInSec,\n                nsec: nsec - nsecInSec * 1e9\n              };\n            }\n            function encodeTimestampExtension(object) {\n              if (object instanceof Date) {\n                var timeSpec = encodeDateToTimeSpec(object);\n                return encodeTimeSpecToTimestamp(timeSpec);\n              } else {\n                return null;\n              }\n            }\n            function decodeTimestampToTimeSpec(data) {\n              var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n              switch (data.byteLength) {\n                case 4: {\n                  var sec = view.getUint32(0);\n                  var nsec = 0;\n                  return { sec, nsec };\n                }\n                case 8: {\n                  var nsec30AndSecHigh2 = view.getUint32(0);\n                  var secLow32 = view.getUint32(4);\n                  var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                  var nsec = nsec30AndSecHigh2 >>> 2;\n                  return { sec, nsec };\n                }\n                case 12: {\n                  var sec = (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n                  var nsec = view.getUint32(0);\n                  return { sec, nsec };\n                }\n                default:\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n              }\n            }\n            function decodeTimestampExtension(data) {\n              var timeSpec = decodeTimestampToTimeSpec(data);\n              return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n            }\n            var timestampExtension = {\n              type: EXT_TIMESTAMP,\n              encode: encodeTimestampExtension,\n              decode: decodeTimestampExtension\n            };\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n          /*!******************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n            \\******************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              UINT32_MAX: () => (\n                /* binding */\n                UINT32_MAX\n              ),\n              /* harmony export */\n              getInt64: () => (\n                /* binding */\n                getInt64\n              ),\n              /* harmony export */\n              getUint64: () => (\n                /* binding */\n                getUint64\n              ),\n              /* harmony export */\n              setInt64: () => (\n                /* binding */\n                setInt64\n              ),\n              /* harmony export */\n              setUint64: () => (\n                /* binding */\n                setUint64\n              )\n              /* harmony export */\n            });\n            var UINT32_MAX = 4294967295;\n            function setUint64(view, offset, value) {\n              var high = value / 4294967296;\n              var low = value;\n              view.setUint32(offset, high);\n              view.setUint32(offset + 4, low);\n            }\n            function setInt64(view, offset, value) {\n              var high = Math.floor(value / 4294967296);\n              var low = value;\n              view.setUint32(offset, high);\n              view.setUint32(offset + 4, low);\n            }\n            function getInt64(view, offset) {\n              var high = view.getInt32(offset);\n              var low = view.getUint32(offset + 4);\n              return high * 4294967296 + low;\n            }\n            function getUint64(view, offset) {\n              var high = view.getUint32(offset);\n              var low = view.getUint32(offset + 4);\n              return high * 4294967296 + low;\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n          /*!*************************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n            \\*************************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              prettyByte: () => (\n                /* binding */\n                prettyByte\n              )\n              /* harmony export */\n            });\n            function prettyByte(byte) {\n              return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n          /*!**************************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n            \\**************************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              createDataView: () => (\n                /* binding */\n                createDataView\n              ),\n              /* harmony export */\n              ensureUint8Array: () => (\n                /* binding */\n                ensureUint8Array\n              )\n              /* harmony export */\n            });\n            function ensureUint8Array(buffer) {\n              if (buffer instanceof Uint8Array) {\n                return buffer;\n              } else if (ArrayBuffer.isView(buffer)) {\n                return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n              } else if (buffer instanceof ArrayBuffer) {\n                return new Uint8Array(buffer);\n              } else {\n                return Uint8Array.from(buffer);\n              }\n            }\n            function createDataView(buffer) {\n              if (buffer instanceof ArrayBuffer) {\n                return new DataView(buffer);\n              }\n              var bufferView = ensureUint8Array(buffer);\n              return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n          /*!*******************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n            \\*******************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              TEXT_DECODER_THRESHOLD: () => (\n                /* binding */\n                TEXT_DECODER_THRESHOLD\n              ),\n              /* harmony export */\n              TEXT_ENCODER_THRESHOLD: () => (\n                /* binding */\n                TEXT_ENCODER_THRESHOLD\n              ),\n              /* harmony export */\n              utf8Count: () => (\n                /* binding */\n                utf8Count\n              ),\n              /* harmony export */\n              utf8DecodeJs: () => (\n                /* binding */\n                utf8DecodeJs\n              ),\n              /* harmony export */\n              utf8DecodeTD: () => (\n                /* binding */\n                utf8DecodeTD\n              ),\n              /* harmony export */\n              utf8EncodeJs: () => (\n                /* binding */\n                utf8EncodeJs\n              ),\n              /* harmony export */\n              utf8EncodeTE: () => (\n                /* binding */\n                utf8EncodeTE\n              )\n              /* harmony export */\n            });\n            var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var _a, _b, _c;\n            var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n            function utf8Count(str) {\n              var strLength = str.length;\n              var byteLength = 0;\n              var pos = 0;\n              while (pos < strLength) {\n                var value = str.charCodeAt(pos++);\n                if ((value & 4294967168) === 0) {\n                  byteLength++;\n                  continue;\n                } else if ((value & 4294965248) === 0) {\n                  byteLength += 2;\n                } else {\n                  if (value >= 55296 && value <= 56319) {\n                    if (pos < strLength) {\n                      var extra = str.charCodeAt(pos);\n                      if ((extra & 64512) === 56320) {\n                        ++pos;\n                        value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                      }\n                    }\n                  }\n                  if ((value & 4294901760) === 0) {\n                    byteLength += 3;\n                  } else {\n                    byteLength += 4;\n                  }\n                }\n              }\n              return byteLength;\n            }\n            function utf8EncodeJs(str, output, outputOffset) {\n              var strLength = str.length;\n              var offset = outputOffset;\n              var pos = 0;\n              while (pos < strLength) {\n                var value = str.charCodeAt(pos++);\n                if ((value & 4294967168) === 0) {\n                  output[offset++] = value;\n                  continue;\n                } else if ((value & 4294965248) === 0) {\n                  output[offset++] = value >> 6 & 31 | 192;\n                } else {\n                  if (value >= 55296 && value <= 56319) {\n                    if (pos < strLength) {\n                      var extra = str.charCodeAt(pos);\n                      if ((extra & 64512) === 56320) {\n                        ++pos;\n                        value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                      }\n                    }\n                  }\n                  if ((value & 4294901760) === 0) {\n                    output[offset++] = value >> 12 & 15 | 224;\n                    output[offset++] = value >> 6 & 63 | 128;\n                  } else {\n                    output[offset++] = value >> 18 & 7 | 240;\n                    output[offset++] = value >> 12 & 63 | 128;\n                    output[offset++] = value >> 6 & 63 | 128;\n                  }\n                }\n                output[offset++] = value & 63 | 128;\n              }\n            }\n            var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n            var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\" ? 200 : 0;\n            function utf8EncodeTEencode(str, output, outputOffset) {\n              output.set(sharedTextEncoder.encode(str), outputOffset);\n            }\n            function utf8EncodeTEencodeInto(str, output, outputOffset) {\n              sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n            }\n            var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n            var CHUNK_SIZE = 4096;\n            function utf8DecodeJs(bytes, inputOffset, byteLength) {\n              var offset = inputOffset;\n              var end = offset + byteLength;\n              var units = [];\n              var result = \"\";\n              while (offset < end) {\n                var byte1 = bytes[offset++];\n                if ((byte1 & 128) === 0) {\n                  units.push(byte1);\n                } else if ((byte1 & 224) === 192) {\n                  var byte2 = bytes[offset++] & 63;\n                  units.push((byte1 & 31) << 6 | byte2);\n                } else if ((byte1 & 240) === 224) {\n                  var byte2 = bytes[offset++] & 63;\n                  var byte3 = bytes[offset++] & 63;\n                  units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n                } else if ((byte1 & 248) === 240) {\n                  var byte2 = bytes[offset++] & 63;\n                  var byte3 = bytes[offset++] & 63;\n                  var byte4 = bytes[offset++] & 63;\n                  var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                  if (unit > 65535) {\n                    unit -= 65536;\n                    units.push(unit >>> 10 & 1023 | 55296);\n                    unit = 56320 | unit & 1023;\n                  }\n                  units.push(unit);\n                } else {\n                  units.push(byte1);\n                }\n                if (units.length >= CHUNK_SIZE) {\n                  result += String.fromCharCode.apply(String, units);\n                  units.length = 0;\n                }\n              }\n              if (units.length > 0) {\n                result += String.fromCharCode.apply(String, units);\n              }\n              return result;\n            }\n            var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n            var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\" ? 200 : 0;\n            function utf8DecodeTD(bytes, inputOffset, byteLength) {\n              var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n              return sharedTextDecoder.decode(stringBytes);\n            }\n          }\n        )\n        /******/\n      };\n      var __webpack_module_cache__ = {};\n      function __nested_webpack_require_215262__(moduleId) {\n        var cachedModule = __webpack_module_cache__[moduleId];\n        if (cachedModule !== void 0) {\n          return cachedModule.exports;\n        }\n        var module2 = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n          /******/\n          // no module.loaded needed\n          /******/\n          exports: {}\n          /******/\n        };\n        __webpack_modules__[moduleId](module2, module2.exports, __nested_webpack_require_215262__);\n        return module2.exports;\n      }\n      (() => {\n        __nested_webpack_require_215262__.d = (exports2, definition) => {\n          for (var key in definition) {\n            if (__nested_webpack_require_215262__.o(definition, key) && !__nested_webpack_require_215262__.o(exports2, key)) {\n              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });\n            }\n          }\n        };\n      })();\n      (() => {\n        __nested_webpack_require_215262__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n      })();\n      (() => {\n        __nested_webpack_require_215262__.r = (exports2) => {\n          if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n            Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n          }\n          Object.defineProperty(exports2, \"__esModule\", { value: true });\n        };\n      })();\n      var __nested_webpack_exports__ = {};\n      /*!*********************************!*\\\n        !*** ./src/websocket-client.js ***!\n        \\*********************************/\n      __nested_webpack_require_215262__.r(__nested_webpack_exports__);\n      __nested_webpack_require_215262__.d(__nested_webpack_exports__, {\n        /* harmony export */\n        API_VERSION: () => (\n          /* reexport safe */\n          _rpc_js__WEBPACK_IMPORTED_MODULE_0__.API_VERSION\n        ),\n        /* harmony export */\n        LocalWebSocket: () => (\n          /* binding */\n          LocalWebSocket\n        ),\n        /* harmony export */\n        RPC: () => (\n          /* reexport safe */\n          _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC\n        ),\n        /* harmony export */\n        connectToServer: () => (\n          /* binding */\n          connectToServer\n        ),\n        /* harmony export */\n        getRTCService: () => (\n          /* reexport safe */\n          _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService\n        ),\n        /* harmony export */\n        getRemoteService: () => (\n          /* binding */\n          getRemoteService\n        ),\n        /* harmony export */\n        loadRequirements: () => (\n          /* reexport safe */\n          _utils__WEBPACK_IMPORTED_MODULE_1__.loadRequirements\n        ),\n        /* harmony export */\n        login: () => (\n          /* binding */\n          login\n        ),\n        /* harmony export */\n        registerRTCService: () => (\n          /* reexport safe */\n          _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService\n        ),\n        /* harmony export */\n        schemaFunction: () => (\n          /* reexport safe */\n          _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction\n        ),\n        /* harmony export */\n        setupLocalClient: () => (\n          /* binding */\n          setupLocalClient\n        )\n        /* harmony export */\n      });\n      var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_215262__(\n        /*! ./rpc.js */\n        \"./src/rpc.js\"\n      );\n      var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_215262__(\n        /*! ./utils */\n        \"./src/utils/index.js\"\n      );\n      var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_215262__(\n        /*! ./utils/schema.js */\n        \"./src/utils/schema.js\"\n      );\n      var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_215262__(\n        /*! ./webrtc-client.js */\n        \"./src/webrtc-client.js\"\n      );\n      const MAX_RETRY = 1e6;\n      class WebsocketRPCConnection {\n        constructor(server_url2, client_id2, workspace2, token2, reconnection_token = null, timeout = 60, WebSocketClass = null, token_refresh_interval = 2 * 60 * 60) {\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(server_url2 && client_id2, \"server_url and client_id are required\");\n          this._server_url = server_url2;\n          this._client_id = client_id2;\n          this._workspace = workspace2;\n          this._token = token2;\n          this._reconnection_token = reconnection_token;\n          this._websocket = null;\n          this._handle_message = null;\n          this._handle_connected = null;\n          this._handle_disconnected = null;\n          this._timeout = timeout;\n          this._WebSocketClass = WebSocketClass || WebSocket;\n          this._closed = false;\n          this._legacy_auth = null;\n          this.connection_info = null;\n          this._enable_reconnect = false;\n          this._token_refresh_interval = token_refresh_interval;\n          this.manager_id = null;\n          this._refresh_token_task = null;\n          this._last_message = null;\n          this._reconnect_timeouts = /* @__PURE__ */ new Set();\n        }\n        /**\n         * Centralized cleanup method to clear all timers and prevent resource leaks\n         */\n        _cleanup() {\n          if (this._refresh_token_task) {\n            clearInterval(this._refresh_token_task);\n            this._refresh_token_task = null;\n          }\n          for (const timeoutId of this._reconnect_timeouts) {\n            clearTimeout(timeoutId);\n          }\n          this._reconnect_timeouts.clear();\n        }\n        on_message(handler) {\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handler, \"handler is required\");\n          this._handle_message = handler;\n        }\n        on_connected(handler) {\n          this._handle_connected = handler;\n        }\n        on_disconnected(handler) {\n          this._handle_disconnected = handler;\n        }\n        async _attempt_connection(server_url2, attempt_fallback = true) {\n          return new Promise((resolve2, reject2) => {\n            this._legacy_auth = false;\n            const websocket = new this._WebSocketClass(server_url2);\n            websocket.binaryType = \"arraybuffer\";\n            websocket.onopen = () => {\n              console.info(\"WebSocket connection established\");\n              resolve2(websocket);\n            };\n            websocket.onerror = (event2) => {\n              console.error(\"WebSocket connection error:\", event2);\n              reject2(new Error(`WebSocket connection error: ${event2}`));\n            };\n            websocket.onclose = (event2) => {\n              if (event2.code === 1003 && attempt_fallback) {\n                console.info(\n                  \"Received 1003 error, attempting connection with query parameters.\"\n                );\n                this._legacy_auth = true;\n                this._attempt_connection_with_query_params(server_url2).then(resolve2).catch(reject2);\n              } else if (this._handle_disconnected) {\n                this._handle_disconnected(event2.reason);\n              }\n            };\n          });\n        }\n        async _attempt_connection_with_query_params(server_url2) {\n          const queryParamsParts = [];\n          if (this._client_id)\n            queryParamsParts.push(`client_id=${encodeURIComponent(this._client_id)}`);\n          if (this._workspace)\n            queryParamsParts.push(`workspace=${encodeURIComponent(this._workspace)}`);\n          if (this._token)\n            queryParamsParts.push(`token=${encodeURIComponent(this._token)}`);\n          if (this._reconnection_token)\n            queryParamsParts.push(\n              `reconnection_token=${encodeURIComponent(this._reconnection_token)}`\n            );\n          const queryString = queryParamsParts.length > 0 ? `?${queryParamsParts.join(\"&\")}` : \"\";\n          const full_url = server_url2 + queryString;\n          return await this._attempt_connection(full_url, false);\n        }\n        _establish_connection() {\n          return new Promise((resolve2, reject2) => {\n            this._websocket.onmessage = (event2) => {\n              const data = event2.data;\n              const first_message = JSON.parse(data);\n              if (first_message.type == \"connection_info\") {\n                this.connection_info = first_message;\n                if (this._workspace) {\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n                    this.connection_info.workspace === this._workspace,\n                    `Connected to the wrong workspace: ${this.connection_info.workspace}, expected: ${this._workspace}`\n                  );\n                }\n                if (this.connection_info.reconnection_token) {\n                  this._reconnection_token = this.connection_info.reconnection_token;\n                }\n                if (this.connection_info.reconnection_token_life_time) {\n                  if (this.token_refresh_interval > this.connection_info.reconnection_token_life_time / 1.5) {\n                    console.warn(\n                      `Token refresh interval is too long (${this.token_refresh_interval}), setting it to 1.5 times of the token life time(${this.connection_info.reconnection_token_life_time}).`\n                    );\n                    this.token_refresh_interval = this.connection_info.reconnection_token_life_time / 1.5;\n                  }\n                }\n                this.manager_id = this.connection_info.manager_id || null;\n                console.log(\n                  `Successfully connected to the server, workspace: ${this.connection_info.workspace}, manager_id: ${this.manager_id}`\n                );\n                if (this.connection_info.announcement) {\n                  console.log(`${this.connection_info.announcement}`);\n                }\n                resolve2(this.connection_info);\n              } else if (first_message.type == \"error\") {\n                const error = \"ConnectionAbortedError: \" + first_message.message;\n                console.error(\"Failed to connect, \" + error);\n                reject2(new Error(error));\n                return;\n              } else {\n                console.error(\n                  \"ConnectionAbortedError: Unexpected message received from the server:\",\n                  data\n                );\n                reject2(\n                  new Error(\n                    \"ConnectionAbortedError: Unexpected message received from the server\"\n                  )\n                );\n                return;\n              }\n            };\n          });\n        }\n        async open() {\n          console.log(\n            \"Creating a new websocket connection to\",\n            this._server_url.split(\"?\")[0]\n          );\n          try {\n            this._websocket = await this._attempt_connection(this._server_url);\n            if (this._legacy_auth) {\n              throw new Error(\n                \"NotImplementedError: Legacy authentication is not supported\"\n              );\n            }\n            const authInfo = JSON.stringify({\n              client_id: this._client_id,\n              workspace: this._workspace,\n              token: this._token,\n              reconnection_token: this._reconnection_token\n            });\n            this._websocket.send(authInfo);\n            await (0, _utils__WEBPACK_IMPORTED_MODULE_1__.waitFor)(\n              this._establish_connection(),\n              this._timeout,\n              \"Failed to receive the first message from the server\"\n            );\n            if (this._token_refresh_interval > 0) {\n              setTimeout(() => {\n                this._send_refresh_token();\n                this._refresh_token_task = setInterval(() => {\n                  this._send_refresh_token();\n                }, this._token_refresh_interval * 1e3);\n              }, 2e3);\n            }\n            this._enable_reconnect = true;\n            this._closed = false;\n            this._websocket.onmessage = (event2) => {\n              if (typeof event2.data === \"string\") {\n                const parsedData = JSON.parse(event2.data);\n                if (parsedData.type === \"reconnection_token\") {\n                  this._reconnection_token = parsedData.reconnection_token;\n                  console.log(\"Reconnection token received\");\n                } else {\n                  console.log(\"Received message from the server:\", parsedData);\n                }\n              } else {\n                this._handle_message(event2.data);\n              }\n            };\n            this._websocket.onerror = (event2) => {\n              console.error(\"WebSocket connection error:\", event2);\n              this._cleanup();\n            };\n            this._websocket.onclose = this._handle_close.bind(this);\n            if (this._handle_connected) {\n              this._handle_connected(this.connection_info);\n            }\n            return this.connection_info;\n          } catch (error) {\n            this._cleanup();\n            console.error(\n              \"Failed to connect to\",\n              this._server_url.split(\"?\")[0],\n              error\n            );\n            throw error;\n          }\n        }\n        _send_refresh_token() {\n          if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n            const refreshMessage = JSON.stringify({ type: \"refresh_token\" });\n            this._websocket.send(refreshMessage);\n            console.log(\"Requested refresh token\");\n          }\n        }\n        _handle_close(event2) {\n          if (!this._closed && this._websocket && this._websocket.readyState === WebSocket.CLOSED) {\n            this._cleanup();\n            if ([1e3, 1001].includes(event2.code)) {\n              console.info(\n                `Websocket connection closed (code: ${event2.code}): ${event2.reason}`\n              );\n              if (this._handle_disconnected) {\n                this._handle_disconnected(event2.reason);\n              }\n              this._closed = true;\n            } else if (this._enable_reconnect) {\n              console.warn(\n                \"Websocket connection closed unexpectedly (code: %s): %s\",\n                event2.code,\n                event2.reason\n              );\n              let retry = 0;\n              const reconnect = async () => {\n                try {\n                  console.warn(\n                    `Reconnecting to ${this._server_url.split(\"?\")[0]} (attempt #${retry})`\n                  );\n                  await this.open();\n                  await new Promise((resolve2) => setTimeout(resolve2, 500));\n                  if (this._last_message) {\n                    console.info(\"Resending last message after reconnection\");\n                    this._websocket.send(this._last_message);\n                    this._last_message = null;\n                  }\n                  console.warn(\n                    `Successfully reconnected to server ${this._server_url} (services re-registered)`\n                  );\n                } catch (e) {\n                  if (`${e}`.includes(\"ConnectionAbortedError:\")) {\n                    console.warn(\"Failed to reconnect, connection aborted:\", e);\n                    return;\n                  } else if (`${e}`.includes(\"NotImplementedError:\")) {\n                    console.error(\n                      `${e}\nIt appears that you are trying to connect to a hypha server that is older than 0.20.0, please upgrade the hypha server or use the websocket client in imjoy-rpc(https://www.npmjs.com/package/imjoy-rpc) instead`\n                    );\n                    return;\n                  }\n                  const timeoutId = setTimeout(async () => {\n                    this._reconnect_timeouts.delete(timeoutId);\n                    if (this._websocket && this._websocket.readyState === WebSocket.CONNECTED) {\n                      return;\n                    }\n                    retry += 1;\n                    if (retry < MAX_RETRY) {\n                      await reconnect();\n                    } else {\n                      console.error(\n                        \"Failed to reconnect after\",\n                        MAX_RETRY,\n                        \"attempts\"\n                      );\n                    }\n                  }, 1e3);\n                  this._reconnect_timeouts.add(timeoutId);\n                }\n              };\n              reconnect();\n            }\n          } else {\n            this._cleanup();\n            if (this._handle_disconnected) {\n              this._handle_disconnected(event2.reason);\n            }\n          }\n        }\n        async emit_message(data) {\n          if (this._closed) {\n            throw new Error(\"Connection is closed\");\n          }\n          if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n            await this.open();\n          }\n          try {\n            this._last_message = data;\n            this._websocket.send(data);\n            this._last_message = null;\n          } catch (exp) {\n            console.error(`Failed to send data, error: ${exp}`);\n            throw exp;\n          }\n        }\n        disconnect(reason) {\n          this._closed = true;\n          this._last_message = null;\n          if (this._websocket && this._websocket.readyState !== WebSocket.CLOSED && this._websocket.readyState !== WebSocket.CLOSING) {\n            this._websocket.close(1e3, reason);\n          }\n          this._cleanup();\n          console.info(`WebSocket connection disconnected (${reason})`);\n        }\n      }\n      function normalizeServerUrl(server_url2) {\n        if (!server_url2)\n          throw new Error(\"server_url is required\");\n        if (server_url2.startsWith(\"http://\")) {\n          server_url2 = server_url2.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n        } else if (server_url2.startsWith(\"https://\")) {\n          server_url2 = server_url2.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n        }\n        return server_url2;\n      }\n      async function login(config2) {\n        const service_id = config2.login_service_id || \"public/hypha-login\";\n        const workspace2 = config2.workspace;\n        const expires_in = config2.expires_in;\n        const timeout = config2.login_timeout || 60;\n        const callback = config2.login_callback;\n        const profile = config2.profile;\n        const server2 = await connectToServer({\n          name: \"initial login client\",\n          server_url: config2.server_url\n        });\n        try {\n          const svc = await server2.getService(service_id);\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(svc, `Failed to get the login service: ${service_id}`);\n          let context2;\n          if (workspace2) {\n            context2 = await svc.start({ workspace: workspace2, expires_in, _rkwargs: true });\n          } else {\n            context2 = await svc.start();\n          }\n          if (callback) {\n            await callback(context2);\n          } else {\n            console.log(`Please open your browser and login at ${context2.login_url}`);\n          }\n          return await svc.check(context2.key, { timeout, profile, _rkwargs: true });\n        } catch (error) {\n          throw error;\n        } finally {\n          await server2.disconnect();\n        }\n      }\n      async function webrtcGetService(wm, rtc_service_id, query, config2) {\n        config2 = config2 || {};\n        const webrtc = config2.webrtc;\n        const webrtc_config = config2.webrtc_config;\n        if (config2.webrtc !== void 0)\n          delete config2.webrtc;\n        if (config2.webrtc_config !== void 0)\n          delete config2.webrtc_config;\n        (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n          [void 0, true, false, \"auto\"].includes(webrtc),\n          \"webrtc must be true, false or 'auto'\"\n        );\n        const svc = await wm.getService(query, config2);\n        if (webrtc === true || webrtc === \"auto\") {\n          if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n            try {\n              const peer = await (0, _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService)(wm, rtc_service_id, webrtc_config);\n              const rtcSvc = await peer.getService(svc.id.split(\":\")[1], config2);\n              rtcSvc._webrtc = true;\n              rtcSvc._peer = peer;\n              rtcSvc._service = svc;\n              return rtcSvc;\n            } catch (e) {\n              console.warn(\n                \"Failed to get webrtc service, using websocket connection\",\n                e\n              );\n            }\n          }\n          if (webrtc === true) {\n            throw new Error(\"Failed to get the service via webrtc\");\n          }\n        }\n        return svc;\n      }\n      async function connectToServer(config2) {\n        if (config2.server) {\n          config2.server_url = config2.server_url || config2.server.url;\n          config2.WebSocketClass = config2.WebSocketClass || config2.server.WebSocketClass;\n        }\n        let clientId = config2.client_id;\n        if (!clientId) {\n          clientId = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n          config2.client_id = clientId;\n        }\n        let server_url2 = normalizeServerUrl(config2.server_url);\n        let connection = new WebsocketRPCConnection(\n          server_url2,\n          clientId,\n          config2.workspace,\n          config2.token,\n          config2.reconnection_token,\n          config2.method_timeout || 60,\n          config2.WebSocketClass\n        );\n        const connection_info = await connection.open();\n        (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n          connection_info,\n          \"Failed to connect to the server, no connection info obtained. This issue is most likely due to an outdated Hypha server version. Please use `imjoy-rpc` for compatibility, or upgrade the Hypha server to the latest version.\"\n        );\n        await new Promise((resolve2) => setTimeout(resolve2, 100));\n        if (!connection.manager_id) {\n          console.warn(\"Manager ID not set immediately, waiting...\");\n          const maxWaitTime = 5e3;\n          const checkInterval = 100;\n          const startTime = Date.now();\n          while (!connection.manager_id && Date.now() - startTime < maxWaitTime) {\n            await new Promise((resolve2) => setTimeout(resolve2, checkInterval));\n          }\n          if (!connection.manager_id) {\n            console.error(\"Manager ID still not set after waiting\");\n            throw new Error(\"Failed to get manager ID from server\");\n          } else {\n            console.info(`Manager ID set after waiting: ${connection.manager_id}`);\n          }\n        }\n        if (config2.workspace && connection_info.workspace !== config2.workspace) {\n          throw new Error(\n            `Connected to the wrong workspace: ${connection_info.workspace}, expected: ${config2.workspace}`\n          );\n        }\n        const workspace2 = connection_info.workspace;\n        const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC(connection, {\n          client_id: clientId,\n          workspace: workspace2,\n          default_context: { connection_type: \"websocket\" },\n          name: config2.name,\n          method_timeout: config2.method_timeout,\n          app_id: config2.app_id,\n          server_base_url: connection_info.public_base_url,\n          long_message_chunk_size: config2.long_message_chunk_size\n        });\n        const wm = await rpc.get_manager_service({\n          timeout: config2.method_timeout,\n          case_conversion: \"camel\",\n          kwargs_expansion: config2.kwargs_expansion || false\n        });\n        wm.rpc = rpc;\n        async function _export(api) {\n          api.id = \"default\";\n          api.name = api.name || config2.name || api.id;\n          api.description = api.description || config2.description;\n          await rpc.register_service(api, { overwrite: true });\n        }\n        async function getApp(clientId2) {\n          clientId2 = clientId2 || \"*\";\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!clientId2.includes(\":\"), \"clientId should not contain ':'\");\n          if (!clientId2.includes(\"/\")) {\n            clientId2 = connection_info.workspace + \"/\" + clientId2;\n          }\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n            clientId2.split(\"/\").length === 2,\n            \"clientId should match pattern workspace/clientId\"\n          );\n          return await wm.getService(`${clientId2}:default`);\n        }\n        async function listApps(ws) {\n          ws = ws || workspace2;\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\":\"), \"workspace should not contain ':'\");\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\"/\"), \"workspace should not contain '/'\");\n          const query = { workspace: ws, service_id: \"default\" };\n          return await wm.listServices(query);\n        }\n        if (connection_info) {\n          wm.config = Object.assign(wm.config, connection_info);\n        }\n        wm.export = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_export, {\n          name: \"export\",\n          description: \"Export the api.\",\n          parameters: {\n            properties: { api: { description: \"The api to export\", type: \"object\" } },\n            required: [\"api\"],\n            type: \"object\"\n          }\n        });\n        wm.getApp = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(getApp, {\n          name: \"getApp\",\n          description: \"Get the app.\",\n          parameters: {\n            properties: {\n              clientId: { default: \"*\", description: \"The clientId\", type: \"string\" }\n            },\n            type: \"object\"\n          }\n        });\n        wm.listApps = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(listApps, {\n          name: \"listApps\",\n          description: \"List the apps.\",\n          parameters: {\n            properties: {\n              workspace: {\n                default: workspace2,\n                description: \"The workspace\",\n                type: \"string\"\n              }\n            },\n            type: \"object\"\n          }\n        });\n        wm.disconnect = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.disconnect.bind(rpc), {\n          name: \"disconnect\",\n          description: \"Disconnect from the server.\",\n          parameters: { type: \"object\", properties: {}, required: [] }\n        });\n        wm.registerCodec = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_codec.bind(rpc), {\n          name: \"registerCodec\",\n          description: \"Register a codec for the webrtc connection\",\n          parameters: {\n            type: \"object\",\n            properties: {\n              codec: {\n                type: \"object\",\n                description: \"Codec to register\",\n                properties: {\n                  name: { type: \"string\" },\n                  type: {},\n                  encoder: { type: \"function\" },\n                  decoder: { type: \"function\" }\n                }\n              }\n            }\n          }\n        });\n        wm.emit = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.emit.bind(rpc), {\n          name: \"emit\",\n          description: \"Emit a message.\",\n          parameters: {\n            properties: { data: { description: \"The data to emit\", type: \"object\" } },\n            required: [\"data\"],\n            type: \"object\"\n          }\n        });\n        wm.on = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.on.bind(rpc), {\n          name: \"on\",\n          description: \"Register a message handler.\",\n          parameters: {\n            properties: {\n              event: { description: \"The event to listen to\", type: \"string\" },\n              handler: { description: \"The handler function\", type: \"function\" }\n            },\n            required: [\"event\", \"handler\"],\n            type: \"object\"\n          }\n        });\n        wm.off = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.off.bind(rpc), {\n          name: \"off\",\n          description: \"Remove a message handler.\",\n          parameters: {\n            properties: {\n              event: { description: \"The event to remove\", type: \"string\" },\n              handler: { description: \"The handler function\", type: \"function\" }\n            },\n            required: [\"event\", \"handler\"],\n            type: \"object\"\n          }\n        });\n        wm.once = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.once.bind(rpc), {\n          name: \"once\",\n          description: \"Register a one-time message handler.\",\n          parameters: {\n            properties: {\n              event: { description: \"The event to listen to\", type: \"string\" },\n              handler: { description: \"The handler function\", type: \"function\" }\n            },\n            required: [\"event\", \"handler\"],\n            type: \"object\"\n          }\n        });\n        wm.getServiceSchema = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.get_service_schema, {\n          name: \"getServiceSchema\",\n          description: \"Get the service schema.\",\n          parameters: {\n            properties: {\n              service: {\n                description: \"The service to extract schema\",\n                type: \"object\"\n              }\n            },\n            required: [\"service\"],\n            type: \"object\"\n          }\n        });\n        wm.registerService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_service.bind(rpc), {\n          name: \"registerService\",\n          description: \"Register a service.\",\n          parameters: {\n            properties: {\n              service: { description: \"The service to register\", type: \"object\" },\n              force: {\n                default: false,\n                description: \"Force to register the service\",\n                type: \"boolean\"\n              }\n            },\n            required: [\"service\"],\n            type: \"object\"\n          }\n        });\n        wm.unregisterService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.unregister_service.bind(rpc), {\n          name: \"unregisterService\",\n          description: \"Unregister a service.\",\n          parameters: {\n            properties: {\n              service: {\n                description: \"The service id to unregister\",\n                type: \"string\"\n              },\n              notify: {\n                default: true,\n                description: \"Notify the workspace manager\",\n                type: \"boolean\"\n              }\n            },\n            required: [\"service\"],\n            type: \"object\"\n          }\n        });\n        if (connection.manager_id) {\n          rpc.on(\"force-exit\", async (message) => {\n            if (message.from === \"*/\" + connection.manager_id) {\n              console.log(\"Disconnecting from server, reason:\", message.reason);\n              await rpc.disconnect();\n            }\n          });\n        }\n        if (config2.webrtc) {\n          await (0, _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService)(wm, `${clientId}-rtc`, config2.webrtc_config);\n          const _wm = Object.assign({}, wm);\n          const description = _wm.getService.__schema__.description;\n          const parameters = _wm.getService.__schema__.parameters;\n          wm.getService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(\n            webrtcGetService.bind(null, _wm, `${workspace2}/${clientId}-rtc`),\n            {\n              name: \"getService\",\n              description,\n              parameters\n            }\n          );\n          wm.getRTCService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService.bind(null, wm), {\n            name: \"getRTCService\",\n            description: \"Get the webrtc connection, returns a peer connection.\",\n            parameters: {\n              properties: {\n                config: {\n                  description: \"The config for the webrtc service\",\n                  type: \"object\"\n                }\n              },\n              required: [\"config\"],\n              type: \"object\"\n            }\n          });\n        } else {\n          const _getService = wm.getService;\n          wm.getService = (query, config3) => {\n            config3 = config3 || {};\n            return _getService(query, config3);\n          };\n          wm.getService.__schema__ = _getService.__schema__;\n        }\n        async function registerProbes(probes) {\n          probes.id = \"probes\";\n          probes.name = \"Probes\";\n          probes.config = { visibility: \"public\" };\n          probes.type = \"probes\";\n          probes.description = `Probes Service, visit ${server_url2}/${workspace2}services/probes for the available probes.`;\n          return await wm.registerService(probes, { overwrite: true });\n        }\n        wm.registerProbes = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(registerProbes, {\n          name: \"registerProbes\",\n          description: \"Register probes service\",\n          parameters: {\n            properties: {\n              probes: {\n                description: \"The probes to register, e.g. {'liveness': {'type': 'function', 'description': 'Check the liveness of the service'}}\",\n                type: \"object\"\n              }\n            },\n            required: [\"probes\"],\n            type: \"object\"\n          }\n        });\n        return wm;\n      }\n      async function getRemoteService(serviceUri, config2 = {}) {\n        const { serverUrl, workspace: workspace2, clientId, serviceId, appId } = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.parseServiceUrl)(serviceUri);\n        const fullServiceId = `${workspace2}/${clientId}:${serviceId}@${appId}`;\n        if (config2.serverUrl) {\n          if (config2.serverUrl !== serverUrl) {\n            throw new Error(\n              \"server_url in config does not match the server_url in the url\"\n            );\n          }\n        }\n        config2.serverUrl = serverUrl;\n        const server2 = await connectToServer(config2);\n        return await server2.getService(fullServiceId);\n      }\n      class LocalWebSocket {\n        constructor(url, client_id2, workspace2) {\n          this.url = url;\n          this.onopen = () => {\n          };\n          this.onmessage = () => {\n          };\n          this.onclose = () => {\n          };\n          this.onerror = () => {\n          };\n          this.client_id = client_id2;\n          this.workspace = workspace2;\n          const context2 = typeof window !== \"undefined\" ? window : self;\n          const isWindow2 = typeof window !== \"undefined\";\n          this.postMessage = (message) => {\n            if (isWindow2) {\n              window.parent.postMessage(message, \"*\");\n            } else {\n              self.postMessage(message);\n            }\n          };\n          this.readyState = WebSocket.CONNECTING;\n          context2.addEventListener(\n            \"message\",\n            (event2) => {\n              const { type: type2, data, to } = event2.data;\n              if (to !== this.client_id) {\n                return;\n              }\n              switch (type2) {\n                case \"message\":\n                  if (this.readyState === WebSocket.OPEN && this.onmessage) {\n                    this.onmessage({ data });\n                  }\n                  break;\n                case \"connected\":\n                  this.readyState = WebSocket.OPEN;\n                  this.onopen(event2);\n                  break;\n                case \"closed\":\n                  this.readyState = WebSocket.CLOSED;\n                  this.onclose(event2);\n                  break;\n                default:\n                  break;\n              }\n            },\n            false\n          );\n          if (!this.client_id)\n            throw new Error(\"client_id is required\");\n          if (!this.workspace)\n            throw new Error(\"workspace is required\");\n          this.postMessage({\n            type: \"connect\",\n            url: this.url,\n            from: this.client_id,\n            workspace: this.workspace\n          });\n        }\n        send(data) {\n          if (this.readyState === WebSocket.OPEN) {\n            this.postMessage({\n              type: \"message\",\n              data,\n              from: this.client_id,\n              workspace: this.workspace\n            });\n          }\n        }\n        close() {\n          this.readyState = WebSocket.CLOSING;\n          this.postMessage({\n            type: \"close\",\n            from: this.client_id,\n            workspace: this.workspace\n          });\n          this.onclose();\n        }\n        addEventListener(type2, listener) {\n          if (type2 === \"message\") {\n            this.onmessage = listener;\n          }\n          if (type2 === \"open\") {\n            this.onopen = listener;\n          }\n          if (type2 === \"close\") {\n            this.onclose = listener;\n          }\n          if (type2 === \"error\") {\n            this.onerror = listener;\n          }\n        }\n      }\n      function setupLocalClient({\n        enable_execution = false,\n        on_ready = null\n      }) {\n        return new Promise((resolve, reject) => {\n          const context = typeof window !== \"undefined\" ? window : self;\n          const isWindow = typeof window !== \"undefined\";\n          context.addEventListener(\n            \"message\",\n            (event) => {\n              const {\n                type,\n                server_url,\n                workspace,\n                client_id,\n                token,\n                method_timeout,\n                name,\n                config\n              } = event.data;\n              if (type === \"initializeHyphaClient\") {\n                if (!server_url || !workspace || !client_id) {\n                  console.error(\"server_url, workspace, and client_id are required.\");\n                  return;\n                }\n                if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n                  console.error(\n                    \"server_url should start with https://local-hypha-server:\"\n                  );\n                  return;\n                }\n                class FixedLocalWebSocket extends LocalWebSocket {\n                  constructor(url) {\n                    super(url, client_id, workspace);\n                  }\n                }\n                connectToServer({\n                  server_url,\n                  workspace,\n                  client_id,\n                  token,\n                  method_timeout,\n                  name,\n                  WebSocketClass: FixedLocalWebSocket\n                }).then(async (server) => {\n                  globalThis.api = server;\n                  try {\n                    if (isWindow && enable_execution) {\n                      let loadScript = function(script2) {\n                        return new Promise((resolve2, reject2) => {\n                          const scriptElement = document.createElement(\"script\");\n                          scriptElement.innerHTML = script2.content;\n                          scriptElement.lang = script2.lang;\n                          scriptElement.onload = () => resolve2();\n                          scriptElement.onerror = (e) => reject2(e);\n                          document.head.appendChild(scriptElement);\n                        });\n                      };\n                      if (config.styles && config.styles.length > 0) {\n                        for (const style of config.styles) {\n                          const styleElement = document.createElement(\"style\");\n                          styleElement.innerHTML = style.content;\n                          styleElement.lang = style.lang;\n                          document.head.appendChild(styleElement);\n                        }\n                      }\n                      if (config.links && config.links.length > 0) {\n                        for (const link of config.links) {\n                          const linkElement = document.createElement(\"a\");\n                          linkElement.href = link.url;\n                          linkElement.innerText = link.text;\n                          document.body.appendChild(linkElement);\n                        }\n                      }\n                      if (config.windows && config.windows.length > 0) {\n                        for (const w of config.windows) {\n                          document.body.innerHTML = w.content;\n                          break;\n                        }\n                      }\n                      if (config.scripts && config.scripts.length > 0) {\n                        for (const script2 of config.scripts) {\n                          if (script2.lang !== \"javascript\")\n                            throw new Error(\"Only javascript scripts are supported\");\n                          await loadScript(script2);\n                        }\n                      }\n                    } else if (!isWindow && enable_execution && config.scripts && config.scripts.length > 0) {\n                      for (const script of config.scripts) {\n                        if (script.lang !== \"javascript\")\n                          throw new Error(\"Only javascript scripts are supported\");\n                        eval(script.content);\n                      }\n                    }\n                    if (on_ready) {\n                      await on_ready(server, config);\n                    }\n                    resolve(server);\n                  } catch (e) {\n                    reject(e);\n                  }\n                });\n              }\n            },\n            false\n          );\n          if (isWindow) {\n            window.parent.postMessage({ type: \"hyphaClientReady\" }, \"*\");\n          } else {\n            self.postMessage({ type: \"hyphaClientReady\" });\n          }\n        });\n      }\n      return __nested_webpack_exports__;\n    })()\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/hypha-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hypha-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js\") };\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/hypha-rpc/index.js?");

/***/ }),

/***/ "./node_modules/mock-socket/dist/mock-socket.js":
/*!******************************************************!*\
  !*** ./node_modules/mock-socket/dist/mock-socket.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function(global2, factory) {\n   true ? factory(exports) : 0;\n})(this, function(exports2) {\n  \"use strict\";\n  var commonjsGlobal = typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : {};\n  var requiresPort = function required(port, protocol) {\n    protocol = protocol.split(\":\")[0];\n    port = +port;\n    if (!port) {\n      return false;\n    }\n    switch (protocol) {\n      case \"http\":\n      case \"ws\":\n        return port !== 80;\n      case \"https\":\n      case \"wss\":\n        return port !== 443;\n      case \"ftp\":\n        return port !== 21;\n      case \"gopher\":\n        return port !== 70;\n      case \"file\":\n        return false;\n    }\n    return port !== 0;\n  };\n  var has = Object.prototype.hasOwnProperty;\n  var undef;\n  function decode(input) {\n    try {\n      return decodeURIComponent(input.replace(/\\+/g, \" \"));\n    } catch (e) {\n      return null;\n    }\n  }\n  function encode(input) {\n    try {\n      return encodeURIComponent(input);\n    } catch (e) {\n      return null;\n    }\n  }\n  function querystring(query) {\n    var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;\n    while (part = parser.exec(query)) {\n      var key = decode(part[1]), value = decode(part[2]);\n      if (key === null || value === null || key in result) {\n        continue;\n      }\n      result[key] = value;\n    }\n    return result;\n  }\n  function querystringify(obj, prefix) {\n    prefix = prefix || \"\";\n    var pairs = [], value, key;\n    if (\"string\" !== typeof prefix) {\n      prefix = \"?\";\n    }\n    for (key in obj) {\n      if (has.call(obj, key)) {\n        value = obj[key];\n        if (!value && (value === null || value === undef || isNaN(value))) {\n          value = \"\";\n        }\n        key = encode(key);\n        value = encode(value);\n        if (key === null || value === null) {\n          continue;\n        }\n        pairs.push(key + \"=\" + value);\n      }\n    }\n    return pairs.length ? prefix + pairs.join(\"&\") : \"\";\n  }\n  var stringify = querystringify;\n  var parse = querystring;\n  var querystringify_1 = {\n    stringify,\n    parse\n  };\n  var CRHTLF = /[\\n\\r\\t]/g;\n  var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n  var protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i;\n  var windowsDriveLetter = /^[a-zA-Z]:/;\n  var whitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n  function trimLeft(str) {\n    return (str ? str : \"\").toString().replace(whitespace, \"\");\n  }\n  var rules = [\n    [\"#\", \"hash\"],\n    // Extract from the back.\n    [\"?\", \"query\"],\n    // Extract from the back.\n    function sanitize(address, url) {\n      return isSpecial(url.protocol) ? address.replace(/\\\\/g, \"/\") : address;\n    },\n    [\"/\", \"pathname\"],\n    // Extract from the back.\n    [\"@\", \"auth\", 1],\n    // Extract from the front.\n    [NaN, \"host\", void 0, 1, 1],\n    // Set left over value.\n    [/:(\\d*)$/, \"port\", void 0, 1],\n    // RegExp the back.\n    [NaN, \"hostname\", void 0, 1, 1]\n    // Set left over.\n  ];\n  var ignore = { hash: 1, query: 1 };\n  function lolcation(loc) {\n    var globalVar;\n    if (typeof window !== \"undefined\") {\n      globalVar = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n      globalVar = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n      globalVar = self;\n    } else {\n      globalVar = {};\n    }\n    var location = globalVar.location || {};\n    loc = loc || location;\n    var finaldestination = {}, type = typeof loc, key;\n    if (\"blob:\" === loc.protocol) {\n      finaldestination = new Url(unescape(loc.pathname), {});\n    } else if (\"string\" === type) {\n      finaldestination = new Url(loc, {});\n      for (key in ignore) {\n        delete finaldestination[key];\n      }\n    } else if (\"object\" === type) {\n      for (key in loc) {\n        if (key in ignore) {\n          continue;\n        }\n        finaldestination[key] = loc[key];\n      }\n      if (finaldestination.slashes === void 0) {\n        finaldestination.slashes = slashes.test(loc.href);\n      }\n    }\n    return finaldestination;\n  }\n  function isSpecial(scheme) {\n    return scheme === \"file:\" || scheme === \"ftp:\" || scheme === \"http:\" || scheme === \"https:\" || scheme === \"ws:\" || scheme === \"wss:\";\n  }\n  function extractProtocol(address, location) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, \"\");\n    location = location || {};\n    var match = protocolre.exec(address);\n    var protocol = match[1] ? match[1].toLowerCase() : \"\";\n    var forwardSlashes = !!match[2];\n    var otherSlashes = !!match[3];\n    var slashesCount = 0;\n    var rest;\n    if (forwardSlashes) {\n      if (otherSlashes) {\n        rest = match[2] + match[3] + match[4];\n        slashesCount = match[2].length + match[3].length;\n      } else {\n        rest = match[2] + match[4];\n        slashesCount = match[2].length;\n      }\n    } else {\n      if (otherSlashes) {\n        rest = match[3] + match[4];\n        slashesCount = match[3].length;\n      } else {\n        rest = match[4];\n      }\n    }\n    if (protocol === \"file:\") {\n      if (slashesCount >= 2) {\n        rest = rest.slice(2);\n      }\n    } else if (isSpecial(protocol)) {\n      rest = match[4];\n    } else if (protocol) {\n      if (forwardSlashes) {\n        rest = rest.slice(2);\n      }\n    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n      rest = match[4];\n    }\n    return {\n      protocol,\n      slashes: forwardSlashes || isSpecial(protocol),\n      slashesCount,\n      rest\n    };\n  }\n  function resolve(relative, base) {\n    if (relative === \"\") {\n      return base;\n    }\n    var path = (base || \"/\").split(\"/\").slice(0, -1).concat(relative.split(\"/\")), i = path.length, last = path[i - 1], unshift = false, up = 0;\n    while (i--) {\n      if (path[i] === \".\") {\n        path.splice(i, 1);\n      } else if (path[i] === \"..\") {\n        path.splice(i, 1);\n        up++;\n      } else if (up) {\n        if (i === 0) {\n          unshift = true;\n        }\n        path.splice(i, 1);\n        up--;\n      }\n    }\n    if (unshift) {\n      path.unshift(\"\");\n    }\n    if (last === \".\" || last === \"..\") {\n      path.push(\"\");\n    }\n    return path.join(\"/\");\n  }\n  function Url(address, location, parser) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, \"\");\n    if (!(this instanceof Url)) {\n      return new Url(address, location, parser);\n    }\n    var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;\n    if (\"object\" !== type && \"string\" !== type) {\n      parser = location;\n      location = null;\n    }\n    if (parser && \"function\" !== typeof parser) {\n      parser = querystringify_1.parse;\n    }\n    location = lolcation(location);\n    extracted = extractProtocol(address || \"\", location);\n    relative = !extracted.protocol && !extracted.slashes;\n    url.slashes = extracted.slashes || relative && location.slashes;\n    url.protocol = extracted.protocol || location.protocol || \"\";\n    address = extracted.rest;\n    if (extracted.protocol === \"file:\" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {\n      instructions[3] = [/(.*)/, \"pathname\"];\n    }\n    for (; i < instructions.length; i++) {\n      instruction = instructions[i];\n      if (typeof instruction === \"function\") {\n        address = instruction(address, url);\n        continue;\n      }\n      parse2 = instruction[0];\n      key = instruction[1];\n      if (parse2 !== parse2) {\n        url[key] = address;\n      } else if (\"string\" === typeof parse2) {\n        index = parse2 === \"@\" ? address.lastIndexOf(parse2) : address.indexOf(parse2);\n        if (~index) {\n          if (\"number\" === typeof instruction[2]) {\n            url[key] = address.slice(0, index);\n            address = address.slice(index + instruction[2]);\n          } else {\n            url[key] = address.slice(index);\n            address = address.slice(0, index);\n          }\n        }\n      } else if (index = parse2.exec(address)) {\n        url[key] = index[1];\n        address = address.slice(0, index.index);\n      }\n      url[key] = url[key] || (relative && instruction[3] ? location[key] || \"\" : \"\");\n      if (instruction[4]) {\n        url[key] = url[key].toLowerCase();\n      }\n    }\n    if (parser) {\n      url.query = parser(url.query);\n    }\n    if (relative && location.slashes && url.pathname.charAt(0) !== \"/\" && (url.pathname !== \"\" || location.pathname !== \"\")) {\n      url.pathname = resolve(url.pathname, location.pathname);\n    }\n    if (url.pathname.charAt(0) !== \"/\" && isSpecial(url.protocol)) {\n      url.pathname = \"/\" + url.pathname;\n    }\n    if (!requiresPort(url.port, url.protocol)) {\n      url.host = url.hostname;\n      url.port = \"\";\n    }\n    url.username = url.password = \"\";\n    if (url.auth) {\n      index = url.auth.indexOf(\":\");\n      if (~index) {\n        url.username = url.auth.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n        url.password = url.auth.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(url.auth));\n      }\n      url.auth = url.password ? url.username + \":\" + url.password : url.username;\n    }\n    url.origin = url.protocol !== \"file:\" && isSpecial(url.protocol) && url.host ? url.protocol + \"//\" + url.host : \"null\";\n    url.href = url.toString();\n  }\n  function set(part, value, fn) {\n    var url = this;\n    switch (part) {\n      case \"query\":\n        if (\"string\" === typeof value && value.length) {\n          value = (fn || querystringify_1.parse)(value);\n        }\n        url[part] = value;\n        break;\n      case \"port\":\n        url[part] = value;\n        if (!requiresPort(value, url.protocol)) {\n          url.host = url.hostname;\n          url[part] = \"\";\n        } else if (value) {\n          url.host = url.hostname + \":\" + value;\n        }\n        break;\n      case \"hostname\":\n        url[part] = value;\n        if (url.port) {\n          value += \":\" + url.port;\n        }\n        url.host = value;\n        break;\n      case \"host\":\n        url[part] = value;\n        if (/:\\d+$/.test(value)) {\n          value = value.split(\":\");\n          url.port = value.pop();\n          url.hostname = value.join(\":\");\n        } else {\n          url.hostname = value;\n          url.port = \"\";\n        }\n        break;\n      case \"protocol\":\n        url.protocol = value.toLowerCase();\n        url.slashes = !fn;\n        break;\n      case \"pathname\":\n      case \"hash\":\n        if (value) {\n          var char = part === \"pathname\" ? \"/\" : \"#\";\n          url[part] = value.charAt(0) !== char ? char + value : value;\n        } else {\n          url[part] = value;\n        }\n        break;\n      case \"username\":\n      case \"password\":\n        url[part] = encodeURIComponent(value);\n        break;\n      case \"auth\":\n        var index = value.indexOf(\":\");\n        if (~index) {\n          url.username = value.slice(0, index);\n          url.username = encodeURIComponent(decodeURIComponent(url.username));\n          url.password = value.slice(index + 1);\n          url.password = encodeURIComponent(decodeURIComponent(url.password));\n        } else {\n          url.username = encodeURIComponent(decodeURIComponent(value));\n        }\n    }\n    for (var i = 0; i < rules.length; i++) {\n      var ins = rules[i];\n      if (ins[4]) {\n        url[ins[1]] = url[ins[1]].toLowerCase();\n      }\n    }\n    url.auth = url.password ? url.username + \":\" + url.password : url.username;\n    url.origin = url.protocol !== \"file:\" && isSpecial(url.protocol) && url.host ? url.protocol + \"//\" + url.host : \"null\";\n    url.href = url.toString();\n    return url;\n  }\n  function toString(stringify2) {\n    if (!stringify2 || \"function\" !== typeof stringify2) {\n      stringify2 = querystringify_1.stringify;\n    }\n    var query, url = this, host = url.host, protocol = url.protocol;\n    if (protocol && protocol.charAt(protocol.length - 1) !== \":\") {\n      protocol += \":\";\n    }\n    var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? \"//\" : \"\");\n    if (url.username) {\n      result += url.username;\n      if (url.password) {\n        result += \":\" + url.password;\n      }\n      result += \"@\";\n    } else if (url.password) {\n      result += \":\" + url.password;\n      result += \"@\";\n    } else if (url.protocol !== \"file:\" && isSpecial(url.protocol) && !host && url.pathname !== \"/\") {\n      result += \"@\";\n    }\n    if (host[host.length - 1] === \":\") {\n      host += \":\";\n    }\n    result += host + url.pathname;\n    query = \"object\" === typeof url.query ? stringify2(url.query) : url.query;\n    if (query) {\n      result += \"?\" !== query.charAt(0) ? \"?\" + query : query;\n    }\n    if (url.hash) {\n      result += url.hash;\n    }\n    return result;\n  }\n  Url.prototype = { set, toString };\n  Url.extractProtocol = extractProtocol;\n  Url.location = lolcation;\n  Url.trimLeft = trimLeft;\n  Url.qs = querystringify_1;\n  var urlParse = Url;\n  function delay(callback, context) {\n    setTimeout(function(timeoutContext) {\n      return callback.call(timeoutContext);\n    }, 4, context);\n  }\n  function log(method, message) {\n    if (typeof process !== \"undefined\" && \"development\" !== \"test\") {\n      console[method].call(null, message);\n    }\n  }\n  function reject(array, callback) {\n    if (array === void 0)\n      array = [];\n    var results = [];\n    array.forEach(function(itemInArray) {\n      if (!callback(itemInArray)) {\n        results.push(itemInArray);\n      }\n    });\n    return results;\n  }\n  function filter(array, callback) {\n    if (array === void 0)\n      array = [];\n    var results = [];\n    array.forEach(function(itemInArray) {\n      if (callback(itemInArray)) {\n        results.push(itemInArray);\n      }\n    });\n    return results;\n  }\n  var EventTarget = function EventTarget2() {\n    this.listeners = {};\n  };\n  EventTarget.prototype.addEventListener = function addEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n      if (!Array.isArray(this.listeners[type])) {\n        this.listeners[type] = [];\n      }\n      if (filter(this.listeners[type], function(item) {\n        return item === listener;\n      }).length === 0) {\n        this.listeners[type].push(listener);\n      }\n    }\n  };\n  EventTarget.prototype.removeEventListener = function removeEventListener(type, removingListener) {\n    var arrayOfListeners = this.listeners[type];\n    this.listeners[type] = reject(arrayOfListeners, function(listener) {\n      return listener === removingListener;\n    });\n  };\n  EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n    var this$1 = this;\n    var customArguments = [], len = arguments.length - 1;\n    while (len-- > 0)\n      customArguments[len] = arguments[len + 1];\n    var eventName = event.type;\n    var listeners = this.listeners[eventName];\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n    listeners.forEach(function(listener) {\n      if (customArguments.length > 0) {\n        listener.apply(this$1, customArguments);\n      } else {\n        listener.call(this$1, event);\n      }\n    });\n    return true;\n  };\n  function trimQueryPartFromURL(url) {\n    var queryIndex = url.indexOf(\"?\");\n    return queryIndex >= 0 ? url.slice(0, queryIndex) : url;\n  }\n  var NetworkBridge = function NetworkBridge2() {\n    this.urlMap = {};\n  };\n  NetworkBridge.prototype.attachWebSocket = function attachWebSocket(websocket, url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) === -1) {\n      connectionLookup.websockets.push(websocket);\n      return connectionLookup.server;\n    }\n  };\n  NetworkBridge.prototype.addMembershipToRoom = function addMembershipToRoom(websocket, room) {\n    var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n    if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) !== -1) {\n      if (!connectionLookup.roomMemberships[room]) {\n        connectionLookup.roomMemberships[room] = [];\n      }\n      connectionLookup.roomMemberships[room].push(websocket);\n    }\n  };\n  NetworkBridge.prototype.attachServer = function attachServer(server, url) {\n    var serverUrl = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverUrl];\n    if (!connectionLookup) {\n      this.urlMap[serverUrl] = {\n        server,\n        websockets: [],\n        roomMemberships: {}\n      };\n      return server;\n    }\n  };\n  NetworkBridge.prototype.serverLookup = function serverLookup(url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup) {\n      return connectionLookup.server;\n    }\n  };\n  NetworkBridge.prototype.websocketsLookup = function websocketsLookup(url, room, broadcaster) {\n    var serverURL = trimQueryPartFromURL(url);\n    var websockets;\n    var connectionLookup = this.urlMap[serverURL];\n    websockets = connectionLookup ? connectionLookup.websockets : [];\n    if (room) {\n      var members = connectionLookup.roomMemberships[room];\n      websockets = members || [];\n    }\n    return broadcaster ? websockets.filter(function(websocket) {\n      return websocket !== broadcaster;\n    }) : websockets;\n  };\n  NetworkBridge.prototype.removeServer = function removeServer(url) {\n    delete this.urlMap[trimQueryPartFromURL(url)];\n  };\n  NetworkBridge.prototype.removeWebSocket = function removeWebSocket(websocket, url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup) {\n      connectionLookup.websockets = reject(connectionLookup.websockets, function(socket) {\n        return socket === websocket;\n      });\n    }\n  };\n  NetworkBridge.prototype.removeMembershipFromRoom = function removeMembershipFromRoom(websocket, room) {\n    var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n    var memberships = connectionLookup.roomMemberships[room];\n    if (connectionLookup && memberships !== null) {\n      connectionLookup.roomMemberships[room] = reject(memberships, function(socket) {\n        return socket === websocket;\n      });\n    }\n  };\n  var networkBridge = new NetworkBridge();\n  var CLOSE_CODES = {\n    CLOSE_NORMAL: 1e3,\n    CLOSE_GOING_AWAY: 1001,\n    CLOSE_PROTOCOL_ERROR: 1002,\n    CLOSE_UNSUPPORTED: 1003,\n    CLOSE_NO_STATUS: 1005,\n    CLOSE_ABNORMAL: 1006,\n    UNSUPPORTED_DATA: 1007,\n    POLICY_VIOLATION: 1008,\n    CLOSE_TOO_LARGE: 1009,\n    MISSING_EXTENSION: 1010,\n    INTERNAL_ERROR: 1011,\n    SERVICE_RESTART: 1012,\n    TRY_AGAIN_LATER: 1013,\n    TLS_HANDSHAKE: 1015\n  };\n  var ERROR_PREFIX = {\n    CONSTRUCTOR_ERROR: \"Failed to construct 'WebSocket':\",\n    CLOSE_ERROR: \"Failed to execute 'close' on 'WebSocket':\",\n    EVENT: {\n      CONSTRUCT: \"Failed to construct 'Event':\",\n      MESSAGE: \"Failed to construct 'MessageEvent':\",\n      CLOSE: \"Failed to construct 'CloseEvent':\"\n    }\n  };\n  var EventPrototype = function EventPrototype2() {\n  };\n  EventPrototype.prototype.stopPropagation = function stopPropagation() {\n  };\n  EventPrototype.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n  };\n  EventPrototype.prototype.initEvent = function initEvent(type, bubbles, cancelable) {\n    if (type === void 0)\n      type = \"undefined\";\n    if (bubbles === void 0)\n      bubbles = false;\n    if (cancelable === void 0)\n      cancelable = false;\n    this.type = \"\" + type;\n    this.bubbles = Boolean(bubbles);\n    this.cancelable = Boolean(cancelable);\n  };\n  var Event = function(EventPrototype$$1) {\n    function Event2(type, eventInitConfig) {\n      if (eventInitConfig === void 0)\n        eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT_ERROR + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== \"object\") {\n        throw new TypeError(ERROR_PREFIX.EVENT_ERROR + \" parameter 2 ('eventInitDict') is not an object.\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.cancelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n    }\n    if (EventPrototype$$1)\n      Event2.__proto__ = EventPrototype$$1;\n    Event2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    Event2.prototype.constructor = Event2;\n    return Event2;\n  }(EventPrototype);\n  var MessageEvent = function(EventPrototype$$1) {\n    function MessageEvent2(type, eventInitConfig) {\n      if (eventInitConfig === void 0)\n        eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== \"object\") {\n        throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + \" parameter 2 ('eventInitDict') is not an object\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      var data = eventInitConfig.data;\n      var origin = eventInitConfig.origin;\n      var lastEventId = eventInitConfig.lastEventId;\n      var ports = eventInitConfig.ports;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.canncelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n      this.origin = \"\" + origin;\n      this.ports = typeof ports === \"undefined\" ? null : ports;\n      this.data = typeof data === \"undefined\" ? null : data;\n      this.lastEventId = \"\" + (lastEventId || \"\");\n    }\n    if (EventPrototype$$1)\n      MessageEvent2.__proto__ = EventPrototype$$1;\n    MessageEvent2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    MessageEvent2.prototype.constructor = MessageEvent2;\n    return MessageEvent2;\n  }(EventPrototype);\n  var CloseEvent = function(EventPrototype$$1) {\n    function CloseEvent2(type, eventInitConfig) {\n      if (eventInitConfig === void 0)\n        eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== \"object\") {\n        throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + \" parameter 2 ('eventInitDict') is not an object\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      var code = eventInitConfig.code;\n      var reason = eventInitConfig.reason;\n      var wasClean = eventInitConfig.wasClean;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.cancelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n      this.code = typeof code === \"number\" ? parseInt(code, 10) : 0;\n      this.reason = \"\" + (reason || \"\");\n      this.wasClean = wasClean ? Boolean(wasClean) : false;\n    }\n    if (EventPrototype$$1)\n      CloseEvent2.__proto__ = EventPrototype$$1;\n    CloseEvent2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    CloseEvent2.prototype.constructor = CloseEvent2;\n    return CloseEvent2;\n  }(EventPrototype);\n  function createEvent(config) {\n    var type = config.type;\n    var target = config.target;\n    var eventObject = new Event(type);\n    if (target) {\n      eventObject.target = target;\n      eventObject.srcElement = target;\n      eventObject.currentTarget = target;\n    }\n    return eventObject;\n  }\n  function createMessageEvent(config) {\n    var type = config.type;\n    var origin = config.origin;\n    var data = config.data;\n    var target = config.target;\n    var messageEvent = new MessageEvent(type, {\n      data,\n      origin\n    });\n    if (target) {\n      messageEvent.target = target;\n      messageEvent.srcElement = target;\n      messageEvent.currentTarget = target;\n    }\n    return messageEvent;\n  }\n  function createCloseEvent(config) {\n    var code = config.code;\n    var reason = config.reason;\n    var type = config.type;\n    var target = config.target;\n    var wasClean = config.wasClean;\n    if (!wasClean) {\n      wasClean = code === CLOSE_CODES.CLOSE_NORMAL || code === CLOSE_CODES.CLOSE_NO_STATUS;\n    }\n    var closeEvent = new CloseEvent(type, {\n      code,\n      reason,\n      wasClean\n    });\n    if (target) {\n      closeEvent.target = target;\n      closeEvent.srcElement = target;\n      closeEvent.currentTarget = target;\n    }\n    return closeEvent;\n  }\n  function closeWebSocketConnection(context, code, reason) {\n    context.readyState = WebSocket$1.CLOSING;\n    var server = networkBridge.serverLookup(context.url);\n    var closeEvent = createCloseEvent({\n      type: \"close\",\n      target: context.target,\n      code,\n      reason\n    });\n    delay(function() {\n      networkBridge.removeWebSocket(context, context.url);\n      context.readyState = WebSocket$1.CLOSED;\n      context.dispatchEvent(closeEvent);\n      if (server) {\n        server.dispatchEvent(closeEvent, server);\n      }\n    }, context);\n  }\n  function failWebSocketConnection(context, code, reason) {\n    context.readyState = WebSocket$1.CLOSING;\n    var server = networkBridge.serverLookup(context.url);\n    var closeEvent = createCloseEvent({\n      type: \"close\",\n      target: context.target,\n      code,\n      reason,\n      wasClean: false\n    });\n    var errorEvent = createEvent({\n      type: \"error\",\n      target: context.target\n    });\n    delay(function() {\n      networkBridge.removeWebSocket(context, context.url);\n      context.readyState = WebSocket$1.CLOSED;\n      context.dispatchEvent(errorEvent);\n      context.dispatchEvent(closeEvent);\n      if (server) {\n        server.dispatchEvent(closeEvent, server);\n      }\n    }, context);\n  }\n  function normalizeSendData(data) {\n    if (Object.prototype.toString.call(data) !== \"[object Blob]\" && !(data instanceof ArrayBuffer)) {\n      data = String(data);\n    }\n    return data;\n  }\n  var proxies = /* @__PURE__ */ new WeakMap();\n  function proxyFactory(target) {\n    if (proxies.has(target)) {\n      return proxies.get(target);\n    }\n    var proxy = new Proxy(target, {\n      get: function get(obj, prop) {\n        if (prop === \"close\") {\n          return function close(options) {\n            if (options === void 0)\n              options = {};\n            var code = options.code || CLOSE_CODES.CLOSE_NORMAL;\n            var reason = options.reason || \"\";\n            closeWebSocketConnection(proxy, code, reason);\n          };\n        }\n        if (prop === \"send\") {\n          return function send(data) {\n            data = normalizeSendData(data);\n            target.dispatchEvent(\n              createMessageEvent({\n                type: \"message\",\n                data,\n                origin: this.url,\n                target\n              })\n            );\n          };\n        }\n        var toSocketName = function(type) {\n          return type === \"message\" ? \"server::\" + type : type;\n        };\n        if (prop === \"on\") {\n          return function onWrapper(type, cb) {\n            target.addEventListener(toSocketName(type), cb);\n          };\n        }\n        if (prop === \"off\") {\n          return function offWrapper(type, cb) {\n            target.removeEventListener(toSocketName(type), cb);\n          };\n        }\n        if (prop === \"target\") {\n          return target;\n        }\n        return obj[prop];\n      }\n    });\n    proxies.set(target, proxy);\n    return proxy;\n  }\n  function lengthInUtf8Bytes(str) {\n    var m = encodeURIComponent(str).match(/%[89ABab]/g);\n    return str.length + (m ? m.length : 0);\n  }\n  function urlVerification(url) {\n    var urlRecord = new urlParse(url);\n    var pathname = urlRecord.pathname;\n    var protocol = urlRecord.protocol;\n    var hash = urlRecord.hash;\n    if (!url) {\n      throw new TypeError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" 1 argument required, but only 0 present.\");\n    }\n    if (!pathname) {\n      urlRecord.pathname = \"/\";\n    }\n    if (protocol === \"\") {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL '\" + urlRecord.toString() + \"' is invalid.\");\n    }\n    if (protocol !== \"ws:\" && protocol !== \"wss:\") {\n      throw new SyntaxError(\n        ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL's scheme must be either 'ws' or 'wss'. '\" + protocol + \"' is not allowed.\"\n      );\n    }\n    if (hash !== \"\") {\n      throw new SyntaxError(\n        ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL contains a fragment identifier ('\" + hash + \"'). Fragment identifiers are not allowed in WebSocket URLs.\"\n      );\n    }\n    return urlRecord.toString();\n  }\n  function protocolVerification(protocols) {\n    if (protocols === void 0)\n      protocols = [];\n    if (!Array.isArray(protocols) && typeof protocols !== \"string\") {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The subprotocol '\" + protocols.toString() + \"' is invalid.\");\n    }\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n    var uniq = protocols.map(function(p) {\n      return { count: 1, protocol: p };\n    }).reduce(function(a, b) {\n      a[b.protocol] = (a[b.protocol] || 0) + b.count;\n      return a;\n    }, {});\n    var duplicates = Object.keys(uniq).filter(function(a) {\n      return uniq[a] > 1;\n    });\n    if (duplicates.length > 0) {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The subprotocol '\" + duplicates[0] + \"' is duplicated.\");\n    }\n    return protocols;\n  }\n  var WebSocket$1 = function(EventTarget$$1) {\n    function WebSocket2(url, protocols) {\n      EventTarget$$1.call(this);\n      this._onopen = null;\n      this._onmessage = null;\n      this._onerror = null;\n      this._onclose = null;\n      this.url = urlVerification(url);\n      protocols = protocolVerification(protocols);\n      this.protocol = protocols[0] || \"\";\n      this.binaryType = \"blob\";\n      this.readyState = WebSocket2.CONNECTING;\n      var client = proxyFactory(this);\n      var server = networkBridge.attachWebSocket(client, this.url);\n      delay(function delayCallback() {\n        if (this.readyState !== WebSocket2.CONNECTING) {\n          return;\n        }\n        if (server) {\n          if (server.options.verifyClient && typeof server.options.verifyClient === \"function\" && !server.options.verifyClient()) {\n            this.readyState = WebSocket2.CLOSED;\n            log(\n              \"error\",\n              \"WebSocket connection to '\" + this.url + \"' failed: HTTP Authentication failed; no valid credentials available\"\n            );\n            networkBridge.removeWebSocket(client, this.url);\n            this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n            this.dispatchEvent(createCloseEvent({ type: \"close\", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n          } else {\n            if (server.options.selectProtocol && typeof server.options.selectProtocol === \"function\") {\n              var selectedProtocol = server.options.selectProtocol(protocols);\n              var isFilled = selectedProtocol !== \"\";\n              var isRequested = protocols.indexOf(selectedProtocol) !== -1;\n              if (isFilled && !isRequested) {\n                this.readyState = WebSocket2.CLOSED;\n                log(\"error\", \"WebSocket connection to '\" + this.url + \"' failed: Invalid Sub-Protocol\");\n                networkBridge.removeWebSocket(client, this.url);\n                this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n                this.dispatchEvent(createCloseEvent({ type: \"close\", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n                return;\n              }\n              this.protocol = selectedProtocol;\n            }\n            this.readyState = WebSocket2.OPEN;\n            this.dispatchEvent(createEvent({ type: \"open\", target: this }));\n            server.dispatchEvent(createEvent({ type: \"connection\" }), client);\n          }\n        } else {\n          this.readyState = WebSocket2.CLOSED;\n          this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n          this.dispatchEvent(createCloseEvent({ type: \"close\", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n          log(\"error\", \"WebSocket connection to '\" + this.url + \"' failed\");\n        }\n      }, this);\n    }\n    if (EventTarget$$1)\n      WebSocket2.__proto__ = EventTarget$$1;\n    WebSocket2.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    WebSocket2.prototype.constructor = WebSocket2;\n    var prototypeAccessors = { onopen: {}, onmessage: {}, onclose: {}, onerror: {} };\n    prototypeAccessors.onopen.get = function() {\n      return this._onopen;\n    };\n    prototypeAccessors.onmessage.get = function() {\n      return this._onmessage;\n    };\n    prototypeAccessors.onclose.get = function() {\n      return this._onclose;\n    };\n    prototypeAccessors.onerror.get = function() {\n      return this._onerror;\n    };\n    prototypeAccessors.onopen.set = function(listener) {\n      this.removeEventListener(\"open\", this._onopen);\n      this._onopen = listener;\n      this.addEventListener(\"open\", listener);\n    };\n    prototypeAccessors.onmessage.set = function(listener) {\n      this.removeEventListener(\"message\", this._onmessage);\n      this._onmessage = listener;\n      this.addEventListener(\"message\", listener);\n    };\n    prototypeAccessors.onclose.set = function(listener) {\n      this.removeEventListener(\"close\", this._onclose);\n      this._onclose = listener;\n      this.addEventListener(\"close\", listener);\n    };\n    prototypeAccessors.onerror.set = function(listener) {\n      this.removeEventListener(\"error\", this._onerror);\n      this._onerror = listener;\n      this.addEventListener(\"error\", listener);\n    };\n    WebSocket2.prototype.send = function send(data) {\n      var this$1 = this;\n      if (this.readyState === WebSocket2.CONNECTING) {\n        throw new Error(\"Failed to execute 'send' on 'WebSocket': Still in CONNECTING state\");\n      }\n      var messageEvent = createMessageEvent({\n        type: \"server::message\",\n        origin: this.url,\n        data: normalizeSendData(data)\n      });\n      var server = networkBridge.serverLookup(this.url);\n      if (server) {\n        delay(function() {\n          this$1.dispatchEvent(messageEvent, data);\n        }, server);\n      }\n    };\n    WebSocket2.prototype.close = function close(code, reason) {\n      if (code !== void 0) {\n        if (typeof code !== \"number\" || code !== 1e3 && (code < 3e3 || code > 4999)) {\n          throw new TypeError(\n            ERROR_PREFIX.CLOSE_ERROR + \" The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\"\n          );\n        }\n      }\n      if (reason !== void 0) {\n        var length = lengthInUtf8Bytes(reason);\n        if (length > 123) {\n          throw new SyntaxError(ERROR_PREFIX.CLOSE_ERROR + \" The message must not be greater than 123 bytes.\");\n        }\n      }\n      if (this.readyState === WebSocket2.CLOSING || this.readyState === WebSocket2.CLOSED) {\n        return;\n      }\n      var client = proxyFactory(this);\n      if (this.readyState === WebSocket2.CONNECTING) {\n        failWebSocketConnection(client, code || CLOSE_CODES.CLOSE_ABNORMAL, reason);\n      } else {\n        closeWebSocketConnection(client, code || CLOSE_CODES.CLOSE_NO_STATUS, reason);\n      }\n    };\n    Object.defineProperties(WebSocket2.prototype, prototypeAccessors);\n    return WebSocket2;\n  }(EventTarget);\n  WebSocket$1.CONNECTING = 0;\n  WebSocket$1.prototype.CONNECTING = WebSocket$1.CONNECTING;\n  WebSocket$1.OPEN = 1;\n  WebSocket$1.prototype.OPEN = WebSocket$1.OPEN;\n  WebSocket$1.CLOSING = 2;\n  WebSocket$1.prototype.CLOSING = WebSocket$1.CLOSING;\n  WebSocket$1.CLOSED = 3;\n  WebSocket$1.prototype.CLOSED = WebSocket$1.CLOSED;\n  var SocketIO$1 = function(EventTarget$$1) {\n    function SocketIO(url, protocol) {\n      var this$1 = this;\n      if (url === void 0)\n        url = \"socket.io\";\n      if (protocol === void 0)\n        protocol = \"\";\n      EventTarget$$1.call(this);\n      this.binaryType = \"blob\";\n      var urlRecord = new urlParse(url);\n      if (!urlRecord.pathname) {\n        urlRecord.pathname = \"/\";\n      }\n      this.url = urlRecord.toString();\n      this.readyState = SocketIO.CONNECTING;\n      this.protocol = \"\";\n      this.target = this;\n      if (typeof protocol === \"string\" || typeof protocol === \"object\" && protocol !== null) {\n        this.protocol = protocol;\n      } else if (Array.isArray(protocol) && protocol.length > 0) {\n        this.protocol = protocol[0];\n      }\n      var server = networkBridge.attachWebSocket(this, this.url);\n      delay(function delayCallback() {\n        if (server) {\n          this.readyState = SocketIO.OPEN;\n          server.dispatchEvent(createEvent({ type: \"connection\" }), server, this);\n          server.dispatchEvent(createEvent({ type: \"connect\" }), server, this);\n          this.dispatchEvent(createEvent({ type: \"connect\", target: this }));\n        } else {\n          this.readyState = SocketIO.CLOSED;\n          this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n          this.dispatchEvent(\n            createCloseEvent({\n              type: \"close\",\n              target: this,\n              code: CLOSE_CODES.CLOSE_NORMAL\n            })\n          );\n          log(\"error\", \"Socket.io connection to '\" + this.url + \"' failed\");\n        }\n      }, this);\n      this.addEventListener(\"close\", function(event) {\n        this$1.dispatchEvent(\n          createCloseEvent({\n            type: \"disconnect\",\n            target: event.target,\n            code: event.code\n          })\n        );\n      });\n    }\n    if (EventTarget$$1)\n      SocketIO.__proto__ = EventTarget$$1;\n    SocketIO.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    SocketIO.prototype.constructor = SocketIO;\n    var prototypeAccessors = { broadcast: {} };\n    SocketIO.prototype.close = function close() {\n      if (this.readyState !== SocketIO.OPEN) {\n        return void 0;\n      }\n      var server = networkBridge.serverLookup(this.url);\n      networkBridge.removeWebSocket(this, this.url);\n      this.readyState = SocketIO.CLOSED;\n      this.dispatchEvent(\n        createCloseEvent({\n          type: \"close\",\n          target: this,\n          code: CLOSE_CODES.CLOSE_NORMAL\n        })\n      );\n      if (server) {\n        server.dispatchEvent(\n          createCloseEvent({\n            type: \"disconnect\",\n            target: this,\n            code: CLOSE_CODES.CLOSE_NORMAL\n          }),\n          server\n        );\n      }\n      return this;\n    };\n    SocketIO.prototype.disconnect = function disconnect() {\n      return this.close();\n    };\n    SocketIO.prototype.emit = function emit(event) {\n      var data = [], len = arguments.length - 1;\n      while (len-- > 0)\n        data[len] = arguments[len + 1];\n      if (this.readyState !== SocketIO.OPEN) {\n        throw new Error(\"SocketIO is already in CLOSING or CLOSED state\");\n      }\n      var messageEvent = createMessageEvent({\n        type: event,\n        origin: this.url,\n        data\n      });\n      var server = networkBridge.serverLookup(this.url);\n      if (server) {\n        server.dispatchEvent.apply(server, [messageEvent].concat(data));\n      }\n      return this;\n    };\n    SocketIO.prototype.send = function send(data) {\n      this.emit(\"message\", data);\n      return this;\n    };\n    prototypeAccessors.broadcast.get = function() {\n      if (this.readyState !== SocketIO.OPEN) {\n        throw new Error(\"SocketIO is already in CLOSING or CLOSED state\");\n      }\n      var self2 = this;\n      var server = networkBridge.serverLookup(this.url);\n      if (!server) {\n        throw new Error(\"SocketIO can not find a server at the specified URL (\" + this.url + \")\");\n      }\n      return {\n        emit: function emit(event, data) {\n          server.emit(event, data, { websockets: networkBridge.websocketsLookup(self2.url, null, self2) });\n          return self2;\n        },\n        to: function to(room) {\n          return server.to(room, self2);\n        },\n        in: function in$1(room) {\n          return server.in(room, self2);\n        }\n      };\n    };\n    SocketIO.prototype.on = function on(type, callback) {\n      this.addEventListener(type, callback);\n      return this;\n    };\n    SocketIO.prototype.off = function off(type, callback) {\n      this.removeEventListener(type, callback);\n    };\n    SocketIO.prototype.hasListeners = function hasListeners(type) {\n      var listeners = this.listeners[type];\n      if (!Array.isArray(listeners)) {\n        return false;\n      }\n      return !!listeners.length;\n    };\n    SocketIO.prototype.join = function join(room) {\n      networkBridge.addMembershipToRoom(this, room);\n    };\n    SocketIO.prototype.leave = function leave(room) {\n      networkBridge.removeMembershipFromRoom(this, room);\n    };\n    SocketIO.prototype.to = function to(room) {\n      return this.broadcast.to(room);\n    };\n    SocketIO.prototype.in = function in$1() {\n      return this.to.apply(null, arguments);\n    };\n    SocketIO.prototype.dispatchEvent = function dispatchEvent(event) {\n      var this$1 = this;\n      var customArguments = [], len = arguments.length - 1;\n      while (len-- > 0)\n        customArguments[len] = arguments[len + 1];\n      var eventName = event.type;\n      var listeners = this.listeners[eventName];\n      if (!Array.isArray(listeners)) {\n        return false;\n      }\n      listeners.forEach(function(listener) {\n        if (customArguments.length > 0) {\n          listener.apply(this$1, customArguments);\n        } else {\n          listener.call(this$1, event.data ? event.data : event);\n        }\n      });\n    };\n    Object.defineProperties(SocketIO.prototype, prototypeAccessors);\n    return SocketIO;\n  }(EventTarget);\n  SocketIO$1.CONNECTING = 0;\n  SocketIO$1.OPEN = 1;\n  SocketIO$1.CLOSING = 2;\n  SocketIO$1.CLOSED = 3;\n  var IO = function ioConstructor(url, protocol) {\n    return new SocketIO$1(url, protocol);\n  };\n  IO.connect = function ioConnect(url, protocol) {\n    return IO(url, protocol);\n  };\n  var dedupe = function(arr) {\n    return arr.reduce(function(deduped, b) {\n      if (deduped.indexOf(b) > -1) {\n        return deduped;\n      }\n      return deduped.concat(b);\n    }, []);\n  };\n  function retrieveGlobalObject() {\n    if (typeof window !== \"undefined\") {\n      return window;\n    }\n    return typeof process === \"object\" && \"function\" === \"function\" && typeof __webpack_require__.g === \"object\" ? __webpack_require__.g : this;\n  }\n  var defaultOptions = {\n    mock: true,\n    verifyClient: null,\n    selectProtocol: null\n  };\n  var Server$1 = function(EventTarget$$1) {\n    function Server2(url, options) {\n      if (options === void 0)\n        options = defaultOptions;\n      EventTarget$$1.call(this);\n      var urlRecord = new urlParse(url);\n      if (!urlRecord.pathname) {\n        urlRecord.pathname = \"/\";\n      }\n      this.url = urlRecord.toString();\n      this.originalWebSocket = null;\n      var server = networkBridge.attachServer(this, this.url);\n      if (!server) {\n        this.dispatchEvent(createEvent({ type: \"error\" }));\n        throw new Error(\"A mock server is already listening on this url\");\n      }\n      this.options = Object.assign({}, defaultOptions, options);\n      if (this.options.mock) {\n        this.mockWebsocket();\n      }\n    }\n    if (EventTarget$$1)\n      Server2.__proto__ = EventTarget$$1;\n    Server2.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    Server2.prototype.constructor = Server2;\n    Server2.prototype.mockWebsocket = function mockWebsocket() {\n      var globalObj = retrieveGlobalObject();\n      this.originalWebSocket = globalObj.WebSocket;\n      globalObj.WebSocket = WebSocket$1;\n    };\n    Server2.prototype.restoreWebsocket = function restoreWebsocket() {\n      var globalObj = retrieveGlobalObject();\n      if (this.originalWebSocket !== null) {\n        globalObj.WebSocket = this.originalWebSocket;\n      }\n      this.originalWebSocket = null;\n    };\n    Server2.prototype.stop = function stop(callback) {\n      if (callback === void 0)\n        callback = function() {\n        };\n      if (this.options.mock) {\n        this.restoreWebsocket();\n      }\n      networkBridge.removeServer(this.url);\n      if (typeof callback === \"function\") {\n        callback();\n      }\n    };\n    Server2.prototype.on = function on(type, callback) {\n      this.addEventListener(type, callback);\n    };\n    Server2.prototype.off = function off(type, callback) {\n      this.removeEventListener(type, callback);\n    };\n    Server2.prototype.close = function close(options) {\n      if (options === void 0)\n        options = {};\n      var code = options.code;\n      var reason = options.reason;\n      var wasClean = options.wasClean;\n      var listeners = networkBridge.websocketsLookup(this.url);\n      networkBridge.removeServer(this.url);\n      listeners.forEach(function(socket) {\n        socket.readyState = WebSocket$1.CLOSED;\n        socket.dispatchEvent(\n          createCloseEvent({\n            type: \"close\",\n            target: socket.target,\n            code: code || CLOSE_CODES.CLOSE_NORMAL,\n            reason: reason || \"\",\n            wasClean\n          })\n        );\n      });\n      this.dispatchEvent(createCloseEvent({ type: \"close\" }), this);\n    };\n    Server2.prototype.emit = function emit(event, data, options) {\n      var this$1 = this;\n      if (options === void 0)\n        options = {};\n      var websockets = options.websockets;\n      if (!websockets) {\n        websockets = networkBridge.websocketsLookup(this.url);\n      }\n      var normalizedData;\n      if (typeof options !== \"object\" || arguments.length > 3) {\n        data = Array.prototype.slice.call(arguments, 1, arguments.length);\n        normalizedData = data.map(function(item) {\n          return normalizeSendData(item);\n        });\n      } else {\n        normalizedData = normalizeSendData(data);\n      }\n      websockets.forEach(function(socket) {\n        var messageData = socket instanceof SocketIO$1 ? data : normalizedData;\n        if (Array.isArray(messageData)) {\n          socket.dispatchEvent.apply(\n            socket,\n            [createMessageEvent({\n              type: event,\n              data: messageData,\n              origin: this$1.url,\n              target: socket.target\n            })].concat(messageData)\n          );\n        } else {\n          socket.dispatchEvent(\n            createMessageEvent({\n              type: event,\n              data: messageData,\n              origin: this$1.url,\n              target: socket.target\n            })\n          );\n        }\n      });\n    };\n    Server2.prototype.clients = function clients() {\n      return networkBridge.websocketsLookup(this.url);\n    };\n    Server2.prototype.to = function to(room, broadcaster, broadcastList) {\n      var this$1 = this;\n      if (broadcastList === void 0)\n        broadcastList = [];\n      var self2 = this;\n      var websockets = dedupe(broadcastList.concat(networkBridge.websocketsLookup(this.url, room, broadcaster)));\n      return {\n        to: function(chainedRoom, chainedBroadcaster) {\n          return this$1.to.call(this$1, chainedRoom, chainedBroadcaster, websockets);\n        },\n        emit: function emit(event, data) {\n          self2.emit(event, data, { websockets });\n        }\n      };\n    };\n    Server2.prototype.in = function in$1() {\n      var args = [], len = arguments.length;\n      while (len--)\n        args[len] = arguments[len];\n      return this.to.apply(null, args);\n    };\n    Server2.prototype.simulate = function simulate(event) {\n      var listeners = networkBridge.websocketsLookup(this.url);\n      if (event === \"error\") {\n        listeners.forEach(function(socket) {\n          socket.readyState = WebSocket$1.CLOSED;\n          socket.dispatchEvent(createEvent({ type: \"error\", target: socket.target }));\n        });\n      }\n    };\n    return Server2;\n  }(EventTarget);\n  Server$1.of = function of(url) {\n    return new Server$1(url);\n  };\n  var Server = Server$1;\n  var WebSocket = WebSocket$1;\n  var SocketIO$$1 = IO;\n  exports2.Server = Server;\n  exports2.WebSocket = WebSocket;\n  exports2.SocketIO = SocketIO$$1;\n  Object.defineProperty(exports2, \"__esModule\", { value: true });\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/mock-socket/dist/mock-socket.js?");

/***/ }),

/***/ "./src/hypha-core.js":
/*!***************************!*\
  !*** ./src/hypha-core.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HyphaCore: () => (/* binding */ HyphaCore),\n/* harmony export */   WebSocket: () => (/* reexport safe */ mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket),\n/* harmony export */   WebsocketRPCConnection: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.WebsocketRPCConnection),\n/* harmony export */   Workspace: () => (/* reexport safe */ _workspace_js__WEBPACK_IMPORTED_MODULE_3__.Workspace),\n/* harmony export */   connectToServer: () => (/* binding */ connectToServer),\n/* harmony export */   hyphaWebsocketClient: () => (/* reexport safe */ hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient),\n/* harmony export */   imjoyRPC: () => (/* binding */ getImjoyRPC)\n/* harmony export */ });\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mock-socket */ \"./node_modules/mock-socket/dist/mock-socket.js\");\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mock_socket__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/index.js */ \"./src/utils/index.js\");\n/* harmony import */ var _workspace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./workspace.js */ \"./src/workspace.js\");\n/* harmony import */ var _utils_redis_mock_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/redis-mock.js */ \"./src/utils/redis-mock.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\n\n\n\n\nconst connectToServer = hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.connectToServer;\nconst AUTH0_NAMESPACE = \"https://api.imjoy.io/\";\nfunction base64UrlEncode(data) {\n  if (typeof btoa !== \"undefined\") {\n    const base64 = btoa(\n      typeof data === \"string\" ? data : String.fromCharCode(...new Uint8Array(data))\n    );\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  } else if (typeof Buffer !== \"undefined\") {\n    const buffer = typeof data === \"string\" ? Buffer.from(data) : Buffer.from(data);\n    const base64 = buffer.toString(\"base64\");\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  } else {\n    throw new Error(\"Base64 encoding not available in current environment\");\n  }\n}\nfunction base64UrlDecode(base64Url) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  if (typeof atob !== \"undefined\") {\n    return atob(base64);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(base64, \"base64\").toString(\"binary\");\n  } else {\n    throw new Error(\"Base64 decoding not available in current environment\");\n  }\n}\nasync function hmacSha256(key, data) {\n  if (typeof crypto !== \"undefined\" && crypto.subtle) {\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(key);\n    const msgData = encoder.encode(data);\n    const cryptoKey = await crypto.subtle.importKey(\n      \"raw\",\n      keyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\"]\n    );\n    const signature = await crypto.subtle.sign(\"HMAC\", cryptoKey, msgData);\n    return new Uint8Array(signature);\n  } else {\n    throw new Error(\"JWT HS256 signing requires Web Crypto API (browser) or crypto module (Node.js/Deno)\");\n  }\n}\nasync function verifyJWT(token, secret) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  const [encodedHeader, encodedPayload, encodedSignature] = parts;\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  try {\n    const header = JSON.parse(base64UrlDecode(encodedHeader));\n    if (header.alg !== \"HS256\") {\n      throw new Error(\"Unsupported algorithm\");\n    }\n    const expectedSignature = await hmacSha256(secret, unsigned);\n    const actualSignature = new Uint8Array(\n      Array.from(base64UrlDecode(encodedSignature)).map((c) => c.charCodeAt(0))\n    );\n    if (expectedSignature.length !== actualSignature.length) {\n      throw new Error(\"Invalid signature\");\n    }\n    for (let i = 0; i < expectedSignature.length; i++) {\n      if (expectedSignature[i] !== actualSignature[i]) {\n        throw new Error(\"Invalid signature\");\n      }\n    }\n    const payload = JSON.parse(base64UrlDecode(encodedPayload));\n    if (payload.exp && Date.now() / 1e3 > payload.exp) {\n      throw new Error(\"Token expired\");\n    }\n    return payload;\n  } catch (error) {\n    throw new Error(`JWT verification failed: ${error.message}`);\n  }\n}\nasync function generateJWT(payload, secret) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await hmacSha256(secret, unsigned);\n  const encodedSignature = base64UrlEncode(signature);\n  return `${unsigned}.${encodedSignature}`;\n}\nconst _HyphaCore = class _HyphaCore extends _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.MessageEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.redis = _utils_redis_mock_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n    this.port = config.port || 8080;\n    if (config.host) {\n      this.host = config.host;\n    } else if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n      this.host = \"local-hypha-server\";\n    } else {\n      this.host = \"localhost\";\n    }\n    this.baseUrl = config.baseUrl || config.base_url || _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.getSafeBaseUrl();\n    if (!this.baseUrl.endsWith(\"/\")) {\n      this.baseUrl += \"/\";\n    }\n    if (config.url && config.port) {\n      throw new Error(\"Please provide either url or port, not both.\");\n    }\n    this.ServerClass = config.ServerClass || mock_socket__WEBPACK_IMPORTED_MODULE_0__.Server;\n    this.WebSocketClass = config.WebSocketClass || mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket;\n    if (config.url && (config.url.startsWith(\"wss://\") || config.url.startsWith(\"ws://\"))) {\n      if (!config.url.endsWith(\"/ws\")) {\n        throw new Error(\"Please provide a valid wss url ending with /ws\");\n      }\n      this.url = config.url.replace(\"wss://\", \"https://\").replace(\"ws://\", \"http://\").slice(0, -3);\n      this.wsUrl = config.url;\n    } else {\n      this.url = config.url || `https://${this.host}:${this.port}`;\n      this.wsUrl = this.url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\") + \"/ws\";\n    }\n    this.api = null;\n    this.server = null;\n    this.workspaceManagerId = \"workspace-manager\";\n    this.connections = {};\n    const defaultServices = config.defaultService || config.default_service || {};\n    if (defaultServices && typeof defaultServices === \"object\" && Object.keys(defaultServices).length > 0) {\n      this.defaultServices = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.convertToSnakeCase)(defaultServices);\n      console.debug(\"\\u{1F527} Converted defaultService methods to snake_case for compatibility\");\n    } else {\n      this.defaultServices = defaultServices;\n    }\n    this.imjoyPluginWindows = /* @__PURE__ */ new Map();\n    this.jwtSecret = config.jwtSecret || \"hypha-core-default-secret-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n    this.environment = _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.getEnvironment();\n    this.on(\"add_window\", (config2) => {\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n        console.log(\"Creating window: \", config2);\n      } else {\n        console.warn(`Window creation requested but not supported in ${this.environment} environment:`, config2);\n      }\n    });\n  }\n  async emit(event, data) {\n    this._fire(event, data);\n  }\n  async _handleImJoyPlugin(event) {\n    if (!_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n      console.warn(\"ImJoy plugin handling is only supported in browser environments\");\n      return;\n    }\n    let imjoyRPC;\n    try {\n      const imjoyModule = await __webpack_require__.e(/*! import() */ \"vendors-node_modules_imjoy-rpc_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! imjoy-rpc */ \"./node_modules/imjoy-rpc/index.js\", 23));\n      imjoyRPC = imjoyModule.imjoyRPC;\n    } catch (error) {\n      console.error(\"Failed to load imjoy-rpc:\", error);\n      return;\n    }\n    const contentWindow = event.source;\n    const data = event.data;\n    let cid = null;\n    for (const [key, value] of Object.entries(this.connections)) {\n      if (value.source === contentWindow) {\n        cid = key;\n        break;\n      }\n    }\n    if (!cid) {\n      console.error(\"Client id not found for the plugin: \", data);\n      return;\n    }\n    const defaultService = this.workspaceManager.getDefaultService();\n    const coreInterface = {};\n    for (const key in defaultService) {\n      const camelKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toCamelCase)(key);\n      if (typeof defaultService[key] === \"function\") {\n        coreInterface[camelKey] = async (...args) => {\n          const context = {\n            ws: this.connections[cid].workspace,\n            from: `${cid}`,\n            to: `${this.connections[cid].workspace}/${this.workspaceManagerId}`,\n            user: this.connections[cid].user || {\n              id: \"anonymous\",\n              is_anonymous: true,\n              email: \"anonymous@imjoy.io\",\n              roles: [],\n              scopes: []\n            }\n          };\n          return await defaultService[key](...args, context);\n        };\n      } else {\n        coreInterface[camelKey] = defaultService[key];\n      }\n    }\n    const coreConnection = {\n      peer_id: data.peer_id,\n      fire(m) {\n        if (coreConnection._messageHandler[m.type]) {\n          coreConnection._messageHandler[m.type](m);\n        }\n      },\n      disconnect: function() {\n      },\n      emit: (msg) => {\n        msg.peer_id = coreConnection.peer_id;\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.safePostMessage(contentWindow, msg, \"*\");\n      },\n      on: function(event2, handler) {\n        coreConnection._messageHandler[event2] = handler;\n      },\n      _messageHandler: {},\n      async execute(code) {\n        coreConnection.emit({ type: \"execute\", code });\n      }\n    };\n    const pluginConfig = data.config;\n    if (data.error) {\n      console.error(\"Failed to initialize the plugin\", data.error);\n      return;\n    }\n    if (!data.peer_id) {\n      throw \"Please provide a peer_id for the connection.\";\n    }\n    this.imjoyPluginWindows.set(\n      event.source,\n      {\n        coreConnection,\n        cid\n      }\n    );\n    console.log(\"plugin initialized:\", pluginConfig);\n    const core = new imjoyRPC.RPC(coreConnection, { name: \"core\" });\n    core.setInterface(coreInterface);\n    core.on(\"interfaceSetAsRemote\", () => {\n      core.on(\"remoteReady\", async () => {\n        const api = core.getRemote();\n        api.id = `${cid}:default`;\n        api.type = \"imjoy\";\n        await this.workspaceManager.eventBus.emit(\"service_added\", api);\n      });\n      core.requestRemote();\n    });\n    core.sendInterface();\n  }\n  _handleClientMessage(event) {\n    if (event.data && event.data.type === \"hyphaClientReady\") {\n      const sourceToMatch = event.source || event.currentTarget;\n      let found = false;\n      for (const key in this.connections) {\n        const conn = this.connections[key];\n        if (conn.source === sourceToMatch) {\n          console.log(`\\u2705 [DEBUG] Found matching connection: ${key}`);\n          this.emit(\"connection_ready\", conn);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        console.error(\"\\u274C [DEBUG] No matching connection found for hyphaClientReady message!\");\n      }\n    }\n    const workspace = event.data.workspace;\n    if (!workspace) {\n      if (event.data.type === \"initialized\") {\n        this._handleImJoyPlugin(event).catch((error) => {\n          console.error(\"Error handling ImJoy plugin:\", error);\n        });\n      } else if (this.imjoyPluginWindows.has(event.source)) {\n        const coreConnection = this.imjoyPluginWindows.get(event.source).coreConnection;\n        coreConnection.fire(event.data);\n      }\n      return;\n    }\n    const clientId = event.data.from;\n    if (!clientId || !this.connections[workspace + \"/\" + clientId]) {\n      console.warn(\"Connection not found for client: \", clientId);\n      return;\n    }\n    const connection = this.connections[workspace + \"/\" + clientId];\n    const ws = connection.websocket;\n    if (event.data.type === \"message\") {\n      ws.send(event.data.data);\n    } else if (event.data.type === \"close\") {\n      ws.close();\n    } else if (event.data.type === \"connect\") {\n      const ws2 = new this.WebSocketClass(event.data.url);\n      ws2.onmessage = (evt) => {\n        connection.postMessage({ type: \"message\", data: evt.data, to: clientId });\n      };\n      ws2.onopen = () => {\n        connection.postMessage({ type: \"connected\", to: clientId });\n      };\n      ws2.onclose = () => {\n        connection.postMessage({ type: \"closed\", to: clientId });\n      };\n      connection.websocket = ws2;\n    }\n  }\n  async start(config) {\n    if (_HyphaCore.servers[this.url]) {\n      throw new Error(`Server already running at ${this.url}`);\n    } else {\n      const serverOptions = {\n        mock: false,\n        hyphaCore: this\n        // Enable HTTP service proxy functionality\n      };\n      this.server = new this.ServerClass(this.wsUrl, serverOptions);\n      _HyphaCore.servers[this.url] = this.server;\n      this.messageHandler = this._handleClientMessage.bind(this);\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.safeAddEventListener(window, \"message\", this.messageHandler);\n      } else {\n        console.log(`Running in ${this.environment} environment - window message handling disabled`);\n      }\n    }\n    this.server.on(\"connection\", async (websocket) => {\n      await this._handleWebsocketConnection(websocket);\n    });\n    config = config || {};\n    config.server = this;\n    config.WebSocketClass = this.WebSocketClass;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(config.workspace === void 0, \"workspace is not allowed to be set in the config\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(config.client_id === void 0, \"client_id is not allowed to be set in the config\");\n    this.workspaceManager = new _workspace_js__WEBPACK_IMPORTED_MODULE_3__.Workspace(this);\n    await this.workspaceManager.setup({\n      client_id: this.workspaceManagerId,\n      method_timeout: 60,\n      default_service: this.defaultServices\n    });\n    const api = this._createDirectAPIWrapper();\n    this.api = api;\n    return api;\n  }\n  async _handleWebsocketConnection(websocket) {\n    let authConfig = {};\n    let userInfo;\n    let workspace;\n    let clientId;\n    try {\n      const authData = await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error(\"Authentication timeout\"));\n        }, 3e4);\n        websocket.on(\"message\", (data) => {\n          clearTimeout(timeout);\n          resolve(data);\n        });\n        websocket.on(\"error\", (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n        websocket.on(\"close\", () => {\n          clearTimeout(timeout);\n          reject(new Error(\"Connection closed during authentication\"));\n        });\n      });\n      try {\n        authConfig = JSON.parse(authData);\n      } catch (parseError) {\n        await this._disconnectWebsocket(websocket, \"Failed to decode authentication information\", 1003);\n        return;\n      }\n      if (authConfig.workspace === void 0 && authConfig.client_id === void 0 && authConfig.token === void 0) {\n        throw new Error(\"Authentication required: workspace, client_id, or token must be provided\");\n      }\n      const authResult = await this._authenticateUser(authConfig);\n      userInfo = authResult.userInfo;\n      workspace = authResult.workspace;\n      clientId = authConfig.client_id;\n      if (!workspace) {\n        workspace = \"workspace-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n      }\n      if (!clientId) {\n        clientId = \"client-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n      }\n      await this._checkClientPermissions(clientId, workspace, userInfo);\n      await this._establishWebsocketCommunication(websocket, workspace, clientId, userInfo);\n    } catch (error) {\n      console.error(\"WebSocket connection failed:\", error.message);\n      await this._disconnectWebsocket(websocket, `Failed to establish connection: ${error.message}`, 1001);\n    }\n  }\n  async _authenticateUser(authConfig) {\n    let userInfo;\n    let workspace = authConfig.workspace;\n    if (authConfig.token) {\n      try {\n        const payload = await verifyJWT(authConfig.token, this.jwtSecret);\n        userInfo = {\n          id: payload.sub || payload.user_id || \"anonymous\",\n          is_anonymous: !payload.email,\n          email: payload.email || \"\",\n          roles: payload.roles || [],\n          scopes: payload.scope ? payload.scope.split(\" \") : [],\n          expires_at: payload.exp\n        };\n        workspace = payload.workspace || authConfig.workspace || \"default\";\n      } catch (jwtError) {\n        try {\n          const info = parseJwt(authConfig.token);\n          const expiresAt = info[\"exp\"];\n          userInfo = {\n            id: info[\"sub\"],\n            is_anonymous: !info[AUTH0_NAMESPACE + \"email\"],\n            email: info[AUTH0_NAMESPACE + \"email\"],\n            roles: info[AUTH0_NAMESPACE + \"roles\"],\n            scopes: info[\"scope\"],\n            expires_at: expiresAt\n          };\n          workspace = info.workspace || authConfig.workspace || userInfo.id;\n        } catch (parseError) {\n          throw new Error(`Token verification failed: ${jwtError.message}`);\n        }\n      }\n    } else if (authConfig.reconnection_token) {\n      try {\n        const payload = await verifyJWT(authConfig.reconnection_token, this.jwtSecret);\n        userInfo = {\n          id: payload.sub || \"anonymous\",\n          is_anonymous: !payload.email,\n          email: payload.email || \"\",\n          roles: payload.roles || [],\n          scopes: payload.scope ? payload.scope.split(\" \") : [],\n          expires_at: payload.exp\n        };\n        workspace = payload.workspace || authConfig.workspace;\n        if (payload.client_id && authConfig.client_id && payload.client_id !== authConfig.client_id) {\n          throw new Error(\"Client ID mismatch during reconnection\");\n        }\n      } catch (error) {\n        throw new Error(`Reconnection token verification failed: ${error.message}`);\n      }\n    } else {\n      const anonymousUserId = \"anonymous-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n      userInfo = {\n        id: anonymousUserId,\n        is_anonymous: true,\n        email: \"anonymous@imjoy.io\",\n        roles: [],\n        scopes: []\n      };\n      const requestedWorkspace = authConfig.workspace;\n      if (!requestedWorkspace) {\n        workspace = anonymousUserId;\n      } else {\n        if (requestedWorkspace !== \"public\" && requestedWorkspace !== anonymousUserId) {\n          throw new Error(`Anonymous client attempted to access protected workspace: ${requestedWorkspace}`);\n        }\n        workspace = requestedWorkspace;\n      }\n    }\n    return { userInfo, workspace };\n  }\n  async _checkClientPermissions(clientId, workspace, userInfo) {\n    if (workspace === \"public\") {\n      return;\n    }\n    if (userInfo.is_anonymous && !workspace.startsWith(\"anonymous-\")) {\n      throw new Error(`Permission denied for workspace: ${workspace}`);\n    }\n  }\n  async _establishWebsocketCommunication(websocket, workspace, clientId, userInfo) {\n    const connectionKey = `${workspace}/${clientId}`;\n    if (!this._websockets) {\n      this._websockets = {};\n    }\n    this._websockets[connectionKey] = websocket;\n    try {\n      const conn = new _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.RedisRPCConnection(this, workspace, clientId, userInfo, this.workspaceManagerId);\n      conn.on_message((data) => {\n        if (websocket.readyState === websocket.OPEN) {\n          websocket.send(data);\n        }\n      });\n      const reconnectionToken = await this._generateReconnectionToken(userInfo, workspace, clientId);\n      const baseUrl = this.url.endsWith(\"/\") ? this.url.slice(0, -1) : this.url;\n      const connectionInfo = {\n        \"type\": \"connection_info\",\n        \"hypha_version\": \"0.1.0\",\n        \"public_base_url\": baseUrl,\n        \"local_base_url\": baseUrl,\n        \"manager_id\": this.workspaceManagerId,\n        \"workspace\": workspace,\n        \"client_id\": clientId,\n        \"user\": userInfo,\n        \"reconnection_token\": reconnectionToken,\n        \"reconnection_token_life_time\": 3600\n        // 1 hour\n      };\n      websocket.send(JSON.stringify(connectionInfo));\n      websocket.on(\"message\", async (data) => {\n        try {\n          if (typeof data === \"string\") {\n            if (data.length > 1e3) {\n              console.warn(`Ignoring long text message: ${data.substring(0, 1e3)}...`);\n              return;\n            }\n            const message = JSON.parse(data);\n            if (message.type === \"ping\") {\n              websocket.send(JSON.stringify({ type: \"pong\" }));\n            } else if (message.type === \"refresh_token\") {\n              const newReconnectionToken = await this._generateReconnectionToken(userInfo, workspace, clientId);\n              websocket.send(JSON.stringify({\n                type: \"reconnection_token\",\n                reconnection_token: newReconnectionToken\n              }));\n            } else {\n              console.info(\"Unknown message type:\", message.type);\n            }\n          } else {\n            await conn.emit_message(data);\n          }\n        } catch (error) {\n          console.error(\"Error processing websocket message:\", error);\n        }\n      });\n      websocket.on(\"close\", async () => {\n        await this._handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn);\n      });\n      websocket.on(\"error\", async (error) => {\n        console.error(`WebSocket error for ${connectionKey}:`, error);\n        await this._handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn);\n      });\n    } catch (error) {\n      if (this._websockets && this._websockets[connectionKey]) {\n        delete this._websockets[connectionKey];\n      }\n      throw error;\n    }\n  }\n  async _generateReconnectionToken(userInfo, workspace, clientId) {\n    const payload = {\n      sub: userInfo.id,\n      workspace,\n      client_id: clientId,\n      email: userInfo.email,\n      roles: userInfo.roles || [],\n      scope: Array.isArray(userInfo.scopes) ? userInfo.scopes.join(\" \") : \"\",\n      iat: Math.floor(Date.now() / 1e3),\n      exp: Math.floor(Date.now() / 1e3) + 3600,\n      // 1 hour\n      iss: \"hypha-core\",\n      aud: \"hypha-reconnection\"\n    };\n    return await generateJWT(payload, this.jwtSecret);\n  }\n  async _handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn) {\n    const connectionKey = `${workspace}/${clientId}`;\n    try {\n      if (conn) {\n        await conn.disconnect(\"disconnected\");\n      }\n      console.info(`Client disconnected: ${connectionKey}`);\n    } catch (error) {\n      console.error(`Error handling disconnection for ${connectionKey}:`, error);\n    } finally {\n      if (this._websockets && this._websockets[connectionKey]) {\n        delete this._websockets[connectionKey];\n      }\n    }\n  }\n  async _disconnectWebsocket(websocket, reason, code = 1e3) {\n    console.error(\"Disconnecting websocket, reason:\", reason, \"code:\", code);\n    try {\n      if (websocket.readyState === websocket.OPEN) {\n        websocket.send(JSON.stringify({ type: \"error\", message: reason }));\n      }\n    } catch (error) {\n      console.error(\"Error sending disconnect message:\", error);\n    }\n    try {\n      if (websocket.readyState === websocket.OPEN || websocket.readyState === websocket.CONNECTING) {\n        websocket.close(code, reason);\n      }\n    } catch (error) {\n      console.error(\"Error closing websocket:\", error);\n    }\n  }\n  getWebsockets() {\n    return this._websockets || {};\n  }\n  async forceDisconnect(workspace, clientId, code, reason) {\n    const connectionKey = `${workspace}/${clientId}`;\n    const websocket = this._websockets && this._websockets[connectionKey];\n    if (!websocket) {\n      throw new Error(`Client not connected: ${connectionKey}`);\n    }\n    await this._disconnectWebsocket(websocket, reason, code);\n  }\n  async connect(config) {\n    config = config || {};\n    config.server = this;\n    config.WebSocketClass = this.WebSocketClass;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.assert)(config.client_id !== \"root\", \"client_id cannot be 'root'\");\n    config.client_id = config.client_id || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.randId)();\n    const rawApi = await connectToServer(config);\n    return this._createCamelCaseWrapper(rawApi, config);\n  }\n  _createCamelCaseWrapper(rawApi, connectionConfig = {}) {\n    const wrappedApi = {};\n    for (const key in rawApi) {\n      const camelKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.toCamelCase)(key);\n      if (typeof rawApi[key] === \"function\") {\n        wrappedApi[camelKey] = rawApi[key].bind(rawApi);\n      } else {\n        wrappedApi[camelKey] = rawApi[key];\n      }\n    }\n    if (rawApi.config) {\n      wrappedApi.config = rawApi.config;\n    } else {\n      const connectionInfo = rawApi._connection_info || rawApi.connection_info || {};\n      wrappedApi.config = {\n        // Connection info from server (if available)\n        public_base_url: connectionInfo.public_base_url || this.url,\n        workspace: connectionInfo.workspace || connectionConfig.workspace,\n        client_id: connectionInfo.client_id || connectionConfig.client_id,\n        // Additional useful config info\n        local_base_url: connectionInfo.local_base_url || this.url,\n        server_url: this.url,\n        manager_id: connectionInfo.manager_id,\n        user: connectionInfo.user,\n        // Connection metadata\n        hypha_version: connectionInfo.hypha_version,\n        reconnection_token: connectionInfo.reconnection_token,\n        reconnection_token_life_time: connectionInfo.reconnection_token_life_time\n      };\n    }\n    return wrappedApi;\n  }\n  async reset() {\n    this.close();\n    await this.start();\n  }\n  close() {\n    if (this.messageHandler) {\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.safeRemoveEventListener(window, \"message\", this.messageHandler);\n      }\n    }\n    if (this.server) {\n      this.server.close();\n      delete _HyphaCore.servers[this.url];\n    }\n  }\n  _createDirectAPIWrapper() {\n    const context = {\n      ws: \"default\",\n      from: \"default/root\",\n      user: {\n        id: \"root\",\n        is_anonymous: false,\n        email: \"root@localhost\",\n        roles: [\"admin\"],\n        scopes: []\n      }\n    };\n    const api = {\n      // API properties that tests expect\n      id: context.from.split(\"/\")[1],\n      // Extract client ID from \"workspace/clientId\"\n      config: {\n        public_base_url: this.url,\n        workspace: context.ws,\n        client_id: context.from.split(\"/\")[1],\n        local_base_url: this.url,\n        server_url: this.url,\n        manager_id: this.workspaceManagerId,\n        user: context.user\n      },\n      // Workspace management functions\n      registerService: async (service) => {\n        return await this.workspaceManager.registerService(service, context);\n      },\n      unregisterService: async (serviceId) => {\n        return await this.workspaceManager.unregisterService(serviceId, context);\n      },\n      listServices: async (query = {}) => {\n        return await this.workspaceManager.listServices(query, context);\n      },\n      getService: async (serviceId, options = {}) => {\n        return await this.workspaceManager.getService(serviceId, options, context);\n      },\n      close: () => {\n        this.close();\n      },\n      // Event methods\n      emit: async (type, data) => {\n        await this.workspaceManager.eventBus.emit(type, data);\n      },\n      on: (event, handler) => {\n        this.workspaceManager.eventBus.on(event, handler);\n      },\n      off: (event, handler) => {\n        this.workspaceManager.eventBus.off(event, handler);\n      },\n      // Utility methods\n      echo: (msg) => {\n        return msg;\n      },\n      alert: (msg) => {\n        alert(msg);\n      },\n      confirm: (msg) => {\n        return confirm(msg);\n      },\n      prompt: (msg, default_value) => {\n        return prompt(msg, default_value);\n      },\n      showProgress: (progress) => {\n        console.log(\"showProgress\", progress);\n      },\n      showMessage: (msg) => {\n        console.log(msg);\n      },\n      log: (msg) => {\n        console.log(msg);\n      },\n      info: (msg) => {\n        console.info(msg);\n      },\n      error: (msg) => {\n        console.error(msg);\n      },\n      warning: (msg) => {\n        console.warn(msg);\n      },\n      critical: (msg) => {\n        console.error(msg);\n      },\n      // Token generation\n      generateToken: async (tokenConfig) => {\n        if (!tokenConfig) {\n          tokenConfig = {};\n        }\n        const currentWorkspace = context.ws;\n        const currentClientId = context.from?.split(\"/\")[1];\n        let targetWorkspace = tokenConfig.workspace || currentWorkspace;\n        if (targetWorkspace !== currentWorkspace) {\n          if (currentWorkspace !== \"default\" || currentClientId !== \"root\") {\n            throw new Error(`Access denied: Cannot generate token for workspace '${targetWorkspace}' from workspace '${currentWorkspace}' with client '${currentClientId}'. Only root client in default workspace can generate cross-workspace tokens.`);\n          }\n        }\n        const payload = {\n          sub: tokenConfig.user_id || context.user?.id || \"anonymous\",\n          workspace: targetWorkspace,\n          client_id: tokenConfig.client_id || context.from?.split(\"/\")[1] || \"anonymous-\" + Date.now().toString(),\n          email: tokenConfig.email || context.user?.email || \"\",\n          roles: tokenConfig.roles || context.user?.roles || [],\n          scope: Array.isArray(tokenConfig.scopes) ? tokenConfig.scopes.join(\" \") : tokenConfig.scope || \"\",\n          iat: Math.floor(Date.now() / 1e3),\n          exp: tokenConfig.expires_in ? Math.floor(Date.now() / 1e3) + tokenConfig.expires_in : Math.floor(Date.now() / 1e3) + 24 * 60 * 60,\n          // Default 24 hours\n          iss: \"hypha-core\",\n          aud: \"hypha-api\"\n        };\n        const jwtSecret = this.jwtSecret;\n        if (!jwtSecret) {\n          throw new Error(\"JWT secret not configured on server\");\n        }\n        return await generateJWT(payload, jwtSecret);\n      },\n      // App and window management methods\n      loadApp: async (config, extra_config) => {\n        return await this.workspaceManager.loadApp(config, extra_config, context);\n      },\n      createWindow: async (config, extra_config) => {\n        return await this.workspaceManager.createWindow(config, extra_config, context);\n      },\n      getWindow: async (config) => {\n        return await this.workspaceManager.getWindow(config, context);\n      },\n      getApp: async (config, extra_config) => {\n        return await this.workspaceManager.getApp(config, extra_config, context);\n      }\n    };\n    api.getPlugin = api.getApp;\n    api.loadPlugin = api.loadApp;\n    this.workspaceManager.registerService({\n      id: \"default\",\n      name: \"Default workspace management service\",\n      description: \"Services for managing workspace.\",\n      config: {\n        visibility: \"public\"\n      },\n      ...this.workspaceManager.getDefaultService()\n    }, context).catch((err) => {\n      console.warn(\"Could not register default service:\", err.message);\n    });\n    return this._createCamelCaseWrapper(api);\n  }\n};\n__publicField(_HyphaCore, \"servers\", {});\nlet HyphaCore = _HyphaCore;\nfunction parseJwt(token) {\n  var base64Url = token.split(\".\")[1];\n  var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  var jsonPayload = decodeURIComponent(atob(base64).split(\"\").map(function(c) {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"));\n  return JSON.parse(jsonPayload);\n}\nlet _imjoyRPC = null;\nasync function getImjoyRPC() {\n  if (!_utils_index_js__WEBPACK_IMPORTED_MODULE_2__.Environment.isBrowser()) {\n    throw new Error(\"imjoyRPC is only available in browser environments\");\n  }\n  if (!_imjoyRPC) {\n    const imjoyModule = await __webpack_require__.e(/*! import() */ \"vendors-node_modules_imjoy-rpc_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! imjoy-rpc */ \"./node_modules/imjoy-rpc/index.js\", 23));\n    _imjoyRPC = imjoyModule.imjoyRPC;\n  }\n  return _imjoyRPC;\n}\n\n\n\n//# sourceURL=webpack://hypha-core/./src/hypha-core.js?");

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   MessageEmitter: () => (/* binding */ MessageEmitter),\n/* harmony export */   RedisRPCConnection: () => (/* binding */ RedisRPCConnection),\n/* harmony export */   WebsocketRPCConnection: () => (/* binding */ WebsocketRPCConnection),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   convertToCamelCase: () => (/* binding */ convertToCamelCase),\n/* harmony export */   convertToSnakeCase: () => (/* binding */ convertToSnakeCase),\n/* harmony export */   parsePluginCode: () => (/* binding */ parsePluginCode),\n/* harmony export */   randId: () => (/* binding */ randId),\n/* harmony export */   toCamelCase: () => (/* binding */ toCamelCase),\n/* harmony export */   toSnakeCase: () => (/* binding */ toSnakeCase)\n/* harmony export */ });\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.esm/encode.mjs\");\n/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginParser.js */ \"./src/utils/pluginParser.js\");\n\n\nfunction toCamelCase(str) {\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\nfunction toSnakeCase(str) {\n  if (!str.includes(\"_\") && /[A-Z]/.test(str)) {\n    return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n  }\n  return str;\n}\nfunction convertToSnakeCase(service) {\n  const convertedService = {};\n  function processObject(obj) {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if ([\"id\", \"name\", \"description\", \"config\", \"app_id\"].includes(key)) {\n        result[key] = value;\n        continue;\n      }\n      const snakeKey = toSnakeCase(key);\n      if (typeof value === \"function\") {\n        result[snakeKey] = value;\n      } else if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        if (value._rintf) {\n          result[snakeKey] = value;\n          continue;\n        }\n        result[snakeKey] = processObject(value);\n      } else {\n        result[snakeKey] = value;\n      }\n    }\n    return result;\n  }\n  return processObject(service);\n}\nfunction convertToCamelCase(service) {\n  function processObject(obj) {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if ([\"id\", \"name\", \"description\", \"config\", \"app_id\"].includes(key)) {\n        result[key] = value;\n        continue;\n      }\n      const camelKey = toCamelCase(key);\n      if (typeof value === \"function\") {\n        result[camelKey] = value;\n      } else if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        if (value._rintf) {\n          result[camelKey] = value;\n          continue;\n        }\n        result[camelKey] = processObject(value);\n      } else {\n        result[camelKey] = value;\n      }\n    }\n    return result;\n  }\n  return processObject(service);\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      if (this._event_handlers[event])\n        this._event_handlers[event] = [];\n    } else {\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout);\n    });\n  }\n}\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nclass WebsocketRPCConnection {\n  constructor(eventBus, clients, clientId, workspace, managerId, timeout = 60) {\n    this._clients = clients;\n    this._clientId = clientId;\n    this._handle_message = null;\n    this._handle_connected = null;\n    this._handle_disconnected = null;\n    this._reconnection_token = null;\n    this._timeout = timeout * 1e3;\n    this.workspace = workspace;\n    this.connection_info = null;\n    this.manager_id = managerId;\n    this.eventBus = eventBus;\n  }\n  mount(config) {\n    assert(config.id && config.workspace && config.websocket && config.user_info, \"Invalid client config\");\n    config.websocket.on(\"message\", (data) => {\n      const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n      const unpacker = decoder.decodeMulti(data);\n      const { value: message } = unpacker.next();\n      const targetId = message.to.includes(\"/\") ? message.to.split(\"/\")[1] : message.to;\n      if (targetId === this._clientId) {\n        this._handle_message(data.buffer);\n      } else {\n        this.emit_message(data);\n      }\n    });\n  }\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n  async emit_message(data) {\n    assert(this._handle_message, \"No handler for message\");\n    const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n    const unpacker = decoder.decodeMulti(data);\n    const { value: message } = unpacker.next();\n    let targetId = message.to;\n    if (!targetId.includes(\"/\")) {\n      targetId = `${this.workspace}/${targetId}`;\n    }\n    if (!this._clients[targetId]) {\n      console.error(\"No client found for targetId:\", targetId);\n      return;\n    }\n    const client = this._clients[targetId];\n    const websocket = client.websocket;\n    if (!message.from.includes(\"/\")) {\n      message.from = `${this.workspace}/${message.from}`;\n    }\n    const updatedMessage = {\n      ...message,\n      ws: this.workspace,\n      to: targetId,\n      from: message.from,\n      user: client.userInfo\n    };\n    const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(updatedMessage);\n    const pos = decoder.pos;\n    const remainingData = data.slice(pos);\n    const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n    finalData.set(encodedUpdatedMessage, 0);\n    finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n    if (!websocket || !websocket.send) {\n      console.error(\"No websocket found for targetId:\", targetId);\n      return;\n    }\n    websocket.send(finalData.buffer);\n  }\n  disconnect(reason) {\n    console.info(`Websocket connection disconnected (${reason})`);\n  }\n}\nclass RedisRPCConnection {\n  /**\n   * Represent a Redis connection for handling RPC-like messaging.\n   * @param {EventBus} eventBus - Event bus for messaging.\n   * @param {string} workspace - Workspace identifier.\n   * @param {string} clientId - Client identifier.\n   * @param {UserInfo} userInfo - User information.\n   * @param {string} managerId - Manager identifier.\n   */\n  constructor(eventBus, workspace, clientId, userInfo, managerId) {\n    if (!workspace || clientId.includes(\"/\")) {\n      throw new Error(\"Invalid workspace or client ID\");\n    }\n    this._workspace = workspace;\n    this._clientId = clientId;\n    this._userInfo = userInfo;\n    this._stop = false;\n    this._eventBus = eventBus;\n    this._handleConnected = null;\n    this._handleDisconnected = null;\n    this._handleMessage = null;\n    this.manager_id = managerId;\n  }\n  /**\n   * Register a disconnection event handler.\n   * @param {function} handler - Disconnection handler.\n   */\n  on_disconnected(handler) {\n    this._handleDisconnected = handler;\n  }\n  /**\n   * Register a connection open event handler.\n   * @param {function} handler - Connection handler.\n   */\n  on_connected(handler) {\n    this._handleConnected = handler;\n  }\n  /**\n   * Set message handler.\n   * @param {function} handler - Message handler.\n   */\n  on_message(handler) {\n    this._handleMessage = handler;\n    this._eventBus.on(`${this._workspace}/${this._clientId}:msg`, handler);\n    this._eventBus.on(`${this._workspace}/*:msg`, handler);\n    if (this._handleConnected) {\n      this._handleConnected(this);\n    }\n  }\n  /**\n   * Send message after packing additional info.\n   * @param {Object|Uint8Array} data - Data to send.\n   */\n  async emit_message(data) {\n    if (this._stop) {\n      throw new Error(`Connection has already been closed (client: ${this._workspace}/${this._clientId})`);\n    }\n    if (!(data instanceof Uint8Array)) {\n      console.log(\"Skipping text message\", data);\n      return;\n    }\n    const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n    const unpacker = decoder.decodeMulti(data);\n    const { value: message } = unpacker.next();\n    const pos = decoder.pos;\n    let targetId = message.to;\n    if (!targetId.includes(\"/\")) {\n      if (this._workspace === \"*\" && targetId.includes(\":\")) {\n        const actualWorkspace = message.ws || message.workspace || this._workspace;\n        targetId = `${actualWorkspace}/${targetId}`;\n      } else {\n        if (targetId.includes(\"/workspace-manager-\")) {\n          throw new Error(`Invalid target ID: ${targetId}, it appears that the target is a workspace manager (target_id should starts with */)`);\n        }\n        targetId = `${this._workspace}/${targetId}`;\n      }\n    }\n    const sourceId = `${this._workspace}/${this._clientId}`;\n    const effectiveWorkspace = this._workspace === \"*\" ? targetId.split(\"/\")[0] : this._workspace;\n    message.ws = effectiveWorkspace;\n    message.to = targetId;\n    message.from = sourceId;\n    message.user = this._userInfo;\n    const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(message);\n    const remainingData = data.slice(pos);\n    const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n    finalData.set(encodedUpdatedMessage, 0);\n    finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n    await this._eventBus.emit(`${targetId}:msg`, finalData.buffer);\n  }\n  /**\n   * Handle disconnection.\n   * @param {string} [reason] - Reason for disconnection.\n   */\n  async disconnect(reason) {\n    this._stop = true;\n    if (this._handleMessage) {\n      this._eventBus.off(`${this._workspace}/${this._clientId}:msg`, this._handleMessage);\n      this._eventBus.off(`${this._workspace}/*:msg`, this._handleMessage);\n    }\n    this._handleMessage = null;\n    console.info(`Redis Connection Disconnected: ${reason}`);\n    if (this._handleDisconnected) {\n      await this._handleDisconnected(reason);\n    }\n  }\n}\nconst CONFIGURABLE_FIELDS = [\n  \"env\",\n  \"requirements\",\n  \"dependencies\",\n  \"icon\",\n  \"ui\",\n  \"type\",\n  \"flags\",\n  \"labels\",\n  \"cover\",\n  \"base_frame\",\n  \"base_worker\",\n  \"passive\"\n];\nfunction parsePluginCode(code, overwrite_config) {\n  overwrite_config = overwrite_config || {};\n  try {\n    const pluginComp = (0,_pluginParser_js__WEBPACK_IMPORTED_MODULE_0__.parseComponent)(code);\n    let config;\n    if (pluginComp.config[0].attrs.lang === \"yaml\") {\n      throw new Error(\"YAML not supported\");\n    } else if (pluginComp.config[0].attrs.lang === \"json\") {\n      config = JSON.parse(pluginComp.config[0].content);\n    } else {\n      config = JSON.parse(pluginComp.config[0].content);\n      if (compareVersions(config.api_version, \">\", \"0.1.5\")) {\n        throw `Unsupported config language ${pluginComp.config[0].attrs.lang}, please set lang=\"json\" or lang=\"yaml\"`;\n      }\n    }\n    config.tag = overwrite_config.tag || config.tags && config.tags[0];\n    config.hot_reloading = overwrite_config.hot_reloading, config.scripts = [];\n    for (let i = 0; i < pluginComp.script.length; i++) {\n      if (pluginComp.script[i].attrs.tag === config.tag) {\n        config.script = pluginComp.script[i].content;\n      }\n      if (!pluginComp.script[i].attrs.tag || pluginComp.script[i].attrs.tag === config.tag) {\n        config.scripts.push(pluginComp.script[i]);\n      }\n    }\n    if (!config.script && pluginComp.script.length > 0) {\n      config.script = pluginComp.script[0].content;\n      config.lang = pluginComp.script[0].attrs.lang;\n    }\n    config.links = pluginComp.link || null;\n    config.windows = pluginComp.window || null;\n    config.styles = pluginComp.style || null;\n    config.docs = pluginComp.docs && pluginComp.docs[0] || config.docs;\n    config.attachments = pluginComp.attachment || null;\n    config._id = overwrite_config._id || config.name.replace(/ /g, \"_\");\n    config.uri = overwrite_config.uri;\n    config.origin = overwrite_config.origin;\n    config.namespace = overwrite_config.namespace;\n    config.code = code;\n    config.id = config.name.trim().replace(/ /g, \"_\") + \"_\" + randId();\n    config.runnable = config.runnable === false ? false : true;\n    config.requirements = config.requirements || [];\n    for (let i = 0; i < CONFIGURABLE_FIELDS.length; i++) {\n      const obj = config[CONFIGURABLE_FIELDS[i]];\n      if (obj && typeof obj === \"object\" && !(obj instanceof Array)) {\n        if (config.tag) {\n          config[CONFIGURABLE_FIELDS[i]] = obj[config.tag];\n          if (!Object.prototype.hasOwnProperty.call(obj, config.tag)) {\n            console.log(\n              \"WARNING: \" + CONFIGURABLE_FIELDS[i] + \" do not contain a tag named: \" + config.tag\n            );\n          }\n        } else {\n          throw \"You must use 'tags' with configurable fields.\";\n        }\n      }\n    }\n    config.lang = config.lang || \"javascript\";\n    return config;\n  } catch (e) {\n    console.error(e);\n    throw `Failed to parse the plugin file, error: ${e}`;\n  }\n}\nconst Environment = {\n  /**\n   * Check if we're running in a browser environment\n   */\n  isBrowser() {\n    return typeof window !== \"undefined\" && typeof document !== \"undefined\" && typeof navigator !== \"undefined\";\n  },\n  /**\n   * Check if we're running in Node.js\n   */\n  isNode() {\n    return typeof process !== \"undefined\" && process.versions && process.versions.node;\n  },\n  /**\n   * Check if we're running in Deno\n   */\n  isDeno() {\n    return typeof Deno !== \"undefined\";\n  },\n  /**\n   * Check if we're running in a server environment (Node.js or Deno)\n   */\n  isServer() {\n    return this.isNode() || this.isDeno();\n  },\n  /**\n   * Get environment name for debugging\n   */\n  getEnvironment() {\n    if (this.isBrowser())\n      return \"browser\";\n    if (this.isDeno())\n      return \"deno\";\n    if (this.isNode())\n      return \"node\";\n    return \"unknown\";\n  },\n  /**\n   * Require browser environment or throw error\n   */\n  requireBrowser(feature) {\n    if (!this.isBrowser()) {\n      throw new Error(`${feature} requires browser environment. Currently running in: ${this.getEnvironment()}`);\n    }\n  },\n  /**\n   * Get safe base URL for different environments\n   */\n  getSafeBaseUrl() {\n    if (this.isBrowser() && typeof document !== \"undefined\" && document.location) {\n      return new URL(\"./\", document.location.href).href;\n    }\n    return \"http://localhost:8080/\";\n  },\n  /**\n   * Safe postMessage wrapper\n   */\n  safePostMessage(target, message, origin = \"*\") {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.postMessage === \"function\") {\n      target.postMessage(message, origin);\n    } else {\n      console.warn(\"postMessage not available in current environment:\", this.getEnvironment());\n    }\n  },\n  /**\n   * Safe event listener management\n   */\n  safeAddEventListener(target, event, handler) {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.addEventListener === \"function\") {\n      target.addEventListener(event, handler);\n      return true;\n    }\n    return false;\n  },\n  safeRemoveEventListener(target, event, handler) {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.removeEventListener === \"function\") {\n      target.removeEventListener(event, handler);\n      return true;\n    }\n    return false;\n  }\n};\n\n\n//# sourceURL=webpack://hypha-core/./src/utils/index.js?");

/***/ }),

/***/ "./src/utils/pluginParser.js":
/*!***********************************!*\
  !*** ./src/utils/pluginParser.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseComponent: () => (/* binding */ parseComponent)\n/* harmony export */ });\nvar splitRE = /\\r?\\n/g;\nvar emptyRE = /^\\s*$/;\nvar needFixRE = /^(\\r?\\n)*[\\t\\s]/;\nvar deIndent = function deindent(str) {\n  if (!needFixRE.test(str)) {\n    return str;\n  }\n  var lines = str.split(splitRE);\n  var min = Infinity;\n  var type, cur, c;\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    if (!emptyRE.test(line)) {\n      if (!type) {\n        c = line.charAt(0);\n        if (c === \" \" || c === \"\t\") {\n          type = c;\n          cur = count(line, type);\n          if (cur < min) {\n            min = cur;\n          }\n        } else {\n          return str;\n        }\n      } else {\n        cur = count(line, type);\n        if (cur < min) {\n          min = cur;\n        }\n      }\n    }\n  }\n  return lines.map(function(line2) {\n    return line2.slice(min);\n  }).join(\"\\n\");\n};\nfunction count(line, type) {\n  var i = 0;\n  while (line.charAt(i) === type) {\n    i++;\n  }\n  return i;\n}\nvar emptyObject = Object.freeze({});\nfunction isUndef(v) {\n  return v === void 0 || v === null;\n}\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || // $flow-disable-line\n  typeof value === \"symbol\" || typeof value === \"boolean\";\n}\nfunction isObject(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\nvar _toString = Object.prototype.toString;\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === \"[object Object]\";\n}\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction makeMap(str, expectsLowerCase) {\n  var map = /* @__PURE__ */ Object.create(null);\n  var list = str.split(\",\");\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function(val) {\n    return map[val.toLowerCase()];\n  } : function(val) {\n    return map[val];\n  };\n}\nvar isBuiltInTag = makeMap(\"slot,component\", true);\nvar isReservedAttribute = makeMap(\"key,ref,slot,slot-scope,is\");\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\nfunction cached(fn) {\n  var cache = /* @__PURE__ */ Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function(str) {\n  return str.replace(camelizeRE, function(_, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n});\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  boundFn._length = fn.length;\n  return boundFn;\n}\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\nfunction noop(a, b, c) {\n}\nvar no = function(a, b, c) {\n  return false;\n};\nvar identity = function(_) {\n  return _;\n};\nfunction genStaticKeys(modules) {\n  return modules.reduce(function(keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(\",\");\n}\nvar isUnaryTag = makeMap(\n  \"area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr\"\n);\nvar canBeLeftOpenTag = makeMap(\n  \"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source\"\n);\nvar isNonPhrasingTag = makeMap(\n  \"address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track\"\n);\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\w\\\\-\\\\.]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\nvar IS_REGEX_CAPTURING_BROKEN = false;\n\"x\".replace(/x(.)?/g, function(m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === \"\";\n});\nvar isPlainTextElement = makeMap(\"script,style,textarea\", true);\nvar reCache = {};\nvar decodingMap = {\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&amp;\": \"&\",\n  \"&#10;\": \"\\n\",\n  \"&#9;\": \"\t\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\nvar isIgnoreNewlineTag = makeMap(\"pre,textarea\", true);\nvar shouldIgnoreFirstNewline = function(tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === \"\\n\";\n};\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function(match) {\n    return decodingMap[match];\n  });\n}\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf(\"<\");\n      if (textEnd === 0) {\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf(\"-->\");\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(\"]>\");\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue;\n        }\n      }\n      var text = void 0, rest = void 0, next = void 0;\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          next = rest.indexOf(\"<\", 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n      if (textEnd < 0) {\n        text = html;\n        html = \"\";\n      }\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(\n        \"([\\\\s\\\\S]*?)(</\" + stackedTag + \"[^>]*>)\",\n        \"i\"\n      ));\n      var rest$1 = html.replace(reStackedTag, function(all, text2, endTag2) {\n        endTagLength = endTag2.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== \"noscript\") {\n          text2 = text2.replace(/<!\\--([\\s\\S]*?)-->/g, \"$1\").replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1\");\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text2)) {\n          text2 = text2.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text2);\n        }\n        return \"\";\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (!stack.length && options.warn) {\n        options.warn('Mal-formatted tag at end of template: \"' + html + '\"');\n      }\n      break;\n    }\n  }\n  parseEndTag();\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n    if (expectHTML) {\n      if (lastTag === \"p\" && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === \"\") {\n          delete args[3];\n        }\n        if (args[4] === \"\") {\n          delete args[4];\n        }\n        if (args[5] === \"\") {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || \"\";\n      var shouldDecodeNewlines = tagName === \"a\" && args[1] === \"href\" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs\n      });\n      lastTag = tagName;\n    }\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      pos = 0;\n    }\n    if (pos >= 0) {\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ((i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === \"br\") {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === \"p\") {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\nvar splitRE$1 = /\\r?\\n/g;\nvar replaceRE = /./g;\nvar isSpecialTag = makeMap(\"script,style,template\", true);\nfunction parseComponent(content, options) {\n  if (options === void 0)\n    options = {};\n  var sfc = {\n    script: [],\n    style: [],\n    config: [],\n    window: [],\n    docs: [],\n    attachment: [],\n    link: [],\n    others: []\n  };\n  var depth = 0;\n  var currentBlock = null;\n  function start(tag, attrs, unary, start2, end2) {\n    if (depth === 0) {\n      currentBlock = {\n        type: tag,\n        content: \"\",\n        start: end2,\n        attrs: attrs.reduce(function(cumulated, ref) {\n          var name = ref.name;\n          var value = ref.value;\n          cumulated[name] = value || true;\n          return cumulated;\n        }, {})\n      };\n      if (sfc[tag]) {\n        checkAttrs(currentBlock, attrs);\n        sfc[tag].push(currentBlock);\n      } else {\n        sfc.others.push(currentBlock);\n      }\n    }\n    if (!unary) {\n      depth++;\n    }\n  }\n  function checkAttrs(block, attrs) {\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (attr.name === \"lang\") {\n        block.lang = attr.value;\n      }\n      if (attr.name === \"scoped\") {\n        block.scoped = true;\n      }\n      if (attr.name === \"module\") {\n        block.module = attr.value || true;\n      }\n      if (attr.name === \"src\") {\n        block.src = attr.value;\n      }\n    }\n  }\n  function end(tag, start2, end2) {\n    if (depth === 1 && currentBlock) {\n      currentBlock.end = start2;\n      var text = deIndent(content.slice(currentBlock.start, currentBlock.end));\n      if (currentBlock.type !== \"template\" && options.pad) {\n        text = padContent(currentBlock, options.pad) + text;\n      }\n      currentBlock.content = text;\n      currentBlock = null;\n    }\n    depth--;\n  }\n  function padContent(block, pad) {\n    if (pad === \"space\") {\n      return content.slice(0, block.start).replace(replaceRE, \" \");\n    } else {\n      var offset = content.slice(0, block.start).split(splitRE$1).length;\n      var padChar = block.type === \"script\" && !block.lang ? \"//\\n\" : \"\\n\";\n      return Array(offset).join(padChar);\n    }\n  }\n  parseHTML(content, {\n    start,\n    end\n  });\n  return sfc;\n}\n\n\n//# sourceURL=webpack://hypha-core/./src/utils/pluginParser.js?");

/***/ }),

/***/ "./src/utils/redis-mock.js":
/*!*********************************!*\
  !*** ./src/utils/redis-mock.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function() {\n  \"use strict\";\n  var root = this || globalThis;\n  var redismock2 = {};\n  function exists(v) {\n    return typeof v !== \"undefined\" && v !== null;\n  }\n  if (typeof exports !== \"undefined\") {\n    if ( true && module.exports) {\n      exports = module.exports = redismock2;\n    }\n    exports.redismock = redismock2;\n  } else {\n    root.redismock = redismock2;\n  }\n  if (typeof setImmediate === \"undefined\" || typeof setImmediate !== \"function\") {\n    var setImmediate = function(f) {\n      setTimeout(f, 0);\n    };\n  }\n  redismock2.Array = Array;\n  function SortedSet() {\n    this.scores = [];\n    this.set = {};\n    this.invset = {};\n    this.indices = {};\n    this.lengths = {};\n    this.card = 0;\n    return this;\n  }\n  SortedSet.prototype.add = function(score, member) {\n    var ret = 1;\n    if (exists(this.invset[member])) {\n      this.rem(member);\n      ret = 0;\n    }\n    if (!exists(this.set[score])) {\n      this.scores.push(score);\n      this.set[score] = [];\n      this.lengths[score] = 0;\n    }\n    this.set[score].push(member);\n    this.invset[member] = score;\n    this.indices[member] = this.set[score].length - 1;\n    this.lengths[score] += 1;\n    this.card += 1;\n    return ret;\n  };\n  SortedSet.prototype.rem = function(member) {\n    var score;\n    if (!exists(this.invset[member])) {\n      return 0;\n    }\n    score = this.invset[member];\n    this.set[score].splice(this.set[score].indexOf(member), 1);\n    this.lengths[score] -= 1;\n    if (this.lengths[score] === 0) {\n      this.set[score] = void 0;\n      this.scores.splice(this.scores.indexOf(score), 1);\n    }\n    this.invset[member] = void 0;\n    this.indices[member] = void 0;\n    this.card -= 1;\n    return 1;\n  };\n  SortedSet.prototype.sortScores = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(a, 10) - parseInt(b, 10);\n    });\n    return this;\n  };\n  SortedSet.prototype.sortScoresRev = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(b, 10) - parseInt(a, 10);\n    });\n    return this;\n  };\n  redismock2.SortedSet = function() {\n    return new SortedSet();\n  };\n  var cache = {};\n  var timeouts = {};\n  var subscribers = [];\n  var watchers = {};\n  var sets = \"sets-\" + Math.random();\n  var zsets = \"zsets-\" + Math.random();\n  var hashes = \"hashes-\" + Math.random();\n  cache[sets] = {};\n  cache[zsets] = {};\n  cache[hashes] = {};\n  String.prototype.escape = function() {\n    var escapable = /[.\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    var meta;\n    meta = {\n      // table of character substitutions\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      \".\": \"\\\\.\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    };\n    function escapechar(a) {\n      var c = meta[a];\n      return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n    }\n    return this.replace(escapable, escapechar);\n  };\n  function translate(pat) {\n    var i = 0, j, n = pat.length || 0, res, c, stuff;\n    res = \"^\";\n    while (i < n) {\n      c = pat[i];\n      i = i + 1;\n      if (c === \"*\") {\n        res = res + \".*\";\n      } else if (c === \"?\") {\n        res = res + \".\";\n      } else if (c === \"[\") {\n        j = i;\n        if (j < n && pat[j] === \"!\") {\n          j = j + 1;\n        }\n        if (j < n && pat[j] === \"]\") {\n          j = j + 1;\n        }\n        while (j < n && pat[j] !== \"]\") {\n          j = j + 1;\n        }\n        if (j >= n) {\n          res = res + \"\\\\[\";\n        } else {\n          stuff = pat.slice(i, j).replace(\"\\\\\", \"\\\\\\\\\");\n          i = j + 1;\n          if (stuff[0] === \"!\") {\n            stuff = \"^\" + stuff.slice(1);\n          } else if (stuff[0] === \"^\") {\n            stuff = \"\\\\\" + stuff;\n          }\n          res = res + \"[\" + stuff + \"]\";\n        }\n      } else {\n        res = res + c.escape();\n      }\n    }\n    return res + \"$\";\n  }\n  var cb = function(callback, context) {\n    return function() {\n      var args = arguments;\n      if (callback && typeof callback === \"function\") {\n        setImmediate(function() {\n          callback.apply(context, args);\n        });\n      }\n      if (args[0] instanceof Error) {\n        return args[0];\n      }\n      return args[1];\n    };\n  };\n  var gather = function() {\n    return function() {\n      var idx, len = arguments.length;\n      var callback;\n      var list = [];\n      for (idx = len - 1; idx >= 0; idx -= 1) {\n        if (!callback && typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        } else if (exists(arguments[idx])) {\n          list.unshift(arguments[idx]);\n        }\n      }\n      return {\n        callback,\n        list\n      };\n    };\n  };\n  var wrongType = function(callback) {\n    return cb(callback)(new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n  };\n  redismock2.ifType = function(key2, type, callback) {\n    var that = this;\n    return {\n      thenex: function(f) {\n        this._ifex = f;\n        return this;\n      },\n      thennx: function(f) {\n        this._ifnx = f;\n        return this;\n      },\n      then: function(f) {\n        this._then = f;\n        return this;\n      },\n      end: function() {\n        var ret;\n        if (that.exists(key2)) {\n          if (that.type(key2) !== type) {\n            return wrongType(callback);\n          }\n          if (typeof this._ifex === \"function\") {\n            ret = this._ifex.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        } else {\n          if (typeof this._ifnx === \"function\") {\n            ret = this._ifnx.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        }\n        if (typeof this._then === \"function\") {\n          ret = this._then.call(that);\n          if (ret && ret instanceof Error) {\n            return cb(callback)(ret);\n          }\n        }\n        return cb(callback)(null, ret);\n      }\n    };\n  };\n  redismock2.del = function(key2, callback) {\n    var that = this;\n    var count = 0;\n    var g = gather(this.del).apply(this, arguments);\n    callback = g.callback;\n    var deleter = function(k) {\n      if (that.exists(k)) {\n        if (k in cache) {\n          cache[k] = void 0;\n        } else if (k in cache[sets]) {\n          cache[sets][k] = void 0;\n        } else if (k in cache[zsets]) {\n          cache[zsets][k] = void 0;\n        } else if (k in cache[hashes]) {\n          cache[hashes][k] = void 0;\n        }\n        return 1;\n      }\n      return 0;\n    };\n    var toDelete = g.list;\n    if (typeof g.list[0] === \"object\") {\n      toDelete = g.list[0];\n    }\n    toDelete.forEach(function(k) {\n      count += deleter(k);\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.dump = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.exists = function(key2, callback) {\n    return cb(callback)(null, exists(cache[key2]) || exists(cache[sets][key2]) || exists(cache[zsets][key2]) || exists(cache[hashes][key2]) ? 1 : 0);\n  };\n  redismock2.expire = function(key2, seconds, callback) {\n    return this.pexpire(key2, seconds * 1e3, callback);\n  };\n  redismock2.expireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp * 1e3 - now.getTime(), callback);\n  };\n  redismock2.keys = function(pattern, callback) {\n    var keys = [], key2;\n    var regex = new RegExp(translate(pattern));\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    return cb(callback)(null, keys);\n  };\n  redismock2.migrate = function(host, port, key2, destination_db, timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.move = function(key2, db, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.object = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.persist = function(key2, callback) {\n    if (this.exists(key2) && timeouts[key2]) {\n      clearTimeout(timeouts[key2].timeout);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.pexpire = function(key2, milliseconds, callback) {\n    var that = this;\n    if (this.exists(key2)) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n      if (milliseconds <= 0) {\n        this.del(key2);\n      } else {\n        timeouts[key2] = {};\n        timeouts[key2].start = /* @__PURE__ */ new Date();\n        timeouts[key2].end = new Date(timeouts[key2].start.getTime() + milliseconds);\n        timeouts[key2].timeout = setTimeout(function() {\n          timeouts[key2] = void 0;\n          that.del(key2);\n        }, milliseconds);\n      }\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.pexpireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp - now.getTime(), callback);\n  };\n  redismock2.pttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, timeouts[key2].end.getTime() - now.getTime());\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock2.randomkey = function(callback) {\n    var rando = null;\n    function loop_through(count, looper) {\n      var key2;\n      for (key2 in looper) {\n        if (key2 === sets) {\n          count = loop_through(count, cache[sets]);\n          continue;\n        } else if (key2 === zsets) {\n          count = loop_through(count, cache[zsets]);\n          continue;\n        } else if (key2 === hashes) {\n          count = loop_through(count, cache[hashes]);\n          continue;\n        } else if (Math.random() < 1 / count) {\n          rando = key2;\n        }\n        count += 1;\n      }\n      return count;\n    }\n    loop_through(1, cache);\n    return cb(callback)(null, rando);\n  };\n  redismock2.rename = function(key2, newkey, callback) {\n    var type;\n    if (!this.exists(key2)) {\n      return cb(callback)(new Error(\"ERR no such key\"));\n    }\n    if (key2 === newkey) {\n      return cb(callback)(null, \"OK\");\n    }\n    type = this.type(key2);\n    if (type === \"string\" || type === \"list\") {\n      cache[newkey] = cache[key2];\n    } else if (type === \"set\") {\n      cache[sets][newkey] = cache[sets][key2];\n    } else if (type === \"zset\") {\n      cache[zsets][newkey] = cache[zsets][key2];\n    } else if (type === \"hash\") {\n      cache[hashes][newkey] = cache[hashes][key2];\n    }\n    this.del(key2);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.renamenx = function(key2, newkey, callback) {\n    var r;\n    if (this.exists(newkey)) {\n      return cb(callback)(null, 0);\n    }\n    r = this.rename(key2, newkey);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, 1);\n  };\n  redismock2.restore = function(key2, ttl, serialized_value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.sort = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.ttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, (timeouts[key2].end.getTime() - now.getTime()) / 1e3);\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock2.type = function(key2, callback) {\n    if (this.exists(key2)) {\n      var type = typeof cache[key2];\n      if (type === \"object\") {\n        if (cache[key2] instanceof Array) {\n          type = \"list\";\n        }\n      } else if (type === \"undefined\") {\n        if (key2 in cache[sets] && cache[sets][key2]) {\n          type = \"set\";\n        } else if (key2 in cache[zsets] && cache[zsets][key2]) {\n          type = \"zset\";\n        } else if (key2 in cache[hashes] && cache[hashes][key2]) {\n          type = \"hash\";\n        }\n      }\n      return cb(callback)(null, type);\n    }\n    return cb(callback)(null, \"none\");\n  };\n  redismock2.scan = function(cursor, callback) {\n    var g = gather(this.scan).apply(null, arguments);\n    var idx = 0;\n    var key2;\n    var reply = [];\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    for (key2 in cache) {\n      if (cache.hasOwnProperty(key2)) {\n        if (key2 === sets || key2 === zsets || key2 === hashes) {\n          continue;\n        }\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    if (!reply.length) {\n      idx = 0;\n    }\n    return cb(callback)(null, [idx, reply]);\n  };\n  redismock2.append = function(key2, value, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      cache[key2] += value;\n      return null;\n    }).thennx(function() {\n      return this.set(key2, value);\n    }).then(function() {\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.bitcount = function(key2, callback) {\n    var g = gather(this.bitcount).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length === 3) {\n      start = g.list[1];\n      end = g.list[2];\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var idx, n, count;\n      if (!exists(start)) {\n        start = 0;\n      }\n      if (!exists(end)) {\n        end = cache[key2].length - 1;\n      }\n      if (end >= cache[key2].length) {\n        end = cache[key2].length - 1;\n      }\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return 0;\n      }\n      count = 0;\n      for (idx = start; idx <= end; idx += 1) {\n        n = cache[key2].charCodeAt(idx);\n        while (n) {\n          count += n & 1;\n          n >>= 1;\n        }\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.bitop = function(operation, destkey, key2, callback) {\n    var that = this;\n    var g = gather(this.bitop).apply(this, arguments);\n    var longest, strings, string, r;\n    operation = typeof operation === \"string\" ? operation.toLowerCase() : \"\";\n    if (operation !== \"and\" && operation !== \"or\" && operation !== \"xor\" && operation !== \"not\") {\n      return cb(callback)(new Error(\"ERR syntax error\"));\n    }\n    callback = g.callback;\n    strings = g.list.slice(2).map(function(k) {\n      if (that.exists(k) && that.type(k) !== \"string\") {\n        return null;\n      }\n      return that.exists(k) ? cache[k] : \"\";\n    });\n    if (strings.some(function(str) {\n      return str === null;\n    })) {\n      return wrongType(callback);\n    }\n    longest = strings.reduce(function(length, str) {\n      return str.length > length ? str.length : length;\n    }, 0);\n    strings = strings.map(function(str) {\n      while (str.length < longest) {\n        str += \"\\0\";\n      }\n      return str;\n    });\n    string = strings.reduce(function(cur, str, index) {\n      var idx, n, s;\n      s = \"\";\n      for (idx = 0; idx < longest; idx += 1) {\n        if (operation === \"and\") {\n          n = cur.charCodeAt(idx) & str.charCodeAt(idx);\n        } else if (operation === \"or\") {\n          n = cur.charCodeAt(idx) | str.charCodeAt(idx);\n        } else if (operation === \"xor\") {\n          if (index > 0) {\n            n = cur.charCodeAt(idx) ^ str.charCodeAt(idx);\n          } else {\n            n = cur.charCodeAt(idx);\n          }\n        } else if (operation === \"not\") {\n          n = ~cur.charCodeAt(idx);\n        }\n        s += String.fromCharCode(n);\n      }\n      return s;\n    }, strings[0]);\n    r = this.set(destkey, string);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, string.length);\n  };\n  redismock2.bitpos = function(key2, bit, callback) {\n    var g = gather(this.bitpos).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length > 2) {\n      start = g.list[2];\n      end = g.list[3];\n    }\n    if (typeof start === \"undefined\") {\n      start = 0;\n    }\n    if (bit !== 0 && bit !== 1) {\n      return cb(callback)(new Error(\"ERR The bit argument must be 1 or 0.\"));\n    }\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      if (bit === 0) {\n        return 0;\n      }\n      return -1;\n    }).thenex(function() {\n      var idx, ch, cnt, noend = false;\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (typeof end === \"undefined\") {\n        noend = true;\n        end = cache[key2].length - 1;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return -1;\n      }\n      for (idx = start; idx <= end; idx += 1) {\n        ch = cache[key2].charCodeAt(idx);\n        cnt = 0;\n        while (cnt < 8) {\n          if (bit === 0 && (ch & 128) !== 128) {\n            return idx * 8 + cnt;\n          }\n          if (bit === 1 && (ch & 128) === 128) {\n            return idx * 8 + cnt;\n          }\n          ch <<= 1;\n          cnt += 1;\n        }\n      }\n      if (bit === 1) {\n        return -1;\n      }\n      if (bit === 0 && noend) {\n        return idx * 8;\n      }\n      return -1;\n    }).end();\n  };\n  redismock2.decr = function(key2, callback) {\n    return this.decrby(key2, 1, callback);\n  };\n  redismock2.decrby = function(key2, decrement, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt - decrement);\n      return asInt - decrement;\n    }).end();\n  };\n  redismock2.get = function(key2, callback) {\n    if (this.type(key2) === \"string\") {\n      return cb(callback)(null, cache[key2]);\n    }\n    return cb(callback)(null, null);\n  };\n  redismock2.getbit = function(key2, offset, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var n, pos;\n      if (offset >= cache[key2].length * 8) {\n        return 0;\n      }\n      n = cache[key2].charCodeAt(Math.floor(offset / 8));\n      pos = offset % 8;\n      return n >> pos & 1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.getrange = function(key2, start, end, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var len = 0;\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start < 0) {\n        len = end - (cache[key2].length + start) + 1;\n      } else {\n        len = end - start + 1;\n      }\n      return cache[key2].substr(start, len);\n    }).thennx(function() {\n      return \"\";\n    }).end();\n  };\n  redismock2.getset = function(key2, value, callback) {\n    var prev = this.get(key2);\n    this.set(key2, value);\n    return cb(callback)(null, prev);\n  };\n  redismock2.incr = function(key2, callback) {\n    return this.incrby(key2, 1, callback);\n  };\n  redismock2.incrby = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return asInt + increment;\n    }).end();\n  };\n  redismock2.incrbyfloat = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseFloat(this.get(key2));\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return this.get(key2);\n    }).end();\n  };\n  redismock2.mget = function(key2, callback) {\n    var g = gather(this.mget).apply(this, arguments);\n    callback = g.callback;\n    var data = typeof g.list[0] === \"object\" ? g.list[0] : g.list;\n    return cb(callback)(null, data.map(function(k) {\n      return cache[k] || null;\n    }));\n  };\n  redismock2.mset = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.mset).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.msetnx = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.msetnx).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    if (kvs.some(function(kv) {\n      return that.exists(kv[0]);\n    })) {\n      return cb(callback)(null, 0);\n    }\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, 1);\n  };\n  redismock2.psetex = function(key2, milliseconds, value, callback) {\n    this.set(key2, value);\n    this.pexpire(key2, milliseconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.set = function(key2, value, callback) {\n    var nx = false, xx = false, ex = -1, px = -1;\n    var g = gather(this.set).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (opt === \"nx\" || opt === \"NX\") {\n        nx = true;\n      } else if (opt === \"xx\" || opt === \"XX\") {\n        xx = true;\n      } else if (opt === \"ex\" || opt === \"EX\") {\n        ex = g.list[index + 1];\n      } else if (opt === \"px\" || opt === \"PX\") {\n        px = g.list[index + 1];\n      }\n    });\n    if (nx) {\n      if (this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    if (xx) {\n      if (!this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    cache[key2] = exists(value) ? value.toString() : \"\";\n    if (px !== -1) {\n      redismock2.pexpire(key2, px);\n    }\n    if (ex !== -1) {\n      redismock2.expire(key2, ex);\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.setbit = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var byteIdx = Math.floor(offset / 8);\n      var bitIdx = offset % 8;\n      var idx, bit, mask;\n      var code;\n      if (value !== 0 && value !== 1) {\n        return new Error(\"ERR bit is not an integer or out of range\");\n      }\n      while (cache[key2].length < byteIdx + 1) {\n        cache[key2] += \"\\0\";\n      }\n      code = cache[key2].charCodeAt(byteIdx);\n      idx = 0;\n      mask = 128;\n      while (idx < bitIdx) {\n        mask >>= 1;\n        idx += 1;\n      }\n      bit = (code & mask) === 0 ? 0 : 1;\n      if (value === 0) {\n        code = code & ~mask;\n      } else {\n        code = code | mask;\n      }\n      cache[key2] = cache[key2].substr(0, byteIdx) + String.fromCharCode(code) + cache[key2].substr(byteIdx + 1);\n      return bit;\n    }).end();\n  };\n  redismock2.setex = function(key2, seconds, value, callback) {\n    this.set(key2, value);\n    this.expire(key2, seconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.setnx = function(key2, value, callback) {\n    if (!this.exists(key2)) {\n      this.set(key2, value);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.setrange = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var idx, newValue;\n      if (cache[key2].length < offset + value.length - 1) {\n        for (idx = cache[key2].length; idx < offset + value.length; idx += 1) {\n          cache[key2] += \"\\0\";\n        }\n      }\n      newValue = cache[key2].substr(0, offset);\n      for (idx = offset; idx < offset + value.length; idx += 1) {\n        newValue += value[idx - offset];\n      }\n      newValue += cache[key2].substr(offset + value.length);\n      cache[key2] = newValue;\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.strlen = function(key2, callback) {\n    if (!this.exists(key2)) {\n      return cb(callback)(null, 0);\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.blpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.blpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    var f, timedout = false;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.lpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.brpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.brpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    var f, timedout = false;\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.rpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.brpoplpush = function(source, destination, timeout, callback) {\n    var that = this;\n    var f, timedout = false;\n    f = function() {\n      var len;\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      len = that.llen(source);\n      if (len instanceof Error) {\n        return cb(callback)(len);\n      }\n      if (len > 0) {\n        that.rpoplpush(source, destination, callback);\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.lindex = function(key2, i, callback) {\n    var elem = null;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (i >= 0 && i < cache[key2].length) {\n        elem = cache[key2][i];\n      } else if (i < 0 && cache[key2].length + 1 >= 0) {\n        elem = cache[key2][cache[key2].length + i];\n      }\n    }).then(function() {\n      return elem;\n    }).end();\n  };\n  redismock2.linsert = function(key2, beforeafter, pivot, value, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx = cache[key2].indexOf(pivot);\n      if (idx !== -1) {\n        if (beforeafter === \"before\") {\n          cache[key2].splice(idx, 0, value);\n        } else if (beforeafter === \"after\") {\n          cache[key2].splice(idx + 1, 0, value);\n        }\n        return cache[key2].length;\n      }\n      return -1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.llen = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.lpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].shift();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.lpush = function(key2, element, callback) {\n    var g = gather(this.lpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock2.Array();\n    }).then(function() {\n      g.list.slice(1).forEach(function(elem) {\n        cache[key2].unshift(elem);\n      });\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.lpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].unshift(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.lrange = function(key2, start, end, callback) {\n    var l = [];\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (start > cache[key2].length - 1) {\n        l = [];\n      } else {\n        if (start < 0) {\n          start = cache[key2].length + start;\n        }\n        if (end < 0) {\n          end = cache[key2].length + end;\n        }\n        if (start > end) {\n          l = [];\n        } else {\n          l = cache[key2].slice(start, end + 1);\n        }\n      }\n    }).then(function() {\n      return l;\n    }).end();\n  };\n  redismock2.lrem = function(key2, count, element, callback) {\n    var cnt = 0;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx;\n      while (true) {\n        idx = cache[key2].indexOf(element);\n        if (idx === -1) {\n          break;\n        }\n        cache[key2].splice(idx, 1);\n        cnt += 1;\n        if (count > 0 && cnt === count) {\n          break;\n        }\n      }\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return cnt;\n    }).end();\n  };\n  redismock2.lset = function(key2, index, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (index >= cache[key2].length) {\n        return new Error(\"ERR index out of range\");\n      }\n      cache[key2][index] = element;\n      return \"OK\";\n    }).thennx(function() {\n      return new Error(\"ERR no such key\");\n    }).end();\n  };\n  redismock2.ltrim = function(key2, start, end, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var tmpS, tmpE;\n      if (start > cache[key2].length - 1 || start > end) {\n        cache[key2] = new redismock2.Array();\n      } else {\n        if (start < 0 && end < 0) {\n          tmpE = cache[key2].length + end;\n          tmpS = cache[key2].length + start;\n          if (tmpS < 0) {\n            tmpS = 0;\n          }\n          start = tmpS;\n          end = tmpE;\n        }\n        if (end > cache[key2].length - 1) {\n          end = cache[key2].length - 1;\n        }\n        cache[key2] = cache[key2].slice(start, end + 1);\n      }\n    }).then(function() {\n      if (this.exists(key2) && !cache[key2].length) {\n        this.del(key2);\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock2.rpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].pop();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.rpoplpush = function(source, dest, callback) {\n    var element = null, reply;\n    if (this.exists(source) && this.type(source) !== \"list\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"list\") {\n      return wrongType(callback);\n    }\n    element = this.rpop(source);\n    if (element instanceof Error) {\n      return cb(callback)(element);\n    }\n    if (element) {\n      reply = this.lpush(dest, element);\n      if (reply instanceof Error) {\n        return cb(callback)(reply);\n      }\n    }\n    return cb(callback)(null, element);\n  };\n  redismock2.rpush = function(key2, element, callback) {\n    var g = gather(this.rpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock2.Array();\n    }).then(function() {\n      cache[key2] = cache[key2].concat(g.list.slice(1));\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.rpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].push(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.sadd = function(key2, member, callback) {\n    var g = gather(this.sadd).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      cache[sets][key2] = {};\n    }).then(function() {\n      g.list.slice(1).forEach(function(m) {\n        m = m ? m.toString() : \"\";\n        if (m.length === 0) {\n          return;\n        }\n        if (!(m in cache[sets][key2])) {\n          cache[sets][key2][m] = \"\";\n          count += 1;\n        }\n      });\n      return count;\n    }).end();\n  };\n  redismock2.scard = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]).length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.sdiff = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sdiff).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(diff, k) {\n        return diff.filter(function(d) {\n          return !(d in cache[sets][k]);\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock2.sdiffstore = function(destination, key2, callback) {\n    var g = gather(this.sdiffstore).apply(this, arguments);\n    var diff = this.sdiff.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (diff instanceof Error) {\n      return cb(callback)(diff);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    this.sadd.apply(this, [destination].concat(diff));\n    return cb(callback)(null, diff.length);\n  };\n  redismock2.sinter = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sinter).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(inter, k) {\n        return inter.filter(function(i) {\n          return i in cache[sets][k];\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock2.sinterstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sinterstore).apply(this, arguments);\n    var inter = this.sinter.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (inter instanceof Error) {\n      return cb(callback)(inter);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    inter.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, inter.length);\n  };\n  redismock2.sismember = function(key2, member, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return member in cache[sets][key2] ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.smembers = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]);\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.smove = function(source, dest, member, callback) {\n    var r, e;\n    if (this.exists(source) && this.type(source) !== \"set\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"set\") {\n      return wrongType(callback);\n    }\n    r = redismock2.srem(source, member);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    if (r === 1) {\n      e = redismock2.sadd(dest, member);\n      if (e instanceof Error) {\n        return cb(callback)(e);\n      }\n    }\n    return cb(callback)(null, r);\n  };\n  redismock2.spop = function(key2, callback) {\n    var r;\n    var rando = this.srandmember(key2);\n    if (rando instanceof Error) {\n      return cb(callback)(rando);\n    }\n    r = this.srem(key2, rando);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, rando);\n  };\n  redismock2.srandmember = function(key2, callback) {\n    var that = this;\n    var count;\n    if (arguments.length === 2 && typeof callback !== \"function\") {\n      count = callback;\n      callback = null;\n    }\n    if (arguments.length === 3) {\n      count = callback;\n      callback = arguments[2];\n    }\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      var k = Object.keys(cache[sets][key2]);\n      var randos, rando;\n      var len = that.scard(key2);\n      if (count === 0) {\n        return null;\n      }\n      if (count) {\n        randos = [];\n        while (randos.length < Math.abs(count)) {\n          rando = k[Math.floor(Math.random() * k.length)];\n          if (count < 0) {\n            randos.push(rando);\n          } else {\n            if (randos.indexOf(rando) === -1) {\n              randos.push(rando);\n              if (randos.length === len) {\n                break;\n              }\n            }\n          }\n        }\n        return randos;\n      }\n      return k[Math.floor(Math.random() * k.length)];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.srem = function(key2, member, callback) {\n    var g = gather(this.srem).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      g.list.slice(1).forEach(function(m) {\n        var k = m ? m.toString() : \"\";\n        if (k in cache[sets][key2]) {\n          delete cache[sets][key2][k];\n          count += 1;\n        }\n      });\n      if (!Object.keys(cache[sets][key2]).length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock2.sunion = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sunion).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return Object.keys(g.list.reduce(function(set, k) {\n        Object.keys(cache[sets][k]).filter(function(u) {\n          return !(u in set);\n        }).forEach(function(u) {\n          set[u] = \"\";\n        });\n        return set;\n      }, {}));\n    }).end();\n  };\n  redismock2.sunionstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sunionstore).apply(this, arguments);\n    var union = this.sunion.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (union instanceof Error) {\n      return cb(callback)(union);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    union.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, union.length);\n  };\n  redismock2.sscan = function(key2, cursor, callback) {\n    var g = gather(this.sscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).then(function() {\n      var arr = [];\n      this.smembers(key2).slice(cursor).some(function(member) {\n        if (typeof match === \"undefined\" || member.match(match)) {\n          arr.push(member);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.zadd = function(key2, score, member, callback) {\n    var g = gather(this.zadd).apply(this, arguments);\n    callback = g.callback;\n    g.list = g.list.slice(1);\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock2.SortedSet();\n    }).then(function() {\n      var count = g.list.map(function(elem, index) {\n        if (index % 2 === 0) {\n          return [parseFloat(g.list[index]), g.list[index + 1]];\n        }\n        return null;\n      }).filter(function(elem) {\n        return elem !== null;\n      }).map(function(sm) {\n        return cache[zsets][key2].add(sm[0], sm[1].toString());\n      }).reduce(function(cnt, ret) {\n        return cnt + ret;\n      }, 0);\n      return count;\n    }).end();\n  };\n  redismock2.zcard = function(key2, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      return cache[zsets][key2].card;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zcount = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = cache[zsets][key2].scores.filter(function(score) {\n        return min <= score && score <= max;\n      }).reduce(function(cnt, score) {\n        return cnt + cache[zsets][key2].lengths[score];\n      }, 0);\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zincrby = function(key2, increment, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock2.SortedSet();\n    }).then(function() {\n      var newScore, score;\n      if (!exists(cache[zsets][key2].invset[member])) {\n        this.zadd(key2, increment, member);\n        return increment;\n      }\n      score = cache[zsets][key2].invset[member];\n      newScore = score + increment;\n      this.zadd(key2, newScore, member);\n      return newScore;\n    }).end();\n  };\n  redismock2.zinterstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zinterstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(inter, k) {\n      var arr = [];\n      var idx, len = inter.length;\n      var score, ms;\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        score = cache[zsets][k].invset[inter[idx]];\n        if (!exists(score)) {\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        ms = [inter[idx + 1], inter[idx]];\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, inter) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, inter[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.zlexcount = function(key2, min, max, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock2.zrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = Math.max(this.zcard(key2) + start, 0);\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].lengths[score] > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].lengths[score];\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        while (from < to) {\n          if (exists(cache[zsets][key2].set[score][from])) {\n            arr.push(cache[zsets][key2].set[score][from]);\n          }\n          from += 1;\n        }\n        arr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrangebylex = function(key2, min, max, callback) {\n    function verify(r) {\n      return typeof r === \"string\" && (r.charAt(0) === \"(\" || r.charAt(0) === \"[\" || r.charAt(0) === \"-\" || r.charAt(0) === \"+\");\n    }\n    if (!verify(min) || !verify(max)) {\n      return cb(callback)(new Error(\"ERR min or max not valid string range item\"));\n    }\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      var minStr = min.substr(1), maxStr = max.substr(1);\n      var minInclusive = min.charAt(0) === \"[\", maxInclusive = max.charAt(0) === \"[\";\n      var maxAll = max.charAt(0) === \"+\";\n      var range = [];\n      if (min.charAt(0) === \"+\") {\n        return [];\n      }\n      if (max.charAt(0) === \"-\") {\n        return [];\n      }\n      cache[zsets][key2].scores.forEach(function(score) {\n        cache[zsets][key2].set[score].forEach(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if (member > minStr && (member < maxStr || maxAll)) {\n            range.push(member);\n          } else if (member === minStr && minInclusive) {\n            range.push(member);\n          } else if (member === maxStr && maxInclusive) {\n            range.push(member);\n          }\n        });\n      });\n      range.sort(function(a, b) {\n        return a.localeCompare(b);\n      });\n      return range;\n    }).end();\n  };\n  redismock2.zrevrangebylex = function(key2, max, min, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.reverse());\n  };\n  redismock2.zrangebyscore = function(key2, min, max, callback) {\n    var withscores = false;\n    var limitOffset = -1, limitCount = -1;\n    var idx, len;\n    var arr = [], offset, count;\n    var minInclusive = true, maxInclusive = true;\n    if (typeof callback !== \"function\") {\n      len = arguments.length;\n      for (idx = 3; idx < len; idx += 1) {\n        if (arguments[idx] === \"withscores\") {\n          withscores = true;\n        }\n        if (typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        }\n        if (arguments[idx] === \"limit\") {\n          limitOffset = arguments[idx + 1];\n          limitCount = arguments[idx + 2];\n        }\n      }\n    }\n    if (min === \"-inf\") {\n      min = Number.NEGATIVE_INFINITY;\n    }\n    if (min === \"+inf\") {\n      min = Number.POSITIVE_INFINITY;\n    }\n    if (max === \"-inf\") {\n      max = Number.NEGATIVE_INFINITY;\n    }\n    if (max === \"+inf\") {\n      max = Number.POSITIVE_INFINITY;\n    }\n    if (min.toString().charAt(0) === \"(\") {\n      minInclusive = false;\n      min = parseFloat(min.toString().substr(1));\n    }\n    if (max.toString().charAt(0) === \"(\") {\n      maxInclusive = false;\n      max = parseFloat(max.toString().substr(1));\n    }\n    offset = 0;\n    count = 0;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        var memberArr = [], scoreArr = [], concatArr = [];\n        cache[zsets][key2].set[score].some(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if ((minInclusive && min <= score || !minInclusive && min < score) && (maxInclusive && score <= max || !maxInclusive && score < max)) {\n            if (limitOffset !== -1 && offset >= limitOffset) {\n              if (limitCount !== -1) {\n                if (count + memberArr.length < limitCount) {\n                  memberArr.push(member);\n                  if (withscores) {\n                    scoreArr.push(score);\n                  }\n                } else {\n                  return true;\n                }\n              }\n            } else if (limitOffset === -1) {\n              memberArr.push(member);\n              if (withscores) {\n                scoreArr.push(score);\n              }\n            }\n          }\n          offset += 1;\n          return false;\n        });\n        count += memberArr.length;\n        memberArr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          memberArr.forEach(function(m, idx2) {\n            concatArr.push(m, scoreArr[idx2]);\n          });\n        } else {\n          concatArr = memberArr;\n        }\n        arr = arr.concat(concatArr);\n        if (limitCount !== -1 && count === limitCount) {\n          return true;\n        }\n        return false;\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx = 0;\n      var found;\n      cache[zsets][key2].sortScores();\n      found = cache[zsets][key2].scores.some(function(score) {\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return true;\n        }\n        idx += 1;\n        return false;\n      });\n      if (!found) {\n        return null;\n      }\n      return idx;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zrem = function(key2, member, callback) {\n    var g = gather(this.zrem).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = g.list.reduce(function(cnt, m) {\n        return cnt + cache[zsets][key2].rem(m);\n      }, 0);\n      if (cache[zsets][key2].scores.length === 0) {\n        this.del(key2);\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zremrangebylex = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebylex(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock2.zremrangebyrank = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var that = this;\n      var idx, len = cache[zsets][key2].scores.length, jdx, nel;\n      var cnt;\n      var score;\n      var toRem = [];\n      var card = this.zcard(key2);\n      if (min < 0) {\n        min = card + min;\n      }\n      if (max < 0) {\n        max = card + max;\n      }\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = 0; idx < len; idx += 1) {\n        score = cache[zsets][key2].scores[idx];\n        nel = cache[zsets][key2].set[score].length;\n        for (jdx = 0; jdx < nel; jdx += 1, cnt += 1) {\n          if (min <= cnt && cnt <= max) {\n            toRem.push(cache[zsets][key2].set[score][jdx]);\n          }\n          if (cnt > max) {\n            break;\n          }\n        }\n        if (cnt > max) {\n          break;\n        }\n      }\n      toRem.forEach(function(r) {\n        that.zrem(key2, r);\n      });\n      return toRem.length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zremrangebyscore = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebyscore(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock2.zrevrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = this.zcard(key2) + start;\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScoresRev().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].set[score].length > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].set[score].length;\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        arr = cache[zsets][key2].set[score].slice(from, to);\n        arr.sort(function(a, b) {\n          return b.localeCompare(a);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrevrangebyscore = function(key2, max, min, callback) {\n    var g = gather(this.zrevrangebyscore).apply(this, arguments);\n    var r, tmpM;\n    callback = g.callback;\n    tmpM = g.list[1];\n    g.list[1] = g.list[2];\n    g.list[2] = tmpM;\n    r = this.zrangebyscore.apply(this, g.list);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    r.reverse();\n    if (g.list.some(function(arg) {\n      return arg === \"withscores\";\n    })) {\n      r = r.map(function(e, idx) {\n        if (idx % 2 === 0) {\n          return r[idx + 1];\n        }\n        return r[idx - 1];\n      });\n    }\n    return cb(callback)(null, r);\n  };\n  redismock2.zrevrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx, len = cache[zsets][key2].scores.length, cnt;\n      var score;\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = len - 1; idx >= 0; idx -= 1, cnt += 1) {\n        score = cache[zsets][key2].scores[idx];\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return cnt;\n        }\n      }\n      return null;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zscore = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var score = null;\n      if (exists(cache[zsets][key2].invset[member])) {\n        score = cache[zsets][key2].invset[member];\n      }\n      return score;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zunionstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zunionstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2, 2 + numkeys).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(union, k) {\n      var arr = [];\n      var idx, len = union.length;\n      var score, ms;\n      var hashk = cache[zsets][k].invset;\n      var hashu = {};\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        ms = [union[idx + 1], union[idx]];\n        score = cache[zsets][k].invset[union[idx]];\n        hashu[ms[1]] = ms[0];\n        if (!exists(score)) {\n          arr.push(ms[1], ms[0]);\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      Object.keys(hashk).forEach(function(member) {\n        if (!exists(hashk[member])) {\n          return;\n        }\n        if (!(member in hashu)) {\n          score = hashk[member];\n          if (k in weights) {\n            score *= weights[k];\n          }\n          arr.push(member, score);\n        }\n      });\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, union) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, union[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.zscan = function(key2, cursor, callback) {\n    var g = gather(this.zscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).then(function() {\n      var arr = [];\n      var cnt = 0;\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        cache[zsets][key2].set[score].some(function(member) {\n          if (cursor <= cnt) {\n            if (typeof match === \"undefined\" || member.match(match)) {\n              arr.push([member, score]);\n            }\n            cursor += 1;\n          }\n          if (arr.length >= count) {\n            return true;\n          }\n          cnt += 1;\n          return false;\n        });\n        if (arr.length >= count) {\n          return true;\n        }\n        return false;\n      });\n      arr = arr.reduce(function(unnested, ms) {\n        return unnested.concat(ms);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.hdel = function(key2, field, callback) {\n    var count = 0;\n    var g = gather(this.hdel).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list.forEach(function(field2) {\n        if (field2 in cache[hashes][key2]) {\n          cache[hashes][key2][field2] = void 0;\n          count += 1;\n        }\n      });\n      if (Object.keys(cache[hashes][key2]).length === 0) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock2.hexists = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field] !== void 0 ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.hget = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.hgetall = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var obj = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        prev[fv[0]] = fv[1];\n        return prev;\n      }, {});\n      return obj;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.hgetall_array = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var arr = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hincrby = function(key2, field, increment, callback) {\n    increment = parseInt(increment, 10);\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseInt(this.hget(key2, field), 10);\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not an integer\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock2.hincrbyfloat = function(key2, field, increment, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseFloat(this.hget(key2, field));\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not a valid float\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock2.hkeys = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return Object.keys(cache[hashes][key2]).filter(function(f) {\n        return cache[hashes][key2][f] !== void 0;\n      });\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hlen = function(key2, callback) {\n    var r = this.hkeys(key2);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock2.hmget = function(key2, field, callback) {\n    var g = gather(this.hmget).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list = g.list.slice(1);\n      var arr = g.list.map(function(f) {\n        return cache[hashes][key2][f];\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hmset = function(key2, field, callback) {\n    var g = gather(this.hmset).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var that = this;\n      var first = g.list[1];\n      if (g.list.length === 2 && typeof first === \"object\" && !(first instanceof Array)) {\n        Object.keys(first).forEach(function(fv) {\n          that.hset(key2, fv, first[fv]);\n        });\n      } else {\n        g.list = g.list.slice(1);\n        g.list.map(function(fv, index) {\n          if (index % 2 === 0) {\n            return [fv, g.list[index + 1]];\n          }\n          return null;\n        }).filter(function(fv) {\n          return fv !== null;\n        }).forEach(function(fv) {\n          that.hset(key2, fv[0], fv[1]);\n        });\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock2.hset = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n      } else {\n        ret = 1;\n      }\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      cache[hashes][key2][field] = value;\n      return ret;\n    }).end();\n  };\n  redismock2.hsetnx = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n        return;\n      }\n      ret = 1;\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      if (ret === 1) {\n        cache[hashes][key2][field] = value;\n      }\n      return ret;\n    }).end();\n  };\n  redismock2.hstrlen = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      return 0;\n    }).thenex(function() {\n      if (!exists(cache[hashes][key2][field])) {\n        return 0;\n      }\n      return cache[hashes][key2][field].toString().length;\n    }).end();\n  };\n  redismock2.hvals = function(key2, callback) {\n    var vals = [];\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      vals = Object.keys(cache[hashes][key2]).filter(function(field) {\n        return cache[hashes][key2][field] !== void 0;\n      }).map(function(field) {\n        return cache[hashes][key2][field];\n      });\n    }).then(function() {\n      return vals;\n    }).end();\n  };\n  redismock2.hscan = function(key2, cursor, callback) {\n    var g = gather(this.hscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).then(function() {\n      var arr = [];\n      this.hgetall_array(key2).slice(cursor * 2).some(function(forv, index, hgetall) {\n        if (index % 2 !== 0) {\n          return false;\n        }\n        if (typeof match === \"undefined\" || forv.match(match)) {\n          arr.push([forv, hgetall[index + 1]]);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      arr = arr.reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.on = function(event, callback) {\n    if (!exists(this.listeners)) {\n      this.listeners = {};\n    }\n    if (!exists(this.listeners[event])) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n    return this;\n  };\n  function emit(rm, event) {\n    var g = gather(emit).apply(null, arguments);\n    if (exists(rm.listeners) && exists(rm.listeners[event])) {\n      rm.listeners[event].forEach(function(cb2) {\n        setImmediate(function() {\n          cb2.apply(rm, g.list.slice(2));\n        });\n      });\n    }\n  }\n  function Subscriber(rm) {\n    this.rm = rm;\n    return this;\n  }\n  Subscriber.prototype.subscribe = function(channel) {\n    this.channel = channel;\n    emit(this.rm, \"subscribe\", channel, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.psubscribe = function(pattern) {\n    this.originalPattern = pattern;\n    this.pattern = new RegExp(translate(pattern));\n    emit(this.rm, \"psubscribe\", pattern, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.matches = function(channel) {\n    if (exists(this.channel) && this.channel === channel) {\n      return true;\n    }\n    if (exists(this.pattern) && channel.match(this.pattern)) {\n      return true;\n    }\n    return false;\n  };\n  Subscriber.prototype.message = function(channel, message) {\n    if (this.matches(channel)) {\n      if (exists(this.channel)) {\n        emit(this.rm, \"message\", channel, message);\n        return true;\n      } else if (exists(this.pattern)) {\n        emit(this.rm, \"pmessage\", this.originalPattern, channel, message);\n        return true;\n      }\n    }\n    return false;\n  };\n  Subscriber.prototype.unsubscribe = function(count) {\n    if (exists(this.channel)) {\n      emit(this.rm, \"unsubscribe\", this.channel, count);\n    }\n    if (exists(this.pattern)) {\n      emit(this.rm, \"punsubscribe\", this.originalPattern, count);\n    }\n    return this;\n  };\n  redismock2.psubscribe = function(pattern, callback) {\n    var that = this;\n    var g = gather(this.psubscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(pat) {\n      subscribers.push(new Subscriber(that).psubscribe(pat));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.pubsub = function(subcommand, callback) {\n    var g = gather(this.pubsub).apply(this, arguments);\n    var ret = null, pat;\n    if (subcommand === \"channels\") {\n      if (g.list[1]) {\n        pat = new RegExp(translate(g.list[1]));\n      }\n      ret = subscribers.map(function(subscriber) {\n        if (exists(subscriber.channel) && (!pat || subscriber.channel.match(pat))) {\n          return subscriber.channel;\n        }\n        return null;\n      }).filter(function(channel) {\n        return channel !== null;\n      });\n    } else if (subcommand === \"numsub\") {\n      ret = g.list.slice(1).map(function(channel) {\n        return subscribers.reduce(function(count, subscriber) {\n          if (subscriber.channel === channel) {\n            return count + 1;\n          }\n          return count;\n        }, 0);\n      }).reduce(function(flattened, cc) {\n        return flattened.concat(cc);\n      }, []);\n    } else if (subcommand === \"numpat\") {\n      ret = subscribers.reduce(function(count, subscriber) {\n        if (exists(subscriber.pattern)) {\n          return count + 1;\n        }\n        return count;\n      }, 0);\n    }\n    callback = g.callback;\n    return cb(callback)(null, ret);\n  };\n  redismock2.publish = function(channel, message, callback) {\n    var count = subscribers.reduce(function(cnt, subscriber) {\n      if (subscriber.message(channel.toString(), message.toString())) {\n        return cnt + 1;\n      }\n      return cnt;\n    }, 0);\n    return cb(callback)(null, count);\n  };\n  redismock2.punsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.punsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.pattern)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.pattern);\n      });\n    } else {\n      g.list.forEach(function(pattern) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.originalPattern === pattern) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.subscribe = function(channel, callback) {\n    var that = this;\n    var g = gather(this.subscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(chan) {\n      subscribers.push(new Subscriber(that).subscribe(chan));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.unsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.unsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.channel)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.channel);\n      });\n    } else {\n      g.list.forEach(function(chan) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.channel === chan) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n          }\n          return subscriber.channel !== chan;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.discard = function(callback) {\n    return cb(callback)(new Error(\"ERR DISCARD without MULTI\"));\n  };\n  redismock2.multi = function(commands) {\n    var rc = {};\n    var that = this;\n    var toApply = [], replies = [];\n    if (exists(commands)) {\n      toApply = toApply.concat(commands.map(function(command) {\n        var args = command.slice(1);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        return [command[0], that[command[0]], that, args];\n      }));\n    }\n    Object.keys(this).forEach(function(key2) {\n      rc[key2] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        toApply.push([key2, that[key2], that, args]);\n        return this;\n      };\n    });\n    rc.exec = function(callback) {\n      if (toApply.some(function(apply) {\n        var check = apply[3][0];\n        if (exists(watchers[check]) && watchers[check].modified && watchers[check].watchers.indexOf(that) !== -1) {\n          return true;\n        }\n        return false;\n      })) {\n        that.unwatch();\n        return cb(callback)(null, null);\n      }\n      toApply.forEach(function(apply) {\n        apply[1].apply(apply[2], apply[3]);\n      });\n      that.unwatch();\n      return cb(callback)(null, replies);\n    };\n    rc.discard = function(callback) {\n      toApply = [];\n      that.unwatch();\n      return cb(callback)(null, \"OK\");\n    };\n    return rc;\n  };\n  redismock2.unwatch = function(callback) {\n    var that = this;\n    Object.keys(watchers).forEach(function(k) {\n      if (exists(watchers[k])) {\n        watchers[k].watchers = watchers[k].watchers.filter(function(mock) {\n          return that !== mock;\n        });\n        if (watchers[k].watchers.length === 0) {\n          watchers[k] = void 0;\n        }\n      }\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.watch = function(key2, callback) {\n    if (!exists(watchers[key2])) {\n      watchers[key2] = {\n        modified: false,\n        watchers: []\n      };\n    }\n    watchers[key2].watchers.push(this);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.eval = function(script, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.evalsha = function(sha1, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_exists = function(script, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_flush = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_load = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.auth = function(password, callback) {\n    if (!redismock2.password) {\n      return cb(callback)(new Error(\"ERR Client sent AUTH, but no password is set\"));\n    }\n    if (password === redismock2.password) {\n      return cb(callback)(null, \"OK\");\n    }\n    return cb(callback)(new Error(\"ERR invalid password\"));\n  };\n  redismock2.echo = function(message, callback) {\n    return cb(callback)(null, message);\n  };\n  redismock2.ping = function(callback) {\n    return cb(callback)(null, \"PONG\");\n  };\n  redismock2.quit = function(callback) {\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.select = function(index, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.createClient = function() {\n    return redismock2.copy();\n  };\n  redismock2.bgrewriteaof = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.bgsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_list = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_getname = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_pause = function(timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_setname = function(connection_name, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.cluster_slots = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_count = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_getkeys = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_get = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_rewrite = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_set = function(parameter, value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_resetstat = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.dbsize = function(callback) {\n    var count = 0, key2;\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    return cb(callback)(null, count);\n  };\n  redismock2.debug_object = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.debug_segfault = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.flushall = function(callback) {\n    return this.flushdb(callback);\n  };\n  redismock2.flushdb = function(callback) {\n    cache = {};\n    cache[sets] = {};\n    cache[zsets] = {};\n    cache[hashes] = {};\n    Object.keys(timeouts).forEach(function(key2) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n    });\n    timeouts = {};\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.lastsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.monitor = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.role = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.save = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.shutdown = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.slaveof = function(host, port, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.slowlog = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.sync = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.time = function(callback) {\n    var now = /* @__PURE__ */ new Date();\n    var epoch = now.getTime();\n    var us;\n    if (root.performance) {\n      if (root.performance.now) {\n        now = root.performance.now();\n        us = (now - Math.floor(now)) * 1e5;\n      } else if (root.performance.webkitNow) {\n        now = root.performance.webkitNow();\n        us = (now - Math.floor(now)) * 1e5;\n      } else {\n        us = 0;\n      }\n    } else if (typeof process !== \"undefined\" && process.hrtime) {\n      us = process.hrtime()[1] / 1e3;\n    } else {\n      us = 0;\n    }\n    return cb(callback)(null, [epoch, us]);\n  };\n  var modifiers = [\"del\", \"mset\", \"msetnx\", \"psetex\", \"set\", \"setbit\", \"setex\", \"setrange\", \"incr\", \"decr\", \"incrby\", \"decrby\", \"incrbyfloat\", \"blpop\", \"brpop\", \"brpoplpush\", \"linsert\", \"lpush\", \"lpushx\", \"rpush\", \"rpushx\", \"lpop\", \"rpop\", \"rpoplpush\", \"ltrim\", \"lset\", \"lrem\", \"sadd\", \"smove\", \"spop\", \"sdiffstore\", \"sinterstore\", \"srem\", \"sunionstore\", \"zadd\", \"zrem\", \"zunionstore\", \"zinterstore\", \"zincrby\", \"zremrangebylex\", \"zremrangebyrank\", \"zremrangebyscore\", \"hdel\", \"hincrby\", \"hincrbyfloat\", \"hset\", \"hmset\", \"hsetnx\"];\n  var capture = {};\n  var fkeys = [];\n  for (var key in redismock2) {\n    if (typeof redismock2[key] === \"function\") {\n      fkeys.push(key);\n      capture[key] = redismock2[key];\n    }\n  }\n  fkeys.forEach(function(key2) {\n    redismock2[key2] = function() {\n      if (arguments.length < capture[key2].length - 1) {\n        return cb(arguments[arguments.length - 1])(new Error(\"ERR wrong number of arguments for '\" + key2 + \"' command\"));\n      }\n      return capture[key2].apply(this, arguments);\n    };\n  });\n  modifiers.forEach(function(modifier) {\n    var mod = redismock2[modifier];\n    redismock2[modifier] = function() {\n      var key2 = arguments[0];\n      if (exists(watchers[key2])) {\n        watchers[key2].modified = true;\n      }\n      return mod.apply(this, arguments);\n    };\n  });\n  function toPromise(f, context, deferFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      var deferred = deferFactory(), promise;\n      var callback;\n      while (args.length < f.length - 1) {\n        args.push(void 0);\n      }\n      if (typeof args[args.length - 1] === \"function\") {\n        callback = args[args.length - 1];\n        args.pop();\n      }\n      args.push(function(err, reply) {\n        if (err) {\n          if (callback && typeof callback === \"function\") {\n            callback(err);\n          }\n          return deferred.reject(err);\n        }\n        if (callback && typeof callback === \"function\") {\n          callback(null, reply);\n        }\n        deferred.resolve(reply);\n      });\n      f.apply(context, args);\n      promise = deferred.promise;\n      if (typeof promise === \"function\") {\n        promise = promise();\n      }\n      return promise;\n    };\n  }\n  redismock2.toPromiseStyle = function(deferFactory) {\n    var that = this;\n    return Object.keys(this).filter(function(key2) {\n      return typeof that[key2] === \"function\" && key2 !== \"multi\";\n    }).map(function(key2) {\n      return [key2, toPromise(that[key2], that, deferFactory)];\n    }).reduce(function(promised, f) {\n      promised[f[0]] = f[1];\n      return promised;\n    }, { multi: this.multi });\n  };\n  redismock2.copy = function() {\n    var copied = {};\n    fkeys.forEach(function(key2) {\n      copied[key2] = function() {\n        return redismock2[key2].apply(copied, arguments);\n      };\n    });\n    copied.toPromiseStyle = redismock2.toPromiseStyle;\n    copied.listeners = {};\n    return copied;\n  };\n  redismock2.unref = function() {\n  };\n  if (typeof process !== \"undefined\" && process.env.REDIS_JS_TO_NODE_REDIS === \"1\") {\n    var asNodeRedis;\n    var node_redis_args = [];\n    if (process.env.REDIS_JS_NODE_REDIS_PORT) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_PORT);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_HOST) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_HOST);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_OPTIONS) {\n      node_redis_args.push(JSON.parse(process.env.REDIS_JS_NODE_REDIS_OPTIONS));\n    }\n  }\n}).call(void 0);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redismock);\n\n\n//# sourceURL=webpack://hypha-core/./src/utils/redis-mock.js?");

/***/ }),

/***/ "./src/workspace.js":
/*!**************************!*\
  !*** ./src/workspace.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Workspace: () => (/* binding */ Workspace)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/index.js */ \"./src/utils/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\nconst _allowedCharacters = /^[a-zA-Z0-9-_/*]*$/;\nfunction validateKeyPart(keyPart) {\n  if (!_allowedCharacters.test(keyPart)) {\n    throw new Error(`Invalid characters in query part: ${keyPart}`);\n  }\n}\nfunction base64UrlEncode(data) {\n  const base64 = btoa(\n    typeof data === \"string\" ? data : String.fromCharCode(...new Uint8Array(data))\n  );\n  return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlDecode(base64Url) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  return atob(base64);\n}\nasync function hmacSha256(key, data) {\n  const encoder = new TextEncoder();\n  const keyData = encoder.encode(key);\n  const msgData = encoder.encode(data);\n  const cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    keyData,\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"]\n  );\n  const signature = await crypto.subtle.sign(\"HMAC\", cryptoKey, msgData);\n  return new Uint8Array(signature);\n}\nasync function generateJWT(payload, secret) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await hmacSha256(secret, unsigned);\n  const encodedSignature = base64UrlEncode(signature);\n  return `${unsigned}.${encodedSignature}`;\n}\nasync function verifyJWT(token, secret) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  const [encodedHeader, encodedPayload, encodedSignature] = parts;\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  try {\n    const header = JSON.parse(base64UrlDecode(encodedHeader));\n    if (header.alg !== \"HS256\") {\n      throw new Error(\"Unsupported algorithm\");\n    }\n    const expectedSignature = await hmacSha256(secret, unsigned);\n    const actualSignature = new Uint8Array(\n      Array.from(base64UrlDecode(encodedSignature)).map((c) => c.charCodeAt(0))\n    );\n    if (expectedSignature.length !== actualSignature.length) {\n      throw new Error(\"Invalid signature\");\n    }\n    for (let i = 0; i < expectedSignature.length; i++) {\n      if (expectedSignature[i] !== actualSignature[i]) {\n        throw new Error(\"Invalid signature\");\n      }\n    }\n    const payload = JSON.parse(base64UrlDecode(encodedPayload));\n    if (payload.exp && Date.now() / 1e3 > payload.exp) {\n      throw new Error(\"Token expired\");\n    }\n    return payload;\n  } catch (error) {\n    throw new Error(`JWT verification failed: ${error.message}`);\n  }\n}\nclass Workspace {\n  constructor(hyphaCore) {\n    this._server = hyphaCore;\n    this._redis = hyphaCore.redis;\n    this.connections = hyphaCore.connections;\n    this.eventBus = hyphaCore;\n    this.serverUrl = hyphaCore.url;\n    this.baseUrl = hyphaCore.baseUrl;\n    this._rpc = null;\n    this._localServices = /* @__PURE__ */ new Map();\n  }\n  waitForClient(cid, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        const ccid = info.id.split(\":\")[0];\n        if (ccid !== cid) {\n          console.log(`\\u{1F6AB} [DEBUG] ccid mismatch, ignoring service: ${info.id}`);\n          return;\n        }\n        this.eventBus.off(\"service_added\", handler);\n        if (info.type === \"imjoy\") {\n          clearTimeout(timeoutId);\n          resolve(info);\n          return;\n        } else {\n          if (!info.id.endsWith(\":default\")) {\n            console.error(`\\u274C [DEBUG] Unexpected service added (not :default):`, info);\n            return;\n          }\n          const defaultService = info;\n          clearTimeout(timeoutId);\n          this._rpc.get_remote_service(defaultService.id).then(async (svc) => {\n            try {\n              await this.eventBus.emit(\"client_ready\", svc);\n              resolve(svc);\n            } catch (e) {\n              reject(e);\n            }\n          }).catch((error) => {\n            console.error(`\\u274C [DEBUG] Failed to get remote service:`, error);\n            reject(error);\n          });\n        }\n      };\n      let timeoutId = setTimeout(() => {\n        this.eventBus.off(\"service_added\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"service_added\", handler);\n    });\n  }\n  async setup(config) {\n    if (!config.client_id) {\n      throw new Error(\"client_id is required in the config\");\n    }\n    const workspace = \"*\";\n    const connection = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.RedisRPCConnection(\n      this.eventBus,\n      workspace,\n      config.client_id,\n      null,\n      null\n    );\n    this.windows = [];\n    this.services = {};\n    this.plugins = {};\n    this.eventBus.on(\"client_ready\", async (svc) => {\n      this.plugins[svc.id] = svc;\n    });\n    const rpc = new hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.RPC(connection, {\n      client_id: config.client_id,\n      default_context: { connection_type: \"websocket\" },\n      workspace,\n      server_base_url: this.serverUrl,\n      silent: false\n    });\n    this._rpc = rpc;\n    const defaultServices = this.getDefaultService();\n    await rpc.register_service(Object.assign(defaultServices, config.default_service || {}), { notify: false });\n  }\n  async registerService(service, context) {\n    const ws = context.ws;\n    const clientId = context.from;\n    const userInfo = context.user;\n    service.config = service.config || {};\n    service.config.workspace = ws;\n    const originalServiceId = service.id;\n    let simpleServiceId = originalServiceId;\n    let isAlreadyConstructed = false;\n    if (originalServiceId.includes(\"/\") && originalServiceId.includes(\":\")) {\n      const parts = originalServiceId.split(\"/\");\n      if (parts.length === 2 && parts[1].includes(\":\")) {\n        isAlreadyConstructed = true;\n        simpleServiceId = parts[1];\n      }\n    }\n    const isBuiltInService = simpleServiceId.includes(\":built-in\") || simpleServiceId === \"built-in\";\n    const isLegitimateDefaultService = simpleServiceId === \"default\" || simpleServiceId.endsWith(\":default\") && clientId.endsWith(\"/\" + simpleServiceId.split(\":\")[0]);\n    if (ws === \"default\" && !clientId.endsWith(\"/root\") && !isBuiltInService && !isLegitimateDefaultService) {\n      throw new Error(`Access denied: Only root user can register services in '${ws}' workspace. Current client: ${clientId}`);\n    }\n    if (!isAlreadyConstructed) {\n      if (!service.id.includes(\":\")) {\n        service.id = `${clientId.split(\"/\")[1]}:${service.id}`;\n      }\n      if (service.id.includes(\"/\")) {\n        throw new Error(\"Service id must not contain '/'\");\n      }\n      service.id = `${ws}/${service.id}`;\n    }\n    service.app_id = service.app_id || \"*\";\n    service.config.visibility = service.config.visibility || \"protected\";\n    const isLocalService = this._hasServiceFunctions(service);\n    if (isLocalService) {\n      service = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToSnakeCase)(service);\n      const localServiceKey = `${service.id}@${service.app_id}`;\n      this._localServices.set(localServiceKey, service);\n      console.info(`Storing local service with snake_case methods: ${localServiceKey}`);\n    }\n    const serviceExists = this._redis.exists(`services:*:${service.id}@${service.app_id}`);\n    const key = `services:${service.config.visibility}:${service.id}@${service.app_id}`;\n    const serviceMetadata = {};\n    for (const [k, v] of Object.entries(service)) {\n      if (isLocalService && typeof v === \"function\") {\n        serviceMetadata[k] = { type: \"function\", name: v.name || k };\n      } else if (isLocalService && typeof v === \"object\" && v !== null && !Array.isArray(v)) {\n        const objMetadata = {};\n        for (const [subK, subV] of Object.entries(v)) {\n          if (typeof subV === \"function\") {\n            objMetadata[subK] = { type: \"function\", name: subV.name || subK };\n          } else {\n            objMetadata[subK] = subV;\n          }\n        }\n        serviceMetadata[k] = objMetadata;\n      } else {\n        serviceMetadata[k] = v;\n      }\n    }\n    for (const [k, v] of Object.entries(serviceMetadata)) {\n      this._redis.hset(key, k, v);\n    }\n    if (serviceExists) {\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_updated\", { id: clientId, workspace: ws });\n        console.info(`Updating built-in service: ${service.id}`);\n      } else {\n        this.eventBus.emit(\"service_updated\", service);\n        console.info(`Updating service: ${service.id}`);\n      }\n    } else {\n      if (key.includes(\":default@\")) {\n        if (isLocalService && service.setup) {\n          setTimeout(async () => {\n            try {\n              await service.setup();\n              console.debug(`\\u2705 Local setup completed for service \\`${clientId}\\``);\n            } catch (e) {\n              console.error(`Failed to run setup for local default service \\`${clientId}\\`: ${e}`);\n            }\n          }, 10);\n        } else if (!isLocalService && this._shouldAttemptRpcSetup(clientId, service)) {\n          this._setupServiceWithRetry(clientId, 3);\n        }\n      }\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_connected\", { id: clientId, workspace: ws });\n        console.info(`Adding built-in service: ${service.id}, key: ${key}`);\n      } else {\n        this.eventBus.emit(\"service_added\", service);\n        console.info(`Adding service ${service.id}, key: ${key}`);\n      }\n    }\n    return service;\n  }\n  /**\n   * Determine if we should attempt RPC setup for a service\n   */\n  _shouldAttemptRpcSetup(clientId, service) {\n    const clientPart = clientId.includes(\"/\") ? clientId.split(\"/\")[1] : clientId;\n    if (clientPart.startsWith(\"client-\")) {\n      return false;\n    }\n    if (service.config && service.config.no_setup) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if a service object contains function properties (indicating it's a local service)\n   */\n  _hasServiceFunctions(service) {\n    for (const [key, value] of Object.entries(service)) {\n      if ([\"id\", \"name\", \"description\", \"config\", \"app_id\"].includes(key)) {\n        continue;\n      }\n      if (typeof value === \"function\") {\n        return true;\n      }\n      if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        if (value._rintf) {\n          continue;\n        }\n        for (const subValue of Object.values(value)) {\n          if (typeof subValue === \"function\") {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Setup service with retry mechanism to handle timing issues\n   */\n  async _setupServiceWithRetry(clientId, maxRetries = 3) {\n    const clientPart = clientId.includes(\"/\") ? clientId.split(\"/\")[1] : clientId;\n    setTimeout(async () => {\n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n          const delay = 100 * Math.pow(4, attempt - 1);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          if (this._rpc) {\n            const svc = await this._rpc.get_remote_service(`${clientPart}:default`, 5);\n            if (svc && svc.setup) {\n              await svc.setup();\n              console.debug(`\\u2705 Setup completed for default service \\`${clientId}\\``);\n              return;\n            }\n          }\n        } catch (e) {\n          if (attempt === maxRetries) {\n            console.debug(`Setup not available for default service \\`${clientId}\\` (this is normal for local services)`);\n          } else {\n            continue;\n          }\n        }\n      }\n    }, 50);\n  }\n  async unregisterService(serviceId, context) {\n    const ws = context.ws;\n    if (!serviceId.includes(\"/\")) {\n      serviceId = `${ws}/${serviceId}`;\n    }\n    if (!serviceId.includes(\":\")) {\n      throw new Error(\"Service id info must contain ':'\");\n    }\n    if (!serviceId.includes(\"@\")) {\n      serviceId = serviceId + \"@*\";\n    }\n    if (this._localServices.has(serviceId)) {\n      this._localServices.delete(serviceId);\n      console.info(`Removed local service: ${serviceId}`);\n    }\n    const key = `services:*:${serviceId}`;\n    console.info(`Removing service: ${key}`);\n    const serviceExists = this._redis.exists(key);\n    if (serviceExists) {\n      this._redis.delete(key);\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_disconnected\", { id: context.from, workspace: ws });\n      } else {\n        this.eventBus.emit(\"service_removed\", { id: serviceId });\n      }\n    } else {\n      console.warning(`Service ${key} does not exist and cannot be removed.`);\n    }\n  }\n  async getService(query, { mode = \"default\", skipTimeout = false, timeout = 5 }, context) {\n    const ws = context.ws;\n    const userInfo = context.user;\n    let serviceId;\n    if (typeof query === \"string\") {\n      serviceId = query;\n      query = { id: serviceId };\n    } else {\n      if (!query.id) {\n        serviceId = query.service_id || \"*\";\n      } else {\n        serviceId = query.id;\n      }\n    }\n    if (typeof serviceId !== \"string\") {\n      throw new Error(\"Service ID must be a string\");\n    }\n    if ((serviceId.match(/\\//g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one '/'\");\n    }\n    if ((serviceId.match(/:/g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one ':'\");\n    }\n    if ((serviceId.match(/@/g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one '@'\");\n    }\n    if (serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n      serviceId += \":default\";\n      query.workspace = serviceId.split(\"/\")[0];\n      if (query.client_id && query.client_id !== serviceId.split(\"/\")[1]) {\n        throw new Error(`client_id (${query.client_id}) does not match service_id (${serviceId})`);\n      }\n      query.client_id = serviceId.split(\"/\")[1];\n    } else if (!serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n      const workspace = query.workspace || ws;\n      serviceId = `${workspace}/*:${serviceId}`;\n      query.workspace = workspace;\n      query.client_id = \"*\";\n    } else if (!serviceId.includes(\"/\") && serviceId.includes(\":\")) {\n      const workspace = query.workspace || ws;\n      query.client_id = serviceId.split(\":\")[0];\n      serviceId = `${workspace}/${serviceId}`;\n      query.workspace = workspace;\n    } else {\n      const workspace = serviceId.split(\"/\")[0];\n      query.client_id = serviceId.split(\"/\")[1].split(\":\")[0];\n      query.workspace = workspace;\n      if (!serviceId.includes(\"*\")) {\n        const localServiceKey = `${serviceId}@*`;\n        if (this._localServices.has(localServiceKey)) {\n          console.info(`Found local service (direct): ${localServiceKey}`);\n          const localService = this._localServices.get(localServiceKey);\n          return this.patchServiceConfig(workspace, localService);\n        }\n        if (this._rpc) {\n          const serviceApi = await this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        }\n        return null;\n      }\n    }\n    let appId = \"*\";\n    if (serviceId.includes(\"@\")) {\n      [serviceId, appId] = serviceId.split(\"@\");\n      if (query.app_id && query.app_id !== appId) {\n        throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n      }\n    }\n    query.app_id = query.app_id || appId;\n    query.service_id = serviceId.split(\"/\")[1].split(\":\")[1];\n    const originalVisibility = query.visibility || \"*\";\n    let visibility;\n    if (query.workspace === \"*\") {\n      visibility = \"public\";\n    } else {\n      visibility = \"*\";\n    }\n    const pattern = `services:${visibility}:${query.workspace}/${query.client_id}:${query.service_id}@${query.app_id}`;\n    if (!pattern.startsWith(\"services:\")) {\n      throw new Error(\"Query pattern does not start with 'services:'.\");\n    }\n    if (pattern.includes(\"{\") || pattern.includes(\"}\")) {\n      throw new Error(\"Query pattern contains invalid characters.\");\n    }\n    const keys = this._redis.keys(pattern);\n    if (query.workspace === \"*\") {\n      const wsPattern = `services:${originalVisibility}:${ws}/${query.client_id}:${query.service_id}@${query.app_id}`;\n      keys.push(...this._redis.keys(wsPattern));\n    }\n    const withinWorkspaceKeys = [];\n    const outsideWorkspaceKeys = [];\n    keys.forEach((key) => {\n      const keyWorkspace = key.split(\"/\")[1];\n      if (keyWorkspace === ws) {\n        withinWorkspaceKeys.push(key);\n      } else {\n        outsideWorkspaceKeys.push(key);\n      }\n    });\n    if (mode === \"random\") {\n      withinWorkspaceKeys.sort(() => Math.random() - 0.5);\n      outsideWorkspaceKeys.sort(() => Math.random() - 0.5);\n    } else {\n      withinWorkspaceKeys.sort();\n      outsideWorkspaceKeys.sort();\n    }\n    const sortedKeys = [...withinWorkspaceKeys, ...outsideWorkspaceKeys];\n    for (const key of sortedKeys) {\n      try {\n        const parts = key.split(\":\");\n        serviceId = parts[2] + \":\" + parts[3];\n        [serviceId, appId] = serviceId.split(\"@\");\n        const workspace = serviceId.split(\"/\")[0];\n        const localServiceKey = `${serviceId}@${appId}`;\n        if (this._localServices.has(localServiceKey)) {\n          const localService = this._localServices.get(localServiceKey);\n          return this.patchServiceConfig(workspace, localService);\n        }\n        if (this._rpc) {\n          const serviceApi = await this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        }\n      } catch (e) {\n        if (skipTimeout && e instanceof TimeoutError) {\n          console.warning(`Timeout while getting service ${serviceId}, skipping to the next one.`);\n          continue;\n        } else {\n          throw new Error(`Timeout while getting service ${serviceId}`);\n        }\n      }\n    }\n    if (query.app_id && query.app_id !== \"*\") {\n      const serviceApi = await this._launch_application_for_service(query, context);\n      return serviceApi;\n    }\n    return null;\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    const isLocalService = this._hasServiceFunctions(serviceApi);\n    if (isLocalService) {\n      serviceApi = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToCamelCase)(serviceApi);\n      if (serviceApi.config.require_context) {\n        return this._wrapLocalServiceMethods(serviceApi, workspace);\n      }\n    }\n    return serviceApi;\n  }\n  /**\n   * Wrap local service methods to inject proper context\n   */\n  _wrapLocalServiceMethods(serviceApi, workspace) {\n    const wrappedService = { ...serviceApi };\n    const getContextForCall = () => {\n      if (this._rpc && this._rpc.current_context) {\n        const contextWorkspace = this._rpc.current_context.ws || workspace;\n        return {\n          ws: contextWorkspace,\n          user: this._rpc.current_context.user || {\n            id: \"anonymous\",\n            email: \"\",\n            roles: [],\n            scopes: []\n          },\n          from: this._rpc.current_context.from || `${contextWorkspace}/anonymous-client`,\n          to: this._rpc.current_context.to || `${contextWorkspace}/workspace-service`\n        };\n      }\n      return {\n        ws: workspace,\n        user: {\n          id: \"anonymous\",\n          email: \"\",\n          roles: [],\n          scopes: []\n        },\n        from: `${workspace}/anonymous-client`,\n        to: `${workspace}/workspace-service`\n      };\n    };\n    const wrapFunctions = (obj, path = \"\") => {\n      const wrapped = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if ([\"id\", \"name\", \"description\", \"config\", \"app_id\"].includes(key)) {\n          wrapped[key] = value;\n        } else if (typeof value === \"function\") {\n          wrapped[key] = (...args) => {\n            const lastArg = args[args.length - 1];\n            const hasContext = lastArg && typeof lastArg === \"object\" && !Array.isArray(lastArg) && (\"ws\" in lastArg || \"user\" in lastArg || \"from\" in lastArg || \"to\" in lastArg);\n            if (!hasContext) {\n              args.push(getContextForCall());\n            } else {\n              const baseContext = getContextForCall();\n              const mergedContext = {\n                ...lastArg,\n                // Preserve existing context properties\n                ws: lastArg.ws || baseContext.ws,\n                user: lastArg.user || baseContext.user,\n                from: lastArg.from || baseContext.from,\n                to: lastArg.to || baseContext.to\n              };\n              args[args.length - 1] = mergedContext;\n            }\n            return value.apply(obj, args);\n          };\n        } else if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          if (value._rintf) {\n            wrapped[key] = value;\n          } else {\n            wrapped[key] = wrapFunctions(value, `${path}.${key}`);\n          }\n        } else {\n          wrapped[key] = value;\n        }\n      }\n      return wrapped;\n    };\n    return wrapFunctions(wrappedService);\n  }\n  async listServices(query, context) {\n    if (!context) {\n      throw new Error(\"context is required\");\n    }\n    const cws = context.ws;\n    const userInfo = context.user;\n    if (!query) {\n      query = {\n        visibility: \"*\",\n        workspace: cws,\n        client_id: \"*\",\n        service_id: \"*\"\n      };\n    } else if (typeof query === \"string\") {\n      let visibility2 = \"*\";\n      let workspace2 = \"*\";\n      let clientId2 = \"*\";\n      let serviceId2 = \"*\";\n      if (query.includes(\"/\") && query.includes(\":\")) {\n        const [workspacePart, remaining] = query.split(\"/\");\n        const [clientPart, servicePart] = remaining.split(\":\");\n        workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n        clientId2 = clientPart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else if (query.includes(\":\")) {\n        const [clientPart, servicePart] = query.split(\":\");\n        clientId2 = clientPart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else if (query.includes(\"/\")) {\n        const [workspacePart, servicePart] = query.split(\"/\");\n        workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else {\n        workspace2 = query;\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      }\n    } else {\n      if (query.id) {\n        if (query.service_id) {\n          throw new Error(\"Cannot specify both 'id' and 'service_id' in the query.\");\n        }\n        query.service_id = query.id;\n        delete query.id;\n      }\n    }\n    const originalVisibility = query.visibility || \"*\";\n    const workspace = query.workspace || \"*\";\n    if (workspace === \"*\") {\n      if (originalVisibility === \"protected\") {\n        throw new Error(\"Cannot list protected services in all workspaces.\");\n      }\n      query.visibility = \"public\";\n    } else if (workspace !== \"public\" && workspace !== cws) {\n    }\n    const visibility = query.visibility || \"*\";\n    const clientId = query.client_id || \"*\";\n    const serviceId = query.service_id || \"*\";\n    const typeFilter = query.type || null;\n    let appId = \"*\";\n    if (serviceId.includes(\"@\")) {\n      [serviceId, appId] = serviceId.split(\"@\");\n      if (query.app_id && query.app_id !== appId) {\n        throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n      }\n    }\n    appId = query.app_id || appId;\n    const allowedKeys = [\"visibility\", \"workspace\", \"client_id\", \"service_id\", \"type\", \"app_id\"];\n    if (Object.keys(query).some((key) => !allowedKeys.includes(key))) {\n      console.error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n      throw new Error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n    }\n    validateKeyPart(visibility);\n    validateKeyPart(workspace);\n    validateKeyPart(clientId);\n    validateKeyPart(serviceId);\n    validateKeyPart(appId);\n    const pattern = `services:${visibility}:${workspace}/${clientId}:${serviceId}@${appId}`;\n    if (!pattern.startsWith(\"services:\")) {\n      throw new Error(\"Query pattern does not start with 'services:'.\");\n    }\n    const keys = this._redis.keys(pattern);\n    if (workspace === \"*\") {\n      const wsPattern = `services:${originalVisibility}:${cws}/${clientId}:${serviceId}@${appId}`;\n      keys.push(...this._redis.keys(wsPattern));\n    }\n    const services = [];\n    for (const key of new Set(keys)) {\n      const serviceData = this._redis.hgetall(key);\n      const convertedServiceData = {};\n      for (const [k, v] of Object.entries(serviceData)) {\n        const keyStr = k;\n        let valueStr = v;\n        if (typeof valueStr === \"string\" && (valueStr.startsWith(\"{\") && valueStr.endsWith(\"}\") || valueStr.startsWith(\"[\") && valueStr.endsWith(\"]\"))) {\n          valueStr = JSON.parse(valueStr);\n        }\n        convertedServiceData[keyStr] = valueStr;\n      }\n      if (typeFilter) {\n        if (convertedServiceData.type === typeFilter) {\n          services.push(convertedServiceData);\n        }\n      } else {\n        services.push(convertedServiceData);\n      }\n    }\n    return services;\n  }\n  async createWindow(config, extra_config, context) {\n    _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.requireBrowser(\"Window/iframe creation\");\n    let elem;\n    const ws = context.ws;\n    const clientId = \"client-\" + Date.now();\n    const connectionId = ws + \"/\" + clientId;\n    this.connections[connectionId] = {\n      id: connectionId,\n      workspace: ws,\n      user: context.user,\n      // Store user info for nested app creation\n      websocket: null,\n      postMessage: (data) => {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.safePostMessage(elem.contentWindow, data);\n      }\n    };\n    let authToken = context.token;\n    if (!authToken) {\n      try {\n        authToken = await this.getDefaultService().generate_token({\n          workspace: ws,\n          client_id: clientId,\n          user_id: context.user?.id || \"anonymous\",\n          email: context.user?.email || \"\",\n          roles: context.user?.roles || [],\n          scopes: context.user?.scopes || [],\n          expires_in: 3600\n          // 1 hour\n        }, context);\n      } catch (error) {\n        console.warn(\"Failed to generate auth token for iframe:\", error);\n      }\n    }\n    const authParams = new URLSearchParams();\n    authParams.set(\"client_id\", clientId);\n    authParams.set(\"workspace\", ws);\n    authParams.set(\"server_url\", this.serverUrl);\n    if (authToken) {\n      authParams.set(\"token\", authToken);\n    }\n    if (context.user) {\n      authParams.set(\"user_info\", JSON.stringify(context.user));\n    }\n    const authHash = `#${authParams.toString()}`;\n    if (config.type === \"iframe\") {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"iframe creation requires browser environment with document API\");\n      }\n      elem = document.createElement(\"iframe\");\n      elem.src = config.src + authHash;\n      elem.id = config.window_id || \"window-\" + Date.now();\n      elem.style.width = config.width || \"100%\";\n      elem.style.height = config.height || \"100%\";\n      elem.style.display = \"none\";\n      document.body.appendChild(elem);\n    } else if (config.window_id) {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"Window element access requires browser environment with document API\");\n      }\n      let count = 0;\n      while (!document.getElementById(config.window_id) && count < 9) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        count++;\n      }\n      elem = document.getElementById(config.window_id);\n      if (!elem) {\n        throw new Error(\"Window element not found: \" + config.window_id);\n      }\n    } else {\n      config.window_id = \"window-\" + Date.now();\n      config.workspace = ws;\n      await this.eventBus.emit(\"add_window\", config);\n      await new Promise((resolve) => setTimeout(resolve, 0));\n      let count = 0;\n      while (!document.getElementById(config.window_id) && count < 9) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        count++;\n      }\n      elem = document.getElementById(config.window_id);\n      if (!elem) {\n        throw new Error(`iframe element not found ${config.window_id} in ${9 * 500 / 1e3} s`);\n      }\n    }\n    if (elem.tagName !== \"IFRAME\") {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"iframe creation requires browser environment with document API\");\n      }\n      const iframe = document.createElement(\"iframe\");\n      iframe.style.width = config.width || \"100%\";\n      iframe.style.height = config.height || \"100%\";\n      iframe.src = config.src + authHash;\n      elem.appendChild(iframe);\n      elem = iframe;\n    }\n    this.connections[connectionId].source = elem.contentWindow;\n    let waitClientPromise;\n    if (!config.passive) {\n      waitClientPromise = this.waitForClient(connectionId, 18e4);\n    }\n    await new Promise((resolve, reject) => {\n      elem.onload = resolve;\n      elem.onerror = reject;\n    });\n    if (config.passive) {\n      delete this.connections[connectionId];\n      return;\n    }\n    const initMessage = {\n      type: \"initializeHyphaClient\",\n      server_url: this.serverUrl,\n      client_id: clientId,\n      workspace: ws,\n      token: authToken || null,\n      user_info: context.user || null,\n      config\n    };\n    setTimeout(() => {\n      try {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.safePostMessage(elem.contentWindow, initMessage);\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] Failed to send initializeHyphaClient to ${connectionId}:`, error);\n      }\n    }, 0);\n    const svc = await waitClientPromise;\n    if (svc.setup && typeof svc.setup === \"function\") {\n      try {\n        await svc.setup();\n        svc._hyphaSetupCalled = true;\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] setup() failed for window plugin: ${config.name || config.src}:`, error);\n      }\n    }\n    if (svc.run && typeof svc.run === \"function\") {\n      try {\n        await svc.run({ data: config.data, config: config.config });\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] run() failed for window plugin: ${config.name || config.src}:`, error);\n      }\n    }\n    this.windows.push({ id: config.window_id, name: config.name || config.src, service: svc });\n    return svc;\n  }\n  async getWindow(config, context) {\n    if (typeof config === \"string\") {\n      return this.windows.find((w) => w.name === config);\n    } else if (config.id) {\n      return this.windows.find((w) => w.id === config.id);\n    } else if (config.name) {\n      return this.windows.find((w) => w.name === config.name);\n    }\n    return void 0;\n  }\n  async loadApp(config, extra_config, context) {\n    let code;\n    const ws = context.ws;\n    const src = config.src;\n    if (config.type === \"web-worker\" && src && (src.startsWith(\"http\") || src.startsWith(\"blob:\"))) {\n      return await this.createWorker(config, ws, src, context);\n    }\n    if (src.startsWith(\"http\") && !src.split(\"?\")[0].endsWith(\".imjoy.html\")) {\n      return await this.createWindow(config, extra_config, context);\n    }\n    if (src.startsWith(\"http\")) {\n      const resp = await fetch(src);\n      code = await resp.text();\n    } else if (src.includes(\"\\n\")) {\n      code = src;\n    } else {\n      throw new Error(\"Only local plugins are supported in the workspace manager.\");\n    }\n    config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.parsePluginCode)(code, {});\n    switch (config.type) {\n      case \"web-worker\":\n        return await this.createWorker(config, ws, this.baseUrl + \"hypha-app-webworker.js\", context);\n      case \"window\":\n      case \"iframe\":\n        config.src = this.baseUrl + \"hypha-app-iframe.html\";\n        return await this.createWindow(config, extra_config, context);\n      case \"web-python\":\n        return await this.createWorker(config, ws, this.baseUrl + \"hypha-app-webpython.js\", context);\n      default:\n        throw new Error(\"Unsupported plugin type: \" + config.type);\n    }\n  }\n  _waitForConnection(conn_id, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        if (info.id === conn_id) {\n          this.eventBus.off(\"connection_ready\", handler);\n          clearTimeout(timeoutId);\n          resolve(info);\n        }\n      };\n      const timeoutId = setTimeout(() => {\n        this.eventBus.off(\"connection_ready\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"connection_ready\", handler);\n    });\n  }\n  async createWorker(config, workspace, workerUrl, context) {\n    if (typeof Worker === \"undefined\") {\n      throw new Error(\"WebWorker creation requires browser environment with Worker API\");\n    }\n    const clientId = \"client-\" + Date.now();\n    let authToken = context.token;\n    if (!authToken) {\n      try {\n        authToken = await this.getDefaultService().generate_token({\n          workspace,\n          client_id: clientId,\n          user_id: context.user?.id || \"anonymous\",\n          email: context.user?.email || \"\",\n          roles: context.user?.roles || [],\n          scopes: context.user?.scopes || [],\n          expires_in: 3600\n          // 1 hour\n        }, context);\n      } catch (error) {\n        console.warn(\"Failed to generate auth token for worker:\", error);\n      }\n    }\n    const authParams = new URLSearchParams();\n    authParams.set(\"client_id\", clientId);\n    authParams.set(\"workspace\", workspace);\n    authParams.set(\"server_url\", this.serverUrl);\n    if (authToken) {\n      authParams.set(\"token\", authToken);\n    }\n    if (context.user) {\n      authParams.set(\"user_info\", JSON.stringify(context.user));\n    }\n    const authHash = `#${authParams.toString()}`;\n    const worker = new Worker(workerUrl + authHash);\n    this.connections[workspace + \"/\" + clientId] = {\n      id: workspace + \"/\" + clientId,\n      source: worker,\n      workspace,\n      user: context.user,\n      // Store user info for nested app creation\n      websocket: null,\n      postMessage: (data) => {\n        worker.postMessage(data);\n      }\n    };\n    worker.onmessage = this._server.messageHandler;\n    await this._waitForConnection(workspace + \"/\" + clientId, 6e4);\n    worker.postMessage({\n      type: \"initializeHyphaClient\",\n      server_url: this.serverUrl,\n      workspace,\n      client_id: clientId,\n      token: authToken || null,\n      user_info: context?.user || null,\n      config\n    });\n    const svc = await this.waitForClient(workspace + \"/\" + clientId, 6e4);\n    if (svc.setup && typeof svc.setup === \"function\") {\n      try {\n        await svc.setup();\n        svc._hyphaSetupCalled = true;\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] setup() failed for ${config.type} plugin: ${config.name || \"unnamed\"}:`, error);\n      }\n    }\n    if (config.type === \"window\" && svc.run && typeof svc.run === \"function\") {\n      try {\n        await svc.run({ data: config.data, config: config.config });\n      } catch (error) {\n        console.error(`\\u274C [DEBUG] run() failed for window worker plugin: ${config.name || \"unnamed\"}:`, error);\n      }\n    }\n    return svc;\n  }\n  async getApp(config, extra_config, context) {\n    if (typeof config === \"string\") {\n      return await this.loadApp({ src: config }, extra_config, context);\n    } else if (config.id) {\n      return this.plugins[config.id];\n    } else if (config.name) {\n      for (const [key, value] of Object.entries(this.plugins)) {\n        if (value.name === config.name) {\n          return value;\n        }\n      }\n    } else {\n      throw new Error(\"Please provide either id or name for the plugin\");\n    }\n  }\n  getDefaultService() {\n    const service = {\n      \"id\": \"default\",\n      \"name\": \"Default workspace management service\",\n      \"description\": \"Services for managing workspace.\",\n      \"config\": {\n        \"require_context\": true,\n        \"visibility\": \"public\"\n      },\n      \"emit\": async (type, data, context) => {\n        const workspaceId = context.ws;\n        await this.eventBus.emit(type, data);\n      },\n      \"on\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.on(event, handler);\n      },\n      \"off\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.off(event, handler);\n      },\n      \"echo\": (msg, context) => {\n        return msg;\n      },\n      \"alert\": (msg, context) => {\n        alert(msg);\n      },\n      \"confirm\": (msg, context) => {\n        return confirm(msg);\n      },\n      \"prompt\": (msg, default_value, context) => {\n        return prompt(msg, default_value);\n      },\n      \"show_progress\": (progress, context) => {\n        if (progress !== 0 && progress !== 100) {\n          console.debug(\"showProgress\", progress);\n        }\n      },\n      \"show_message\": (msg, context) => {\n        console.log(msg);\n      },\n      \"log\": (msg, context) => {\n        console.log(msg);\n      },\n      \"info\": (msg, context) => {\n        console.info(msg);\n      },\n      \"error\": (msg, context) => {\n        console.error(msg);\n      },\n      \"warning\": (msg, context) => {\n        console.warn(msg);\n      },\n      \"critical\": (msg, context) => {\n        console.error(msg);\n      },\n      \"getService\": this.getService.bind(this),\n      \"listServices\": this.listServices.bind(this),\n      \"generateToken\": async (tokenConfig, context) => {\n        if (!tokenConfig) {\n          tokenConfig = {};\n        }\n        const currentWorkspace = context.ws;\n        const currentClientId = context.from?.split(\"/\")[1];\n        let targetWorkspace = tokenConfig.workspace || currentWorkspace;\n        if (targetWorkspace !== currentWorkspace) {\n          if (currentWorkspace !== \"default\" || currentClientId !== \"root\") {\n            throw new Error(`Access denied: Cannot generate token for workspace '${targetWorkspace}' from workspace '${currentWorkspace}' with client '${currentClientId}'. Only root client in default workspace can generate cross-workspace tokens.`);\n          }\n        }\n        const payload = {\n          sub: tokenConfig.user_id || context.user?.id || \"anonymous\",\n          workspace: targetWorkspace,\n          client_id: tokenConfig.client_id || context.from?.split(\"/\")[1] || \"anonymouz-\" + Date.now().toString(),\n          email: tokenConfig.email || context.user?.email || \"\",\n          roles: tokenConfig.roles || context.user?.roles || [],\n          scope: Array.isArray(tokenConfig.scopes) ? tokenConfig.scopes.join(\" \") : tokenConfig.scope || \"\",\n          iat: Math.floor(Date.now() / 1e3),\n          exp: tokenConfig.expires_in ? Math.floor(Date.now() / 1e3) + tokenConfig.expires_in : Math.floor(Date.now() / 1e3) + 24 * 60 * 60,\n          // Default 24 hours\n          iss: \"hypha-core\",\n          aud: \"hypha-api\"\n        };\n        const jwtSecret = this._server.jwtSecret;\n        if (!jwtSecret) {\n          throw new Error(\"JWT secret not configured on server\");\n        }\n        return await generateJWT(payload, jwtSecret);\n      },\n      \"loadApp\": async (config, extra_config, context) => {\n        return this.loadApp(config, extra_config, context);\n      },\n      \"createWindow\": async (config, extra_config, context) => {\n        return this.createWindow(config, extra_config, context);\n      },\n      \"getWindow\": async (config, context) => {\n        return this.getWindow(config, context);\n      },\n      \"getApp\": async (config, extra_config, context) => {\n        return this.getApp(config, extra_config, context);\n      },\n      \"registerService\": async (service2, context) => {\n        return await this.registerService(service2, context);\n      },\n      \"unregisterService\": async (serviceId, context) => {\n        return await this.unregisterService(serviceId, context);\n      }\n    };\n    service.getPlugin = service.getApp;\n    service.loadPlugin = service.loadApp;\n    const convertedService = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.convertToSnakeCase)(service);\n    console.debug(\"\\u{1F527} Converted workspace default service methods to snake_case for compatibility\");\n    return convertedService;\n  }\n}\n__publicField(Workspace, \"workspaces\", {});\n__publicField(Workspace, \"clients\", {});\n\n\n//# sourceURL=webpack://hypha-core/./src/workspace.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/create fake namespace object */
/******/ (() => {
/******/ 	var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 	var leafPrototypes;
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 16: return value when it's Promise-like
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = this(value);
/******/ 		if(mode & 8) return value;
/******/ 		if(typeof value === 'object' && value) {
/******/ 			if((mode & 4) && value.__esModule) return value;
/******/ 			if((mode & 16) && typeof value.then === 'function') return value;
/******/ 		}
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		var def = {};
/******/ 		leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 		for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 			Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 		}
/******/ 		def['default'] = () => (value);
/******/ 		__webpack_require__.d(ns, def);
/******/ 		return ns;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
/******/ 	__webpack_require__.f = {};
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = (chunkId) => {
/******/ 		return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 			__webpack_require__.f[key](chunkId, promises);
/******/ 			return promises;
/******/ 		}, []));
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".hypha-core.mjs";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/harmony module decorator */
/******/ (() => {
/******/ 	__webpack_require__.hmd = (module) => {
/******/ 		module = Object.create(module);
/******/ 		if (!module.children) module.children = [];
/******/ 		Object.defineProperty(module, 'exports', {
/******/ 			enumerable: true,
/******/ 			set: () => {
/******/ 				throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 			}
/******/ 		});
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	// no baseURI
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"lib": 0
/******/ 	};
/******/ 	
/******/ 	var installChunk = (data) => {
/******/ 		var {__webpack_ids__, __webpack_modules__, __webpack_runtime__} = data;
/******/ 		// add "modules" to the modules object,
/******/ 		// then flag all "ids" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0;
/******/ 		for(moduleId in __webpack_modules__) {
/******/ 			if(__webpack_require__.o(__webpack_modules__, moduleId)) {
/******/ 				__webpack_require__.m[moduleId] = __webpack_modules__[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(__webpack_runtime__) __webpack_runtime__(__webpack_require__);
/******/ 		for(;i < __webpack_ids__.length; i++) {
/******/ 			chunkId = __webpack_ids__[i];
/******/ 			if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				installedChunks[chunkId][0]();
/******/ 			}
/******/ 			installedChunks[__webpack_ids__[i]] = 0;
/******/ 		}
/******/ 	
/******/ 	}
/******/ 	
/******/ 	__webpack_require__.f.j = (chunkId, promises) => {
/******/ 			// import() chunk loading for javascript
/******/ 			var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 	
/******/ 				// a Promise means "currently loading".
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[1]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// setup Promise in chunk cache
/******/ 						var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {
/******/ 							if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;
/******/ 							throw e;
/******/ 						});
/******/ 						var promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])
/******/ 						promises.push(installedChunkData[1] = promise);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 	};
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/hypha-core.js");
/******/ const __webpack_exports__HyphaCore = __webpack_exports__.HyphaCore;
/******/ const __webpack_exports__WebSocket = __webpack_exports__.WebSocket;
/******/ const __webpack_exports__WebsocketRPCConnection = __webpack_exports__.WebsocketRPCConnection;
/******/ const __webpack_exports__Workspace = __webpack_exports__.Workspace;
/******/ const __webpack_exports__connectToServer = __webpack_exports__.connectToServer;
/******/ const __webpack_exports__hyphaWebsocketClient = __webpack_exports__.hyphaWebsocketClient;
/******/ const __webpack_exports__imjoyRPC = __webpack_exports__.imjoyRPC;
/******/ export { __webpack_exports__HyphaCore as HyphaCore, __webpack_exports__WebSocket as WebSocket, __webpack_exports__WebsocketRPCConnection as WebsocketRPCConnection, __webpack_exports__Workspace as Workspace, __webpack_exports__connectToServer as connectToServer, __webpack_exports__hyphaWebsocketClient as hyphaWebsocketClient, __webpack_exports__imjoyRPC as imjoyRPC };
/******/ 
