/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, () => {\n  return (\n    /******/\n    (() => {\n      \"use strict\";\n      var __webpack_modules__ = {\n        /***/\n        \"./src/rpc.js\": (\n          /*!********************!*\\\n            !*** ./src/rpc.js ***!\n            \\********************/\n          /***/\n          (__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              API_VERSION: () => (\n                /* binding */\n                API_VERSION\n              ),\n              /* harmony export */\n              RPC: () => (\n                /* binding */\n                RPC\n              )\n              /* harmony export */\n            });\n            var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./utils */\n              \"./src/utils/index.js\"\n            );\n            var _utils_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./utils/schema */\n              \"./src/utils/schema.js\"\n            );\n            var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! @msgpack/msgpack */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n            );\n            var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! @msgpack/msgpack */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n            );\n            const API_VERSION = 3;\n            const CHUNK_SIZE = 1024 * 256;\n            const CONCURRENCY_LIMIT = 30;\n            const ArrayBufferView = Object.getPrototypeOf(\n              Object.getPrototypeOf(new Uint8Array())\n            ).constructor;\n            function _appendBuffer(buffer1, buffer2) {\n              const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n              tmp.set(new Uint8Array(buffer1), 0);\n              tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n              return tmp.buffer;\n            }\n            function indexObject(obj, is) {\n              if (!is)\n                throw new Error(\"undefined index\");\n              if (typeof is === \"string\")\n                return indexObject(obj, is.split(\".\"));\n              else if (is.length === 0)\n                return obj;\n              else\n                return indexObject(obj[is[0]], is.slice(1));\n            }\n            function _get_schema(obj, name2 = null, skipContext = false) {\n              if (Array.isArray(obj)) {\n                return obj.map((v, i) => _get_schema(v, null, skipContext));\n              } else if (typeof obj === \"object\" && obj !== null) {\n                let schema = {};\n                for (let k in obj) {\n                  schema[k] = _get_schema(obj[k], k, skipContext);\n                }\n                return schema;\n              } else if (typeof obj === \"function\") {\n                if (obj.__schema__) {\n                  const schema = JSON.parse(JSON.stringify(obj.__schema__));\n                  if (name2) {\n                    schema.name = name2;\n                    obj.__schema__.name = name2;\n                  }\n                  if (skipContext) {\n                    if (schema.parameters && schema.parameters.properties) {\n                      delete schema.parameters.properties[\"context\"];\n                    }\n                  }\n                  return { type: \"function\", function: schema };\n                } else {\n                  return { type: \"function\" };\n                }\n              } else if (typeof obj === \"number\") {\n                return { type: \"number\" };\n              } else if (typeof obj === \"string\") {\n                return { type: \"string\" };\n              } else if (typeof obj === \"boolean\") {\n                return { type: \"boolean\" };\n              } else if (obj === null) {\n                return { type: \"null\" };\n              } else {\n                return {};\n              }\n            }\n            function _annotate_service(service, serviceTypeInfo) {\n              function validateKeys(serviceDict, schemaDict, path = \"root\") {\n                for (let key in schemaDict) {\n                  if (!serviceDict.hasOwnProperty(key)) {\n                    throw new Error(`Missing key '${key}' in service at path '${path}'`);\n                  }\n                }\n                for (let key in serviceDict) {\n                  if (key !== \"type\" && !schemaDict.hasOwnProperty(key)) {\n                    throw new Error(`Unexpected key '${key}' in service at path '${path}'`);\n                  }\n                }\n              }\n              function annotateRecursive(newService, schemaInfo, path = \"root\") {\n                if (typeof newService === \"object\" && !Array.isArray(newService)) {\n                  validateKeys(newService, schemaInfo, path);\n                  for (let k in newService) {\n                    let v = newService[k];\n                    let newPath = `${path}.${k}`;\n                    if (typeof v === \"object\" && !Array.isArray(v)) {\n                      annotateRecursive(v, schemaInfo[k], newPath);\n                    } else if (typeof v === \"function\") {\n                      if (schemaInfo.hasOwnProperty(k)) {\n                        newService[k] = (0, _utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n                          name: schemaInfo[k][\"name\"],\n                          description: schemaInfo[k].description || \"\",\n                          parameters: schemaInfo[k][\"parameters\"]\n                        });\n                      } else {\n                        throw new Error(\n                          `Missing schema for function '${k}' at path '${newPath}'`\n                        );\n                      }\n                    }\n                  }\n                } else if (Array.isArray(newService)) {\n                  if (newService.length !== schemaInfo.length) {\n                    throw new Error(`Length mismatch at path '${path}'`);\n                  }\n                  newService.forEach((v, i) => {\n                    let newPath = `${path}[${i}]`;\n                    if (typeof v === \"object\" && !Array.isArray(v)) {\n                      annotateRecursive(v, schemaInfo[i], newPath);\n                    } else if (typeof v === \"function\") {\n                      if (schemaInfo.hasOwnProperty(i)) {\n                        newService[i] = (0, _utils_schema__WEBPACK_IMPORTED_MODULE_1__.schemaFunction)(v, {\n                          name: schemaInfo[i][\"name\"],\n                          description: schemaInfo[i].description || \"\",\n                          parameters: schemaInfo[i][\"parameters\"]\n                        });\n                      } else {\n                        throw new Error(\n                          `Missing schema for function at index ${i} in path '${newPath}'`\n                        );\n                      }\n                    }\n                  });\n                }\n              }\n              validateKeys(service, serviceTypeInfo[\"definition\"]);\n              annotateRecursive(service, serviceTypeInfo[\"definition\"]);\n              return service;\n            }\n            function getFunctionInfo(func) {\n              const funcString = func.toString();\n              const nameMatch = funcString.match(/function\\s*(\\w*)/);\n              const name2 = nameMatch && nameMatch[1] || \"\";\n              const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n              let params = \"\";\n              if (paramsMatch) {\n                params = paramsMatch[1].split(\",\").map(\n                  (p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")\n                ).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n              }\n              let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n              const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n              docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n              const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n              const docstring = docstringBlock || docstringLine;\n              return name2 && params.length > 0 && {\n                name: name2,\n                sig: params,\n                doc: docstring\n              };\n            }\n            function concatArrayBuffers(buffers) {\n              var buffersLengths = buffers.map(function(b) {\n                return b.byteLength;\n              }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n                return p + c;\n              }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n              buffersLengths.reduce(function(p, c, i) {\n                unit8Arr.set(new Uint8Array(buffers[i]), p);\n                return p + c;\n              }, 0);\n              return unit8Arr.buffer;\n            }\n            class Timer {\n              constructor(timeout, callback, args, label) {\n                this._timeout = timeout;\n                this._callback = callback;\n                this._args = args;\n                this._label = label || \"timer\";\n                this._task = null;\n                this.started = false;\n              }\n              start() {\n                if (this.started) {\n                  this.reset();\n                } else {\n                  this._task = setTimeout(() => {\n                    this._callback.apply(this, this._args);\n                  }, this._timeout * 1e3);\n                  this.started = true;\n                }\n              }\n              clear() {\n                if (this._task && this.started) {\n                  clearTimeout(this._task);\n                  this._task = null;\n                  this.started = false;\n                } else {\n                  console.warn(`Clearing a timer (${this._label}) which is not started`);\n                }\n              }\n              reset() {\n                if (this._task) {\n                  clearTimeout(this._task);\n                }\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            class RemoteService extends Object {\n            }\n            class RPC extends _utils__WEBPACK_IMPORTED_MODULE_0__.MessageEmitter {\n              constructor(connection, {\n                client_id: client_id2 = null,\n                default_context = null,\n                name: name2 = null,\n                codecs = null,\n                method_timeout: method_timeout2 = null,\n                max_message_buffer_size = 0,\n                debug = false,\n                workspace: workspace2 = null,\n                silent = false,\n                app_id = null,\n                server_base_url = null,\n                long_message_chunk_size = null\n              }) {\n                super(debug);\n                this._codecs = codecs || {};\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id2 && typeof client_id2 === \"string\");\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(client_id2, \"client_id is required\");\n                this._client_id = client_id2;\n                this._name = name2;\n                this._app_id = app_id || \"*\";\n                this._local_workspace = workspace2;\n                this._silent = silent;\n                this.default_context = default_context || {};\n                this._method_annotations = /* @__PURE__ */ new WeakMap();\n                this._max_message_buffer_size = max_message_buffer_size;\n                this._chunk_store = {};\n                this._method_timeout = method_timeout2 || 30;\n                this._server_base_url = server_base_url;\n                this._long_message_chunk_size = long_message_chunk_size || CHUNK_SIZE;\n                this._services = {};\n                this._object_store = {\n                  services: this._services\n                };\n                if (connection) {\n                  this.add_service({\n                    id: \"built-in\",\n                    type: \"built-in\",\n                    name: `Built-in services for ${this._local_workspace}/${this._client_id}`,\n                    config: {\n                      require_context: true,\n                      visibility: \"public\",\n                      api_version: API_VERSION\n                    },\n                    ping: this._ping.bind(this),\n                    get_service: this.get_local_service.bind(this),\n                    message_cache: {\n                      create: this._create_message.bind(this),\n                      append: this._append_message.bind(this),\n                      set: this._set_message.bind(this),\n                      process: this._process_message.bind(this),\n                      remove: this._remove_message.bind(this)\n                    }\n                  });\n                  this.on(\"method\", this._handle_method.bind(this));\n                  this.on(\"error\", console.error);\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(connection.emit_message && connection.on_message);\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    connection.manager_id !== void 0,\n                    \"Connection must have manager_id\"\n                  );\n                  this._emit_message = connection.emit_message.bind(connection);\n                  connection.on_message(this._on_message.bind(this));\n                  this._connection = connection;\n                  const onConnected = async (connectionInfo) => {\n                    if (!this._silent && this._connection.manager_id) {\n                      console.debug(\"Connection established, reporting services...\");\n                      try {\n                        const manager = await this.get_manager_service({\n                          timeout: 10,\n                          case_conversion: \"camel\"\n                        });\n                        const services = Object.values(this._services);\n                        const servicesCount = services.length;\n                        let registeredCount = 0;\n                        for (let service of services) {\n                          try {\n                            const serviceInfo = this._extract_service_info(service);\n                            await manager.registerService(serviceInfo);\n                            registeredCount++;\n                          } catch (serviceError) {\n                            console.error(\n                              `Failed to register service ${service.id || \"unknown\"}: ${serviceError}`\n                            );\n                          }\n                        }\n                        if (registeredCount === servicesCount) {\n                          console.info(\n                            `Successfully registered all ${registeredCount} services with the server`\n                          );\n                        } else {\n                          console.warn(\n                            `Only registered ${registeredCount} out of ${servicesCount} services with the server`\n                          );\n                        }\n                      } catch (managerError) {\n                        console.error(\n                          `Failed to get manager service for registering services: ${managerError}`\n                        );\n                      }\n                    } else {\n                    }\n                    if (connectionInfo) {\n                      if (connectionInfo.public_base_url) {\n                        this._server_base_url = connectionInfo.public_base_url;\n                      }\n                      this._fire(\"connected\", connectionInfo);\n                    }\n                  };\n                  connection.on_connected(onConnected);\n                  onConnected();\n                } else {\n                  this._emit_message = function() {\n                    console.log(\"No connection to emit message\");\n                  };\n                }\n              }\n              register_codec(config2) {\n                if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                  throw new Error(\n                    \"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\"\n                  );\n                } else {\n                  if (config2.type) {\n                    for (let k of Object.keys(this._codecs)) {\n                      if (this._codecs[k].type === config2.type || k === config2.name) {\n                        delete this._codecs[k];\n                        console.warn(\"Remove duplicated codec: \" + k);\n                      }\n                    }\n                  }\n                  this._codecs[config2[\"name\"]] = config2;\n                }\n              }\n              async _ping(msg, context2) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(msg == \"ping\");\n                return \"pong\";\n              }\n              async ping(client_id2, timeout) {\n                let method = this._generate_remote_method({\n                  _rserver: this._server_base_url,\n                  _rtarget: client_id2,\n                  _rmethod: \"services.built-in.ping\",\n                  _rpromise: true,\n                  _rdoc: \"Ping a remote client\"\n                });\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(await method(\"ping\", timeout) == \"pong\");\n              }\n              _create_message(key, heartbeat, overwrite, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                if (!this._object_store[\"message_cache\"]) {\n                  this._object_store[\"message_cache\"] = {};\n                }\n                if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                  throw new Error(\n                    `Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`\n                  );\n                }\n                this._object_store[\"message_cache\"][key] = [];\n              }\n              _append_message(key, data, heartbeat, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                const cache = this._object_store[\"message_cache\"];\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n                cache[key].push(data);\n              }\n              _set_message(key, index, data, heartbeat, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                const cache = this._object_store[\"message_cache\"];\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data instanceof ArrayBufferView);\n                cache[key][index] = data;\n              }\n              _remove_message(key, context2) {\n                const cache = this._object_store[\"message_cache\"];\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                delete cache[key];\n              }\n              _process_message(key, heartbeat, context2) {\n                if (heartbeat) {\n                  if (!this._object_store[key]) {\n                    throw new Error(`session does not exist anymore: ${key}`);\n                  }\n                  this._object_store[key][\"timer\"].reset();\n                }\n                const cache = this._object_store[\"message_cache\"];\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(!!context2, \"Context is required\");\n                if (!cache[key]) {\n                  throw new Error(`Message with key ${key} does not exists.`);\n                }\n                cache[key] = concatArrayBuffers(cache[key]);\n                let unpacker = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(cache[key]);\n                const { done, value } = unpacker.next();\n                const main = value;\n                Object.assign(main, {\n                  from: context2.from,\n                  to: context2.to,\n                  ws: context2.ws,\n                  user: context2.user\n                });\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n                delete cache[key];\n              }\n              _on_message(message) {\n                if (typeof message === \"string\") {\n                  const main = JSON.parse(message);\n                  this._fire(main[\"type\"], main);\n                } else if (message instanceof ArrayBuffer) {\n                  let unpacker = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.decodeMulti)(message);\n                  const { done, value } = unpacker.next();\n                  const main = value;\n                  main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                  Object.assign(main[\"ctx\"], this.default_context);\n                  if (!done) {\n                    let extra = unpacker.next();\n                    Object.assign(main, extra.value);\n                  }\n                  this._fire(main[\"type\"], main);\n                } else if (typeof message === \"object\") {\n                  this._fire(message[\"type\"], message);\n                } else {\n                  throw new Error(\"Invalid message format\");\n                }\n              }\n              reset() {\n                this._event_handlers = {};\n                this._services = {};\n              }\n              async disconnect() {\n                this._fire(\"disconnected\");\n                await this._connection.disconnect();\n              }\n              async get_manager_service(config2) {\n                config2 = config2 || {};\n                const maxRetries = 20;\n                const retryDelay = 500;\n                for (let attempt = 0; attempt < maxRetries; attempt++) {\n                  if (!this._connection.manager_id) {\n                    if (attempt < maxRetries - 1) {\n                      console.warn(\n                        `Manager ID not set, retrying in ${retryDelay}ms (attempt ${attempt + 1}/${maxRetries})`\n                      );\n                      await new Promise((resolve2) => setTimeout(resolve2, retryDelay));\n                      continue;\n                    } else {\n                      throw new Error(\"Manager ID not set after maximum retries\");\n                    }\n                  }\n                  try {\n                    const svc = await this.get_remote_service(\n                      `*/${this._connection.manager_id}:default`,\n                      config2\n                    );\n                    return svc;\n                  } catch (e) {\n                    if (attempt < maxRetries - 1) {\n                      console.warn(\n                        `Failed to get manager service, retrying in ${retryDelay}ms: ${e.message}`\n                      );\n                      await new Promise((resolve2) => setTimeout(resolve2, retryDelay));\n                    } else {\n                      throw e;\n                    }\n                  }\n                }\n              }\n              get_all_local_services() {\n                return this._services;\n              }\n              get_local_service(service_id, context2) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(service_id);\n                const [ws, client_id2] = context2[\"to\"].split(\"/\");\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  client_id2 === this._client_id,\n                  \"Services can only be accessed locally\"\n                );\n                const service = this._services[service_id];\n                if (!service) {\n                  throw new Error(\"Service not found: \" + service_id);\n                }\n                service.config[\"workspace\"] = context2[\"ws\"];\n                if (service.config.visibility == \"public\") {\n                  return service;\n                }\n                if (context2[\"ws\"] === ws) {\n                  return service;\n                }\n                throw new Error(\n                  `Permission denied for getting protected service: ${service_id}, workspace mismatch: ${ws} != ${context2[\"ws\"]}`\n                );\n              }\n              async get_remote_service(service_uri, config2) {\n                let { timeout, case_conversion, kwargs_expansion } = config2 || {};\n                timeout = timeout === void 0 ? this._method_timeout : timeout;\n                if (!service_uri && this._connection.manager_id) {\n                  service_uri = \"*/\" + this._connection.manager_id;\n                } else if (!service_uri.includes(\":\")) {\n                  service_uri = this._client_id + \":\" + service_uri;\n                }\n                const provider = service_uri.split(\":\")[0];\n                let service_id = service_uri.split(\":\")[1];\n                if (service_id.includes(\"@\")) {\n                  service_id = service_id.split(\"@\")[0];\n                  const app_id = service_uri.split(\"@\")[1];\n                  if (this._app_id && this._app_id !== \"*\")\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      app_id === this._app_id,\n                      `Invalid app id: ${app_id} != ${this._app_id}`\n                    );\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(provider, `Invalid service uri: ${service_uri}`);\n                try {\n                  const method = this._generate_remote_method({\n                    _rserver: this._server_base_url,\n                    _rtarget: provider,\n                    _rmethod: \"services.built-in.get_service\",\n                    _rpromise: true,\n                    _rdoc: \"Get a remote service\"\n                  });\n                  let svc = await (0, _utils__WEBPACK_IMPORTED_MODULE_0__.waitFor)(\n                    method(service_id),\n                    timeout,\n                    \"Timeout Error: Failed to get remote service: \" + service_uri\n                  );\n                  svc.id = `${provider}:${service_id}`;\n                  if (kwargs_expansion) {\n                    svc = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.expandKwargs)(svc);\n                  }\n                  if (case_conversion)\n                    return Object.assign(\n                      new RemoteService(),\n                      (0, _utils__WEBPACK_IMPORTED_MODULE_0__.convertCase)(svc, case_conversion)\n                    );\n                  else\n                    return Object.assign(new RemoteService(), svc);\n                } catch (e) {\n                  console.warn(\"Failed to get remote service: \" + service_uri, e);\n                  throw e;\n                }\n              }\n              _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n                if (typeof aObject === \"function\") {\n                  let method_name = object_id.split(\".\")[1];\n                  this._method_annotations.set(aObject, {\n                    require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                    run_in_executor,\n                    method_id: \"services.\" + object_id,\n                    visibility\n                  });\n                } else if (aObject instanceof Array || aObject instanceof Object) {\n                  for (let key of Object.keys(aObject)) {\n                    let val = aObject[key];\n                    if (typeof val === \"function\" && val.__rpc_object__) {\n                      let client_id2 = val.__rpc_object__._rtarget;\n                      if (client_id2.includes(\"/\")) {\n                        client_id2 = client_id2.split(\"/\")[1];\n                      }\n                      if (this._client_id === client_id2) {\n                        if (aObject instanceof Array) {\n                          aObject = aObject.slice();\n                        }\n                        aObject[key] = indexObject(\n                          this._object_store,\n                          val.__rpc_object__._rmethod\n                        );\n                        val = aObject[key];\n                      } else {\n                        throw new Error(\n                          `Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id2}`\n                        );\n                      }\n                    }\n                    this._annotate_service_methods(\n                      val,\n                      object_id + \".\" + key,\n                      require_context,\n                      run_in_executor,\n                      visibility\n                    );\n                  }\n                }\n              }\n              add_service(api, overwrite) {\n                if (!api || Array.isArray(api))\n                  throw new Error(\"Invalid service object\");\n                if (api.constructor === Object) {\n                  api = Object.assign({}, api);\n                } else {\n                  const normApi = {};\n                  const props = Object.getOwnPropertyNames(api).concat(\n                    Object.getOwnPropertyNames(Object.getPrototypeOf(api))\n                  );\n                  for (let k of props) {\n                    if (k !== \"constructor\") {\n                      if (typeof api[k] === \"function\")\n                        normApi[k] = api[k].bind(api);\n                      else\n                        normApi[k] = api[k];\n                    }\n                  }\n                  api.id = api.id || \"default\";\n                  api = normApi;\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  api.id && typeof api.id === \"string\",\n                  `Service id not found: ${api}`\n                );\n                if (!api.name) {\n                  api.name = api.id;\n                }\n                if (!api.config) {\n                  api.config = {};\n                }\n                if (!api.type) {\n                  api.type = \"generic\";\n                }\n                let require_context = false, run_in_executor = false;\n                if (api.config.require_context)\n                  require_context = api.config.require_context;\n                if (api.config.run_in_executor)\n                  run_in_executor = true;\n                const visibility = api.config.visibility || \"protected\";\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)([\"protected\", \"public\"].includes(visibility));\n                this._annotate_service_methods(\n                  api,\n                  api[\"id\"],\n                  require_context,\n                  run_in_executor,\n                  visibility\n                );\n                if (this._services[api.id]) {\n                  if (overwrite) {\n                    delete this._services[api.id];\n                  } else {\n                    throw new Error(\n                      `Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`\n                    );\n                  }\n                }\n                this._services[api.id] = api;\n                return api;\n              }\n              _extract_service_info(service) {\n                const config2 = service.config || {};\n                config2.workspace = config2.workspace || this._local_workspace || this._connection.workspace;\n                const skipContext = config2.require_context;\n                const serviceSchema = _get_schema(service, null, skipContext);\n                const serviceInfo = {\n                  config: config2,\n                  id: `${config2.workspace}/${this._client_id}:${service[\"id\"]}`,\n                  name: service.name || service[\"id\"],\n                  description: service.description || \"\",\n                  type: service.type || \"generic\",\n                  docs: service.docs || null,\n                  app_id: this._app_id,\n                  service_schema: serviceSchema\n                };\n                return serviceInfo;\n              }\n              async get_service_schema(service) {\n                const skipContext = service.config.require_context;\n                return _get_schema(service, null, skipContext);\n              }\n              async register_service(api, config2) {\n                let { check_type, notify, overwrite } = config2 || {};\n                notify = notify === void 0 ? true : notify;\n                let manager;\n                if (check_type && api.type) {\n                  try {\n                    manager = await this.get_manager_service({\n                      timeout: 10,\n                      case_conversion: \"camel\"\n                    });\n                    const type_info = await manager.get_service_type(api.type);\n                    api = _annotate_service(api, type_info);\n                  } catch (e) {\n                    throw new Error(`Failed to get service type ${api.type}, error: ${e}`);\n                  }\n                }\n                const service = this.add_service(api, overwrite);\n                const serviceInfo = this._extract_service_info(service);\n                if (notify) {\n                  try {\n                    manager = manager || await this.get_manager_service({\n                      timeout: 10,\n                      case_conversion: \"camel\"\n                    });\n                    await manager.registerService(serviceInfo);\n                  } catch (e) {\n                    throw new Error(`Failed to notify workspace manager: ${e}`);\n                  }\n                }\n                return serviceInfo;\n              }\n              async unregister_service(service, notify) {\n                notify = notify === void 0 ? true : notify;\n                let service_id;\n                if (typeof service === \"string\") {\n                  service_id = service;\n                } else {\n                  service_id = service.id;\n                }\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  service_id && typeof service_id === \"string\",\n                  `Invalid service id: ${service_id}`\n                );\n                if (service_id.includes(\":\")) {\n                  service_id = service_id.split(\":\")[1];\n                }\n                if (service_id.includes(\"@\")) {\n                  service_id = service_id.split(\"@\")[0];\n                }\n                if (!this._services[service_id]) {\n                  throw new Error(`Service not found: ${service_id}`);\n                }\n                if (notify) {\n                  const manager = await this.get_manager_service({\n                    timeout: 10,\n                    case_conversion: \"camel\"\n                  });\n                  await manager.unregisterService(service_id);\n                }\n                delete this._services[service_id];\n              }\n              _ndarray(typedArray, shape, dtype) {\n                const _dtype = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(typedArray);\n                if (dtype && dtype !== _dtype) {\n                  throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n                }\n                shape = shape || [typedArray.length];\n                return {\n                  _rtype: \"ndarray\",\n                  _rvalue: typedArray.buffer,\n                  _rshape: shape,\n                  _rdtype: _dtype\n                };\n              }\n              _encode_callback(name2, callback, session_id, clear_after_called, timer, local_workspace, description) {\n                let method_id = `${session_id}.${name2}`;\n                let encoded = {\n                  _rtype: \"method\",\n                  _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                  _rmethod: method_id,\n                  _rpromise: false\n                };\n                const self2 = this;\n                let wrapped_callback = function() {\n                  try {\n                    callback.apply(null, Array.prototype.slice.call(arguments));\n                  } catch (error) {\n                    console.error(\n                      `Error in callback(${method_id}, ${description}): ${error}`\n                    );\n                  } finally {\n                    if (timer && timer.started) {\n                      timer.clear();\n                    }\n                    if (clear_after_called && self2._object_store[session_id]) {\n                      delete self2._object_store[session_id];\n                    }\n                  }\n                };\n                wrapped_callback.__name__ = `callback(${method_id})`;\n                return [encoded, wrapped_callback];\n              }\n              async _encode_promise(resolve2, reject2, session_id, clear_after_called, timer, local_workspace, description) {\n                let store = this._get_session_store(session_id, true);\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  store,\n                  `Failed to create session store ${session_id} due to invalid parent`\n                );\n                let encoded = {};\n                if (timer && reject2 && this._method_timeout) {\n                  [encoded.heartbeat, store.heartbeat] = this._encode_callback(\n                    \"heartbeat\",\n                    timer.reset.bind(timer),\n                    session_id,\n                    false,\n                    null,\n                    local_workspace\n                    // `heartbeat (${description})`,\n                  );\n                  store.timer = timer;\n                  encoded.interval = this._method_timeout / 2;\n                } else {\n                  timer = null;\n                }\n                [encoded.resolve, store.resolve] = this._encode_callback(\n                  \"resolve\",\n                  resolve2,\n                  session_id,\n                  clear_after_called,\n                  timer,\n                  local_workspace,\n                  `resolve (${description})`\n                );\n                [encoded.reject, store.reject] = this._encode_callback(\n                  \"reject\",\n                  reject2,\n                  session_id,\n                  clear_after_called,\n                  timer,\n                  local_workspace,\n                  `reject (${description})`\n                );\n                return encoded;\n              }\n              async _send_chunks(data, target_id, session_id) {\n                const remote_services = await this.get_remote_service(\n                  `${target_id}:built-in`\n                );\n                if (!remote_services.message_cache) {\n                  throw new Error(\n                    \"Remote client does not support message caching for large messages.\"\n                  );\n                }\n                const message_cache = remote_services.message_cache;\n                const message_id = session_id || (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                const total_size = data.length;\n                const start_time = Date.now();\n                const chunk_num = Math.ceil(total_size / this._long_message_chunk_size);\n                if (remote_services.config.api_version >= 3) {\n                  await message_cache.create(message_id, !!session_id);\n                  const semaphore = new _utils__WEBPACK_IMPORTED_MODULE_0__.Semaphore(CONCURRENCY_LIMIT);\n                  const tasks = [];\n                  for (let idx = 0; idx < chunk_num; idx++) {\n                    const startByte = idx * this._long_message_chunk_size;\n                    const chunk = data.slice(\n                      startByte,\n                      startByte + this._long_message_chunk_size\n                    );\n                    const taskFn = async () => {\n                      await message_cache.set(message_id, idx, chunk, !!session_id);\n                      console.debug(\n                        `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`\n                      );\n                    };\n                    tasks.push(semaphore.run(taskFn));\n                  }\n                  await Promise.all(tasks);\n                } else {\n                  await message_cache.create(message_id, !!session_id);\n                  for (let idx = 0; idx < chunk_num; idx++) {\n                    const startByte = idx * this._long_message_chunk_size;\n                    const chunk = data.slice(\n                      startByte,\n                      startByte + this._long_message_chunk_size\n                    );\n                    await message_cache.append(message_id, chunk, !!session_id);\n                    console.debug(\n                      `Sending chunk ${idx + 1}/${chunk_num} (total=${total_size} bytes)`\n                    );\n                  }\n                }\n                await message_cache.process(message_id, !!session_id);\n                const durationSec = ((Date.now() - start_time) / 1e3).toFixed(2);\n                console.debug(`All chunks (${total_size} bytes) sent in ${durationSec} s`);\n              }\n              emit(main_message, extra_data) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                  typeof main_message === \"object\" && main_message.type,\n                  \"Invalid message, must be an object with a `type` fields.\"\n                );\n                if (!main_message.to) {\n                  this._fire(main_message.type, main_message);\n                  return;\n                }\n                let message_package = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n                if (extra_data) {\n                  const extra = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n                  message_package = new Uint8Array([...message_package, ...extra]);\n                }\n                const total_size = message_package.length;\n                if (total_size > this._long_message_chunk_size + 1024) {\n                  console.warn(`Sending large message (size=${total_size})`);\n                }\n                return this._emit_message(message_package);\n              }\n              _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n                let target_id = encoded_method._rtarget;\n                if (remote_workspace && !target_id.includes(\"/\")) {\n                  if (remote_workspace !== target_id) {\n                    target_id = remote_workspace + \"/\" + target_id;\n                  }\n                  encoded_method._rtarget = target_id;\n                }\n                let method_id = encoded_method._rmethod;\n                let with_promise = encoded_method._rpromise || false;\n                const description = `method: ${method_id}, docs: ${encoded_method._rdoc}`;\n                const self2 = this;\n                function remote_method() {\n                  return new Promise(async (resolve2, reject2) => {\n                    let local_session_id = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                    if (local_parent) {\n                      local_session_id = local_parent + \".\" + local_session_id;\n                    }\n                    let store = self2._get_session_store(local_session_id, true);\n                    if (!store) {\n                      reject2(\n                        new Error(\n                          `Runtime Error: Failed to get session store ${local_session_id} (context: ${description})`\n                        )\n                      );\n                      return;\n                    }\n                    store[\"target_id\"] = target_id;\n                    const args = await self2._encode(\n                      Array.prototype.slice.call(arguments),\n                      local_session_id,\n                      local_workspace\n                    );\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    let from_client;\n                    if (!self2._local_workspace) {\n                      from_client = self2._client_id;\n                    } else {\n                      from_client = self2._local_workspace + \"/\" + self2._client_id;\n                    }\n                    let main_message = {\n                      type: \"method\",\n                      from: from_client,\n                      to: target_id,\n                      method: method_id\n                    };\n                    let extra_data = {};\n                    if (args) {\n                      extra_data[\"args\"] = args;\n                    }\n                    if (withKwargs) {\n                      extra_data[\"with_kwargs\"] = withKwargs;\n                    }\n                    if (remote_parent) {\n                      main_message[\"parent\"] = remote_parent;\n                    }\n                    let timer = null;\n                    if (with_promise) {\n                      main_message[\"session\"] = local_session_id;\n                      let method_name = `${target_id}:${method_id}`;\n                      timer = new Timer(\n                        self2._method_timeout,\n                        reject2,\n                        [`Method call time out: ${method_name}, context: ${description}`],\n                        method_name\n                      );\n                      let clear_after_called = true;\n                      for (let arg of args) {\n                        if (typeof arg === \"object\" && arg._rintf === true) {\n                          clear_after_called = false;\n                          break;\n                        }\n                      }\n                      const promiseData = await self2._encode_promise(\n                        resolve2,\n                        reject2,\n                        local_session_id,\n                        clear_after_called,\n                        timer,\n                        local_workspace,\n                        description\n                      );\n                      if (with_promise === true) {\n                        extra_data[\"promise\"] = promiseData;\n                      } else if (with_promise === \"*\") {\n                        extra_data[\"promise\"] = \"*\";\n                        extra_data[\"t\"] = self2._method_timeout / 2;\n                      } else {\n                        throw new Error(`Unsupported promise type: ${with_promise}`);\n                      }\n                    }\n                    let message_package = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(main_message);\n                    if (extra_data) {\n                      const extra = (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.encode)(extra_data);\n                      message_package = new Uint8Array([...message_package, ...extra]);\n                    }\n                    const total_size = message_package.length;\n                    if (total_size <= self2._long_message_chunk_size + 1024 || remote_method.__no_chunk__) {\n                      self2._emit_message(message_package).then(function() {\n                        if (timer) {\n                          timer.reset();\n                        }\n                      }).catch(function(err) {\n                        console.error(\"Failed to send message\", err);\n                        reject2(err);\n                        if (timer) {\n                          timer.clear();\n                        }\n                      });\n                    } else {\n                      self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                        if (timer) {\n                          timer.reset();\n                        }\n                      }).catch(function(err) {\n                        console.error(\"Failed to send message\", err);\n                        reject2(err);\n                        if (timer) {\n                          timer.clear();\n                        }\n                      });\n                    }\n                  });\n                }\n                remote_method.__rpc_object__ = encoded_method;\n                const parts = method_id.split(\".\");\n                remote_method.__name__ = encoded_method._rname || parts[parts.length - 1];\n                if (remote_method.__name__.includes(\"#\")) {\n                  remote_method.__name__ = remote_method.__name__.split(\"#\")[1];\n                }\n                remote_method.__doc__ = encoded_method._rdoc || `Remote method: ${method_id}`;\n                remote_method.__schema__ = encoded_method._rschema;\n                remote_method.__no_chunk__ = encoded_method._rmethod === \"services.built-in.message_cache.append\";\n                return remote_method;\n              }\n              get_client_info() {\n                const services = [];\n                for (let service of Object.values(this._services)) {\n                  services.push(this._extract_service_info(service));\n                }\n                return {\n                  id: this._client_id,\n                  services\n                };\n              }\n              async _handle_method(data) {\n                let reject2 = null;\n                let heartbeat_task = null;\n                try {\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(data.method && data.ctx && data.from);\n                  const method_name = data.from + \":\" + data.method;\n                  const remote_workspace = data.from.split(\"/\")[0];\n                  const remote_client_id = data.from.split(\"/\")[1];\n                  data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                  data[\"ctx\"][\"to\"] = data[\"to\"];\n                  let local_workspace;\n                  if (!this._local_workspace) {\n                    local_workspace = data[\"to\"].split(\"/\")[0];\n                  } else {\n                    if (this._local_workspace && this._local_workspace !== \"*\") {\n                      (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                        data[\"to\"].split(\"/\")[0] === this._local_workspace,\n                        \"Workspace mismatch: \" + data[\"to\"].split(\"/\")[0] + \" != \" + this._local_workspace\n                      );\n                    }\n                    local_workspace = this._local_workspace;\n                  }\n                  const local_parent = data.parent;\n                  let resolve2, reject3;\n                  if (data.promise) {\n                    const promise = await this._decode(\n                      data.promise === \"*\" ? this._expand_promise(data) : data.promise,\n                      data.session,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    resolve2 = promise.resolve;\n                    reject3 = promise.reject;\n                    if (promise.heartbeat && promise.interval) {\n                      async function heartbeat() {\n                        try {\n                          await promise.heartbeat();\n                        } catch (err) {\n                          console.error(err);\n                        }\n                      }\n                      heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                    }\n                  }\n                  let method;\n                  try {\n                    method = indexObject(this._object_store, data[\"method\"]);\n                  } catch (e) {\n                    throw new Error(\n                      `Method not found: ${method_name} at ${this._client_id}`\n                    );\n                  }\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    method && typeof method === \"function\",\n                    \"Invalid method: \" + method_name\n                  );\n                  if (this._method_annotations.has(method)) {\n                    if (this._method_annotations.get(method).visibility === \"protected\") {\n                      if (local_workspace !== remote_workspace && (remote_workspace !== \"*\" || remote_client_id !== this._connection.manager_id)) {\n                        throw new Error(\n                          \"Permission denied for invoking protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace\n                        );\n                      }\n                    }\n                  } else {\n                    let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                    if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                      session_target_id = local_workspace + \"/\" + session_target_id;\n                    }\n                    if (session_target_id !== data.from) {\n                      throw new Error(\n                        \"Access denied for method call (\" + method_name + \") from \" + data.from + \" to target \" + session_target_id\n                      );\n                    }\n                  }\n                  if (local_parent) {\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      this._get_session_store(local_parent, true) !== null,\n                      \"Parent session was closed: \" + local_parent\n                    );\n                  }\n                  let args;\n                  if (data.args) {\n                    args = await this._decode(\n                      data.args,\n                      data.session,\n                      null,\n                      remote_workspace,\n                      null\n                    );\n                  } else {\n                    args = [];\n                  }\n                  if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                    if (args.length + 1 < method.length) {\n                      for (let i = args.length; i < method.length - 1; i++) {\n                        args.push(void 0);\n                      }\n                    }\n                    args.push(data.ctx);\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      args.length === method.length,\n                      `Runtime Error: Invalid number of arguments for method ${method_name}, expected ${method.length} but got ${args.length}`\n                    );\n                  }\n                  if (data.promise) {\n                    const result = method.apply(null, args);\n                    if (result instanceof Promise) {\n                      result.then((result2) => {\n                        resolve2(result2);\n                        clearInterval(heartbeat_task);\n                      }).catch((err) => {\n                        reject3(err);\n                        clearInterval(heartbeat_task);\n                      });\n                    } else {\n                      resolve2(result);\n                      clearInterval(heartbeat_task);\n                    }\n                  } else {\n                    method.apply(null, args);\n                    clearInterval(heartbeat_task);\n                  }\n                } catch (err) {\n                  if (reject2) {\n                    reject2(err);\n                  } else {\n                    console.error(\"Error during calling method: \", err);\n                  }\n                  clearInterval(heartbeat_task);\n                }\n              }\n              encode(aObject, session_id) {\n                return this._encode(aObject, session_id);\n              }\n              _get_session_store(session_id, create) {\n                let store = this._object_store;\n                const levels = session_id.split(\".\");\n                if (create) {\n                  const last_index = levels.length - 1;\n                  for (let level of levels.slice(0, last_index)) {\n                    if (!store[level]) {\n                      return null;\n                    }\n                    store = store[level];\n                  }\n                  if (!store[levels[last_index]]) {\n                    store[levels[last_index]] = {};\n                  }\n                  return store[levels[last_index]];\n                } else {\n                  for (let level of levels) {\n                    if (!store[level]) {\n                      return null;\n                    }\n                    store = store[level];\n                  }\n                  return store;\n                }\n              }\n              /**\n               * Prepares the provided set of remote method arguments for\n               * sending to the remote site, replaces all the callbacks with\n               * identifiers\n               *\n               * @param {Array} args to wrap\n               *\n               * @returns {Array} wrapped arguments\n               */\n              async _encode(aObject, session_id, local_workspace) {\n                const aType = typeof aObject;\n                if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                  return aObject;\n                }\n                if (aObject instanceof ArrayBuffer) {\n                  return {\n                    _rtype: \"memoryview\",\n                    _rvalue: new Uint8Array(aObject)\n                  };\n                }\n                if (aObject.__rpc_object__) {\n                  const _server = aObject.__rpc_object__._rserver || this._server_base_url;\n                  if (_server === this._server_base_url) {\n                    return aObject.__rpc_object__;\n                  }\n                }\n                let bObject;\n                if (aObject.constructor instanceof Object && aObject._rtype) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._encode(aObject, session_id, local_workspace);\n                  bObject._rtype = temp;\n                  return bObject;\n                }\n                if ((0, _utils__WEBPACK_IMPORTED_MODULE_0__.isGenerator)(aObject) || (0, _utils__WEBPACK_IMPORTED_MODULE_0__.isAsyncGenerator)(aObject)) {\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    session_id && typeof session_id === \"string\",\n                    \"Session ID is required for generator encoding\"\n                  );\n                  const object_id = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                  const store = this._get_session_store(session_id, true);\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                    store !== null,\n                    `Failed to create session store ${session_id} due to invalid parent`\n                  );\n                  const isAsync = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.isAsyncGenerator)(aObject);\n                  const nextItemMethod = async () => {\n                    if (isAsync) {\n                      const iterator = aObject;\n                      const result = await iterator.next();\n                      if (result.done) {\n                        delete store[object_id];\n                        return { _rtype: \"stop_iteration\" };\n                      }\n                      return result.value;\n                    } else {\n                      const iterator = aObject;\n                      const result = iterator.next();\n                      if (result.done) {\n                        delete store[object_id];\n                        return { _rtype: \"stop_iteration\" };\n                      }\n                      return result.value;\n                    }\n                  };\n                  store[object_id] = nextItemMethod;\n                  bObject = {\n                    _rtype: \"generator\",\n                    _rserver: this._server_base_url,\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: \"*\",\n                    _rdoc: \"Remote generator\"\n                  };\n                  return bObject;\n                } else if (typeof aObject === \"function\") {\n                  if (this._method_annotations.has(aObject)) {\n                    let annotation = this._method_annotations.get(aObject);\n                    bObject = {\n                      _rtype: \"method\",\n                      _rserver: this._server_base_url,\n                      _rtarget: this._client_id,\n                      _rmethod: annotation.method_id,\n                      _rpromise: \"*\",\n                      _rname: aObject.name\n                    };\n                  } else {\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(typeof session_id === \"string\");\n                    let object_id;\n                    if (aObject.__name__) {\n                      object_id = `${(0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)()}#${aObject.__name__}`;\n                    } else {\n                      object_id = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.randId)();\n                    }\n                    bObject = {\n                      _rtype: \"method\",\n                      _rserver: this._server_base_url,\n                      _rtarget: this._client_id,\n                      _rmethod: `${session_id}.${object_id}`,\n                      _rpromise: \"*\",\n                      _rname: aObject.name\n                    };\n                    let store = this._get_session_store(session_id, true);\n                    (0, _utils__WEBPACK_IMPORTED_MODULE_0__.assert)(\n                      store !== null,\n                      `Failed to create session store ${session_id} due to invalid parent`\n                    );\n                    store[object_id] = aObject;\n                  }\n                  bObject._rdoc = aObject.__doc__;\n                  if (!bObject._rdoc) {\n                    try {\n                      const funcInfo = getFunctionInfo(aObject);\n                      if (funcInfo && !bObject._rdoc) {\n                        bObject._rdoc = `${funcInfo.doc}`;\n                      }\n                    } catch (e) {\n                      console.error(\"Failed to extract function docstring:\", aObject);\n                    }\n                  }\n                  bObject._rschema = aObject.__schema__;\n                  return bObject;\n                }\n                const isarray = Array.isArray(aObject);\n                for (let tp of Object.keys(this._codecs)) {\n                  const codec = this._codecs[tp];\n                  if (codec.encoder && aObject instanceof codec.type) {\n                    let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                    if (encodedObj && !encodedObj._rtype)\n                      encodedObj._rtype = codec.name;\n                    if (typeof encodedObj === \"object\") {\n                      const temp = encodedObj._rtype;\n                      delete encodedObj._rtype;\n                      encodedObj = await this._encode(\n                        encodedObj,\n                        session_id,\n                        local_workspace\n                      );\n                      encodedObj._rtype = temp;\n                    }\n                    bObject = encodedObj;\n                    return bObject;\n                  }\n                }\n                if (\n                  /*global tf*/\n                  typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n                ) {\n                  const v_buffer = aObject.dataSync();\n                  bObject = {\n                    _rtype: \"ndarray\",\n                    _rvalue: new Uint8Array(v_buffer.buffer),\n                    _rshape: aObject.shape,\n                    _rdtype: aObject.dtype\n                  };\n                } else if (\n                  /*global nj*/\n                  typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n                ) {\n                  const dtype = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject.selection.data);\n                  bObject = {\n                    _rtype: \"ndarray\",\n                    _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                    _rshape: aObject.shape,\n                    _rdtype: dtype\n                  };\n                } else if (aObject instanceof Error) {\n                  console.error(aObject);\n                  bObject = {\n                    _rtype: \"error\",\n                    _rvalue: aObject.toString(),\n                    _rtrace: aObject.stack\n                  };\n                } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                  bObject = aObject;\n                } else if (aObject instanceof Blob) {\n                  let seek = function(pos) {\n                    _current_pos = pos;\n                  };\n                  let _current_pos = 0;\n                  async function read(length) {\n                    let blob;\n                    if (length) {\n                      blob = aObject.slice(_current_pos, _current_pos + length);\n                    } else {\n                      blob = aObject.slice(_current_pos);\n                    }\n                    const ret = new Uint8Array(await blob.arrayBuffer());\n                    _current_pos = _current_pos + ret.byteLength;\n                    return ret;\n                  }\n                  bObject = {\n                    _rtype: \"iostream\",\n                    _rnative: \"js:blob\",\n                    type: aObject.type,\n                    name: aObject.name,\n                    size: aObject.size,\n                    path: aObject._path || aObject.webkitRelativePath,\n                    read: await this._encode(read, session_id, local_workspace),\n                    seek: await this._encode(seek, session_id, local_workspace)\n                  };\n                } else if (aObject instanceof ArrayBufferView) {\n                  const dtype = (0, _utils__WEBPACK_IMPORTED_MODULE_0__.typedArrayToDtype)(aObject);\n                  bObject = {\n                    _rtype: \"typedarray\",\n                    _rvalue: new Uint8Array(aObject.buffer),\n                    _rdtype: dtype\n                  };\n                } else if (aObject instanceof DataView) {\n                  bObject = {\n                    _rtype: \"memoryview\",\n                    _rvalue: new Uint8Array(aObject.buffer)\n                  };\n                } else if (aObject instanceof Set) {\n                  bObject = {\n                    _rtype: \"set\",\n                    _rvalue: await this._encode(\n                      Array.from(aObject),\n                      session_id,\n                      local_workspace\n                    )\n                  };\n                } else if (aObject instanceof Map) {\n                  bObject = {\n                    _rtype: \"orderedmap\",\n                    _rvalue: await this._encode(\n                      Array.from(aObject),\n                      session_id,\n                      local_workspace\n                    )\n                  };\n                } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                  bObject = isarray ? [] : {};\n                  const keys = Object.keys(aObject);\n                  for (let k of keys) {\n                    bObject[k] = await this._encode(\n                      aObject[k],\n                      session_id,\n                      local_workspace\n                    );\n                  }\n                } else {\n                  throw `hypha-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n                }\n                if (!bObject) {\n                  throw new Error(\"Failed to encode object\");\n                }\n                return bObject;\n              }\n              async decode(aObject) {\n                return await this._decode(aObject);\n              }\n              async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n                if (!aObject) {\n                  return aObject;\n                }\n                let bObject;\n                if (aObject._rtype) {\n                  if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    aObject = await this._decode(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    aObject._rtype = temp;\n                    bObject = await Promise.resolve(\n                      this._codecs[aObject._rtype].decoder(aObject)\n                    );\n                  } else if (aObject._rtype === \"method\") {\n                    bObject = this._generate_remote_method(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                  } else if (aObject._rtype === \"generator\") {\n                    const gen_method = this._generate_remote_method(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    async function* asyncGeneratorProxy() {\n                      try {\n                        while (true) {\n                          try {\n                            const next_item = await gen_method();\n                            if (next_item && next_item._rtype === \"stop_iteration\") {\n                              break;\n                            }\n                            yield next_item;\n                          } catch (error) {\n                            console.error(\"Error in generator:\", error);\n                            throw error;\n                          }\n                        }\n                      } catch (error) {\n                        console.error(\"Error in generator:\", error);\n                        throw error;\n                      }\n                    }\n                    bObject = asyncGeneratorProxy();\n                  } else if (aObject._rtype === \"ndarray\") {\n                    if (typeof nj !== \"undefined\" && nj.array) {\n                      if (Array.isArray(aObject._rvalue)) {\n                        aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                      }\n                      bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                    } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                      if (Array.isArray(aObject._rvalue)) {\n                        aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                      }\n                      const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n                      bObject = tf.tensor(\n                        new arraytype(aObject._rvalue),\n                        aObject._rshape,\n                        aObject._rdtype\n                      );\n                    } else {\n                      bObject = aObject;\n                    }\n                  } else if (aObject._rtype === \"error\") {\n                    bObject = new Error(\n                      \"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\")\n                    );\n                  } else if (aObject._rtype === \"typedarray\") {\n                    const arraytype = _utils__WEBPACK_IMPORTED_MODULE_0__.dtypeToTypedArray[aObject._rdtype];\n                    if (!arraytype)\n                      throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                    const buffer = aObject._rvalue.buffer.slice(\n                      aObject._rvalue.byteOffset,\n                      aObject._rvalue.byteOffset + aObject._rvalue.byteLength\n                    );\n                    bObject = new arraytype(buffer);\n                  } else if (aObject._rtype === \"memoryview\") {\n                    bObject = aObject._rvalue.buffer.slice(\n                      aObject._rvalue.byteOffset,\n                      aObject._rvalue.byteOffset + aObject._rvalue.byteLength\n                    );\n                  } else if (aObject._rtype === \"iostream\") {\n                    if (aObject._rnative === \"js:blob\") {\n                      const read = await this._generate_remote_method(\n                        aObject.read,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      );\n                      const bytes = await read();\n                      bObject = new Blob([bytes], {\n                        type: aObject.type,\n                        name: aObject.name\n                      });\n                    } else {\n                      bObject = {};\n                      for (let k of Object.keys(aObject)) {\n                        if (!k.startsWith(\"_\")) {\n                          bObject[k] = await this._decode(\n                            aObject[k],\n                            remote_parent,\n                            local_parent,\n                            remote_workspace,\n                            local_workspace\n                          );\n                        }\n                      }\n                    }\n                    bObject[\"__rpc_object__\"] = aObject;\n                  } else if (aObject._rtype === \"orderedmap\") {\n                    bObject = new Map(\n                      await this._decode(\n                        aObject._rvalue,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      )\n                    );\n                  } else if (aObject._rtype === \"set\") {\n                    bObject = new Set(\n                      await this._decode(\n                        aObject._rvalue,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      )\n                    );\n                  } else {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    bObject = await this._decode(\n                      aObject,\n                      remote_parent,\n                      local_parent,\n                      remote_workspace,\n                      local_workspace\n                    );\n                    bObject._rtype = temp;\n                  }\n                } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  const isarray = Array.isArray(aObject);\n                  bObject = isarray ? [] : {};\n                  for (let k of Object.keys(aObject)) {\n                    if (isarray || aObject.hasOwnProperty(k)) {\n                      const v = aObject[k];\n                      bObject[k] = await this._decode(\n                        v,\n                        remote_parent,\n                        local_parent,\n                        remote_workspace,\n                        local_workspace\n                      );\n                    }\n                  }\n                } else {\n                  bObject = aObject;\n                }\n                if (bObject === void 0) {\n                  throw new Error(\"Failed to decode object\");\n                }\n                return bObject;\n              }\n              _expand_promise(data) {\n                return {\n                  heartbeat: {\n                    _rtype: \"method\",\n                    _rtarget: data.from.split(\"/\")[1],\n                    _rmethod: data.session + \".heartbeat\",\n                    _rdoc: `heartbeat callback for method: ${data.method}`\n                  },\n                  resolve: {\n                    _rtype: \"method\",\n                    _rtarget: data.from.split(\"/\")[1],\n                    _rmethod: data.session + \".resolve\",\n                    _rdoc: `resolve callback for method: ${data.method}`\n                  },\n                  reject: {\n                    _rtype: \"method\",\n                    _rtarget: data.from.split(\"/\")[1],\n                    _rmethod: data.session + \".reject\",\n                    _rdoc: `reject callback for method: ${data.method}`\n                  },\n                  interval: data.t\n                };\n              }\n            }\n          }\n        ),\n        /***/\n        \"./src/utils/index.js\": (\n          /*!****************************!*\\\n            !*** ./src/utils/index.js ***!\n            \\****************************/\n          /***/\n          (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_80122__) => {\n            __nested_webpack_require_80122__.r(__nested_webpack_exports__);\n            __nested_webpack_require_80122__.d(__nested_webpack_exports__, {\n              /* harmony export */\n              MessageEmitter: () => (\n                /* binding */\n                MessageEmitter\n              ),\n              /* harmony export */\n              Semaphore: () => (\n                /* binding */\n                Semaphore\n              ),\n              /* harmony export */\n              assert: () => (\n                /* binding */\n                assert\n              ),\n              /* harmony export */\n              cacheRequirements: () => (\n                /* binding */\n                cacheRequirements\n              ),\n              /* harmony export */\n              convertCase: () => (\n                /* binding */\n                convertCase\n              ),\n              /* harmony export */\n              dtypeToTypedArray: () => (\n                /* binding */\n                dtypeToTypedArray\n              ),\n              /* harmony export */\n              expandKwargs: () => (\n                /* binding */\n                expandKwargs\n              ),\n              /* harmony export */\n              isAsyncGenerator: () => (\n                /* binding */\n                isAsyncGenerator\n              ),\n              /* harmony export */\n              isGenerator: () => (\n                /* binding */\n                isGenerator\n              ),\n              /* harmony export */\n              loadRequirements: () => (\n                /* binding */\n                loadRequirements\n              ),\n              /* harmony export */\n              loadRequirementsInWebworker: () => (\n                /* binding */\n                loadRequirementsInWebworker\n              ),\n              /* harmony export */\n              loadRequirementsInWindow: () => (\n                /* binding */\n                loadRequirementsInWindow\n              ),\n              /* harmony export */\n              normalizeConfig: () => (\n                /* binding */\n                normalizeConfig\n              ),\n              /* harmony export */\n              parseServiceUrl: () => (\n                /* binding */\n                parseServiceUrl\n              ),\n              /* harmony export */\n              randId: () => (\n                /* binding */\n                randId\n              ),\n              /* harmony export */\n              toCamelCase: () => (\n                /* binding */\n                toCamelCase\n              ),\n              /* harmony export */\n              toSnakeCase: () => (\n                /* binding */\n                toSnakeCase\n              ),\n              /* harmony export */\n              typedArrayToDtype: () => (\n                /* binding */\n                typedArrayToDtype\n              ),\n              /* harmony export */\n              typedArrayToDtypeMapping: () => (\n                /* binding */\n                typedArrayToDtypeMapping\n              ),\n              /* harmony export */\n              urlJoin: () => (\n                /* binding */\n                urlJoin\n              ),\n              /* harmony export */\n              waitFor: () => (\n                /* binding */\n                waitFor\n              )\n              /* harmony export */\n            });\n            function randId() {\n              return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n            }\n            function toCamelCase(str) {\n              if (!str.includes(\"_\")) {\n                return str;\n              }\n              return str.replace(/_./g, (match) => match[1].toUpperCase());\n            }\n            function toSnakeCase(str) {\n              return str.replace(/([A-Z])/g, \"_$1\").toLowerCase();\n            }\n            function expandKwargs(obj) {\n              if (typeof obj !== \"object\" || obj === null) {\n                return obj;\n              }\n              const newObj = Array.isArray(obj) ? [] : {};\n              for (const key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                  const value = obj[key];\n                  if (typeof value === \"function\") {\n                    newObj[key] = (...args) => {\n                      if (args.length === 0) {\n                        throw new Error(`Function \"${key}\" expects at least one argument.`);\n                      }\n                      const lastArg = args[args.length - 1];\n                      let kwargs = {};\n                      if (typeof lastArg === \"object\" && lastArg !== null && !Array.isArray(lastArg)) {\n                        kwargs = { ...lastArg, _rkwarg: true };\n                        args = args.slice(0, -1);\n                      }\n                      return value(...args, kwargs);\n                    };\n                    newObj[key].__name__ = key;\n                    if (value.__schema__) {\n                      newObj[key].__schema__ = { ...value.__schema__ };\n                      newObj[key].__schema__.name = key;\n                    }\n                  } else {\n                    newObj[key] = expandKwargs(value);\n                  }\n                }\n              }\n              return newObj;\n            }\n            function convertCase(obj, caseType) {\n              if (typeof obj !== \"object\" || obj === null || !caseType) {\n                return obj;\n              }\n              const newObj = Array.isArray(obj) ? [] : {};\n              for (const key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                  const value = obj[key];\n                  const camelKey = toCamelCase(key);\n                  const snakeKey = toSnakeCase(key);\n                  if (caseType === \"camel\") {\n                    newObj[camelKey] = convertCase(value, caseType);\n                    if (typeof value === \"function\") {\n                      newObj[camelKey].__name__ = camelKey;\n                      if (value.__schema__) {\n                        newObj[camelKey].__schema__ = { ...value.__schema__ };\n                        newObj[camelKey].__schema__.name = camelKey;\n                      }\n                    }\n                  } else if (caseType === \"snake\") {\n                    newObj[snakeKey] = convertCase(value, caseType);\n                    if (typeof value === \"function\") {\n                      newObj[snakeKey].__name__ = snakeKey;\n                      if (value.__schema__) {\n                        newObj[snakeKey].__schema__ = { ...value.__schema__ };\n                        newObj[snakeKey].__schema__.name = snakeKey;\n                      }\n                    }\n                  } else {\n                    if (caseType.includes(\"camel\")) {\n                      newObj[camelKey] = convertCase(value, \"camel\");\n                    }\n                    if (caseType.includes(\"snake\")) {\n                      newObj[snakeKey] = convertCase(value, \"snake\");\n                    }\n                  }\n                }\n              }\n              return newObj;\n            }\n            function parseServiceUrl(url) {\n              url = url.replace(/\\/$/, \"\");\n              const pattern = new RegExp(\n                \"^(https?:\\\\/\\\\/[^/]+)\\\\/([a-z0-9_-]+)\\\\/services\\\\/(?:(?<clientId>[a-zA-Z0-9_-]+):)?(?<serviceId>[a-zA-Z0-9_-]+)(?:@(?<appId>[a-zA-Z0-9_-]+))?\"\n                // optional app_id\n              );\n              const match = url.match(pattern);\n              if (!match) {\n                throw new Error(\"URL does not match the expected pattern\");\n              }\n              const serverUrl = match[1];\n              const workspace2 = match[2];\n              const clientId = match.groups?.clientId || \"*\";\n              const serviceId = match.groups?.serviceId;\n              const appId = match.groups?.appId || \"*\";\n              return { serverUrl, workspace: workspace2, clientId, serviceId, appId };\n            }\n            const dtypeToTypedArray = {\n              int8: Int8Array,\n              int16: Int16Array,\n              int32: Int32Array,\n              uint8: Uint8Array,\n              uint16: Uint16Array,\n              uint32: Uint32Array,\n              float32: Float32Array,\n              float64: Float64Array,\n              array: Array\n            };\n            async function loadRequirementsInWindow(requirements) {\n              function _importScript(url) {\n                return new Promise((resolve2, reject2) => {\n                  var scriptTag = document.createElement(\"script\");\n                  scriptTag.src = url;\n                  scriptTag.type = \"text/javascript\";\n                  scriptTag.onload = resolve2;\n                  scriptTag.onreadystatechange = function() {\n                    if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                      resolve2();\n                    }\n                  };\n                  scriptTag.onerror = reject2;\n                  document.head.appendChild(scriptTag);\n                });\n              }\n              async function importScripts2() {\n                var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n                for (; i2 < len; i2++) {\n                  await _importScript(args[i2]);\n                }\n              }\n              if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n                try {\n                  var link_node;\n                  requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                  if (Array.isArray(requirements)) {\n                    for (var i = 0; i < requirements.length; i++) {\n                      if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                        if (requirements[i].startsWith(\"css:\")) {\n                          requirements[i] = requirements[i].slice(4);\n                        }\n                        link_node = document.createElement(\"link\");\n                        link_node.rel = \"stylesheet\";\n                        link_node.href = requirements[i];\n                        document.head.appendChild(link_node);\n                      } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                        if (requirements[i].startsWith(\"mjs:\")) {\n                          requirements[i] = requirements[i].slice(4);\n                        }\n                        await import(\n                          /* webpackIgnore: true */\n                          requirements[i]\n                        );\n                      } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                        if (requirements[i].startsWith(\"js:\")) {\n                          requirements[i] = requirements[i].slice(3);\n                        }\n                        await importScripts2(requirements[i]);\n                      } else if (requirements[i].startsWith(\"http\")) {\n                        await importScripts2(requirements[i]);\n                      } else if (requirements[i].startsWith(\"cache:\")) {\n                      } else {\n                        console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                      }\n                    }\n                  } else {\n                    throw \"unsupported requirements definition\";\n                  }\n                } catch (e) {\n                  throw \"failed to import required scripts: \" + requirements.toString();\n                }\n              }\n            }\n            async function loadRequirementsInWebworker(requirements) {\n              if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n                try {\n                  if (!Array.isArray(requirements)) {\n                    requirements = [requirements];\n                  }\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      throw \"unable to import css in a webworker\";\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      importScripts(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      importScripts(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } catch (e) {\n                  throw \"failed to import required scripts: \" + requirements.toString();\n                }\n              }\n            }\n            function loadRequirements(requirements) {\n              if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n                return loadRequirementsInWebworker(requirements);\n              } else {\n                return loadRequirementsInWindow(requirements);\n              }\n            }\n            function normalizeConfig(config2) {\n              config2.version = config2.version || \"0.1.0\";\n              config2.description = config2.description || `[TODO: add description for ${config2.name} ]`;\n              config2.type = config2.type || \"rpc-window\";\n              config2.id = config2.id || randId();\n              config2.target_origin = config2.target_origin || \"*\";\n              config2.allow_execution = config2.allow_execution || false;\n              config2 = Object.keys(config2).reduce((p, c) => {\n                if (typeof config2[c] !== \"function\")\n                  p[c] = config2[c];\n                return p;\n              }, {});\n              return config2;\n            }\n            const typedArrayToDtypeMapping = {\n              Int8Array: \"int8\",\n              Int16Array: \"int16\",\n              Int32Array: \"int32\",\n              Uint8Array: \"uint8\",\n              Uint16Array: \"uint16\",\n              Uint32Array: \"uint32\",\n              Float32Array: \"float32\",\n              Float64Array: \"float64\",\n              Array: \"array\"\n            };\n            const typedArrayToDtypeKeys = [];\n            for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n              typedArrayToDtypeKeys.push(eval(arrType));\n            }\n            function typedArrayToDtype(obj) {\n              let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n              if (!dtype) {\n                const pt = Object.getPrototypeOf(obj);\n                for (const arrType2 of typedArrayToDtypeKeys) {\n                  if (pt instanceof arrType2) {\n                    dtype = typedArrayToDtypeMapping[arrType2.name];\n                    break;\n                  }\n                }\n              }\n              return dtype;\n            }\n            function cacheUrlInServiceWorker(url) {\n              return new Promise(function(resolve2, reject2) {\n                const message = {\n                  command: \"add\",\n                  url\n                };\n                if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                  reject2(\"Service worker is not supported.\");\n                  return;\n                }\n                const messageChannel = new MessageChannel();\n                messageChannel.port1.onmessage = function(event2) {\n                  if (event2.data && event2.data.error) {\n                    reject2(event2.data.error);\n                  } else {\n                    resolve2(event2.data && event2.data.result);\n                  }\n                };\n                if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                  navigator.serviceWorker.controller.postMessage(message, [\n                    messageChannel.port2\n                  ]);\n                } else {\n                  reject2(\"Service worker controller is not available\");\n                }\n              });\n            }\n            async function cacheRequirements(requirements) {\n              requirements = requirements || [];\n              if (!Array.isArray(requirements)) {\n                requirements = [requirements];\n              }\n              for (let req of requirements) {\n                if (req.startsWith(\"js:\"))\n                  req = req.slice(3);\n                if (req.startsWith(\"css:\"))\n                  req = req.slice(4);\n                if (req.startsWith(\"cache:\"))\n                  req = req.slice(6);\n                if (!req.startsWith(\"http\"))\n                  continue;\n                await cacheUrlInServiceWorker(req).catch((e) => {\n                  console.error(e);\n                });\n              }\n            }\n            function assert(condition, message) {\n              if (!condition) {\n                throw new Error(message || \"Assertion failed\");\n              }\n            }\n            function urlJoin(...args) {\n              return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n            }\n            function waitFor(prom, time, error) {\n              let timer;\n              return Promise.race([\n                prom,\n                new Promise(\n                  (_r, rej) => timer = setTimeout(() => {\n                    rej(error || \"Timeout Error\");\n                  }, time * 1e3)\n                )\n              ]).finally(() => clearTimeout(timer));\n            }\n            class MessageEmitter {\n              constructor(debug) {\n                this._event_handlers = {};\n                this._once_handlers = {};\n                this._debug = debug;\n              }\n              emit() {\n                throw new Error(\"emit is not implemented\");\n              }\n              on(event2, handler) {\n                if (!this._event_handlers[event2]) {\n                  this._event_handlers[event2] = [];\n                }\n                this._event_handlers[event2].push(handler);\n              }\n              once(event2, handler) {\n                handler.___event_run_once = true;\n                this.on(event2, handler);\n              }\n              off(event2, handler) {\n                if (!event2 && !handler) {\n                  this._event_handlers = {};\n                } else if (event2 && !handler) {\n                  if (this._event_handlers[event2])\n                    this._event_handlers[event2] = [];\n                } else {\n                  if (this._event_handlers[event2]) {\n                    const idx = this._event_handlers[event2].indexOf(handler);\n                    if (idx >= 0) {\n                      this._event_handlers[event2].splice(idx, 1);\n                    }\n                  }\n                }\n              }\n              _fire(event2, data) {\n                if (this._event_handlers[event2]) {\n                  var i = this._event_handlers[event2].length;\n                  while (i--) {\n                    const handler = this._event_handlers[event2][i];\n                    try {\n                      handler(data);\n                    } catch (e) {\n                      console.error(e);\n                    } finally {\n                      if (handler.___event_run_once) {\n                        this._event_handlers[event2].splice(i, 1);\n                      }\n                    }\n                  }\n                } else {\n                  if (this._debug) {\n                    console.warn(\"unhandled event\", event2, data);\n                  }\n                }\n              }\n              waitFor(event2, timeout) {\n                return new Promise((resolve2, reject2) => {\n                  const handler = (data) => {\n                    clearTimeout(timer);\n                    resolve2(data);\n                  };\n                  this.once(event2, handler);\n                  const timer = setTimeout(() => {\n                    this.off(event2, handler);\n                    reject2(new Error(\"Timeout\"));\n                  }, timeout);\n                });\n              }\n            }\n            class Semaphore {\n              constructor(max) {\n                this.max = max;\n                this.queue = [];\n                this.current = 0;\n              }\n              async run(task) {\n                if (this.current >= this.max) {\n                  await new Promise((resolve2) => this.queue.push(resolve2));\n                }\n                this.current++;\n                try {\n                  return await task();\n                } finally {\n                  this.current--;\n                  if (this.queue.length > 0) {\n                    this.queue.shift()();\n                  }\n                }\n              }\n            }\n            function isGenerator(obj) {\n              if (!obj)\n                return false;\n              return typeof obj === \"object\" && typeof obj.next === \"function\" && typeof obj.throw === \"function\" && typeof obj.return === \"function\";\n            }\n            function isAsyncGenerator(obj) {\n              if (!obj)\n                return false;\n              return typeof obj === \"object\" && typeof obj.next === \"function\" && typeof obj.throw === \"function\" && typeof obj.return === \"function\" && Symbol.asyncIterator in Object(obj) && obj[Symbol.toStringTag] === \"AsyncGenerator\";\n            }\n          }\n        ),\n        /***/\n        \"./src/utils/schema.js\": (\n          /*!*****************************!*\\\n            !*** ./src/utils/schema.js ***!\n            \\*****************************/\n          /***/\n          (__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              schemaFunction: () => (\n                /* binding */\n                schemaFunction\n              )\n              /* harmony export */\n            });\n            var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! . */\n              \"./src/utils/index.js\"\n            );\n            function schemaFunction(func, { schema_type = \"auto\", name: name2 = null, description = null, parameters = null }) {\n              if (!func || typeof func !== \"function\") {\n                throw Error(\"func should be a function\");\n              }\n              (0, ___WEBPACK_IMPORTED_MODULE_0__.assert)(schema_type === \"auto\", \"schema_type should be auto\");\n              (0, ___WEBPACK_IMPORTED_MODULE_0__.assert)(name2, \"name should not be null\");\n              (0, ___WEBPACK_IMPORTED_MODULE_0__.assert)(\n                parameters && parameters.type === \"object\",\n                \"parameters should be an object\"\n              );\n              func.__schema__ = {\n                name: name2,\n                description,\n                parameters: parameters || []\n              };\n              return func;\n            }\n          }\n        ),\n        /***/\n        \"./src/webrtc-client.js\": (\n          /*!******************************!*\\\n            !*** ./src/webrtc-client.js ***!\n            \\******************************/\n          /***/\n          (__unused_webpack_module2, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              getRTCService: () => (\n                /* binding */\n                getRTCService\n              ),\n              /* harmony export */\n              registerRTCService: () => (\n                /* binding */\n                registerRTCService\n              )\n              /* harmony export */\n            });\n            var _rpc_js__WEBPACK_IMPORTED_MODULE_0__2 = __webpack_require__2(\n              /*! ./rpc.js */\n              \"./src/rpc.js\"\n            );\n            var _utils__WEBPACK_IMPORTED_MODULE_1__2 = __webpack_require__2(\n              /*! ./utils */\n              \"./src/utils/index.js\"\n            );\n            var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n              /*! ./utils/schema.js */\n              \"./src/utils/schema.js\"\n            );\n            class WebRTCConnection {\n              constructor(channel) {\n                this._data_channel = channel;\n                this._handle_message = null;\n                this._reconnection_token = null;\n                this._handle_disconnected = null;\n                this._handle_connected = () => {\n                };\n                this.manager_id = null;\n                this._last_message = null;\n                this._data_channel.onopen = async () => {\n                  if (this._last_message) {\n                    console.info(\"Resending last message after connection established\");\n                    this._data_channel.send(this._last_message);\n                    this._last_message = null;\n                  }\n                  this._handle_connected && this._handle_connected({ channel: this._data_channel });\n                };\n                this._data_channel.onmessage = async (event2) => {\n                  let data = event2.data;\n                  if (data instanceof Blob) {\n                    data = await data.arrayBuffer();\n                  }\n                  this._handle_message(data);\n                };\n                const self2 = this;\n                this._data_channel.onclose = function() {\n                  if (this._handle_disconnected)\n                    this._handle_disconnected(\"closed\");\n                  console.log(\"websocket closed\");\n                  self2._data_channel = null;\n                };\n              }\n              on_disconnected(handler) {\n                this._handle_disconnected = handler;\n              }\n              on_connected(handler) {\n                this._handle_connected = handler;\n              }\n              on_message(handler) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(handler, \"handler is required\");\n                this._handle_message = handler;\n              }\n              async emit_message(data) {\n                (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(this._handle_message, \"No handler for message\");\n                try {\n                  this._last_message = data;\n                  this._data_channel.send(data);\n                  this._last_message = null;\n                } catch (exp) {\n                  console.error(`Failed to send data, error: ${exp}`);\n                  throw exp;\n                }\n              }\n              async disconnect(reason) {\n                this._last_message = null;\n                this._data_channel = null;\n                console.info(`data channel connection disconnected (${reason})`);\n              }\n            }\n            async function _setupRPC(config2) {\n              (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(config2.channel, \"No channel provided\");\n              (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(config2.workspace, \"No workspace provided\");\n              const channel = config2.channel;\n              const clientId = config2.client_id || (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.randId)();\n              const connection = new WebRTCConnection(channel);\n              config2.context = config2.context || {};\n              config2.context.connection_type = \"webrtc\";\n              config2.context.ws = config2.workspace;\n              const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__2.RPC(connection, {\n                client_id: clientId,\n                default_context: config2.context,\n                name: config2.name,\n                method_timeout: config2.method_timeout || 10,\n                workspace: config2.workspace,\n                app_id: config2.app_id,\n                long_message_chunk_size: config2.long_message_chunk_size\n              });\n              return rpc;\n            }\n            async function _createOffer(params, server2, config2, onInit, context2) {\n              config2 = config2 || {};\n              let offer = new RTCSessionDescription({\n                sdp: params.sdp,\n                type: params.type\n              });\n              let pc = new RTCPeerConnection({\n                iceServers: config2.ice_servers || [\n                  { urls: [\"stun:stun.l.google.com:19302\"] }\n                ],\n                sdpSemantics: \"unified-plan\"\n              });\n              if (server2) {\n                pc.addEventListener(\"datachannel\", async (event2) => {\n                  const channel = event2.channel;\n                  let ctx = null;\n                  if (context2 && context2.user)\n                    ctx = { user: context2.user, ws: context2.ws };\n                  const rpc = await _setupRPC({\n                    channel,\n                    client_id: channel.label,\n                    workspace: server2.config.workspace,\n                    context: ctx\n                  });\n                  rpc._services = server2.rpc._services;\n                });\n              }\n              if (onInit) {\n                await onInit(pc);\n              }\n              await pc.setRemoteDescription(offer);\n              let answer = await pc.createAnswer();\n              await pc.setLocalDescription(answer);\n              return {\n                sdp: pc.localDescription.sdp,\n                type: pc.localDescription.type,\n                workspace: server2.config.workspace\n              };\n            }\n            async function getRTCService(server2, service_id, config2) {\n              config2 = config2 || {};\n              config2.peer_id = config2.peer_id || (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.randId)();\n              const pc = new RTCPeerConnection({\n                iceServers: config2.ice_servers || [\n                  { urls: [\"stun:stun.l.google.com:19302\"] }\n                ],\n                sdpSemantics: \"unified-plan\"\n              });\n              return new Promise(async (resolve2, reject2) => {\n                try {\n                  pc.addEventListener(\n                    \"connectionstatechange\",\n                    () => {\n                      if (pc.connectionState === \"failed\") {\n                        pc.close();\n                        reject2(new Error(\"WebRTC Connection failed\"));\n                      } else if (pc.connectionState === \"closed\") {\n                        reject2(new Error(\"WebRTC Connection closed\"));\n                      } else {\n                        console.log(\"WebRTC Connection state: \", pc.connectionState);\n                      }\n                    },\n                    false\n                  );\n                  if (config2.on_init) {\n                    await config2.on_init(pc);\n                    delete config2.on_init;\n                  }\n                  let channel = pc.createDataChannel(config2.peer_id, { ordered: true });\n                  channel.binaryType = \"arraybuffer\";\n                  const offer = await pc.createOffer();\n                  await pc.setLocalDescription(offer);\n                  const svc = await server2.getService(service_id);\n                  const answer = await svc.offer({\n                    sdp: pc.localDescription.sdp,\n                    type: pc.localDescription.type\n                  });\n                  channel.onopen = () => {\n                    config2.channel = channel;\n                    config2.workspace = answer.workspace;\n                    setTimeout(async () => {\n                      const rpc = await _setupRPC(config2);\n                      pc.rpc = rpc;\n                      async function get_service(name2, ...args) {\n                        (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(\n                          !name2.includes(\":\"),\n                          \"WebRTC service name should not contain ':'\"\n                        );\n                        (0, _utils__WEBPACK_IMPORTED_MODULE_1__2.assert)(\n                          !name2.includes(\"/\"),\n                          \"WebRTC service name should not contain '/'\"\n                        );\n                        return await rpc.get_remote_service(\n                          config2.workspace + \"/\" + config2.peer_id + \":\" + name2,\n                          ...args\n                        );\n                      }\n                      async function disconnect() {\n                        await rpc.disconnect();\n                        pc.close();\n                      }\n                      pc.getService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2.schemaFunction)(get_service, {\n                        name: \"getService\",\n                        description: \"Get a remote service via webrtc\",\n                        parameters: {\n                          type: \"object\",\n                          properties: {\n                            service_id: {\n                              type: \"string\",\n                              description: \"Service ID. This should be a service id in the format: 'workspace/service_id', 'workspace/client_id:service_id' or 'workspace/client_id:service_id@app_id'\"\n                            },\n                            config: {\n                              type: \"object\",\n                              description: \"Options for the service\"\n                            }\n                          },\n                          required: [\"id\"]\n                        }\n                      });\n                      pc.disconnect = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2.schemaFunction)(disconnect, {\n                        name: \"disconnect\",\n                        description: \"Disconnect from the webrtc connection via webrtc\",\n                        parameters: { type: \"object\", properties: {} }\n                      });\n                      pc.registerCodec = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__2.schemaFunction)(rpc.register_codec, {\n                        name: \"registerCodec\",\n                        description: \"Register a codec for the webrtc connection\",\n                        parameters: {\n                          type: \"object\",\n                          properties: {\n                            codec: {\n                              type: \"object\",\n                              description: \"Codec to register\",\n                              properties: {\n                                name: { type: \"string\" },\n                                type: {},\n                                encoder: { type: \"function\" },\n                                decoder: { type: \"function\" }\n                              }\n                            }\n                          }\n                        }\n                      });\n                      resolve2(pc);\n                    }, 500);\n                  };\n                  channel.onclose = () => reject2(new Error(\"Data channel closed\"));\n                  await pc.setRemoteDescription(\n                    new RTCSessionDescription({\n                      sdp: answer.sdp,\n                      type: answer.type\n                    })\n                  );\n                } catch (e) {\n                  reject2(e);\n                }\n              });\n            }\n            async function registerRTCService(server2, service_id, config2) {\n              config2 = config2 || {\n                visibility: \"protected\",\n                require_context: true\n              };\n              const onInit = config2.on_init;\n              delete config2.on_init;\n              return await server2.registerService({\n                id: service_id,\n                config: config2,\n                offer: (params, context2) => _createOffer(params, server2, config2, onInit, context2)\n              });\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n          /*!*************************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n            \\*************************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              CachedKeyDecoder: () => (\n                /* binding */\n                CachedKeyDecoder\n              )\n              /* harmony export */\n            });\n            var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./utils/utf8.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n            );\n            var DEFAULT_MAX_KEY_LENGTH = 16;\n            var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n            var CachedKeyDecoder = (\n              /** @class */\n              function() {\n                function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                  if (maxKeyLength === void 0) {\n                    maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                  }\n                  if (maxLengthPerKey === void 0) {\n                    maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                  }\n                  this.maxKeyLength = maxKeyLength;\n                  this.maxLengthPerKey = maxLengthPerKey;\n                  this.hit = 0;\n                  this.miss = 0;\n                  this.caches = [];\n                  for (var i = 0; i < this.maxKeyLength; i++) {\n                    this.caches.push([]);\n                  }\n                }\n                CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                  return byteLength > 0 && byteLength <= this.maxKeyLength;\n                };\n                CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                  var records = this.caches[byteLength - 1];\n                  FIND_CHUNK:\n                    for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                      var record = records_1[_i];\n                      var recordBytes = record.bytes;\n                      for (var j = 0; j < byteLength; j++) {\n                        if (recordBytes[j] !== bytes[inputOffset + j]) {\n                          continue FIND_CHUNK;\n                        }\n                      }\n                      return record.str;\n                    }\n                  return null;\n                };\n                CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                  var records = this.caches[bytes.length - 1];\n                  var record = { bytes, str: value };\n                  if (records.length >= this.maxLengthPerKey) {\n                    records[Math.random() * records.length | 0] = record;\n                  } else {\n                    records.push(record);\n                  }\n                };\n                CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                  var cachedValue = this.find(bytes, inputOffset, byteLength);\n                  if (cachedValue != null) {\n                    this.hit++;\n                    return cachedValue;\n                  }\n                  this.miss++;\n                  var str = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n                  var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                  this.store(slicedCopyOfBytes, str);\n                  return str;\n                };\n                return CachedKeyDecoder2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n          /*!********************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n            \\********************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              DecodeError: () => (\n                /* binding */\n                DecodeError\n              )\n              /* harmony export */\n            });\n            var __extends = function() {\n              var extendStatics = function(d, b) {\n                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                  d2.__proto__ = b2;\n                } || function(d2, b2) {\n                  for (var p in b2)\n                    if (Object.prototype.hasOwnProperty.call(b2, p))\n                      d2[p] = b2[p];\n                };\n                return extendStatics(d, b);\n              };\n              return function(d, b) {\n                if (typeof b !== \"function\" && b !== null)\n                  throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                extendStatics(d, b);\n                function __() {\n                  this.constructor = d;\n                }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n              };\n            }();\n            var DecodeError = (\n              /** @class */\n              function(_super) {\n                __extends(DecodeError2, _super);\n                function DecodeError2(message) {\n                  var _this = _super.call(this, message) || this;\n                  var proto = Object.create(DecodeError2.prototype);\n                  Object.setPrototypeOf(_this, proto);\n                  Object.defineProperty(_this, \"name\", {\n                    configurable: true,\n                    enumerable: false,\n                    value: DecodeError2.name\n                  });\n                  return _this;\n                }\n                return DecodeError2;\n              }(Error)\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n          /*!****************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n            \\****************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              DataViewIndexOutOfBoundsError: () => (\n                /* binding */\n                DataViewIndexOutOfBoundsError\n              ),\n              /* harmony export */\n              Decoder: () => (\n                /* binding */\n                Decoder\n              )\n              /* harmony export */\n            });\n            var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n              /*! ./utils/prettyByte.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n            );\n            var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./ExtensionCodec.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n            );\n            var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! ./utils/int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n              /*! ./utils/utf8.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n            );\n            var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! ./utils/typedArrays.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n            );\n            var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./CachedKeyDecoder.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n            );\n            var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n              /*! ./DecodeError.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n            );\n            var __awaiter = function(thisArg, _arguments, P, generator) {\n              function adopt(value) {\n                return value instanceof P ? value : new P(function(resolve2) {\n                  resolve2(value);\n                });\n              }\n              return new (P || (P = Promise))(function(resolve2, reject2) {\n                function fulfilled(value) {\n                  try {\n                    step(generator.next(value));\n                  } catch (e) {\n                    reject2(e);\n                  }\n                }\n                function rejected(value) {\n                  try {\n                    step(generator[\"throw\"](value));\n                  } catch (e) {\n                    reject2(e);\n                  }\n                }\n                function step(result) {\n                  result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n                }\n                step((generator = generator.apply(thisArg, _arguments || [])).next());\n              });\n            };\n            var __generator = function(thisArg, body) {\n              var _ = { label: 0, sent: function() {\n                if (t[0] & 1)\n                  throw t[1];\n                return t[1];\n              }, trys: [], ops: [] }, f, y, t, g;\n              return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n                return this;\n              }), g;\n              function verb(n) {\n                return function(v) {\n                  return step([n, v]);\n                };\n              }\n              function step(op) {\n                if (f)\n                  throw new TypeError(\"Generator is already executing.\");\n                while (_)\n                  try {\n                    if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                      return t;\n                    if (y = 0, t)\n                      op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                      case 0:\n                      case 1:\n                        t = op;\n                        break;\n                      case 4:\n                        _.label++;\n                        return { value: op[1], done: false };\n                      case 5:\n                        _.label++;\n                        y = op[1];\n                        op = [0];\n                        continue;\n                      case 7:\n                        op = _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                      default:\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                          _ = 0;\n                          continue;\n                        }\n                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                          _.label = op[1];\n                          break;\n                        }\n                        if (op[0] === 6 && _.label < t[1]) {\n                          _.label = t[1];\n                          t = op;\n                          break;\n                        }\n                        if (t && _.label < t[2]) {\n                          _.label = t[2];\n                          _.ops.push(op);\n                          break;\n                        }\n                        if (t[2])\n                          _.ops.pop();\n                        _.trys.pop();\n                        continue;\n                    }\n                    op = body.call(thisArg, _);\n                  } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                  } finally {\n                    f = t = 0;\n                  }\n                if (op[0] & 5)\n                  throw op[1];\n                return { value: op[0] ? op[1] : void 0, done: true };\n              }\n            };\n            var __asyncValues = function(o) {\n              if (!Symbol.asyncIterator)\n                throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n              var m = o[Symbol.asyncIterator], i;\n              return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n                return this;\n              }, i);\n              function verb(n) {\n                i[n] = o[n] && function(v) {\n                  return new Promise(function(resolve2, reject2) {\n                    v = o[n](v), settle(resolve2, reject2, v.done, v.value);\n                  });\n                };\n              }\n              function settle(resolve2, reject2, d, v) {\n                Promise.resolve(v).then(function(v2) {\n                  resolve2({ value: v2, done: d });\n                }, reject2);\n              }\n            };\n            var __await = function(v) {\n              return this instanceof __await ? (this.v = v, this) : new __await(v);\n            };\n            var __asyncGenerator = function(thisArg, _arguments, generator) {\n              if (!Symbol.asyncIterator)\n                throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n              var g = generator.apply(thisArg, _arguments || []), i, q = [];\n              return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n                return this;\n              }, i;\n              function verb(n) {\n                if (g[n])\n                  i[n] = function(v) {\n                    return new Promise(function(a, b) {\n                      q.push([n, v, a, b]) > 1 || resume(n, v);\n                    });\n                  };\n              }\n              function resume(n, v) {\n                try {\n                  step(g[n](v));\n                } catch (e) {\n                  settle(q[0][3], e);\n                }\n              }\n              function step(r) {\n                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);\n              }\n              function fulfill(value) {\n                resume(\"next\", value);\n              }\n              function reject2(value) {\n                resume(\"throw\", value);\n              }\n              function settle(f, v) {\n                if (f(v), q.shift(), q.length)\n                  resume(q[0][0], q[0][1]);\n              }\n            };\n            var isValidMapKeyType = function(key) {\n              var keyType = typeof key;\n              return keyType === \"string\" || keyType === \"number\";\n            };\n            var HEAD_BYTE_REQUIRED = -1;\n            var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n            var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n            var DataViewIndexOutOfBoundsError = function() {\n              try {\n                EMPTY_VIEW.getInt8(0);\n              } catch (e) {\n                return e.constructor;\n              }\n              throw new Error(\"never reached\");\n            }();\n            var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n            var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\n            var Decoder = (\n              /** @class */\n              function() {\n                function Decoder2(extensionCodec, context2, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                  if (extensionCodec === void 0) {\n                    extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n                  }\n                  if (context2 === void 0) {\n                    context2 = void 0;\n                  }\n                  if (maxStrLength === void 0) {\n                    maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxBinLength === void 0) {\n                    maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxArrayLength === void 0) {\n                    maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxMapLength === void 0) {\n                    maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (maxExtLength === void 0) {\n                    maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n                  }\n                  if (keyDecoder === void 0) {\n                    keyDecoder = sharedCachedKeyDecoder;\n                  }\n                  this.extensionCodec = extensionCodec;\n                  this.context = context2;\n                  this.maxStrLength = maxStrLength;\n                  this.maxBinLength = maxBinLength;\n                  this.maxArrayLength = maxArrayLength;\n                  this.maxMapLength = maxMapLength;\n                  this.maxExtLength = maxExtLength;\n                  this.keyDecoder = keyDecoder;\n                  this.totalPos = 0;\n                  this.pos = 0;\n                  this.view = EMPTY_VIEW;\n                  this.bytes = EMPTY_BYTES;\n                  this.headByte = HEAD_BYTE_REQUIRED;\n                  this.stack = [];\n                }\n                Decoder2.prototype.reinitializeState = function() {\n                  this.totalPos = 0;\n                  this.headByte = HEAD_BYTE_REQUIRED;\n                  this.stack.length = 0;\n                };\n                Decoder2.prototype.setBuffer = function(buffer) {\n                  this.bytes = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n                  this.view = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n                  this.pos = 0;\n                };\n                Decoder2.prototype.appendBuffer = function(buffer) {\n                  if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                    this.setBuffer(buffer);\n                  } else {\n                    var remainingData = this.bytes.subarray(this.pos);\n                    var newData = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n                    var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                    newBuffer.set(remainingData);\n                    newBuffer.set(newData, remainingData.length);\n                    this.setBuffer(newBuffer);\n                  }\n                };\n                Decoder2.prototype.hasRemaining = function(size) {\n                  return this.view.byteLength - this.pos >= size;\n                };\n                Decoder2.prototype.createExtraByteError = function(posToShow) {\n                  var _a = this, view = _a.view, pos = _a.pos;\n                  return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n                };\n                Decoder2.prototype.decode = function(buffer) {\n                  this.reinitializeState();\n                  this.setBuffer(buffer);\n                  var object = this.doDecodeSync();\n                  if (this.hasRemaining(1)) {\n                    throw this.createExtraByteError(this.pos);\n                  }\n                  return object;\n                };\n                Decoder2.prototype.decodeMulti = function(buffer) {\n                  return __generator(this, function(_a) {\n                    switch (_a.label) {\n                      case 0:\n                        this.reinitializeState();\n                        this.setBuffer(buffer);\n                        _a.label = 1;\n                      case 1:\n                        if (!this.hasRemaining(1))\n                          return [3, 3];\n                        return [4, this.doDecodeSync()];\n                      case 2:\n                        _a.sent();\n                        return [3, 1];\n                      case 3:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                };\n                Decoder2.prototype.decodeAsync = function(stream) {\n                  var stream_1, stream_1_1;\n                  var e_1, _a;\n                  return __awaiter(this, void 0, void 0, function() {\n                    var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                    return __generator(this, function(_c) {\n                      switch (_c.label) {\n                        case 0:\n                          decoded = false;\n                          _c.label = 1;\n                        case 1:\n                          _c.trys.push([1, 6, 7, 12]);\n                          stream_1 = __asyncValues(stream);\n                          _c.label = 2;\n                        case 2:\n                          return [4, stream_1.next()];\n                        case 3:\n                          if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                            return [3, 5];\n                          buffer = stream_1_1.value;\n                          if (decoded) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          this.appendBuffer(buffer);\n                          try {\n                            object = this.doDecodeSync();\n                            decoded = true;\n                          } catch (e) {\n                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                              throw e;\n                            }\n                          }\n                          this.totalPos += this.pos;\n                          _c.label = 4;\n                        case 4:\n                          return [3, 2];\n                        case 5:\n                          return [3, 12];\n                        case 6:\n                          e_1_1 = _c.sent();\n                          e_1 = { error: e_1_1 };\n                          return [3, 12];\n                        case 7:\n                          _c.trys.push([7, , 10, 11]);\n                          if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                            return [3, 9];\n                          return [4, _a.call(stream_1)];\n                        case 8:\n                          _c.sent();\n                          _c.label = 9;\n                        case 9:\n                          return [3, 11];\n                        case 10:\n                          if (e_1)\n                            throw e_1.error;\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 11:\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 12:\n                          if (decoded) {\n                            if (this.hasRemaining(1)) {\n                              throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2, object];\n                          }\n                          _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                          throw new RangeError(\"Insufficient data in parsing \".concat((0, _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                      }\n                    });\n                  });\n                };\n                Decoder2.prototype.decodeArrayStream = function(stream) {\n                  return this.decodeMultiAsync(stream, true);\n                };\n                Decoder2.prototype.decodeStream = function(stream) {\n                  return this.decodeMultiAsync(stream, false);\n                };\n                Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                  return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                    var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                    var e_3, _a;\n                    return __generator(this, function(_b) {\n                      switch (_b.label) {\n                        case 0:\n                          isArrayHeaderRequired = isArray;\n                          arrayItemsLeft = -1;\n                          _b.label = 1;\n                        case 1:\n                          _b.trys.push([1, 13, 14, 19]);\n                          stream_2 = __asyncValues(stream);\n                          _b.label = 2;\n                        case 2:\n                          return [4, __await(stream_2.next())];\n                        case 3:\n                          if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                            return [3, 12];\n                          buffer = stream_2_1.value;\n                          if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          this.appendBuffer(buffer);\n                          if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                          }\n                          _b.label = 4;\n                        case 4:\n                          _b.trys.push([4, 9, , 10]);\n                          _b.label = 5;\n                        case 5:\n                          if (false) {}\n                          return [4, __await(this.doDecodeSync())];\n                        case 6:\n                          return [4, _b.sent()];\n                        case 7:\n                          _b.sent();\n                          if (--arrayItemsLeft === 0) {\n                            return [3, 8];\n                          }\n                          return [3, 5];\n                        case 8:\n                          return [3, 10];\n                        case 9:\n                          e_2 = _b.sent();\n                          if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2;\n                          }\n                          return [3, 10];\n                        case 10:\n                          this.totalPos += this.pos;\n                          _b.label = 11;\n                        case 11:\n                          return [3, 2];\n                        case 12:\n                          return [3, 19];\n                        case 13:\n                          e_3_1 = _b.sent();\n                          e_3 = { error: e_3_1 };\n                          return [3, 19];\n                        case 14:\n                          _b.trys.push([14, , 17, 18]);\n                          if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                            return [3, 16];\n                          return [4, __await(_a.call(stream_2))];\n                        case 15:\n                          _b.sent();\n                          _b.label = 16;\n                        case 16:\n                          return [3, 18];\n                        case 17:\n                          if (e_3)\n                            throw e_3.error;\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 18:\n                          return [\n                            7\n                            /*endfinally*/\n                          ];\n                        case 19:\n                          return [\n                            2\n                            /*return*/\n                          ];\n                      }\n                    });\n                  });\n                };\n                Decoder2.prototype.doDecodeSync = function() {\n                  DECODE:\n                    while (true) {\n                      var headByte = this.readHeadByte();\n                      var object = void 0;\n                      if (headByte >= 224) {\n                        object = headByte - 256;\n                      } else if (headByte < 192) {\n                        if (headByte < 128) {\n                          object = headByte;\n                        } else if (headByte < 144) {\n                          var size = headByte - 128;\n                          if (size !== 0) {\n                            this.pushMapState(size);\n                            this.complete();\n                            continue DECODE;\n                          } else {\n                            object = {};\n                          }\n                        } else if (headByte < 160) {\n                          var size = headByte - 144;\n                          if (size !== 0) {\n                            this.pushArrayState(size);\n                            this.complete();\n                            continue DECODE;\n                          } else {\n                            object = [];\n                          }\n                        } else {\n                          var byteLength = headByte - 160;\n                          object = this.decodeUtf8String(byteLength, 0);\n                        }\n                      } else if (headByte === 192) {\n                        object = null;\n                      } else if (headByte === 194) {\n                        object = false;\n                      } else if (headByte === 195) {\n                        object = true;\n                      } else if (headByte === 202) {\n                        object = this.readF32();\n                      } else if (headByte === 203) {\n                        object = this.readF64();\n                      } else if (headByte === 204) {\n                        object = this.readU8();\n                      } else if (headByte === 205) {\n                        object = this.readU16();\n                      } else if (headByte === 206) {\n                        object = this.readU32();\n                      } else if (headByte === 207) {\n                        object = this.readU64();\n                      } else if (headByte === 208) {\n                        object = this.readI8();\n                      } else if (headByte === 209) {\n                        object = this.readI16();\n                      } else if (headByte === 210) {\n                        object = this.readI32();\n                      } else if (headByte === 211) {\n                        object = this.readI64();\n                      } else if (headByte === 217) {\n                        var byteLength = this.lookU8();\n                        object = this.decodeUtf8String(byteLength, 1);\n                      } else if (headByte === 218) {\n                        var byteLength = this.lookU16();\n                        object = this.decodeUtf8String(byteLength, 2);\n                      } else if (headByte === 219) {\n                        var byteLength = this.lookU32();\n                        object = this.decodeUtf8String(byteLength, 4);\n                      } else if (headByte === 220) {\n                        var size = this.readU16();\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else if (headByte === 221) {\n                        var size = this.readU32();\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else if (headByte === 222) {\n                        var size = this.readU16();\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte === 223) {\n                        var size = this.readU32();\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte === 196) {\n                        var size = this.lookU8();\n                        object = this.decodeBinary(size, 1);\n                      } else if (headByte === 197) {\n                        var size = this.lookU16();\n                        object = this.decodeBinary(size, 2);\n                      } else if (headByte === 198) {\n                        var size = this.lookU32();\n                        object = this.decodeBinary(size, 4);\n                      } else if (headByte === 212) {\n                        object = this.decodeExtension(1, 0);\n                      } else if (headByte === 213) {\n                        object = this.decodeExtension(2, 0);\n                      } else if (headByte === 214) {\n                        object = this.decodeExtension(4, 0);\n                      } else if (headByte === 215) {\n                        object = this.decodeExtension(8, 0);\n                      } else if (headByte === 216) {\n                        object = this.decodeExtension(16, 0);\n                      } else if (headByte === 199) {\n                        var size = this.lookU8();\n                        object = this.decodeExtension(size, 1);\n                      } else if (headByte === 200) {\n                        var size = this.lookU16();\n                        object = this.decodeExtension(size, 2);\n                      } else if (headByte === 201) {\n                        var size = this.lookU32();\n                        object = this.decodeExtension(size, 4);\n                      } else {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0, _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                      }\n                      this.complete();\n                      var stack = this.stack;\n                      while (stack.length > 0) {\n                        var state = stack[stack.length - 1];\n                        if (state.type === 0) {\n                          state.array[state.position] = object;\n                          state.position++;\n                          if (state.position === state.size) {\n                            stack.pop();\n                            object = state.array;\n                          } else {\n                            continue DECODE;\n                          }\n                        } else if (state.type === 1) {\n                          if (!isValidMapKeyType(object)) {\n                            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                          }\n                          if (object === \"__proto__\") {\n                            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                          }\n                          state.key = object;\n                          state.type = 2;\n                          continue DECODE;\n                        } else {\n                          state.map[state.key] = object;\n                          state.readCount++;\n                          if (state.readCount === state.size) {\n                            stack.pop();\n                            object = state.map;\n                          } else {\n                            state.key = null;\n                            state.type = 1;\n                            continue DECODE;\n                          }\n                        }\n                      }\n                      return object;\n                    }\n                };\n                Decoder2.prototype.readHeadByte = function() {\n                  if (this.headByte === HEAD_BYTE_REQUIRED) {\n                    this.headByte = this.readU8();\n                  }\n                  return this.headByte;\n                };\n                Decoder2.prototype.complete = function() {\n                  this.headByte = HEAD_BYTE_REQUIRED;\n                };\n                Decoder2.prototype.readArraySize = function() {\n                  var headByte = this.readHeadByte();\n                  switch (headByte) {\n                    case 220:\n                      return this.readU16();\n                    case 221:\n                      return this.readU32();\n                    default: {\n                      if (headByte < 160) {\n                        return headByte - 144;\n                      } else {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0, _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                      }\n                    }\n                  }\n                };\n                Decoder2.prototype.pushMapState = function(size) {\n                  if (size > this.maxMapLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n                  }\n                  this.stack.push({\n                    type: 1,\n                    size,\n                    key: null,\n                    readCount: 0,\n                    map: {}\n                  });\n                };\n                Decoder2.prototype.pushArrayState = function(size) {\n                  if (size > this.maxArrayLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n                  }\n                  this.stack.push({\n                    type: 0,\n                    size,\n                    array: new Array(size),\n                    position: 0\n                  });\n                };\n                Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                  var _a;\n                  if (byteLength > this.maxStrLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n                  }\n                  if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                    throw MORE_DATA;\n                  }\n                  var offset = this.pos + headerOffset;\n                  var object;\n                  if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                    object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                  } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.TEXT_DECODER_THRESHOLD) {\n                    object = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeTD)(this.bytes, offset, byteLength);\n                  } else {\n                    object = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8DecodeJs)(this.bytes, offset, byteLength);\n                  }\n                  this.pos += headerOffset + byteLength;\n                  return object;\n                };\n                Decoder2.prototype.stateIsMapKey = function() {\n                  if (this.stack.length > 0) {\n                    var state = this.stack[this.stack.length - 1];\n                    return state.type === 1;\n                  }\n                  return false;\n                };\n                Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                  if (byteLength > this.maxBinLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n                  }\n                  if (!this.hasRemaining(byteLength + headOffset)) {\n                    throw MORE_DATA;\n                  }\n                  var offset = this.pos + headOffset;\n                  var object = this.bytes.subarray(offset, offset + byteLength);\n                  this.pos += headOffset + byteLength;\n                  return object;\n                };\n                Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                  if (size > this.maxExtLength) {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n                  }\n                  var extType = this.view.getInt8(this.pos + headOffset);\n                  var data = this.decodeBinary(\n                    size,\n                    headOffset + 1\n                    /* extType */\n                  );\n                  return this.extensionCodec.decode(data, extType, this.context);\n                };\n                Decoder2.prototype.lookU8 = function() {\n                  return this.view.getUint8(this.pos);\n                };\n                Decoder2.prototype.lookU16 = function() {\n                  return this.view.getUint16(this.pos);\n                };\n                Decoder2.prototype.lookU32 = function() {\n                  return this.view.getUint32(this.pos);\n                };\n                Decoder2.prototype.readU8 = function() {\n                  var value = this.view.getUint8(this.pos);\n                  this.pos++;\n                  return value;\n                };\n                Decoder2.prototype.readI8 = function() {\n                  var value = this.view.getInt8(this.pos);\n                  this.pos++;\n                  return value;\n                };\n                Decoder2.prototype.readU16 = function() {\n                  var value = this.view.getUint16(this.pos);\n                  this.pos += 2;\n                  return value;\n                };\n                Decoder2.prototype.readI16 = function() {\n                  var value = this.view.getInt16(this.pos);\n                  this.pos += 2;\n                  return value;\n                };\n                Decoder2.prototype.readU32 = function() {\n                  var value = this.view.getUint32(this.pos);\n                  this.pos += 4;\n                  return value;\n                };\n                Decoder2.prototype.readI32 = function() {\n                  var value = this.view.getInt32(this.pos);\n                  this.pos += 4;\n                  return value;\n                };\n                Decoder2.prototype.readU64 = function() {\n                  var value = (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n                  this.pos += 8;\n                  return value;\n                };\n                Decoder2.prototype.readI64 = function() {\n                  var value = (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n                  this.pos += 8;\n                  return value;\n                };\n                Decoder2.prototype.readF32 = function() {\n                  var value = this.view.getFloat32(this.pos);\n                  this.pos += 4;\n                  return value;\n                };\n                Decoder2.prototype.readF64 = function() {\n                  var value = this.view.getFloat64(this.pos);\n                  this.pos += 8;\n                  return value;\n                };\n                return Decoder2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n          /*!****************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n            \\****************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              DEFAULT_INITIAL_BUFFER_SIZE: () => (\n                /* binding */\n                DEFAULT_INITIAL_BUFFER_SIZE\n              ),\n              /* harmony export */\n              DEFAULT_MAX_DEPTH: () => (\n                /* binding */\n                DEFAULT_MAX_DEPTH\n              ),\n              /* harmony export */\n              Encoder: () => (\n                /* binding */\n                Encoder\n              )\n              /* harmony export */\n            });\n            var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./utils/utf8.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n            );\n            var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./ExtensionCodec.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n            );\n            var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! ./utils/int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! ./utils/typedArrays.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n            );\n            var DEFAULT_MAX_DEPTH = 100;\n            var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n            var Encoder = (\n              /** @class */\n              function() {\n                function Encoder2(extensionCodec, context2, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                  if (extensionCodec === void 0) {\n                    extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;\n                  }\n                  if (context2 === void 0) {\n                    context2 = void 0;\n                  }\n                  if (maxDepth === void 0) {\n                    maxDepth = DEFAULT_MAX_DEPTH;\n                  }\n                  if (initialBufferSize === void 0) {\n                    initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                  }\n                  if (sortKeys === void 0) {\n                    sortKeys = false;\n                  }\n                  if (forceFloat32 === void 0) {\n                    forceFloat32 = false;\n                  }\n                  if (ignoreUndefined === void 0) {\n                    ignoreUndefined = false;\n                  }\n                  if (forceIntegerToFloat === void 0) {\n                    forceIntegerToFloat = false;\n                  }\n                  this.extensionCodec = extensionCodec;\n                  this.context = context2;\n                  this.maxDepth = maxDepth;\n                  this.initialBufferSize = initialBufferSize;\n                  this.sortKeys = sortKeys;\n                  this.forceFloat32 = forceFloat32;\n                  this.ignoreUndefined = ignoreUndefined;\n                  this.forceIntegerToFloat = forceIntegerToFloat;\n                  this.pos = 0;\n                  this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                  this.bytes = new Uint8Array(this.view.buffer);\n                }\n                Encoder2.prototype.reinitializeState = function() {\n                  this.pos = 0;\n                };\n                Encoder2.prototype.encodeSharedRef = function(object) {\n                  this.reinitializeState();\n                  this.doEncode(object, 1);\n                  return this.bytes.subarray(0, this.pos);\n                };\n                Encoder2.prototype.encode = function(object) {\n                  this.reinitializeState();\n                  this.doEncode(object, 1);\n                  return this.bytes.slice(0, this.pos);\n                };\n                Encoder2.prototype.doEncode = function(object, depth) {\n                  if (depth > this.maxDepth) {\n                    throw new Error(\"Too deep objects in depth \".concat(depth));\n                  }\n                  if (object == null) {\n                    this.encodeNil();\n                  } else if (typeof object === \"boolean\") {\n                    this.encodeBoolean(object);\n                  } else if (typeof object === \"number\") {\n                    this.encodeNumber(object);\n                  } else if (typeof object === \"string\") {\n                    this.encodeString(object);\n                  } else {\n                    this.encodeObject(object, depth);\n                  }\n                };\n                Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                  var requiredSize = this.pos + sizeToWrite;\n                  if (this.view.byteLength < requiredSize) {\n                    this.resizeBuffer(requiredSize * 2);\n                  }\n                };\n                Encoder2.prototype.resizeBuffer = function(newSize) {\n                  var newBuffer = new ArrayBuffer(newSize);\n                  var newBytes = new Uint8Array(newBuffer);\n                  var newView = new DataView(newBuffer);\n                  newBytes.set(this.bytes);\n                  this.view = newView;\n                  this.bytes = newBytes;\n                };\n                Encoder2.prototype.encodeNil = function() {\n                  this.writeU8(192);\n                };\n                Encoder2.prototype.encodeBoolean = function(object) {\n                  if (object === false) {\n                    this.writeU8(194);\n                  } else {\n                    this.writeU8(195);\n                  }\n                };\n                Encoder2.prototype.encodeNumber = function(object) {\n                  if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                    if (object >= 0) {\n                      if (object < 128) {\n                        this.writeU8(object);\n                      } else if (object < 256) {\n                        this.writeU8(204);\n                        this.writeU8(object);\n                      } else if (object < 65536) {\n                        this.writeU8(205);\n                        this.writeU16(object);\n                      } else if (object < 4294967296) {\n                        this.writeU8(206);\n                        this.writeU32(object);\n                      } else {\n                        this.writeU8(207);\n                        this.writeU64(object);\n                      }\n                    } else {\n                      if (object >= -32) {\n                        this.writeU8(224 | object + 32);\n                      } else if (object >= -128) {\n                        this.writeU8(208);\n                        this.writeI8(object);\n                      } else if (object >= -32768) {\n                        this.writeU8(209);\n                        this.writeI16(object);\n                      } else if (object >= -2147483648) {\n                        this.writeU8(210);\n                        this.writeI32(object);\n                      } else {\n                        this.writeU8(211);\n                        this.writeI64(object);\n                      }\n                    }\n                  } else {\n                    if (this.forceFloat32) {\n                      this.writeU8(202);\n                      this.writeF32(object);\n                    } else {\n                      this.writeU8(203);\n                      this.writeF64(object);\n                    }\n                  }\n                };\n                Encoder2.prototype.writeStringHeader = function(byteLength) {\n                  if (byteLength < 32) {\n                    this.writeU8(160 + byteLength);\n                  } else if (byteLength < 256) {\n                    this.writeU8(217);\n                    this.writeU8(byteLength);\n                  } else if (byteLength < 65536) {\n                    this.writeU8(218);\n                    this.writeU16(byteLength);\n                  } else if (byteLength < 4294967296) {\n                    this.writeU8(219);\n                    this.writeU32(byteLength);\n                  } else {\n                    throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n                  }\n                };\n                Encoder2.prototype.encodeString = function(object) {\n                  var maxHeaderSize = 1 + 4;\n                  var strLength = object.length;\n                  if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER_THRESHOLD) {\n                    var byteLength = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n                    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                    this.writeStringHeader(byteLength);\n                    (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeTE)(object, this.bytes, this.pos);\n                    this.pos += byteLength;\n                  } else {\n                    var byteLength = (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n                    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                    this.writeStringHeader(byteLength);\n                    (0, _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8EncodeJs)(object, this.bytes, this.pos);\n                    this.pos += byteLength;\n                  }\n                };\n                Encoder2.prototype.encodeObject = function(object, depth) {\n                  var ext = this.extensionCodec.tryToEncode(object, this.context);\n                  if (ext != null) {\n                    this.encodeExtension(ext);\n                  } else if (Array.isArray(object)) {\n                    this.encodeArray(object, depth);\n                  } else if (ArrayBuffer.isView(object)) {\n                    this.encodeBinary(object);\n                  } else if (typeof object === \"object\") {\n                    this.encodeMap(object, depth);\n                  } else {\n                    throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n                  }\n                };\n                Encoder2.prototype.encodeBinary = function(object) {\n                  var size = object.byteLength;\n                  if (size < 256) {\n                    this.writeU8(196);\n                    this.writeU8(size);\n                  } else if (size < 65536) {\n                    this.writeU8(197);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(198);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large binary: \".concat(size));\n                  }\n                  var bytes = (0, _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n                  this.writeU8a(bytes);\n                };\n                Encoder2.prototype.encodeArray = function(object, depth) {\n                  var size = object.length;\n                  if (size < 16) {\n                    this.writeU8(144 + size);\n                  } else if (size < 65536) {\n                    this.writeU8(220);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(221);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large array: \".concat(size));\n                  }\n                  for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                    var item = object_1[_i];\n                    this.doEncode(item, depth + 1);\n                  }\n                };\n                Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                  var count = 0;\n                  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                    var key = keys_1[_i];\n                    if (object[key] !== void 0) {\n                      count++;\n                    }\n                  }\n                  return count;\n                };\n                Encoder2.prototype.encodeMap = function(object, depth) {\n                  var keys = Object.keys(object);\n                  if (this.sortKeys) {\n                    keys.sort();\n                  }\n                  var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                  if (size < 16) {\n                    this.writeU8(128 + size);\n                  } else if (size < 65536) {\n                    this.writeU8(222);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(223);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large map object: \".concat(size));\n                  }\n                  for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                    var key = keys_2[_i];\n                    var value = object[key];\n                    if (!(this.ignoreUndefined && value === void 0)) {\n                      this.encodeString(key);\n                      this.doEncode(value, depth + 1);\n                    }\n                  }\n                };\n                Encoder2.prototype.encodeExtension = function(ext) {\n                  var size = ext.data.length;\n                  if (size === 1) {\n                    this.writeU8(212);\n                  } else if (size === 2) {\n                    this.writeU8(213);\n                  } else if (size === 4) {\n                    this.writeU8(214);\n                  } else if (size === 8) {\n                    this.writeU8(215);\n                  } else if (size === 16) {\n                    this.writeU8(216);\n                  } else if (size < 256) {\n                    this.writeU8(199);\n                    this.writeU8(size);\n                  } else if (size < 65536) {\n                    this.writeU8(200);\n                    this.writeU16(size);\n                  } else if (size < 4294967296) {\n                    this.writeU8(201);\n                    this.writeU32(size);\n                  } else {\n                    throw new Error(\"Too large extension object: \".concat(size));\n                  }\n                  this.writeI8(ext.type);\n                  this.writeU8a(ext.data);\n                };\n                Encoder2.prototype.writeU8 = function(value) {\n                  this.ensureBufferSizeToWrite(1);\n                  this.view.setUint8(this.pos, value);\n                  this.pos++;\n                };\n                Encoder2.prototype.writeU8a = function(values) {\n                  var size = values.length;\n                  this.ensureBufferSizeToWrite(size);\n                  this.bytes.set(values, this.pos);\n                  this.pos += size;\n                };\n                Encoder2.prototype.writeI8 = function(value) {\n                  this.ensureBufferSizeToWrite(1);\n                  this.view.setInt8(this.pos, value);\n                  this.pos++;\n                };\n                Encoder2.prototype.writeU16 = function(value) {\n                  this.ensureBufferSizeToWrite(2);\n                  this.view.setUint16(this.pos, value);\n                  this.pos += 2;\n                };\n                Encoder2.prototype.writeI16 = function(value) {\n                  this.ensureBufferSizeToWrite(2);\n                  this.view.setInt16(this.pos, value);\n                  this.pos += 2;\n                };\n                Encoder2.prototype.writeU32 = function(value) {\n                  this.ensureBufferSizeToWrite(4);\n                  this.view.setUint32(this.pos, value);\n                  this.pos += 4;\n                };\n                Encoder2.prototype.writeI32 = function(value) {\n                  this.ensureBufferSizeToWrite(4);\n                  this.view.setInt32(this.pos, value);\n                  this.pos += 4;\n                };\n                Encoder2.prototype.writeF32 = function(value) {\n                  this.ensureBufferSizeToWrite(4);\n                  this.view.setFloat32(this.pos, value);\n                  this.pos += 4;\n                };\n                Encoder2.prototype.writeF64 = function(value) {\n                  this.ensureBufferSizeToWrite(8);\n                  this.view.setFloat64(this.pos, value);\n                  this.pos += 8;\n                };\n                Encoder2.prototype.writeU64 = function(value) {\n                  this.ensureBufferSizeToWrite(8);\n                  (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n                  this.pos += 8;\n                };\n                Encoder2.prototype.writeI64 = function(value) {\n                  this.ensureBufferSizeToWrite(8);\n                  (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n                  this.pos += 8;\n                };\n                return Encoder2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n          /*!****************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n            \\****************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              ExtData: () => (\n                /* binding */\n                ExtData\n              )\n              /* harmony export */\n            });\n            var ExtData = (\n              /** @class */\n              function() {\n                function ExtData2(type2, data) {\n                  this.type = type2;\n                  this.data = data;\n                }\n                return ExtData2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n          /*!***********************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n            \\***********************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              ExtensionCodec: () => (\n                /* binding */\n                ExtensionCodec\n              )\n              /* harmony export */\n            });\n            var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./ExtData.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n            );\n            var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./timestamp.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n            );\n            var ExtensionCodec = (\n              /** @class */\n              function() {\n                function ExtensionCodec2() {\n                  this.builtInEncoders = [];\n                  this.builtInDecoders = [];\n                  this.encoders = [];\n                  this.decoders = [];\n                  this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n                }\n                ExtensionCodec2.prototype.register = function(_a) {\n                  var type2 = _a.type, encode = _a.encode, decode = _a.decode;\n                  if (type2 >= 0) {\n                    this.encoders[type2] = encode;\n                    this.decoders[type2] = decode;\n                  } else {\n                    var index = 1 + type2;\n                    this.builtInEncoders[index] = encode;\n                    this.builtInDecoders[index] = decode;\n                  }\n                };\n                ExtensionCodec2.prototype.tryToEncode = function(object, context2) {\n                  for (var i = 0; i < this.builtInEncoders.length; i++) {\n                    var encodeExt = this.builtInEncoders[i];\n                    if (encodeExt != null) {\n                      var data = encodeExt(object, context2);\n                      if (data != null) {\n                        var type2 = -1 - i;\n                        return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type2, data);\n                      }\n                    }\n                  }\n                  for (var i = 0; i < this.encoders.length; i++) {\n                    var encodeExt = this.encoders[i];\n                    if (encodeExt != null) {\n                      var data = encodeExt(object, context2);\n                      if (data != null) {\n                        var type2 = i;\n                        return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type2, data);\n                      }\n                    }\n                  }\n                  if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n                    return object;\n                  }\n                  return null;\n                };\n                ExtensionCodec2.prototype.decode = function(data, type2, context2) {\n                  var decodeExt = type2 < 0 ? this.builtInDecoders[-1 - type2] : this.decoders[type2];\n                  if (decodeExt) {\n                    return decodeExt(data, type2, context2);\n                  } else {\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type2, data);\n                  }\n                };\n                ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n                return ExtensionCodec2;\n              }()\n            );\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n          /*!***************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n            \\***************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              decode: () => (\n                /* binding */\n                decode\n              ),\n              /* harmony export */\n              decodeMulti: () => (\n                /* binding */\n                decodeMulti\n              ),\n              /* harmony export */\n              defaultDecodeOptions: () => (\n                /* binding */\n                defaultDecodeOptions\n              )\n              /* harmony export */\n            });\n            var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./Decoder.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n            );\n            var defaultDecodeOptions = {};\n            function decode(buffer, options) {\n              if (options === void 0) {\n                options = defaultDecodeOptions;\n              }\n              var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n              return decoder.decode(buffer);\n            }\n            function decodeMulti(buffer, options) {\n              if (options === void 0) {\n                options = defaultDecodeOptions;\n              }\n              var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Decoder(options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n              return decoder.decodeMulti(buffer);\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n          /*!***************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n            \\***************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              encode: () => (\n                /* binding */\n                encode\n              )\n              /* harmony export */\n            });\n            var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./Encoder.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n            );\n            var defaultEncodeOptions = {};\n            function encode(value, options) {\n              if (options === void 0) {\n                options = defaultEncodeOptions;\n              }\n              var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n              return encoder.encodeSharedRef(value);\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n          /*!******************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n            \\******************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              EXT_TIMESTAMP: () => (\n                /* binding */\n                EXT_TIMESTAMP\n              ),\n              /* harmony export */\n              decodeTimestampExtension: () => (\n                /* binding */\n                decodeTimestampExtension\n              ),\n              /* harmony export */\n              decodeTimestampToTimeSpec: () => (\n                /* binding */\n                decodeTimestampToTimeSpec\n              ),\n              /* harmony export */\n              encodeDateToTimeSpec: () => (\n                /* binding */\n                encodeDateToTimeSpec\n              ),\n              /* harmony export */\n              encodeTimeSpecToTimestamp: () => (\n                /* binding */\n                encodeTimeSpecToTimestamp\n              ),\n              /* harmony export */\n              encodeTimestampExtension: () => (\n                /* binding */\n                encodeTimestampExtension\n              ),\n              /* harmony export */\n              timestampExtension: () => (\n                /* binding */\n                timestampExtension\n              )\n              /* harmony export */\n            });\n            var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ./DecodeError.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n            );\n            var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./utils/int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var EXT_TIMESTAMP = -1;\n            var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n            var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n            function encodeTimeSpecToTimestamp(_a) {\n              var sec = _a.sec, nsec = _a.nsec;\n              if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n                if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                  var rv = new Uint8Array(4);\n                  var view = new DataView(rv.buffer);\n                  view.setUint32(0, sec);\n                  return rv;\n                } else {\n                  var secHigh = sec / 4294967296;\n                  var secLow = sec & 4294967295;\n                  var rv = new Uint8Array(8);\n                  var view = new DataView(rv.buffer);\n                  view.setUint32(0, nsec << 2 | secHigh & 3);\n                  view.setUint32(4, secLow);\n                  return rv;\n                }\n              } else {\n                var rv = new Uint8Array(12);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec);\n                (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n                return rv;\n              }\n            }\n            function encodeDateToTimeSpec(date) {\n              var msec = date.getTime();\n              var sec = Math.floor(msec / 1e3);\n              var nsec = (msec - sec * 1e3) * 1e6;\n              var nsecInSec = Math.floor(nsec / 1e9);\n              return {\n                sec: sec + nsecInSec,\n                nsec: nsec - nsecInSec * 1e9\n              };\n            }\n            function encodeTimestampExtension(object) {\n              if (object instanceof Date) {\n                var timeSpec = encodeDateToTimeSpec(object);\n                return encodeTimeSpecToTimestamp(timeSpec);\n              } else {\n                return null;\n              }\n            }\n            function decodeTimestampToTimeSpec(data) {\n              var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n              switch (data.byteLength) {\n                case 4: {\n                  var sec = view.getUint32(0);\n                  var nsec = 0;\n                  return { sec, nsec };\n                }\n                case 8: {\n                  var nsec30AndSecHigh2 = view.getUint32(0);\n                  var secLow32 = view.getUint32(4);\n                  var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                  var nsec = nsec30AndSecHigh2 >>> 2;\n                  return { sec, nsec };\n                }\n                case 12: {\n                  var sec = (0, _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n                  var nsec = view.getUint32(0);\n                  return { sec, nsec };\n                }\n                default:\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n              }\n            }\n            function decodeTimestampExtension(data) {\n              var timeSpec = decodeTimestampToTimeSpec(data);\n              return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n            }\n            var timestampExtension = {\n              type: EXT_TIMESTAMP,\n              encode: encodeTimestampExtension,\n              decode: decodeTimestampExtension\n            };\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n          /*!******************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n            \\******************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              UINT32_MAX: () => (\n                /* binding */\n                UINT32_MAX\n              ),\n              /* harmony export */\n              getInt64: () => (\n                /* binding */\n                getInt64\n              ),\n              /* harmony export */\n              getUint64: () => (\n                /* binding */\n                getUint64\n              ),\n              /* harmony export */\n              setInt64: () => (\n                /* binding */\n                setInt64\n              ),\n              /* harmony export */\n              setUint64: () => (\n                /* binding */\n                setUint64\n              )\n              /* harmony export */\n            });\n            var UINT32_MAX = 4294967295;\n            function setUint64(view, offset, value) {\n              var high = value / 4294967296;\n              var low = value;\n              view.setUint32(offset, high);\n              view.setUint32(offset + 4, low);\n            }\n            function setInt64(view, offset, value) {\n              var high = Math.floor(value / 4294967296);\n              var low = value;\n              view.setUint32(offset, high);\n              view.setUint32(offset + 4, low);\n            }\n            function getInt64(view, offset) {\n              var high = view.getInt32(offset);\n              var low = view.getUint32(offset + 4);\n              return high * 4294967296 + low;\n            }\n            function getUint64(view, offset) {\n              var high = view.getUint32(offset);\n              var low = view.getUint32(offset + 4);\n              return high * 4294967296 + low;\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n          /*!*************************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n            \\*************************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              prettyByte: () => (\n                /* binding */\n                prettyByte\n              )\n              /* harmony export */\n            });\n            function prettyByte(byte) {\n              return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n          /*!**************************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n            \\**************************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              createDataView: () => (\n                /* binding */\n                createDataView\n              ),\n              /* harmony export */\n              ensureUint8Array: () => (\n                /* binding */\n                ensureUint8Array\n              )\n              /* harmony export */\n            });\n            function ensureUint8Array(buffer) {\n              if (buffer instanceof Uint8Array) {\n                return buffer;\n              } else if (ArrayBuffer.isView(buffer)) {\n                return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n              } else if (buffer instanceof ArrayBuffer) {\n                return new Uint8Array(buffer);\n              } else {\n                return Uint8Array.from(buffer);\n              }\n            }\n            function createDataView(buffer) {\n              if (buffer instanceof ArrayBuffer) {\n                return new DataView(buffer);\n              }\n              var bufferView = ensureUint8Array(buffer);\n              return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n            }\n          }\n        ),\n        /***/\n        \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n          /*!*******************************************************************!*\\\n            !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n            \\*******************************************************************/\n          /***/\n          (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {\n            __webpack_require__2.r(__webpack_exports__2);\n            __webpack_require__2.d(__webpack_exports__2, {\n              /* harmony export */\n              TEXT_DECODER_THRESHOLD: () => (\n                /* binding */\n                TEXT_DECODER_THRESHOLD\n              ),\n              /* harmony export */\n              TEXT_ENCODER_THRESHOLD: () => (\n                /* binding */\n                TEXT_ENCODER_THRESHOLD\n              ),\n              /* harmony export */\n              utf8Count: () => (\n                /* binding */\n                utf8Count\n              ),\n              /* harmony export */\n              utf8DecodeJs: () => (\n                /* binding */\n                utf8DecodeJs\n              ),\n              /* harmony export */\n              utf8DecodeTD: () => (\n                /* binding */\n                utf8DecodeTD\n              ),\n              /* harmony export */\n              utf8EncodeJs: () => (\n                /* binding */\n                utf8EncodeJs\n              ),\n              /* harmony export */\n              utf8EncodeTE: () => (\n                /* binding */\n                utf8EncodeTE\n              )\n              /* harmony export */\n            });\n            var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ./int.mjs */\n              \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n            );\n            var _a, _b, _c;\n            var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[\"TEXT_ENCODING\"]) !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n            function utf8Count(str) {\n              var strLength = str.length;\n              var byteLength = 0;\n              var pos = 0;\n              while (pos < strLength) {\n                var value = str.charCodeAt(pos++);\n                if ((value & 4294967168) === 0) {\n                  byteLength++;\n                  continue;\n                } else if ((value & 4294965248) === 0) {\n                  byteLength += 2;\n                } else {\n                  if (value >= 55296 && value <= 56319) {\n                    if (pos < strLength) {\n                      var extra = str.charCodeAt(pos);\n                      if ((extra & 64512) === 56320) {\n                        ++pos;\n                        value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                      }\n                    }\n                  }\n                  if ((value & 4294901760) === 0) {\n                    byteLength += 3;\n                  } else {\n                    byteLength += 4;\n                  }\n                }\n              }\n              return byteLength;\n            }\n            function utf8EncodeJs(str, output, outputOffset) {\n              var strLength = str.length;\n              var offset = outputOffset;\n              var pos = 0;\n              while (pos < strLength) {\n                var value = str.charCodeAt(pos++);\n                if ((value & 4294967168) === 0) {\n                  output[offset++] = value;\n                  continue;\n                } else if ((value & 4294965248) === 0) {\n                  output[offset++] = value >> 6 & 31 | 192;\n                } else {\n                  if (value >= 55296 && value <= 56319) {\n                    if (pos < strLength) {\n                      var extra = str.charCodeAt(pos);\n                      if ((extra & 64512) === 56320) {\n                        ++pos;\n                        value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                      }\n                    }\n                  }\n                  if ((value & 4294901760) === 0) {\n                    output[offset++] = value >> 12 & 15 | 224;\n                    output[offset++] = value >> 6 & 63 | 128;\n                  } else {\n                    output[offset++] = value >> 18 & 7 | 240;\n                    output[offset++] = value >> 12 & 63 | 128;\n                    output[offset++] = value >> 6 & 63 | 128;\n                  }\n                }\n                output[offset++] = value & 63 | 128;\n              }\n            }\n            var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n            var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX : typeof process !== \"undefined\" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b[\"TEXT_ENCODING\"]) !== \"force\" ? 200 : 0;\n            function utf8EncodeTEencode(str, output, outputOffset) {\n              output.set(sharedTextEncoder.encode(str), outputOffset);\n            }\n            function utf8EncodeTEencodeInto(str, output, outputOffset) {\n              sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n            }\n            var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n            var CHUNK_SIZE = 4096;\n            function utf8DecodeJs(bytes, inputOffset, byteLength) {\n              var offset = inputOffset;\n              var end = offset + byteLength;\n              var units = [];\n              var result = \"\";\n              while (offset < end) {\n                var byte1 = bytes[offset++];\n                if ((byte1 & 128) === 0) {\n                  units.push(byte1);\n                } else if ((byte1 & 224) === 192) {\n                  var byte2 = bytes[offset++] & 63;\n                  units.push((byte1 & 31) << 6 | byte2);\n                } else if ((byte1 & 240) === 224) {\n                  var byte2 = bytes[offset++] & 63;\n                  var byte3 = bytes[offset++] & 63;\n                  units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n                } else if ((byte1 & 248) === 240) {\n                  var byte2 = bytes[offset++] & 63;\n                  var byte3 = bytes[offset++] & 63;\n                  var byte4 = bytes[offset++] & 63;\n                  var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                  if (unit > 65535) {\n                    unit -= 65536;\n                    units.push(unit >>> 10 & 1023 | 55296);\n                    unit = 56320 | unit & 1023;\n                  }\n                  units.push(unit);\n                } else {\n                  units.push(byte1);\n                }\n                if (units.length >= CHUNK_SIZE) {\n                  result += String.fromCharCode.apply(String, units);\n                  units.length = 0;\n                }\n              }\n              if (units.length > 0) {\n                result += String.fromCharCode.apply(String, units);\n              }\n              return result;\n            }\n            var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n            var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__.UINT32_MAX : typeof process !== \"undefined\" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c[\"TEXT_DECODER\"]) !== \"force\" ? 200 : 0;\n            function utf8DecodeTD(bytes, inputOffset, byteLength) {\n              var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n              return sharedTextDecoder.decode(stringBytes);\n            }\n          }\n        )\n        /******/\n      };\n      var __webpack_module_cache__ = {};\n      function __nested_webpack_require_207781__(moduleId) {\n        var cachedModule = __webpack_module_cache__[moduleId];\n        if (cachedModule !== void 0) {\n          return cachedModule.exports;\n        }\n        var module2 = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n          /******/\n          // no module.loaded needed\n          /******/\n          exports: {}\n          /******/\n        };\n        __webpack_modules__[moduleId](module2, module2.exports, __nested_webpack_require_207781__);\n        return module2.exports;\n      }\n      (() => {\n        __nested_webpack_require_207781__.d = (exports2, definition) => {\n          for (var key in definition) {\n            if (__nested_webpack_require_207781__.o(definition, key) && !__nested_webpack_require_207781__.o(exports2, key)) {\n              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });\n            }\n          }\n        };\n      })();\n      (() => {\n        __nested_webpack_require_207781__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n      })();\n      (() => {\n        __nested_webpack_require_207781__.r = (exports2) => {\n          if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n            Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n          }\n          Object.defineProperty(exports2, \"__esModule\", { value: true });\n        };\n      })();\n      var __nested_webpack_exports__ = {};\n      /*!*********************************!*\\\n        !*** ./src/websocket-client.js ***!\n        \\*********************************/\n      __nested_webpack_require_207781__.r(__nested_webpack_exports__);\n      __nested_webpack_require_207781__.d(__nested_webpack_exports__, {\n        /* harmony export */\n        API_VERSION: () => (\n          /* reexport safe */\n          _rpc_js__WEBPACK_IMPORTED_MODULE_0__.API_VERSION\n        ),\n        /* harmony export */\n        LocalWebSocket: () => (\n          /* binding */\n          LocalWebSocket\n        ),\n        /* harmony export */\n        RPC: () => (\n          /* reexport safe */\n          _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC\n        ),\n        /* harmony export */\n        connectToServer: () => (\n          /* binding */\n          connectToServer\n        ),\n        /* harmony export */\n        getRTCService: () => (\n          /* reexport safe */\n          _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService\n        ),\n        /* harmony export */\n        getRemoteService: () => (\n          /* binding */\n          getRemoteService\n        ),\n        /* harmony export */\n        loadRequirements: () => (\n          /* reexport safe */\n          _utils__WEBPACK_IMPORTED_MODULE_1__.loadRequirements\n        ),\n        /* harmony export */\n        login: () => (\n          /* binding */\n          login\n        ),\n        /* harmony export */\n        registerRTCService: () => (\n          /* reexport safe */\n          _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService\n        ),\n        /* harmony export */\n        schemaFunction: () => (\n          /* reexport safe */\n          _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction\n        ),\n        /* harmony export */\n        setupLocalClient: () => (\n          /* binding */\n          setupLocalClient\n        )\n        /* harmony export */\n      });\n      var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_207781__(\n        /*! ./rpc.js */\n        \"./src/rpc.js\"\n      );\n      var _utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_207781__(\n        /*! ./utils */\n        \"./src/utils/index.js\"\n      );\n      var _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_207781__(\n        /*! ./utils/schema.js */\n        \"./src/utils/schema.js\"\n      );\n      var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_207781__(\n        /*! ./webrtc-client.js */\n        \"./src/webrtc-client.js\"\n      );\n      const MAX_RETRY = 1e6;\n      class WebsocketRPCConnection {\n        constructor(server_url2, client_id2, workspace2, token2, reconnection_token = null, timeout = 60, WebSocketClass = null, token_refresh_interval = 2 * 60 * 60) {\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(server_url2 && client_id2, \"server_url and client_id are required\");\n          this._server_url = server_url2;\n          this._client_id = client_id2;\n          this._workspace = workspace2;\n          this._token = token2;\n          this._reconnection_token = reconnection_token;\n          this._websocket = null;\n          this._handle_message = null;\n          this._handle_connected = null;\n          this._handle_disconnected = null;\n          this._timeout = timeout;\n          this._WebSocketClass = WebSocketClass || WebSocket;\n          this._closed = false;\n          this._legacy_auth = null;\n          this.connection_info = null;\n          this._enable_reconnect = false;\n          this._token_refresh_interval = token_refresh_interval;\n          this.manager_id = null;\n          this._refresh_token_task = null;\n          this._last_message = null;\n        }\n        on_message(handler) {\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(handler, \"handler is required\");\n          this._handle_message = handler;\n        }\n        on_connected(handler) {\n          this._handle_connected = handler;\n        }\n        on_disconnected(handler) {\n          this._handle_disconnected = handler;\n        }\n        async _attempt_connection(server_url2, attempt_fallback = true) {\n          return new Promise((resolve2, reject2) => {\n            this._legacy_auth = false;\n            const websocket = new this._WebSocketClass(server_url2);\n            websocket.binaryType = \"arraybuffer\";\n            websocket.onopen = () => {\n              console.info(\"WebSocket connection established\");\n              resolve2(websocket);\n            };\n            websocket.onerror = (event2) => {\n              console.error(\"WebSocket connection error:\", event2);\n              reject2(new Error(`WebSocket connection error: ${event2}`));\n            };\n            websocket.onclose = (event2) => {\n              if (event2.code === 1003 && attempt_fallback) {\n                console.info(\n                  \"Received 1003 error, attempting connection with query parameters.\"\n                );\n                this._legacy_auth = true;\n                this._attempt_connection_with_query_params(server_url2).then(resolve2).catch(reject2);\n              } else if (this._handle_disconnected) {\n                this._handle_disconnected(event2.reason);\n              }\n            };\n          });\n        }\n        async _attempt_connection_with_query_params(server_url2) {\n          const queryParamsParts = [];\n          if (this._client_id)\n            queryParamsParts.push(`client_id=${encodeURIComponent(this._client_id)}`);\n          if (this._workspace)\n            queryParamsParts.push(`workspace=${encodeURIComponent(this._workspace)}`);\n          if (this._token)\n            queryParamsParts.push(`token=${encodeURIComponent(this._token)}`);\n          if (this._reconnection_token)\n            queryParamsParts.push(\n              `reconnection_token=${encodeURIComponent(this._reconnection_token)}`\n            );\n          const queryString = queryParamsParts.length > 0 ? `?${queryParamsParts.join(\"&\")}` : \"\";\n          const full_url = server_url2 + queryString;\n          return await this._attempt_connection(full_url, false);\n        }\n        _establish_connection() {\n          return new Promise((resolve2, reject2) => {\n            this._websocket.onmessage = (event2) => {\n              const data = event2.data;\n              const first_message = JSON.parse(data);\n              if (first_message.type == \"connection_info\") {\n                this.connection_info = first_message;\n                if (this._workspace) {\n                  (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n                    this.connection_info.workspace === this._workspace,\n                    `Connected to the wrong workspace: ${this.connection_info.workspace}, expected: ${this._workspace}`\n                  );\n                }\n                if (this.connection_info.reconnection_token) {\n                  this._reconnection_token = this.connection_info.reconnection_token;\n                }\n                if (this.connection_info.reconnection_token_life_time) {\n                  if (this.token_refresh_interval > this.connection_info.reconnection_token_life_time / 1.5) {\n                    console.warn(\n                      `Token refresh interval is too long (${this.token_refresh_interval}), setting it to 1.5 times of the token life time(${this.connection_info.reconnection_token_life_time}).`\n                    );\n                    this.token_refresh_interval = this.connection_info.reconnection_token_life_time / 1.5;\n                  }\n                }\n                this.manager_id = this.connection_info.manager_id || null;\n                console.log(\n                  `Successfully connected to the server, workspace: ${this.connection_info.workspace}, manager_id: ${this.manager_id}`\n                );\n                if (this.connection_info.announcement) {\n                  console.log(`${this.connection_info.announcement}`);\n                }\n                resolve2(this.connection_info);\n              } else if (first_message.type == \"error\") {\n                const error = \"ConnectionAbortedError: \" + first_message.message;\n                console.error(\"Failed to connect, \" + error);\n                reject2(new Error(error));\n                return;\n              } else {\n                console.error(\n                  \"ConnectionAbortedError: Unexpected message received from the server:\",\n                  data\n                );\n                reject2(\n                  new Error(\n                    \"ConnectionAbortedError: Unexpected message received from the server\"\n                  )\n                );\n                return;\n              }\n            };\n          });\n        }\n        async open() {\n          console.log(\n            \"Creating a new websocket connection to\",\n            this._server_url.split(\"?\")[0]\n          );\n          try {\n            this._websocket = await this._attempt_connection(this._server_url);\n            if (this._legacy_auth) {\n              throw new Error(\n                \"NotImplementedError: Legacy authentication is not supported\"\n              );\n            }\n            const authInfo = JSON.stringify({\n              client_id: this._client_id,\n              workspace: this._workspace,\n              token: this._token,\n              reconnection_token: this._reconnection_token\n            });\n            this._websocket.send(authInfo);\n            await (0, _utils__WEBPACK_IMPORTED_MODULE_1__.waitFor)(\n              this._establish_connection(),\n              this._timeout,\n              \"Failed to receive the first message from the server\"\n            );\n            if (this._token_refresh_interval > 0) {\n              setTimeout(() => {\n                this._send_refresh_token();\n                this._refresh_token_task = setInterval(() => {\n                  this._send_refresh_token();\n                }, this._token_refresh_interval * 1e3);\n              }, 2e3);\n            }\n            this._enable_reconnect = true;\n            this._closed = false;\n            this._websocket.onmessage = (event2) => {\n              if (typeof event2.data === \"string\") {\n                const parsedData = JSON.parse(event2.data);\n                if (parsedData.type === \"reconnection_token\") {\n                  this._reconnection_token = parsedData.reconnection_token;\n                  console.log(\"Reconnection token received\");\n                } else {\n                  console.log(\"Received message from the server:\", parsedData);\n                }\n              } else {\n                this._handle_message(event2.data);\n              }\n            };\n            this._websocket.onerror = (event2) => {\n              console.error(\"WebSocket connection error:\", event2);\n            };\n            this._websocket.onclose = this._handle_close.bind(this);\n            if (this._handle_connected) {\n              this._handle_connected(this.connection_info);\n            }\n            return this.connection_info;\n          } catch (error) {\n            console.error(\n              \"Failed to connect to\",\n              this._server_url.split(\"?\")[0],\n              error\n            );\n            throw error;\n          }\n        }\n        _send_refresh_token() {\n          if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n            const refreshMessage = JSON.stringify({ type: \"refresh_token\" });\n            this._websocket.send(refreshMessage);\n            console.log(\"Requested refresh token\");\n          }\n        }\n        _handle_close(event2) {\n          if (!this._closed && this._websocket && this._websocket.readyState === WebSocket.CLOSED) {\n            if ([1e3, 1001].includes(event2.code)) {\n              console.info(\n                `Websocket connection closed (code: ${event2.code}): ${event2.reason}`\n              );\n              if (this._handle_disconnected) {\n                this._handle_disconnected(event2.reason);\n              }\n              this._closed = true;\n            } else if (this._enable_reconnect) {\n              console.warn(\n                \"Websocket connection closed unexpectedly (code: %s): %s\",\n                event2.code,\n                event2.reason\n              );\n              let retry = 0;\n              const reconnect = async () => {\n                try {\n                  console.warn(\n                    `Reconnecting to ${this._server_url.split(\"?\")[0]} (attempt #${retry})`\n                  );\n                  await this.open();\n                  await new Promise((resolve2) => setTimeout(resolve2, 500));\n                  if (this._last_message) {\n                    console.info(\"Resending last message after reconnection\");\n                    this._websocket.send(this._last_message);\n                    this._last_message = null;\n                  }\n                  console.warn(\n                    `Successfully reconnected to server ${this._server_url} (services re-registered)`\n                  );\n                } catch (e) {\n                  if (`${e}`.includes(\"ConnectionAbortedError:\")) {\n                    console.warn(\"Failed to reconnect, connection aborted:\", e);\n                    return;\n                  } else if (`${e}`.includes(\"NotImplementedError:\")) {\n                    console.error(\n                      `${e}\nIt appears that you are trying to connect to a hypha server that is older than 0.20.0, please upgrade the hypha server or use the websocket client in imjoy-rpc(https://www.npmjs.com/package/imjoy-rpc) instead`\n                    );\n                    return;\n                  }\n                  await new Promise((resolve2) => setTimeout(resolve2, 1e3));\n                  if (this._websocket && this._websocket.readyState === WebSocket.CONNECTED) {\n                    return;\n                  }\n                  retry += 1;\n                  if (retry < MAX_RETRY) {\n                    await reconnect();\n                  } else {\n                    console.error(\"Failed to reconnect after\", MAX_RETRY, \"attempts\");\n                  }\n                }\n              };\n              reconnect();\n            }\n          } else {\n            if (this._handle_disconnected) {\n              this._handle_disconnected(event2.reason);\n            }\n          }\n        }\n        async emit_message(data) {\n          if (this._closed) {\n            throw new Error(\"Connection is closed\");\n          }\n          if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n            await this.open();\n          }\n          try {\n            this._last_message = data;\n            this._websocket.send(data);\n            this._last_message = null;\n          } catch (exp) {\n            console.error(`Failed to send data, error: ${exp}`);\n            throw exp;\n          }\n        }\n        disconnect(reason) {\n          this._closed = true;\n          this._last_message = null;\n          if (this._websocket && this._websocket.readyState !== WebSocket.CLOSED && this._websocket.readyState !== WebSocket.CLOSING) {\n            this._websocket.close(1e3, reason);\n          }\n          if (this._refresh_token_task) {\n            clearInterval(this._refresh_token_task);\n          }\n          console.info(`WebSocket connection disconnected (${reason})`);\n        }\n      }\n      function normalizeServerUrl(server_url2) {\n        if (!server_url2)\n          throw new Error(\"server_url is required\");\n        if (server_url2.startsWith(\"http://\")) {\n          server_url2 = server_url2.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n        } else if (server_url2.startsWith(\"https://\")) {\n          server_url2 = server_url2.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n        }\n        return server_url2;\n      }\n      async function login(config2) {\n        const service_id = config2.login_service_id || \"public/hypha-login\";\n        const workspace2 = config2.workspace;\n        const expires_in = config2.expires_in;\n        const timeout = config2.login_timeout || 60;\n        const callback = config2.login_callback;\n        const profile = config2.profile;\n        const server2 = await connectToServer({\n          name: \"initial login client\",\n          server_url: config2.server_url\n        });\n        try {\n          const svc = await server2.getService(service_id);\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(svc, `Failed to get the login service: ${service_id}`);\n          let context2;\n          if (workspace2) {\n            context2 = await svc.start({ workspace: workspace2, expires_in, _rkwargs: true });\n          } else {\n            context2 = await svc.start();\n          }\n          if (callback) {\n            await callback(context2);\n          } else {\n            console.log(`Please open your browser and login at ${context2.login_url}`);\n          }\n          return await svc.check(context2.key, { timeout, profile, _rkwargs: true });\n        } catch (error) {\n          throw error;\n        } finally {\n          await server2.disconnect();\n        }\n      }\n      async function webrtcGetService(wm, rtc_service_id, query, config2) {\n        config2 = config2 || {};\n        const webrtc = config2.webrtc;\n        const webrtc_config = config2.webrtc_config;\n        if (config2.webrtc !== void 0)\n          delete config2.webrtc;\n        if (config2.webrtc_config !== void 0)\n          delete config2.webrtc_config;\n        (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n          [void 0, true, false, \"auto\"].includes(webrtc),\n          \"webrtc must be true, false or 'auto'\"\n        );\n        const svc = await wm.getService(query, config2);\n        if (webrtc === true || webrtc === \"auto\") {\n          if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n            try {\n              const peer = await (0, _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService)(wm, rtc_service_id, webrtc_config);\n              const rtcSvc = await peer.getService(svc.id.split(\":\")[1], config2);\n              rtcSvc._webrtc = true;\n              rtcSvc._peer = peer;\n              rtcSvc._service = svc;\n              return rtcSvc;\n            } catch (e) {\n              console.warn(\n                \"Failed to get webrtc service, using websocket connection\",\n                e\n              );\n            }\n          }\n          if (webrtc === true) {\n            throw new Error(\"Failed to get the service via webrtc\");\n          }\n        }\n        return svc;\n      }\n      async function connectToServer(config2) {\n        if (config2.server) {\n          config2.server_url = config2.server_url || config2.server.url;\n          config2.WebSocketClass = config2.WebSocketClass || config2.server.WebSocketClass;\n        }\n        let clientId = config2.client_id;\n        if (!clientId) {\n          clientId = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.randId)();\n          config2.client_id = clientId;\n        }\n        let server_url2 = normalizeServerUrl(config2.server_url);\n        let connection = new WebsocketRPCConnection(\n          server_url2,\n          clientId,\n          config2.workspace,\n          config2.token,\n          config2.reconnection_token,\n          config2.method_timeout || 60,\n          config2.WebSocketClass\n        );\n        const connection_info = await connection.open();\n        (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n          connection_info,\n          \"Failed to connect to the server, no connection info obtained. This issue is most likely due to an outdated Hypha server version. Please use `imjoy-rpc` for compatibility, or upgrade the Hypha server to the latest version.\"\n        );\n        await new Promise((resolve2) => setTimeout(resolve2, 100));\n        if (!connection.manager_id) {\n          console.warn(\"Manager ID not set immediately, waiting...\");\n          const maxWaitTime = 5e3;\n          const checkInterval = 100;\n          const startTime = Date.now();\n          while (!connection.manager_id && Date.now() - startTime < maxWaitTime) {\n            await new Promise((resolve2) => setTimeout(resolve2, checkInterval));\n          }\n          if (!connection.manager_id) {\n            console.error(\"Manager ID still not set after waiting\");\n            throw new Error(\"Failed to get manager ID from server\");\n          } else {\n            console.info(`Manager ID set after waiting: ${connection.manager_id}`);\n          }\n        }\n        if (config2.workspace && connection_info.workspace !== config2.workspace) {\n          throw new Error(\n            `Connected to the wrong workspace: ${connection_info.workspace}, expected: ${config2.workspace}`\n          );\n        }\n        const workspace2 = connection_info.workspace;\n        const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__.RPC(connection, {\n          client_id: clientId,\n          workspace: workspace2,\n          default_context: { connection_type: \"websocket\" },\n          name: config2.name,\n          method_timeout: config2.method_timeout,\n          app_id: config2.app_id,\n          server_base_url: connection_info.public_base_url,\n          long_message_chunk_size: config2.long_message_chunk_size\n        });\n        const wm = await rpc.get_manager_service({\n          timeout: config2.method_timeout,\n          case_conversion: \"camel\",\n          kwargs_expansion: config2.kwargs_expansion || false\n        });\n        wm.rpc = rpc;\n        async function _export(api) {\n          api.id = \"default\";\n          api.name = api.name || config2.name || api.id;\n          api.description = api.description || config2.description;\n          await rpc.register_service(api, { overwrite: true });\n        }\n        async function getApp(clientId2) {\n          clientId2 = clientId2 || \"*\";\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!clientId2.includes(\":\"), \"clientId should not contain ':'\");\n          if (!clientId2.includes(\"/\")) {\n            clientId2 = connection_info.workspace + \"/\" + clientId2;\n          }\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(\n            clientId2.split(\"/\").length === 2,\n            \"clientId should match pattern workspace/clientId\"\n          );\n          return await wm.getService(`${clientId2}:default`);\n        }\n        async function listApps(ws) {\n          ws = ws || workspace2;\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\":\"), \"workspace should not contain ':'\");\n          (0, _utils__WEBPACK_IMPORTED_MODULE_1__.assert)(!ws.includes(\"/\"), \"workspace should not contain '/'\");\n          const query = { workspace: ws, service_id: \"default\" };\n          return await wm.listServices(query);\n        }\n        if (connection_info) {\n          wm.config = Object.assign(wm.config, connection_info);\n        }\n        wm.export = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_export, {\n          name: \"export\",\n          description: \"Export the api.\",\n          parameters: {\n            properties: { api: { description: \"The api to export\", type: \"object\" } },\n            required: [\"api\"],\n            type: \"object\"\n          }\n        });\n        wm.getApp = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(getApp, {\n          name: \"getApp\",\n          description: \"Get the app.\",\n          parameters: {\n            properties: {\n              clientId: { default: \"*\", description: \"The clientId\", type: \"string\" }\n            },\n            type: \"object\"\n          }\n        });\n        wm.listApps = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(listApps, {\n          name: \"listApps\",\n          description: \"List the apps.\",\n          parameters: {\n            properties: {\n              workspace: {\n                default: workspace2,\n                description: \"The workspace\",\n                type: \"string\"\n              }\n            },\n            type: \"object\"\n          }\n        });\n        wm.disconnect = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.disconnect.bind(rpc), {\n          name: \"disconnect\",\n          description: \"Disconnect from the server.\",\n          parameters: { type: \"object\", properties: {}, required: [] }\n        });\n        wm.registerCodec = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_codec.bind(rpc), {\n          name: \"registerCodec\",\n          description: \"Register a codec for the webrtc connection\",\n          parameters: {\n            type: \"object\",\n            properties: {\n              codec: {\n                type: \"object\",\n                description: \"Codec to register\",\n                properties: {\n                  name: { type: \"string\" },\n                  type: {},\n                  encoder: { type: \"function\" },\n                  decoder: { type: \"function\" }\n                }\n              }\n            }\n          }\n        });\n        wm.emit = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.emit.bind(rpc), {\n          name: \"emit\",\n          description: \"Emit a message.\",\n          parameters: {\n            properties: { data: { description: \"The data to emit\", type: \"object\" } },\n            required: [\"data\"],\n            type: \"object\"\n          }\n        });\n        wm.on = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.on.bind(rpc), {\n          name: \"on\",\n          description: \"Register a message handler.\",\n          parameters: {\n            properties: {\n              event: { description: \"The event to listen to\", type: \"string\" },\n              handler: { description: \"The handler function\", type: \"function\" }\n            },\n            required: [\"event\", \"handler\"],\n            type: \"object\"\n          }\n        });\n        wm.off = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.off.bind(rpc), {\n          name: \"off\",\n          description: \"Remove a message handler.\",\n          parameters: {\n            properties: {\n              event: { description: \"The event to remove\", type: \"string\" },\n              handler: { description: \"The handler function\", type: \"function\" }\n            },\n            required: [\"event\", \"handler\"],\n            type: \"object\"\n          }\n        });\n        wm.once = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.once.bind(rpc), {\n          name: \"once\",\n          description: \"Register a one-time message handler.\",\n          parameters: {\n            properties: {\n              event: { description: \"The event to listen to\", type: \"string\" },\n              handler: { description: \"The handler function\", type: \"function\" }\n            },\n            required: [\"event\", \"handler\"],\n            type: \"object\"\n          }\n        });\n        wm.getServiceSchema = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.get_service_schema, {\n          name: \"getServiceSchema\",\n          description: \"Get the service schema.\",\n          parameters: {\n            properties: {\n              service: {\n                description: \"The service to extract schema\",\n                type: \"object\"\n              }\n            },\n            required: [\"service\"],\n            type: \"object\"\n          }\n        });\n        wm.registerService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.register_service.bind(rpc), {\n          name: \"registerService\",\n          description: \"Register a service.\",\n          parameters: {\n            properties: {\n              service: { description: \"The service to register\", type: \"object\" },\n              force: {\n                default: false,\n                description: \"Force to register the service\",\n                type: \"boolean\"\n              }\n            },\n            required: [\"service\"],\n            type: \"object\"\n          }\n        });\n        wm.unregisterService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(rpc.unregister_service.bind(rpc), {\n          name: \"unregisterService\",\n          description: \"Unregister a service.\",\n          parameters: {\n            properties: {\n              service: {\n                description: \"The service id to unregister\",\n                type: \"string\"\n              },\n              notify: {\n                default: true,\n                description: \"Notify the workspace manager\",\n                type: \"boolean\"\n              }\n            },\n            required: [\"service\"],\n            type: \"object\"\n          }\n        });\n        if (connection.manager_id) {\n          rpc.on(\"force-exit\", async (message) => {\n            if (message.from === \"*/\" + connection.manager_id) {\n              console.log(\"Disconnecting from server, reason:\", message.reason);\n              await rpc.disconnect();\n            }\n          });\n        }\n        if (config2.webrtc) {\n          await (0, _webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.registerRTCService)(wm, `${clientId}-rtc`, config2.webrtc_config);\n          const _wm = Object.assign({}, wm);\n          const description = _wm.getService.__schema__.description;\n          const parameters = _wm.getService.__schema__.parameters;\n          wm.getService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(\n            webrtcGetService.bind(null, _wm, `${workspace2}/${clientId}-rtc`),\n            {\n              name: \"getService\",\n              description,\n              parameters\n            }\n          );\n          wm.getRTCService = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_3__.getRTCService.bind(null, wm), {\n            name: \"getRTCService\",\n            description: \"Get the webrtc connection, returns a peer connection.\",\n            parameters: {\n              properties: {\n                config: {\n                  description: \"The config for the webrtc service\",\n                  type: \"object\"\n                }\n              },\n              required: [\"config\"],\n              type: \"object\"\n            }\n          });\n        } else {\n          const _getService = wm.getService;\n          wm.getService = (query, config3) => {\n            config3 = config3 || {};\n            return _getService(query, config3);\n          };\n          wm.getService.__schema__ = _getService.__schema__;\n        }\n        async function registerProbes(probes) {\n          probes.id = \"probes\";\n          probes.name = \"Probes\";\n          probes.config = { visibility: \"public\" };\n          probes.type = \"probes\";\n          probes.description = `Probes Service, visit ${server_url2}/${workspace2}services/probes for the available probes.`;\n          return await wm.registerService(probes, { overwrite: true });\n        }\n        wm.registerProbes = (0, _utils_schema_js__WEBPACK_IMPORTED_MODULE_2__.schemaFunction)(registerProbes, {\n          name: \"registerProbes\",\n          description: \"Register probes service\",\n          parameters: {\n            properties: {\n              probes: {\n                description: \"The probes to register, e.g. {'liveness': {'type': 'function', 'description': 'Check the liveness of the service'}}\",\n                type: \"object\"\n              }\n            },\n            required: [\"probes\"],\n            type: \"object\"\n          }\n        });\n        return wm;\n      }\n      async function getRemoteService(serviceUri, config2 = {}) {\n        const { serverUrl, workspace: workspace2, clientId, serviceId, appId } = (0, _utils__WEBPACK_IMPORTED_MODULE_1__.parseServiceUrl)(serviceUri);\n        const fullServiceId = `${workspace2}/${clientId}:${serviceId}@${appId}`;\n        if (config2.serverUrl) {\n          if (config2.serverUrl !== serverUrl) {\n            throw new Error(\n              \"server_url in config does not match the server_url in the url\"\n            );\n          }\n        }\n        config2.serverUrl = serverUrl;\n        const server2 = await connectToServer(config2);\n        return await server2.getService(fullServiceId);\n      }\n      class LocalWebSocket {\n        constructor(url, client_id2, workspace2) {\n          this.url = url;\n          this.onopen = () => {\n          };\n          this.onmessage = () => {\n          };\n          this.onclose = () => {\n          };\n          this.onerror = () => {\n          };\n          this.client_id = client_id2;\n          this.workspace = workspace2;\n          const context2 = typeof window !== \"undefined\" ? window : self;\n          const isWindow2 = typeof window !== \"undefined\";\n          this.postMessage = (message) => {\n            if (isWindow2) {\n              window.parent.postMessage(message, \"*\");\n            } else {\n              self.postMessage(message);\n            }\n          };\n          this.readyState = WebSocket.CONNECTING;\n          context2.addEventListener(\n            \"message\",\n            (event2) => {\n              const { type: type2, data, to } = event2.data;\n              if (to !== this.client_id) {\n                return;\n              }\n              switch (type2) {\n                case \"message\":\n                  if (this.readyState === WebSocket.OPEN && this.onmessage) {\n                    this.onmessage({ data });\n                  }\n                  break;\n                case \"connected\":\n                  this.readyState = WebSocket.OPEN;\n                  this.onopen(event2);\n                  break;\n                case \"closed\":\n                  this.readyState = WebSocket.CLOSED;\n                  this.onclose(event2);\n                  break;\n                default:\n                  break;\n              }\n            },\n            false\n          );\n          if (!this.client_id)\n            throw new Error(\"client_id is required\");\n          if (!this.workspace)\n            throw new Error(\"workspace is required\");\n          this.postMessage({\n            type: \"connect\",\n            url: this.url,\n            from: this.client_id,\n            workspace: this.workspace\n          });\n        }\n        send(data) {\n          if (this.readyState === WebSocket.OPEN) {\n            this.postMessage({\n              type: \"message\",\n              data,\n              from: this.client_id,\n              workspace: this.workspace\n            });\n          }\n        }\n        close() {\n          this.readyState = WebSocket.CLOSING;\n          this.postMessage({\n            type: \"close\",\n            from: this.client_id,\n            workspace: this.workspace\n          });\n          this.onclose();\n        }\n        addEventListener(type2, listener) {\n          if (type2 === \"message\") {\n            this.onmessage = listener;\n          }\n          if (type2 === \"open\") {\n            this.onopen = listener;\n          }\n          if (type2 === \"close\") {\n            this.onclose = listener;\n          }\n          if (type2 === \"error\") {\n            this.onerror = listener;\n          }\n        }\n      }\n      function setupLocalClient({\n        enable_execution = false,\n        on_ready = null\n      }) {\n        return new Promise((resolve, reject) => {\n          const context = typeof window !== \"undefined\" ? window : self;\n          const isWindow = typeof window !== \"undefined\";\n          context.addEventListener(\n            \"message\",\n            (event) => {\n              const {\n                type,\n                server_url,\n                workspace,\n                client_id,\n                token,\n                method_timeout,\n                name,\n                config\n              } = event.data;\n              if (type === \"initializeHyphaClient\") {\n                if (!server_url || !workspace || !client_id) {\n                  console.error(\"server_url, workspace, and client_id are required.\");\n                  return;\n                }\n                if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n                  console.error(\n                    \"server_url should start with https://local-hypha-server:\"\n                  );\n                  return;\n                }\n                class FixedLocalWebSocket extends LocalWebSocket {\n                  constructor(url) {\n                    super(url, client_id, workspace);\n                  }\n                }\n                connectToServer({\n                  server_url,\n                  workspace,\n                  client_id,\n                  token,\n                  method_timeout,\n                  name,\n                  WebSocketClass: FixedLocalWebSocket\n                }).then(async (server) => {\n                  globalThis.api = server;\n                  try {\n                    if (isWindow && enable_execution) {\n                      let loadScript = function(script2) {\n                        return new Promise((resolve2, reject2) => {\n                          const scriptElement = document.createElement(\"script\");\n                          scriptElement.innerHTML = script2.content;\n                          scriptElement.lang = script2.lang;\n                          scriptElement.onload = () => resolve2();\n                          scriptElement.onerror = (e) => reject2(e);\n                          document.head.appendChild(scriptElement);\n                        });\n                      };\n                      if (config.styles && config.styles.length > 0) {\n                        for (const style of config.styles) {\n                          const styleElement = document.createElement(\"style\");\n                          styleElement.innerHTML = style.content;\n                          styleElement.lang = style.lang;\n                          document.head.appendChild(styleElement);\n                        }\n                      }\n                      if (config.links && config.links.length > 0) {\n                        for (const link of config.links) {\n                          const linkElement = document.createElement(\"a\");\n                          linkElement.href = link.url;\n                          linkElement.innerText = link.text;\n                          document.body.appendChild(linkElement);\n                        }\n                      }\n                      if (config.windows && config.windows.length > 0) {\n                        for (const w of config.windows) {\n                          document.body.innerHTML = w.content;\n                          break;\n                        }\n                      }\n                      if (config.scripts && config.scripts.length > 0) {\n                        for (const script2 of config.scripts) {\n                          if (script2.lang !== \"javascript\")\n                            throw new Error(\"Only javascript scripts are supported\");\n                          await loadScript(script2);\n                        }\n                      }\n                    } else if (!isWindow && enable_execution && config.scripts && config.scripts.length > 0) {\n                      for (const script of config.scripts) {\n                        if (script.lang !== \"javascript\")\n                          throw new Error(\"Only javascript scripts are supported\");\n                        eval(script.content);\n                      }\n                    }\n                    if (on_ready) {\n                      await on_ready(server, config);\n                    }\n                    resolve(server);\n                  } catch (e) {\n                    reject(e);\n                  }\n                });\n              }\n            },\n            false\n          );\n          if (isWindow) {\n            window.parent.postMessage({ type: \"hyphaClientReady\" }, \"*\");\n          } else {\n            self.postMessage({ type: \"hyphaClientReady\" });\n          }\n        });\n      }\n      return __nested_webpack_exports__;\n    })()\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/hypha-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hypha-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/hypha-rpc/dist/hypha-rpc-websocket.js\") };\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/hypha-rpc/index.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js":
/*!******************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js ***!
  \******************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/hypha/sse-client.js\");\n    }({\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: CachedKeyDecoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"CachedKeyDecoder\", function() {\n            return CachedKeyDecoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var DEFAULT_MAX_KEY_LENGTH = 16;\n          var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n          var CachedKeyDecoder = (\n            /** @class */\n            function() {\n              function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                if (maxKeyLength === void 0) {\n                  maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                }\n                if (maxLengthPerKey === void 0) {\n                  maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                }\n                this.maxKeyLength = maxKeyLength;\n                this.maxLengthPerKey = maxLengthPerKey;\n                this.hit = 0;\n                this.miss = 0;\n                this.caches = [];\n                for (var i = 0; i < this.maxKeyLength; i++) {\n                  this.caches.push([]);\n                }\n              }\n              CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                return byteLength > 0 && byteLength <= this.maxKeyLength;\n              };\n              CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                var records = this.caches[byteLength - 1];\n                FIND_CHUNK:\n                  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                    var record = records_1[_i];\n                    var recordBytes = record.bytes;\n                    for (var j = 0; j < byteLength; j++) {\n                      if (recordBytes[j] !== bytes[inputOffset + j]) {\n                        continue FIND_CHUNK;\n                      }\n                    }\n                    return record.str;\n                  }\n                return null;\n              };\n              CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                var records = this.caches[bytes.length - 1];\n                var record = { bytes, str: value };\n                if (records.length >= this.maxLengthPerKey) {\n                  records[Math.random() * records.length | 0] = record;\n                } else {\n                  records.push(record);\n                }\n              };\n              CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                var cachedValue = this.find(bytes, inputOffset, byteLength);\n                if (cachedValue != null) {\n                  this.hit++;\n                  return cachedValue;\n                }\n                this.miss++;\n                var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n                var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                this.store(slicedCopyOfBytes, str);\n                return str;\n              };\n              return CachedKeyDecoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: DecodeError */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return DecodeError;\n          });\n          var __extends = function() {\n            var extendStatics = function(d, b) {\n              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                d2.__proto__ = b2;\n              } || function(d2, b2) {\n                for (var p in b2)\n                  if (Object.prototype.hasOwnProperty.call(b2, p))\n                    d2[p] = b2[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function(d, b) {\n              if (typeof b !== \"function\" && b !== null)\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          var DecodeError = (\n            /** @class */\n            function(_super) {\n              __extends(DecodeError2, _super);\n              function DecodeError2(message) {\n                var _this = _super.call(this, message) || this;\n                var proto = Object.create(DecodeError2.prototype);\n                Object.setPrototypeOf(_this, proto);\n                Object.defineProperty(_this, \"name\", {\n                  configurable: true,\n                  enumerable: false,\n                  value: DecodeError2.name\n                });\n                return _this;\n              }\n              return DecodeError2;\n            }(Error)\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return DataViewIndexOutOfBoundsError;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/prettyByte.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./CachedKeyDecoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n          );\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __asyncValues = function(o) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i);\n            function verb(n) {\n              i[n] = o[n] && function(v) {\n                return new Promise(function(resolve, reject) {\n                  v = o[n](v), settle(resolve, reject, v.done, v.value);\n                });\n              };\n            }\n            function settle(resolve, reject, d, v) {\n              Promise.resolve(v).then(function(v2) {\n                resolve({ value: v2, done: d });\n              }, reject);\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          var isValidMapKeyType = function(key) {\n            var keyType = typeof key;\n            return keyType === \"string\" || keyType === \"number\";\n          };\n          var HEAD_BYTE_REQUIRED = -1;\n          var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n          var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n          var DataViewIndexOutOfBoundsError = function() {\n            try {\n              EMPTY_VIEW.getInt8(0);\n            } catch (e) {\n              return e.constructor;\n            }\n            throw new Error(\"never reached\");\n          }();\n          var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n          var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\n          var Decoder = (\n            /** @class */\n            function() {\n              function Decoder2(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxStrLength === void 0) {\n                  maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxBinLength === void 0) {\n                  maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxArrayLength === void 0) {\n                  maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxMapLength === void 0) {\n                  maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxExtLength === void 0) {\n                  maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (keyDecoder === void 0) {\n                  keyDecoder = sharedCachedKeyDecoder;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxStrLength = maxStrLength;\n                this.maxBinLength = maxBinLength;\n                this.maxArrayLength = maxArrayLength;\n                this.maxMapLength = maxMapLength;\n                this.maxExtLength = maxExtLength;\n                this.keyDecoder = keyDecoder;\n                this.totalPos = 0;\n                this.pos = 0;\n                this.view = EMPTY_VIEW;\n                this.bytes = EMPTY_BYTES;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack = [];\n              }\n              Decoder2.prototype.reinitializeState = function() {\n                this.totalPos = 0;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack.length = 0;\n              };\n              Decoder2.prototype.setBuffer = function(buffer) {\n                this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n                this.pos = 0;\n              };\n              Decoder2.prototype.appendBuffer = function(buffer) {\n                if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                  this.setBuffer(buffer);\n                } else {\n                  var remainingData = this.bytes.subarray(this.pos);\n                  var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                  var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                  newBuffer.set(remainingData);\n                  newBuffer.set(newData, remainingData.length);\n                  this.setBuffer(newBuffer);\n                }\n              };\n              Decoder2.prototype.hasRemaining = function(size) {\n                return this.view.byteLength - this.pos >= size;\n              };\n              Decoder2.prototype.createExtraByteError = function(posToShow) {\n                var _a = this, view = _a.view, pos = _a.pos;\n                return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n              };\n              Decoder2.prototype.decode = function(buffer) {\n                this.reinitializeState();\n                this.setBuffer(buffer);\n                var object = this.doDecodeSync();\n                if (this.hasRemaining(1)) {\n                  throw this.createExtraByteError(this.pos);\n                }\n                return object;\n              };\n              Decoder2.prototype.decodeMulti = function(buffer) {\n                return __generator(this, function(_a) {\n                  switch (_a.label) {\n                    case 0:\n                      this.reinitializeState();\n                      this.setBuffer(buffer);\n                      _a.label = 1;\n                    case 1:\n                      if (!this.hasRemaining(1))\n                        return [3, 3];\n                      return [4, this.doDecodeSync()];\n                    case 2:\n                      _a.sent();\n                      return [3, 1];\n                    case 3:\n                      return [\n                        2\n                        /*return*/\n                      ];\n                  }\n                });\n              };\n              Decoder2.prototype.decodeAsync = function(stream) {\n                var stream_1, stream_1_1;\n                var e_1, _a;\n                return __awaiter(this, void 0, void 0, function() {\n                  var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                  return __generator(this, function(_c) {\n                    switch (_c.label) {\n                      case 0:\n                        decoded = false;\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                      case 2:\n                        return [4, stream_1.next()];\n                      case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                          return [3, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                          object = this.doDecodeSync();\n                          decoded = true;\n                        } catch (e) {\n                          if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e;\n                          }\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                      case 4:\n                        return [3, 2];\n                      case 5:\n                        return [3, 12];\n                      case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3, 12];\n                      case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                          return [3, 9];\n                        return [4, _a.call(stream_1)];\n                      case 8:\n                        _c.sent();\n                        _c.label = 9;\n                      case 9:\n                        return [3, 11];\n                      case 10:\n                        if (e_1)\n                          throw e_1.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 11:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 12:\n                        if (decoded) {\n                          if (this.hasRemaining(1)) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          return [2, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.decodeArrayStream = function(stream) {\n                return this.decodeMultiAsync(stream, true);\n              };\n              Decoder2.prototype.decodeStream = function(stream) {\n                return this.decodeMultiAsync(stream, false);\n              };\n              Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                  var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                  var e_3, _a;\n                  return __generator(this, function(_b) {\n                    switch (_b.label) {\n                      case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                      case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                      case 2:\n                        return [4, __await(stream_2.next())];\n                      case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                          return [3, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                          arrayItemsLeft = this.readArraySize();\n                          isArrayHeaderRequired = false;\n                          this.complete();\n                        }\n                        _b.label = 4;\n                      case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                      case 5:\n                        if (false) {}\n                        return [4, __await(this.doDecodeSync())];\n                      case 6:\n                        return [4, _b.sent()];\n                      case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                          return [3, 8];\n                        }\n                        return [3, 5];\n                      case 8:\n                        return [3, 10];\n                      case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                          throw e_2;\n                        }\n                        return [3, 10];\n                      case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                      case 11:\n                        return [3, 2];\n                      case 12:\n                        return [3, 19];\n                      case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3, 19];\n                      case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                          return [3, 16];\n                        return [4, __await(_a.call(stream_2))];\n                      case 15:\n                        _b.sent();\n                        _b.label = 16;\n                      case 16:\n                        return [3, 18];\n                      case 17:\n                        if (e_3)\n                          throw e_3.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 18:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 19:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.doDecodeSync = function() {\n                DECODE:\n                  while (true) {\n                    var headByte = this.readHeadByte();\n                    var object = void 0;\n                    if (headByte >= 224) {\n                      object = headByte - 256;\n                    } else if (headByte < 192) {\n                      if (headByte < 128) {\n                        object = headByte;\n                      } else if (headByte < 144) {\n                        var size = headByte - 128;\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte < 160) {\n                        var size = headByte - 144;\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else {\n                        var byteLength = headByte - 160;\n                        object = this.decodeUtf8String(byteLength, 0);\n                      }\n                    } else if (headByte === 192) {\n                      object = null;\n                    } else if (headByte === 194) {\n                      object = false;\n                    } else if (headByte === 195) {\n                      object = true;\n                    } else if (headByte === 202) {\n                      object = this.readF32();\n                    } else if (headByte === 203) {\n                      object = this.readF64();\n                    } else if (headByte === 204) {\n                      object = this.readU8();\n                    } else if (headByte === 205) {\n                      object = this.readU16();\n                    } else if (headByte === 206) {\n                      object = this.readU32();\n                    } else if (headByte === 207) {\n                      object = this.readU64();\n                    } else if (headByte === 208) {\n                      object = this.readI8();\n                    } else if (headByte === 209) {\n                      object = this.readI16();\n                    } else if (headByte === 210) {\n                      object = this.readI32();\n                    } else if (headByte === 211) {\n                      object = this.readI64();\n                    } else if (headByte === 217) {\n                      var byteLength = this.lookU8();\n                      object = this.decodeUtf8String(byteLength, 1);\n                    } else if (headByte === 218) {\n                      var byteLength = this.lookU16();\n                      object = this.decodeUtf8String(byteLength, 2);\n                    } else if (headByte === 219) {\n                      var byteLength = this.lookU32();\n                      object = this.decodeUtf8String(byteLength, 4);\n                    } else if (headByte === 220) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 221) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 222) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 223) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 196) {\n                      var size = this.lookU8();\n                      object = this.decodeBinary(size, 1);\n                    } else if (headByte === 197) {\n                      var size = this.lookU16();\n                      object = this.decodeBinary(size, 2);\n                    } else if (headByte === 198) {\n                      var size = this.lookU32();\n                      object = this.decodeBinary(size, 4);\n                    } else if (headByte === 212) {\n                      object = this.decodeExtension(1, 0);\n                    } else if (headByte === 213) {\n                      object = this.decodeExtension(2, 0);\n                    } else if (headByte === 214) {\n                      object = this.decodeExtension(4, 0);\n                    } else if (headByte === 215) {\n                      object = this.decodeExtension(8, 0);\n                    } else if (headByte === 216) {\n                      object = this.decodeExtension(16, 0);\n                    } else if (headByte === 199) {\n                      var size = this.lookU8();\n                      object = this.decodeExtension(size, 1);\n                    } else if (headByte === 200) {\n                      var size = this.lookU16();\n                      object = this.decodeExtension(size, 2);\n                    } else if (headByte === 201) {\n                      var size = this.lookU32();\n                      object = this.decodeExtension(size, 4);\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                    this.complete();\n                    var stack = this.stack;\n                    while (stack.length > 0) {\n                      var state = stack[stack.length - 1];\n                      if (state.type === 0) {\n                        state.array[state.position] = object;\n                        state.position++;\n                        if (state.position === state.size) {\n                          stack.pop();\n                          object = state.array;\n                        } else {\n                          continue DECODE;\n                        }\n                      } else if (state.type === 1) {\n                        if (!isValidMapKeyType(object)) {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                        }\n                        if (object === \"__proto__\") {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                        }\n                        state.key = object;\n                        state.type = 2;\n                        continue DECODE;\n                      } else {\n                        state.map[state.key] = object;\n                        state.readCount++;\n                        if (state.readCount === state.size) {\n                          stack.pop();\n                          object = state.map;\n                        } else {\n                          state.key = null;\n                          state.type = 1;\n                          continue DECODE;\n                        }\n                      }\n                    }\n                    return object;\n                  }\n              };\n              Decoder2.prototype.readHeadByte = function() {\n                if (this.headByte === HEAD_BYTE_REQUIRED) {\n                  this.headByte = this.readU8();\n                }\n                return this.headByte;\n              };\n              Decoder2.prototype.complete = function() {\n                this.headByte = HEAD_BYTE_REQUIRED;\n              };\n              Decoder2.prototype.readArraySize = function() {\n                var headByte = this.readHeadByte();\n                switch (headByte) {\n                  case 220:\n                    return this.readU16();\n                  case 221:\n                    return this.readU32();\n                  default: {\n                    if (headByte < 160) {\n                      return headByte - 144;\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                  }\n                }\n              };\n              Decoder2.prototype.pushMapState = function(size) {\n                if (size > this.maxMapLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n                }\n                this.stack.push({\n                  type: 1,\n                  size,\n                  key: null,\n                  readCount: 0,\n                  map: {}\n                });\n              };\n              Decoder2.prototype.pushArrayState = function(size) {\n                if (size > this.maxArrayLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n                }\n                this.stack.push({\n                  type: 0,\n                  size,\n                  array: new Array(size),\n                  position: 0\n                });\n              };\n              Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                var _a;\n                if (byteLength > this.maxStrLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n                }\n                if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headerOffset;\n                var object;\n                if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                  object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n                } else {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n                }\n                this.pos += headerOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.stateIsMapKey = function() {\n                if (this.stack.length > 0) {\n                  var state = this.stack[this.stack.length - 1];\n                  return state.type === 1;\n                }\n                return false;\n              };\n              Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                if (byteLength > this.maxBinLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n                }\n                if (!this.hasRemaining(byteLength + headOffset)) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headOffset;\n                var object = this.bytes.subarray(offset, offset + byteLength);\n                this.pos += headOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                if (size > this.maxExtLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n                }\n                var extType = this.view.getInt8(this.pos + headOffset);\n                var data = this.decodeBinary(\n                  size,\n                  headOffset + 1\n                  /* extType */\n                );\n                return this.extensionCodec.decode(data, extType, this.context);\n              };\n              Decoder2.prototype.lookU8 = function() {\n                return this.view.getUint8(this.pos);\n              };\n              Decoder2.prototype.lookU16 = function() {\n                return this.view.getUint16(this.pos);\n              };\n              Decoder2.prototype.lookU32 = function() {\n                return this.view.getUint32(this.pos);\n              };\n              Decoder2.prototype.readU8 = function() {\n                var value = this.view.getUint8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readI8 = function() {\n                var value = this.view.getInt8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readU16 = function() {\n                var value = this.view.getUint16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readI16 = function() {\n                var value = this.view.getInt16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readU32 = function() {\n                var value = this.view.getUint32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readI32 = function() {\n                var value = this.view.getInt32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readU64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readI64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readF32 = function() {\n                var value = this.view.getFloat32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readF64 = function() {\n                var value = this.view.getFloat64(this.pos);\n                this.pos += 8;\n                return value;\n              };\n              return Decoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_MAX_DEPTH\", function() {\n            return DEFAULT_MAX_DEPTH;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() {\n            return DEFAULT_INITIAL_BUFFER_SIZE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var DEFAULT_MAX_DEPTH = 100;\n          var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n          var Encoder = (\n            /** @class */\n            function() {\n              function Encoder2(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxDepth === void 0) {\n                  maxDepth = DEFAULT_MAX_DEPTH;\n                }\n                if (initialBufferSize === void 0) {\n                  initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                }\n                if (sortKeys === void 0) {\n                  sortKeys = false;\n                }\n                if (forceFloat32 === void 0) {\n                  forceFloat32 = false;\n                }\n                if (ignoreUndefined === void 0) {\n                  ignoreUndefined = false;\n                }\n                if (forceIntegerToFloat === void 0) {\n                  forceIntegerToFloat = false;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxDepth = maxDepth;\n                this.initialBufferSize = initialBufferSize;\n                this.sortKeys = sortKeys;\n                this.forceFloat32 = forceFloat32;\n                this.ignoreUndefined = ignoreUndefined;\n                this.forceIntegerToFloat = forceIntegerToFloat;\n                this.pos = 0;\n                this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                this.bytes = new Uint8Array(this.view.buffer);\n              }\n              Encoder2.prototype.getUint8Array = function() {\n                return this.bytes.subarray(0, this.pos);\n              };\n              Encoder2.prototype.reinitializeState = function() {\n                this.pos = 0;\n              };\n              Encoder2.prototype.encode = function(object) {\n                this.reinitializeState();\n                this.doEncode(object, 1);\n                return this.getUint8Array();\n              };\n              Encoder2.prototype.doEncode = function(object, depth) {\n                if (depth > this.maxDepth) {\n                  throw new Error(\"Too deep objects in depth \" + depth);\n                }\n                if (object == null) {\n                  this.encodeNil();\n                } else if (typeof object === \"boolean\") {\n                  this.encodeBoolean(object);\n                } else if (typeof object === \"number\") {\n                  this.encodeNumber(object);\n                } else if (typeof object === \"string\") {\n                  this.encodeString(object);\n                } else {\n                  this.encodeObject(object, depth);\n                }\n              };\n              Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                var requiredSize = this.pos + sizeToWrite;\n                if (this.view.byteLength < requiredSize) {\n                  this.resizeBuffer(requiredSize * 2);\n                }\n              };\n              Encoder2.prototype.resizeBuffer = function(newSize) {\n                var newBuffer = new ArrayBuffer(newSize);\n                var newBytes = new Uint8Array(newBuffer);\n                var newView = new DataView(newBuffer);\n                newBytes.set(this.bytes);\n                this.view = newView;\n                this.bytes = newBytes;\n              };\n              Encoder2.prototype.encodeNil = function() {\n                this.writeU8(192);\n              };\n              Encoder2.prototype.encodeBoolean = function(object) {\n                if (object === false) {\n                  this.writeU8(194);\n                } else {\n                  this.writeU8(195);\n                }\n              };\n              Encoder2.prototype.encodeNumber = function(object) {\n                if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                  if (object >= 0) {\n                    if (object < 128) {\n                      this.writeU8(object);\n                    } else if (object < 256) {\n                      this.writeU8(204);\n                      this.writeU8(object);\n                    } else if (object < 65536) {\n                      this.writeU8(205);\n                      this.writeU16(object);\n                    } else if (object < 4294967296) {\n                      this.writeU8(206);\n                      this.writeU32(object);\n                    } else {\n                      this.writeU8(207);\n                      this.writeU64(object);\n                    }\n                  } else {\n                    if (object >= -32) {\n                      this.writeU8(224 | object + 32);\n                    } else if (object >= -128) {\n                      this.writeU8(208);\n                      this.writeI8(object);\n                    } else if (object >= -32768) {\n                      this.writeU8(209);\n                      this.writeI16(object);\n                    } else if (object >= -2147483648) {\n                      this.writeU8(210);\n                      this.writeI32(object);\n                    } else {\n                      this.writeU8(211);\n                      this.writeI64(object);\n                    }\n                  }\n                } else {\n                  if (this.forceFloat32) {\n                    this.writeU8(202);\n                    this.writeF32(object);\n                  } else {\n                    this.writeU8(203);\n                    this.writeF64(object);\n                  }\n                }\n              };\n              Encoder2.prototype.writeStringHeader = function(byteLength) {\n                if (byteLength < 32) {\n                  this.writeU8(160 + byteLength);\n                } else if (byteLength < 256) {\n                  this.writeU8(217);\n                  this.writeU8(byteLength);\n                } else if (byteLength < 65536) {\n                  this.writeU8(218);\n                  this.writeU16(byteLength);\n                } else if (byteLength < 4294967296) {\n                  this.writeU8(219);\n                  this.writeU32(byteLength);\n                } else {\n                  throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n                }\n              };\n              Encoder2.prototype.encodeString = function(object) {\n                var maxHeaderSize = 1 + 4;\n                var strLength = object.length;\n                if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                } else {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                }\n              };\n              Encoder2.prototype.encodeObject = function(object, depth) {\n                var ext = this.extensionCodec.tryToEncode(object, this.context);\n                if (ext != null) {\n                  this.encodeExtension(ext);\n                } else if (Array.isArray(object)) {\n                  this.encodeArray(object, depth);\n                } else if (ArrayBuffer.isView(object)) {\n                  this.encodeBinary(object);\n                } else if (typeof object === \"object\") {\n                  this.encodeMap(object, depth);\n                } else {\n                  throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n                }\n              };\n              Encoder2.prototype.encodeBinary = function(object) {\n                var size = object.byteLength;\n                if (size < 256) {\n                  this.writeU8(196);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(197);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(198);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large binary: \" + size);\n                }\n                var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n                this.writeU8a(bytes);\n              };\n              Encoder2.prototype.encodeArray = function(object, depth) {\n                var size = object.length;\n                if (size < 16) {\n                  this.writeU8(144 + size);\n                } else if (size < 65536) {\n                  this.writeU8(220);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(221);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large array: \" + size);\n                }\n                for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                  var item = object_1[_i];\n                  this.doEncode(item, depth + 1);\n                }\n              };\n              Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                var count = 0;\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                  var key = keys_1[_i];\n                  if (object[key] !== void 0) {\n                    count++;\n                  }\n                }\n                return count;\n              };\n              Encoder2.prototype.encodeMap = function(object, depth) {\n                var keys = Object.keys(object);\n                if (this.sortKeys) {\n                  keys.sort();\n                }\n                var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                if (size < 16) {\n                  this.writeU8(128 + size);\n                } else if (size < 65536) {\n                  this.writeU8(222);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(223);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large map object: \" + size);\n                }\n                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                  var key = keys_2[_i];\n                  var value = object[key];\n                  if (!(this.ignoreUndefined && value === void 0)) {\n                    this.encodeString(key);\n                    this.doEncode(value, depth + 1);\n                  }\n                }\n              };\n              Encoder2.prototype.encodeExtension = function(ext) {\n                var size = ext.data.length;\n                if (size === 1) {\n                  this.writeU8(212);\n                } else if (size === 2) {\n                  this.writeU8(213);\n                } else if (size === 4) {\n                  this.writeU8(214);\n                } else if (size === 8) {\n                  this.writeU8(215);\n                } else if (size === 16) {\n                  this.writeU8(216);\n                } else if (size < 256) {\n                  this.writeU8(199);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(200);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(201);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large extension object: \" + size);\n                }\n                this.writeI8(ext.type);\n                this.writeU8a(ext.data);\n              };\n              Encoder2.prototype.writeU8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setUint8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU8a = function(values) {\n                var size = values.length;\n                this.ensureBufferSizeToWrite(size);\n                this.bytes.set(values, this.pos);\n                this.pos += size;\n              };\n              Encoder2.prototype.writeI8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setInt8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setUint16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeI16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setInt16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeU32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setUint32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeI32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setInt32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setFloat32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                this.view.setFloat64(this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeU64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeI64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              return Encoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: ExtData */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return ExtData;\n          });\n          var ExtData = (\n            /** @class */\n            function() {\n              function ExtData2(type, data) {\n                this.type = type;\n                this.data = data;\n              }\n              return ExtData2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n          \\***********************************************************************/\n        /*! exports provided: ExtensionCodec */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return ExtensionCodec;\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          var ExtensionCodec = (\n            /** @class */\n            function() {\n              function ExtensionCodec2() {\n                this.builtInEncoders = [];\n                this.builtInDecoders = [];\n                this.encoders = [];\n                this.decoders = [];\n                this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n              }\n              ExtensionCodec2.prototype.register = function(_a) {\n                var type = _a.type, encode = _a.encode, decode = _a.decode;\n                if (type >= 0) {\n                  this.encoders[type] = encode;\n                  this.decoders[type] = decode;\n                } else {\n                  var index = 1 + type;\n                  this.builtInEncoders[index] = encode;\n                  this.builtInDecoders[index] = decode;\n                }\n              };\n              ExtensionCodec2.prototype.tryToEncode = function(object, context) {\n                for (var i = 0; i < this.builtInEncoders.length; i++) {\n                  var encodeExt = this.builtInEncoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = -1 - i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                for (var i = 0; i < this.encoders.length; i++) {\n                  var encodeExt = this.encoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n                  return object;\n                }\n                return null;\n              };\n              ExtensionCodec2.prototype.decode = function(data, type, context) {\n                var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n                if (decodeExt) {\n                  return decodeExt(data, type, context);\n                } else {\n                  return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n              };\n              ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n              return ExtensionCodec2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"defaultDecodeOptions\", function() {\n            return defaultDecodeOptions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return decodeMulti;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var defaultDecodeOptions = {};\n          function decode(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decode(buffer);\n          }\n          function decodeMulti(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeMulti(buffer);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return decodeAsync;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return decodeArrayStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return decodeMultiStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return decodeStream;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/stream.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\"\n          );\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          function decodeAsync(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return __awaiter(this, void 0, void 0, function() {\n              var stream, decoder;\n              return __generator(this, function(_a) {\n                stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n                decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n                return [2, decoder.decodeAsync(stream)];\n              });\n            });\n          }\n          function decodeArrayStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeArrayStream(stream);\n          }\n          function decodeMultiStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeStream(stream);\n          }\n          function decodeStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return decodeMultiStream(streamLike, options);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: encode */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          var defaultEncodeOptions = {};\n          function encode(value, options) {\n            if (options === void 0) {\n              options = defaultEncodeOptions;\n            }\n            var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n            return encoder.encode(value);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n          \\**************************************************************/\n        /*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"];\n          });\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"];\n          });\n          var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decodeAsync.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"];\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"];\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"];\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"];\n          });\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"];\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"];\n          });\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"];\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return EXT_TIMESTAMP;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return encodeTimeSpecToTimestamp;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return encodeDateToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return encodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return decodeTimestampToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return decodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"timestampExtension\", function() {\n            return timestampExtension;\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var EXT_TIMESTAMP = -1;\n          var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n          var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n          function encodeTimeSpecToTimestamp(_a) {\n            var sec = _a.sec, nsec = _a.nsec;\n            if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n              if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                var rv = new Uint8Array(4);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, sec);\n                return rv;\n              } else {\n                var secHigh = sec / 4294967296;\n                var secLow = sec & 4294967295;\n                var rv = new Uint8Array(8);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec << 2 | secHigh & 3);\n                view.setUint32(4, secLow);\n                return rv;\n              }\n            } else {\n              var rv = new Uint8Array(12);\n              var view = new DataView(rv.buffer);\n              view.setUint32(0, nsec);\n              Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n              return rv;\n            }\n          }\n          function encodeDateToTimeSpec(date) {\n            var msec = date.getTime();\n            var sec = Math.floor(msec / 1e3);\n            var nsec = (msec - sec * 1e3) * 1e6;\n            var nsecInSec = Math.floor(nsec / 1e9);\n            return {\n              sec: sec + nsecInSec,\n              nsec: nsec - nsecInSec * 1e9\n            };\n          }\n          function encodeTimestampExtension(object) {\n            if (object instanceof Date) {\n              var timeSpec = encodeDateToTimeSpec(object);\n              return encodeTimeSpecToTimestamp(timeSpec);\n            } else {\n              return null;\n            }\n          }\n          function decodeTimestampToTimeSpec(data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            switch (data.byteLength) {\n              case 4: {\n                var sec = view.getUint32(0);\n                var nsec = 0;\n                return { sec, nsec };\n              }\n              case 8: {\n                var nsec30AndSecHigh2 = view.getUint32(0);\n                var secLow32 = view.getUint32(4);\n                var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                var nsec = nsec30AndSecHigh2 >>> 2;\n                return { sec, nsec };\n              }\n              case 12: {\n                var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n                var nsec = view.getUint32(0);\n                return { sec, nsec };\n              }\n              default:\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n            }\n          }\n          function decodeTimestampExtension(data) {\n            var timeSpec = decodeTimestampToTimeSpec(data);\n            return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n          }\n          var timestampExtension = {\n            type: EXT_TIMESTAMP,\n            encode: encodeTimestampExtension,\n            decode: decodeTimestampExtension\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"UINT32_MAX\", function() {\n            return UINT32_MAX;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setUint64\", function() {\n            return setUint64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setInt64\", function() {\n            return setInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getInt64\", function() {\n            return getInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getUint64\", function() {\n            return getUint64;\n          });\n          var UINT32_MAX = 4294967295;\n          function setUint64(view, offset, value) {\n            var high = value / 4294967296;\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function setInt64(view, offset, value) {\n            var high = Math.floor(value / 4294967296);\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function getInt64(view, offset) {\n            var high = view.getInt32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n          function getUint64(view, offset) {\n            var high = view.getUint32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: prettyByte */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"prettyByte\", function() {\n            return prettyByte;\n          });\n          function prettyByte(byte) {\n            return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n          \\*********************************************************************/\n        /*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isAsyncIterable\", function() {\n            return isAsyncIterable;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"asyncIterableFromStream\", function() {\n            return asyncIterableFromStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ensureAsyncIterable\", function() {\n            return ensureAsyncIterable;\n          });\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          function isAsyncIterable(object) {\n            return object[Symbol.asyncIterator] != null;\n          }\n          function assertNonNull(value) {\n            if (value == null) {\n              throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n            }\n          }\n          function asyncIterableFromStream(stream) {\n            return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n              var reader, _a, done, value;\n              return __generator(this, function(_b) {\n                switch (_b.label) {\n                  case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                  case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                  case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done)\n                      return [3, 5];\n                    return [4, __await(void 0)];\n                  case 4:\n                    return [2, _b.sent()];\n                  case 5:\n                    assertNonNull(value);\n                    return [4, __await(value)];\n                  case 6:\n                    return [4, _b.sent()];\n                  case 7:\n                    _b.sent();\n                    return [3, 2];\n                  case 8:\n                    return [3, 10];\n                  case 9:\n                    reader.releaseLock();\n                    return [\n                      7\n                      /*endfinally*/\n                    ];\n                  case 10:\n                    return [\n                      2\n                      /*return*/\n                    ];\n                }\n              });\n            });\n          }\n          function ensureAsyncIterable(streamLike) {\n            if (isAsyncIterable(streamLike)) {\n              return streamLike;\n            } else {\n              return asyncIterableFromStream(streamLike);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n        /*!**************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n          \\**************************************************************************/\n        /*! exports provided: ensureUint8Array, createDataView */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ensureUint8Array\", function() {\n            return ensureUint8Array;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"createDataView\", function() {\n            return createDataView;\n          });\n          function ensureUint8Array(buffer) {\n            if (buffer instanceof Uint8Array) {\n              return buffer;\n            } else if (ArrayBuffer.isView(buffer)) {\n              return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            } else if (buffer instanceof ArrayBuffer) {\n              return new Uint8Array(buffer);\n            } else {\n              return Uint8Array.from(buffer);\n            }\n          }\n          function createDataView(buffer) {\n            if (buffer instanceof ArrayBuffer) {\n              return new DataView(buffer);\n            }\n            var bufferView = ensureUint8Array(buffer);\n            return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n          \\*******************************************************************/\n        /*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"utf8Count\", function() {\n            return utf8Count;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeJs\", function() {\n            return utf8EncodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_ENCODER_THRESHOLD\", function() {\n            return TEXT_ENCODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeTE\", function() {\n            return utf8EncodeTE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeJs\", function() {\n            return utf8DecodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_DECODER_THRESHOLD\", function() {\n            return TEXT_DECODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeTD\", function() {\n            return utf8DecodeTD;\n          });\n          var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n          function utf8Count(str) {\n            var strLength = str.length;\n            var byteLength = 0;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                byteLength++;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                byteLength += 2;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  byteLength += 3;\n                } else {\n                  byteLength += 4;\n                }\n              }\n            }\n            return byteLength;\n          }\n          function utf8EncodeJs(str, output, outputOffset) {\n            var strLength = str.length;\n            var offset = outputOffset;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                output[offset++] = value;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                output[offset++] = value >> 6 & 31 | 192;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  output[offset++] = value >> 12 & 15 | 224;\n                  output[offset++] = value >> 6 & 63 | 128;\n                } else {\n                  output[offset++] = value >> 18 & 7 | 240;\n                  output[offset++] = value >> 12 & 63 | 128;\n                  output[offset++] = value >> 6 & 63 | 128;\n                }\n              }\n              output[offset++] = value & 63 | 128;\n            }\n          }\n          var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n          var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\" ? 200 : 0;\n          function utf8EncodeTEencode(str, output, outputOffset) {\n            output.set(sharedTextEncoder.encode(str), outputOffset);\n          }\n          function utf8EncodeTEencodeInto(str, output, outputOffset) {\n            sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n          }\n          var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n          var CHUNK_SIZE = 4096;\n          function utf8DecodeJs(bytes, inputOffset, byteLength) {\n            var offset = inputOffset;\n            var end = offset + byteLength;\n            var units = [];\n            var result = \"\";\n            while (offset < end) {\n              var byte1 = bytes[offset++];\n              if ((byte1 & 128) === 0) {\n                units.push(byte1);\n              } else if ((byte1 & 224) === 192) {\n                var byte2 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 6 | byte2);\n              } else if ((byte1 & 240) === 224) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n              } else if ((byte1 & 248) === 240) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                var byte4 = bytes[offset++] & 63;\n                var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                if (unit > 65535) {\n                  unit -= 65536;\n                  units.push(unit >>> 10 & 1023 | 55296);\n                  unit = 56320 | unit & 1023;\n                }\n                units.push(unit);\n              } else {\n                units.push(byte1);\n              }\n              if (units.length >= CHUNK_SIZE) {\n                result += String.fromCharCode.apply(String, units);\n                units.length = 0;\n              }\n            }\n            if (units.length > 0) {\n              result += String.fromCharCode.apply(String, units);\n            }\n            return result;\n          }\n          var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n          var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\" ? 200 : 0;\n          function utf8DecodeTD(bytes, inputOffset, byteLength) {\n            var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n            return sharedTextDecoder.decode(stringBytes);\n          }\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/hypha/rpc.js\": (\n        /*!**************************!*\\\n          !*** ./src/hypha/rpc.js ***!\n          \\**************************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @msgpack/msgpack */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\"\n          );\n          const API_VERSION = \"0.3.0\";\n          const CHUNK_SIZE = 1024 * 500;\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          function getFunctionInfo(func) {\n            const funcString = func.toString();\n            const nameMatch = funcString.match(/function\\s*(\\w*)/);\n            const name = nameMatch && nameMatch[1] || \"\";\n            const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n            let params = \"\";\n            if (paramsMatch) {\n              params = paramsMatch[1].split(\",\").map((p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n            }\n            let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n            const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n            docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n            const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n            const docstring = docstringBlock || docstringLine;\n            return name && params.length > 0 && {\n              name,\n              sig: params,\n              doc: docstring\n            };\n          }\n          function concatArrayBuffers(buffers) {\n            var buffersLengths = buffers.map(function(b) {\n              return b.byteLength;\n            }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n              return p + c;\n            }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n            buffersLengths.reduce(function(p, c, i) {\n              unit8Arr.set(new Uint8Array(buffers[i]), p);\n              return p + c;\n            }, 0);\n            return unit8Arr.buffer;\n          }\n          class Timer {\n            constructor(timeout, callback, args, label) {\n              this._timeout = timeout;\n              this._callback = callback;\n              this._args = args;\n              this._label = label || \"timer\";\n              this._task = null;\n              this.started = false;\n            }\n            start() {\n              if (this.started) {\n                this.reset();\n              } else {\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            clear() {\n              if (this._task) {\n                clearTimeout(this._task);\n                this._task = null;\n                this.started = false;\n              } else {\n                console.warn(`Clearing a timer (${this._label}) which is not started`);\n              }\n            }\n            reset() {\n              if (this._task) {\n                clearTimeout(this._task);\n              }\n              this._task = setTimeout(() => {\n                this._callback.apply(this, this._args);\n              }, this._timeout * 1e3);\n              this.started = true;\n            }\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, {\n              client_id = null,\n              manager_id = null,\n              default_context = null,\n              name = null,\n              codecs = null,\n              method_timeout = null,\n              max_message_buffer_size = 0,\n              debug = false,\n              workspace = null\n            }) {\n              super(debug);\n              this._codecs = codecs || {};\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n              this._client_id = client_id;\n              this._name = name;\n              this._connection_info = null;\n              this._workspace = null;\n              this._local_workspace = workspace;\n              this.manager_id = manager_id;\n              this.default_context = default_context || {};\n              this._method_annotations = /* @__PURE__ */ new WeakMap();\n              this._manager_service = null;\n              this._max_message_buffer_size = max_message_buffer_size;\n              this._chunk_store = {};\n              this._method_timeout = method_timeout || 30;\n              this._services = {};\n              this._object_store = {\n                services: this._services\n              };\n              if (connection) {\n                this.add_service({\n                  id: \"built-in\",\n                  type: \"built-in\",\n                  name: \"RPC built-in services\",\n                  config: {\n                    require_context: true,\n                    visibility: \"public\"\n                  },\n                  ping: this._ping.bind(this),\n                  get_service: this.get_local_service.bind(this),\n                  register_service: this.register_service.bind(this),\n                  message_cache: {\n                    create: this._create_message.bind(this),\n                    append: this._append_message.bind(this),\n                    process: this._process_message.bind(this),\n                    remove: this._remove_message.bind(this)\n                  }\n                });\n                this.on(\"method\", this._handle_method.bind(this));\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n                this._emit_message = connection.emit_message.bind(connection);\n                connection.on_message(this._on_message.bind(this));\n                this._connection = connection;\n                this._get_connection_info();\n              } else {\n                this._emit_message = function() {\n                  console.log(\"No connection to emit message\");\n                };\n              }\n            }\n            async _get_connection_info() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  this._connection_info = await this._manager_service.get_connection_info();\n                  if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n                    this._local_workspace = this._connection_info.workspace;\n                  }\n                  if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n                    this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n                    const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8;\n                    this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1e3);\n                  }\n                } catch (exp) {\n                  console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n                }\n              }\n            }\n            register_codec(config) {\n              if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n                throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n              } else {\n                if (config.type) {\n                  for (let k of Object.keys(this._codecs)) {\n                    if (this._codecs[k].type === config.type || k === config.name) {\n                      delete this._codecs[k];\n                      console.warn(\"Remove duplicated codec: \" + k);\n                    }\n                  }\n                }\n                this._codecs[config[\"name\"]] = config;\n              }\n            }\n            async _ping(msg, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n              return \"pong\";\n            }\n            async ping(client_id, timeout) {\n              let method = this._generate_remote_method({\n                _rtarget: client_id,\n                _rmethod: \"services.built-in.ping\",\n                _rpromise: true,\n                _rdoc: \"Ping a remote client\",\n                _rsig: \"ping(msg)\"\n              });\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(await method(\"ping\", timeout) == \"pong\");\n            }\n            _create_message(key, heartbeat, overwrite, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              if (!this._object_store[\"message_cache\"]) {\n                this._object_store[\"message_cache\"] = {};\n              }\n              if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n              }\n              this._object_store[\"message_cache\"][key] = [];\n            }\n            _append_message(key, data, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n              cache[key].push(data);\n            }\n            _remove_message(key, context) {\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              delete cache[key];\n            }\n            _process_message(key, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              cache[key] = concatArrayBuffers(cache[key]);\n              console.debug(`Processing message ${key} (size=${cache[key].length})`);\n              let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n              const {\n                done,\n                value\n              } = unpacker.next();\n              const main = value;\n              Object.assign(main, {\n                from: context.from,\n                to: context.to,\n                user: context.user\n              });\n              main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n              Object.assign(main[\"ctx\"], this.default_context);\n              if (!done) {\n                let extra = unpacker.next();\n                Object.assign(main, extra.value);\n              }\n              this._fire(main[\"type\"], main);\n              delete cache[key];\n            }\n            _on_message(message) {\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n                let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n                const {\n                  done,\n                  value\n                } = unpacker.next();\n                const main = value;\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n              } catch (error) {\n                console.error(error);\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._services = {};\n            }\n            async disconnect() {\n              if (this._get_connection_info_task) {\n                clearTimeout(this._get_connection_info_task);\n                this._get_connection_info_task = null;\n              }\n              this._fire(\"disconnect\");\n            }\n            async get_manager_service(timeout) {\n              if (this.manager_id && !this._manager_service) {\n                this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n              }\n            }\n            get_all_local_services() {\n              return this._services;\n            }\n            get_local_service(service_id, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n              const [ws, client_id] = context[\"to\"].split(\"/\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n              const service = this._services[service_id];\n              if (!service) {\n                throw new Error(\"Service not found: \" + service_id);\n              }\n              if (service.config.visibility == \"public\") {\n                return service;\n              }\n              if (context[\"from\"].startsWith(ws + \"/\")) {\n                return service;\n              }\n              throw new Error(\"Permission denied for service: \" + service_id);\n            }\n            async get_remote_service(service_uri, timeout) {\n              timeout = timeout === void 0 ? this._method_timeout : timeout;\n              if (!service_uri && this.manager_id) {\n                service_uri = this.manager_id;\n              } else if (!service_uri.includes(\":\")) {\n                service_uri = this._client_id + \":\" + service_uri;\n              }\n              const provider = service_uri.split(\":\")[0];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n              try {\n                const method = this._generate_remote_method({\n                  _rtarget: provider,\n                  _rmethod: \"services.built-in.get_service\",\n                  _rpromise: true,\n                  _rdoc: \"Get a remote service\",\n                  _rsig: \"get_service(service_id)\"\n                });\n                const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n                svc.id = service_uri;\n                return svc;\n              } catch (e) {\n                console.error(\"Failed to get remote service: \" + service_uri, e);\n                throw e;\n              }\n            }\n            _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n              if (typeof aObject === \"function\") {\n                let method_name = object_id.split(\".\")[1];\n                this._method_annotations.set(aObject, {\n                  require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                  run_in_executor,\n                  method_id: \"services.\" + object_id,\n                  visibility\n                });\n              } else if (aObject instanceof Array || aObject instanceof Object) {\n                for (let key of Object.keys(aObject)) {\n                  let val = aObject[key];\n                  if (typeof val === \"function\" && val.__rpc_object__) {\n                    let client_id = val.__rpc_object__._rtarget;\n                    if (client_id.includes(\"/\")) {\n                      client_id = client_id.split(\"/\")[1];\n                    }\n                    if (this._client_id === client_id) {\n                      if (aObject instanceof Array) {\n                        aObject = aObject.slice();\n                      }\n                      aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n                      val = aObject[key];\n                    } else {\n                      throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n                    }\n                  }\n                  this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n                }\n              }\n            }\n            add_service(api, overwrite) {\n              if (!api || Array.isArray(api))\n                throw new Error(\"Invalid service object\");\n              if (api.constructor === Object) {\n                api = Object.assign({}, api);\n              } else {\n                const normApi = {};\n                const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n                for (let k of props) {\n                  if (k !== \"constructor\") {\n                    if (typeof api[k] === \"function\")\n                      normApi[k] = api[k].bind(api);\n                    else\n                      normApi[k] = api[k];\n                  }\n                }\n                api.id = api.id || \"default\";\n                api = normApi;\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n              if (!api.name) {\n                api.name = api.id;\n              }\n              if (!api.config) {\n                api.config = {};\n              }\n              if (!api.type) {\n                api.type = \"generic\";\n              }\n              let require_context = false, run_in_executor = false;\n              if (api.config.require_context)\n                require_context = api.config.require_context;\n              if (api.config.run_in_executor)\n                run_in_executor = true;\n              const visibility = api.config.visibility || \"protected\";\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n              this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n              if (this._services[api.id]) {\n                if (overwrite) {\n                  delete this._services[api.id];\n                } else {\n                  throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n                }\n              }\n              this._services[api.id] = api;\n              return api;\n            }\n            async register_service(api, overwrite, notify, context) {\n              if (notify === void 0)\n                notify = true;\n              if (context) {\n                const [workspace, client_id] = context[\"to\"].split(\"/\");\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n              }\n              const service = this.add_service(api, overwrite);\n              if (notify) {\n                this._fire(\"service-updated\", {\n                  service_id: service[\"id\"],\n                  api: service,\n                  type: \"add\"\n                });\n                await this._notify_service_update();\n              }\n              return {\n                id: `${this._client_id}:${service[\"id\"]}`,\n                type: service[\"type\"],\n                name: service[\"name\"],\n                description: service[\"description\"] || \"\",\n                config: service[\"config\"]\n              };\n            }\n            async unregister_service(service, notify) {\n              if (service instanceof Object) {\n                service = service.id;\n              }\n              if (!this._services[service]) {\n                throw new Error(`Service not found: ${service}`);\n              }\n              const api = this._services[service];\n              delete this._services[service];\n              this._fire(\"service-updated\", {\n                service_id: service,\n                api,\n                type: \"remove\"\n              });\n              await this._notify_service_update();\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n              let method_id = `${session_id}.${name}`;\n              let encoded = {\n                _rtype: \"method\",\n                _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                _rmethod: method_id,\n                _rpromise: false\n              };\n              const self2 = this;\n              let wrapped_callback = function() {\n                try {\n                  callback.apply(null, Array.prototype.slice.call(arguments));\n                } catch (error) {\n                  console.error(\"Error in callback:\", method_id, error);\n                } finally {\n                  if (clear_after_called && self2._object_store[session_id]) {\n                    delete self2._object_store[session_id];\n                  }\n                  if (timer && timer.started) {\n                    timer.clear();\n                  }\n                }\n              };\n              return [encoded, wrapped_callback];\n            }\n            async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n              let store = this._get_session_store(session_id, true);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n              let encoded = {};\n              if (timer && reject && this._method_timeout) {\n                encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n                encoded.interval = this._method_timeout / 2;\n                store.timer = timer;\n              } else {\n                timer = null;\n              }\n              [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n              [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n              return encoded;\n            }\n            async _send_chunks(data, target_id, session_id) {\n              let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n              let message_cache = remote_services.message_cache;\n              let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n              await message_cache.create(message_id, !!session_id);\n              let total_size = data.length;\n              let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n              for (let idx = 0; idx < chunk_num; idx++) {\n                let start_byte = idx * CHUNK_SIZE;\n                await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id);\n              }\n              await message_cache.process(message_id, !!session_id);\n            }\n            emit(main_message, extra_data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n              let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n              if (extra_data) {\n                const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                message_package = new Uint8Array([...message_package, ...extra]);\n              }\n              const total_size = message_package.length;\n              if (total_size <= CHUNK_SIZE + 1024) {\n                return this._emit_message(message_package);\n              } else {\n                throw new Error(\"Message is too large to send in one go.\");\n              }\n            }\n            _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n              let target_id = encoded_method._rtarget;\n              if (remote_workspace && !target_id.includes(\"/\")) {\n                if (remote_workspace !== target_id) {\n                  target_id = remote_workspace + \"/\" + target_id;\n                }\n                encoded_method._rtarget = target_id;\n              }\n              let method_id = encoded_method._rmethod;\n              let with_promise = encoded_method._rpromise;\n              const self2 = this;\n              function remote_method() {\n                return new Promise(async (resolve, reject) => {\n                  let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  if (local_parent) {\n                    local_session_id = local_parent + \".\" + local_session_id;\n                  }\n                  let store = self2._get_session_store(local_session_id, true);\n                  if (!store) {\n                    reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n                    return;\n                  }\n                  store[\"target_id\"] = target_id;\n                  const args = await self2._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  let main_message = {\n                    type: \"method\",\n                    from: self2._local_workspace ? self2._local_workspace + \"/\" + self2._client_id : self2._client_id,\n                    to: target_id,\n                    method: method_id\n                  };\n                  let extra_data = {};\n                  if (args) {\n                    extra_data[\"args\"] = args;\n                  }\n                  if (withKwargs) {\n                    extra_data[\"with_kwargs\"] = withKwargs;\n                  }\n                  if (remote_parent) {\n                    main_message[\"parent\"] = remote_parent;\n                  }\n                  let timer = null;\n                  if (with_promise) {\n                    main_message[\"session\"] = local_session_id;\n                    let method_name = `${target_id}:${method_id}`;\n                    timer = new Timer(self2._method_timeout, reject, [`Method call time out: ${method_name}`], method_name);\n                    let clear_after_called = true;\n                    for (let arg of args) {\n                      if (typeof arg === \"object\" && arg._rintf === true) {\n                        clear_after_called = false;\n                        break;\n                      }\n                    }\n                    extra_data[\"promise\"] = await self2._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n                  }\n                  let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n                  if (extra_data) {\n                    const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                    message_package = new Uint8Array([...message_package, ...extra]);\n                  }\n                  const total_size = message_package.length;\n                  if (total_size <= CHUNK_SIZE + 1024) {\n                    self2._emit_message(message_package).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  } else {\n                    self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  }\n                });\n              }\n              remote_method.__rpc_object__ = encoded_method;\n              const parts = method_id.split(\".\");\n              remote_method.__name__ = parts[parts.length - 1];\n              remote_method.__doc__ = encoded_method._rdoc;\n              remote_method.__sig__ = encoded_method._rsig;\n              return remote_method;\n            }\n            async _notify_service_update() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  await this._manager_service.update_client_info(this.get_client_info());\n                } catch (exp) {\n                  console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n                }\n              }\n            }\n            get_client_info() {\n              const services = [];\n              for (let service of Object.values(this._services)) {\n                services.push({\n                  id: `${this._client_id}:${service[\"id\"]}`,\n                  type: service[\"type\"],\n                  name: service[\"name\"],\n                  description: service[\"description\"] || \"\",\n                  config: service[\"config\"]\n                });\n              }\n              return {\n                id: this._client_id,\n                services\n              };\n            }\n            async _handle_method(data) {\n              let reject = null;\n              let heartbeat_task = null;\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n                const method_name = data.from + \":\" + data.method;\n                const remote_workspace = data.from.split(\"/\")[0];\n                data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                data[\"ctx\"][\"to\"] = data[\"to\"];\n                const local_workspace = data.to.split(\"/\")[0];\n                const local_parent = data.parent;\n                let resolve, reject2;\n                if (data.promise) {\n                  const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n                  resolve = promise.resolve;\n                  reject2 = promise.reject;\n                  if (promise.heartbeat && promise.interval) {\n                    async function heartbeat() {\n                      try {\n                        await promise.heartbeat();\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                    heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                  }\n                }\n                let method;\n                try {\n                  method = indexObject(this._object_store, data[\"method\"]);\n                } catch (e) {\n                  console.debug(\"Failed to find method\", method_name, e);\n                  throw new Error(`Method not found: ${method_name}`);\n                }\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name);\n                if (this._method_annotations.has(method)) {\n                  if (this._method_annotations.get(method).visibility === \"protected\") {\n                    if (local_workspace !== remote_workspace) {\n                      throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n                    }\n                  }\n                } else {\n                  let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                  if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                    session_target_id = local_workspace + \"/\" + session_target_id;\n                  }\n                  if (session_target_id !== data.from) {\n                    throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n                  }\n                }\n                if (local_parent) {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n                }\n                let args;\n                if (data.args) {\n                  args = await this._decode(data.args, data.session, null, remote_workspace, null);\n                } else {\n                  args = [];\n                }\n                if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                  args.push(data.ctx);\n                }\n                if (data.promise) {\n                  const result = method.apply(null, args);\n                  if (result instanceof Promise) {\n                    result.then((result2) => {\n                      resolve(result2);\n                      clearInterval(heartbeat_task);\n                    }).catch((err) => {\n                      reject2(err);\n                      clearInterval(heartbeat_task);\n                    });\n                  } else {\n                    resolve(result);\n                    clearInterval(heartbeat_task);\n                  }\n                } else {\n                  method.apply(null, args);\n                  clearInterval(heartbeat_task);\n                }\n              } catch (err) {\n                if (reject) {\n                  reject(err);\n                  console.debug(\"Error during calling method: \", err);\n                } else {\n                  console.error(\"Error during calling method: \", err);\n                }\n                clearInterval(heartbeat_task);\n              }\n            }\n            encode(aObject, session_id) {\n              return this._encode(aObject, session_id);\n            }\n            _get_session_store(session_id, create) {\n              let store = this._object_store;\n              const levels = session_id.split(\".\");\n              if (create) {\n                const last_index = levels.length - 1;\n                for (let level of levels.slice(0, last_index)) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                if (!store[levels[last_index]]) {\n                  store[levels[last_index]] = {};\n                }\n                return store[levels[last_index]];\n              } else {\n                for (let level of levels) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                return store;\n              }\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, session_id, local_workspace) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                return aObject;\n              }\n              if (aObject instanceof ArrayBuffer) {\n                return {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject)\n                };\n              }\n              if (aObject.__rpc_object__) {\n                return aObject.__rpc_object__;\n              }\n              let bObject;\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                const temp = aObject._rtype;\n                delete aObject._rtype;\n                bObject = await this._encode(aObject, session_id, local_workspace);\n                bObject._rtype = temp;\n                return bObject;\n              }\n              if (typeof aObject === \"function\") {\n                if (this._method_annotations.has(aObject)) {\n                  let annotation = this._method_annotations.get(aObject);\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: annotation.method_id,\n                    _rpromise: true\n                  };\n                } else {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n                  let object_id;\n                  if (aObject.__name__) {\n                    object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n                  } else {\n                    object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  }\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: true\n                  };\n                  let store = this._get_session_store(session_id, true);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n                  store[object_id] = aObject;\n                }\n                bObject._rdoc = aObject.__doc__;\n                bObject._rsig = aObject.__sig__;\n                if (!bObject._rdoc || !bObject._rsig) {\n                  try {\n                    const funcInfo = getFunctionInfo(aObject);\n                    if (funcInfo && !bObject._rdoc) {\n                      bObject._rdoc = `${funcInfo.doc}`;\n                    }\n                    if (funcInfo && !bObject._rsig) {\n                      bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n                    }\n                  } catch (e) {\n                    console.error(\"Failed to extract function docstring:\", aObject);\n                  }\n                }\n                return bObject;\n              }\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (typeof encodedObj === \"object\") {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(v_buffer.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString(),\n                  _rtrace: aObject.stack\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (aObject instanceof Blob) {\n                let seek = function(pos) {\n                  _current_pos = pos;\n                };\n                let _current_pos = 0;\n                async function read(length) {\n                  let blob;\n                  if (length) {\n                    blob = aObject.slice(_current_pos, _current_pos + length);\n                  } else {\n                    blob = aObject.slice(_current_pos);\n                  }\n                  const ret = new Uint8Array(await blob.arrayBuffer());\n                  _current_pos = _current_pos + ret.byteLength;\n                  return ret;\n                }\n                bObject = {\n                  _rtype: \"iostream\",\n                  _rnative: \"js:blob\",\n                  type: aObject.type,\n                  name: aObject.name,\n                  size: aObject.size,\n                  path: aObject._path || aObject.webkitRelativePath,\n                  read: await this._encode(read, session_id, local_workspace),\n                  seek: await this._encode(seek, session_id, local_workspace)\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: new Uint8Array(aObject.buffer),\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject.buffer)\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                const keys = Object.keys(aObject);\n                for (let k of keys) {\n                  bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n                }\n              } else {\n                throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async decode(aObject) {\n              return await this._decode(aObject);\n            }\n            async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject._rtype) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  aObject._rtype = temp;\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"method\") {\n                  bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                  bObject = new arraytype(buffer);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                } else if (aObject._rtype === \"iostream\") {\n                  if (aObject._rnative === \"js:blob\") {\n                    const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n                    const bytes = await read();\n                    bObject = new Blob([bytes], {\n                      type: aObject.type,\n                      name: aObject.name\n                    });\n                  } else {\n                    bObject = {};\n                    for (let k of Object.keys(aObject)) {\n                      if (!k.startsWith(\"_\")) {\n                        bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n                      }\n                    }\n                  }\n                  bObject[\"__rpc_object__\"] = aObject;\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  bObject._rtype = temp;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              return bObject;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/sse-client.js\": (\n        /*!*********************************!*\\\n          !*** ./src/hypha/sse-client.js ***!\n          \\*********************************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, getRTCService, registerRTCService, login, connectToServer */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"login\", function() {\n            return login;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"connectToServer\", function() {\n            return connectToServer;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"API_VERSION\"];\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"loadRequirements\"];\n          });\n          var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./webrtc-client.js */\n            \"./src/hypha/webrtc-client.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"getRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"registerRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ../../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_3__[\"version\"];\n          });\n          function b64toArrayBuffer(base64, type = \"application/octet-stream\") {\n            return fetch(`data:${type};base64,${base64}`).then((res) => res.arrayBuffer());\n          }\n          class SSERPCConnection {\n            constructor(server_url, client_id, workspace, token, timeout = 120) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(server_url && client_id, \"server_url and client_id are required\");\n              server_url = server_url + \"?client_id=\" + client_id;\n              if (workspace) {\n                server_url += \"&workspace=\" + workspace;\n              }\n              if (token) {\n                server_url += \"&token=\" + token;\n              }\n              server_url += \"&session_id=\" + Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n              this._events = null;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._server_url = server_url;\n              this._timeout = timeout * 1e3;\n              this._opening = false;\n              this._retry_count = 0;\n              this._closing = false;\n            }\n            set_reconnection_token(token) {\n              this._reconnection_token = token;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            open() {\n              if (this._opening)\n                return this._opening;\n              this._opening = new Promise((resolve, reject) => {\n                const server_url = this._reconnection_token ? `${this._server_url}&reconnection_token=${this._reconnection_token}` : this._server_url;\n                console.info(\"Creating a new connection to \", server_url.split(\"?\")[0]);\n                this._events = new EventSource(server_url);\n                this._events.onmessage = async (event) => {\n                  const data = await b64toArrayBuffer(event.data);\n                  this._handle_message(data);\n                };\n                this._events.onclose = (event) => {\n                  console.log(\"eventsource closed\");\n                  if (!this._closing) {\n                    console.log(\"Connection interrupted, retrying...\");\n                    this._retry_count++;\n                    setTimeout(() => this.open(), this._timeout);\n                  }\n                  this._events = null;\n                  this._opening = false;\n                  reject(\"closed\");\n                };\n                this._events.onerror = (event) => {\n                  console.trace();\n                  console.log(\"Error occurred in eventsource connection: \", event.message);\n                  debugger;\n                  reject(event.toString());\n                };\n                this._events.onopen = (event) => {\n                  resolve(true);\n                };\n              });\n              return this._opening;\n            }\n            async _send(data) {\n              await fetch(this._server_url, {\n                method: \"POST\",\n                mode: \"cors\",\n                // no-cors, *cors, same-origin\n                cache: \"no-cache\",\n                // *default, no-cache, reload, force-cache, only-if-cached\n                credentials: \"same-origin\",\n                // include, *same-origin, omit\n                headers: {\n                  \"Content-Type\": \"octet-stream\"\n                  // 'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                redirect: \"follow\",\n                // manual, *follow, error\n                referrerPolicy: \"no-referrer\",\n                // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url\n                body: data\n                // body data type must match \"Content-Type\" header\n              });\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n              if (!this._events || this._events.readyState === EventSource.CLOSED) {\n                await this.open();\n              }\n              await this._send(data);\n            }\n            disconnect(reason) {\n              this._closing = true;\n              const ev = this._events;\n              this._events = null;\n              if (ev && ev.readyState === EventSource.OPEN) {\n                ev.close();\n              }\n              console.info(`EventSource connection disconnected (${reason})`);\n            }\n          }\n          function normalizeServerUrl(server_url) {\n            if (!server_url)\n              throw new Error(\"server_url is required\");\n            server_url = server_url.replace(/\\/$/, \"\") + \"/sse\";\n            return server_url;\n          }\n          async function login(config) {\n            const service_id = config.login_service_id || \"public/*:hypha-login\";\n            const timeout = config.login_timeout || 120;\n            const callback = config.login_callback;\n            const server = await connectToServer({\n              name: \"initial login client\",\n              server_url: config.server_url,\n              method_timeout: timeout\n            });\n            try {\n              const svc = await server.get_service(service_id);\n              const context = await svc.start();\n              if (callback) {\n                await callback(context);\n              } else {\n                console.log(`Please open your browser and login at ${context.login_url}`);\n              }\n              return await svc.check(context.key, timeout);\n            } catch (error) {\n              throw error;\n            } finally {\n              await server.disconnect();\n            }\n          }\n          async function connectToServer(config) {\n            let clientId = config.client_id;\n            if (!clientId) {\n              clientId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n            }\n            let server_url = normalizeServerUrl(config.server_url);\n            let connection = new SSERPCConnection(server_url, clientId, config.workspace, config.token, config.method_timeout || 120);\n            await connection.open();\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: \"workspace-manager\",\n              default_context: {\n                connection_type: \"eventsource\"\n              },\n              name: config.name,\n              method_timeout: config.method_timeout\n            });\n            const wm = await rpc.get_remote_service(\"workspace-manager:default\", config.method_timeout);\n            wm.rpc = rpc;\n            async function _export(api) {\n              api.id = \"default\";\n              api.name = config.name || api.id;\n              await rpc.register_service(api, true);\n            }\n            async function getPlugin(query) {\n              return await wm.get_service(query + \":default\");\n            }\n            async function disconnect() {\n              await rpc.disconnect();\n              await connection.disconnect();\n            }\n            wm.export = _export;\n            wm.getPlugin = getPlugin;\n            wm.listPlugins = wm.listServices;\n            wm.disconnect = disconnect;\n            wm.registerCodec = rpc.register_codec.bind(rpc);\n            if (config.webrtc) {\n              await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"])(wm, clientId + \"-rtc\", config.webrtc_config);\n            }\n            if (wm.get_service || wm.getService) {\n              const _get_service = wm.get_service || wm.getService;\n              wm.get_service = async function(query, webrtc, webrtc_config) {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])([void 0, true, false, \"auto\"].includes(webrtc), \"webrtc must be true, false or 'auto'\");\n                const svc = await _get_service(query);\n                if (webrtc === true || webrtc === \"auto\") {\n                  if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n                    const client = svc.id.split(\":\")[0];\n                    try {\n                      const peer = await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"])(wm, client + \":\" + client.split(\"/\")[1] + \"-rtc\", webrtc_config);\n                      const rtcSvc = await peer.get_service(svc.id.split(\":\")[1]);\n                      rtcSvc._webrtc = true;\n                      rtcSvc._peer = peer;\n                      rtcSvc._service = svc;\n                      return rtcSvc;\n                    } catch (e) {\n                      console.warn(\"Failed to get webrtc service, using eventsource connection\", e);\n                    }\n                  }\n                  if (webrtc === true) {\n                    throw new Error(\"Failed to get the service via webrtc\");\n                  }\n                }\n                return svc;\n              };\n              wm.getService = wm.get_service;\n            }\n            return wm;\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/utils.js\": (\n        /*!****************************!*\\\n          !*** ./src/hypha/utils.js ***!\n          \\****************************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_179193__) {\n          \"use strict\";\n          __nested_webpack_require_179193__.r(__nested_webpack_exports__);\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"assert\", function() {\n            return assert;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"waitFor\", function() {\n            return waitFor;\n          });\n          __nested_webpack_require_179193__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message || \"Assertion failed\");\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          function waitFor(prom, time, error) {\n            let timer;\n            return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n              rej(error || \"Timeout Error\");\n            }, time * 1e3))]).finally(() => clearTimeout(timer));\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/webrtc-client.js\": (\n        /*!************************************!*\\\n          !*** ./src/hypha/webrtc-client.js ***!\n          \\************************************/\n        /*! exports provided: getRTCService, registerRTCService */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"getRTCService\", function() {\n            return getRTCService;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"registerRTCService\", function() {\n            return registerRTCService;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          class WebRTCConnection {\n            constructor(channel) {\n              this._data_channel = channel;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._data_channel.onmessage = async (event) => {\n                let data = event.data;\n                if (data instanceof Blob) {\n                  data = await data.arrayBuffer();\n                }\n                this._handle_message(data);\n              };\n              const self2 = this;\n              this._data_channel.onclose = function() {\n                console.log(\"websocket closed\");\n                self2._data_channel = null;\n              };\n            }\n            set_reconnection_token(token) {\n              this._reconnection_token = token;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n              try {\n                this._data_channel.send(data);\n              } catch (exp) {\n                console.error(`Failed to send data, error: ${exp}`);\n                throw exp;\n              }\n            }\n            async disconnect(reason) {\n              this._data_channel = null;\n              console.info(`data channel connection disconnected (${reason})`);\n            }\n          }\n          async function _setupRPC(config) {\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.channel, \"No channel provided\");\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(config.workspace, \"No workspace provided\");\n            const channel = config.channel;\n            const clientId = config.client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n            const connection = new WebRTCConnection(channel);\n            config.context = config.context || {};\n            config.context.connection_type = \"webrtc\";\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: null,\n              default_context: config.context,\n              name: config.name,\n              method_timeout: config.method_timeout || 10,\n              workspace: config.workspace\n            });\n            return rpc;\n          }\n          async function _createOffer(params, server, config, onInit, context) {\n            config = config || {};\n            let offer = new RTCSessionDescription({\n              sdp: params.sdp,\n              type: params.type\n            });\n            let pc = new RTCPeerConnection({\n              iceServers: config.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            if (server) {\n              pc.addEventListener(\"datachannel\", async (event) => {\n                const channel = event.channel;\n                let ctx = null;\n                if (context && context.user)\n                  ctx = {\n                    user: context.user\n                  };\n                const rpc = await _setupRPC({\n                  channel,\n                  client_id: channel.label,\n                  workspace: server.config.workspace,\n                  context: ctx\n                });\n                rpc._services = server.rpc._services;\n              });\n            }\n            if (onInit) {\n              await onInit(pc);\n            }\n            await pc.setRemoteDescription(offer);\n            let answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            return {\n              sdp: pc.localDescription.sdp,\n              type: pc.localDescription.type,\n              workspace: server.config.workspace\n            };\n          }\n          async function getRTCService(server, service_id, config) {\n            config = config || {};\n            config.peer_id = config.peer_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n            const pc = new RTCPeerConnection({\n              iceServers: config.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            return new Promise(async (resolve, reject) => {\n              try {\n                pc.addEventListener(\"connectionstatechange\", () => {\n                  if (pc.connectionState === \"failed\") {\n                    pc.close();\n                    reject(new Error(\"Connection failed\"));\n                  }\n                }, false);\n                if (config.on_init) {\n                  await config.on_init(pc);\n                  delete config.on_init;\n                }\n                let channel = pc.createDataChannel(config.peer_id, {\n                  ordered: true\n                });\n                channel.binaryType = \"arraybuffer\";\n                const offer = await pc.createOffer();\n                await pc.setLocalDescription(offer);\n                const svc = await server.getService(service_id);\n                const answer = await svc.offer({\n                  sdp: pc.localDescription.sdp,\n                  type: pc.localDescription.type\n                });\n                channel.onopen = () => {\n                  config.channel = channel;\n                  config.workspace = answer.workspace;\n                  setTimeout(async () => {\n                    const rpc = await _setupRPC(config);\n                    pc.rpc = rpc;\n                    async function getService(name) {\n                      return await rpc.get_remote_service(config.peer_id + \":\" + name);\n                    }\n                    async function disconnect() {\n                      await rpc.disconnect();\n                      pc.close();\n                    }\n                    pc.get_service = getService;\n                    pc.getService = getService;\n                    pc.disconnect = disconnect;\n                    pc.register_codec = rpc.register_codec;\n                    pc.registerCodec = rpc.register_codec;\n                    resolve(pc);\n                  }, 500);\n                };\n                channel.onclose = () => reject(new Error(\"Data channel closed\"));\n                await pc.setRemoteDescription(new RTCSessionDescription({\n                  sdp: answer.sdp,\n                  type: answer.type\n                }));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          }\n          async function registerRTCService(server, service_id, config) {\n            config = config || {\n              visibility: \"protected\",\n              require_context: true\n            };\n            const onInit = config.on_init;\n            delete config.on_init;\n            await server.registerService({\n              id: service_id,\n              config,\n              offer: (params, context) => _createOffer(params, server, config, onInit, context)\n            });\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js ***!
  \************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name2, getter) {\n        if (!__webpack_require__2.o(exports2, name2)) {\n          Object.defineProperty(exports2, name2, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/hypha/websocket-client.js\");\n    }({\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: CachedKeyDecoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"CachedKeyDecoder\", function() {\n            return CachedKeyDecoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var DEFAULT_MAX_KEY_LENGTH = 16;\n          var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n          var CachedKeyDecoder = (\n            /** @class */\n            function() {\n              function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                if (maxKeyLength === void 0) {\n                  maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                }\n                if (maxLengthPerKey === void 0) {\n                  maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                }\n                this.maxKeyLength = maxKeyLength;\n                this.maxLengthPerKey = maxLengthPerKey;\n                this.hit = 0;\n                this.miss = 0;\n                this.caches = [];\n                for (var i = 0; i < this.maxKeyLength; i++) {\n                  this.caches.push([]);\n                }\n              }\n              CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                return byteLength > 0 && byteLength <= this.maxKeyLength;\n              };\n              CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                var records = this.caches[byteLength - 1];\n                FIND_CHUNK:\n                  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                    var record = records_1[_i];\n                    var recordBytes = record.bytes;\n                    for (var j = 0; j < byteLength; j++) {\n                      if (recordBytes[j] !== bytes[inputOffset + j]) {\n                        continue FIND_CHUNK;\n                      }\n                    }\n                    return record.str;\n                  }\n                return null;\n              };\n              CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                var records = this.caches[bytes.length - 1];\n                var record = { bytes, str: value };\n                if (records.length >= this.maxLengthPerKey) {\n                  records[Math.random() * records.length | 0] = record;\n                } else {\n                  records.push(record);\n                }\n              };\n              CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                var cachedValue = this.find(bytes, inputOffset, byteLength);\n                if (cachedValue != null) {\n                  this.hit++;\n                  return cachedValue;\n                }\n                this.miss++;\n                var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n                var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                this.store(slicedCopyOfBytes, str);\n                return str;\n              };\n              return CachedKeyDecoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: DecodeError */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return DecodeError;\n          });\n          var __extends = function() {\n            var extendStatics = function(d, b) {\n              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                d2.__proto__ = b2;\n              } || function(d2, b2) {\n                for (var p in b2)\n                  if (Object.prototype.hasOwnProperty.call(b2, p))\n                    d2[p] = b2[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function(d, b) {\n              if (typeof b !== \"function\" && b !== null)\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          var DecodeError = (\n            /** @class */\n            function(_super) {\n              __extends(DecodeError2, _super);\n              function DecodeError2(message) {\n                var _this = _super.call(this, message) || this;\n                var proto = Object.create(DecodeError2.prototype);\n                Object.setPrototypeOf(_this, proto);\n                Object.defineProperty(_this, \"name\", {\n                  configurable: true,\n                  enumerable: false,\n                  value: DecodeError2.name\n                });\n                return _this;\n              }\n              return DecodeError2;\n            }(Error)\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return DataViewIndexOutOfBoundsError;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/prettyByte.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./CachedKeyDecoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n          );\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve2) {\n                resolve2(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve2, reject2) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __asyncValues = function(o) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i);\n            function verb(n) {\n              i[n] = o[n] && function(v) {\n                return new Promise(function(resolve2, reject2) {\n                  v = o[n](v), settle(resolve2, reject2, v.done, v.value);\n                });\n              };\n            }\n            function settle(resolve2, reject2, d, v) {\n              Promise.resolve(v).then(function(v2) {\n                resolve2({ value: v2, done: d });\n              }, reject2);\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject2(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          var isValidMapKeyType = function(key) {\n            var keyType = typeof key;\n            return keyType === \"string\" || keyType === \"number\";\n          };\n          var HEAD_BYTE_REQUIRED = -1;\n          var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n          var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n          var DataViewIndexOutOfBoundsError = function() {\n            try {\n              EMPTY_VIEW.getInt8(0);\n            } catch (e) {\n              return e.constructor;\n            }\n            throw new Error(\"never reached\");\n          }();\n          var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n          var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\n          var Decoder = (\n            /** @class */\n            function() {\n              function Decoder2(extensionCodec, context2, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context2 === void 0) {\n                  context2 = void 0;\n                }\n                if (maxStrLength === void 0) {\n                  maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxBinLength === void 0) {\n                  maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxArrayLength === void 0) {\n                  maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxMapLength === void 0) {\n                  maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxExtLength === void 0) {\n                  maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (keyDecoder === void 0) {\n                  keyDecoder = sharedCachedKeyDecoder;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context2;\n                this.maxStrLength = maxStrLength;\n                this.maxBinLength = maxBinLength;\n                this.maxArrayLength = maxArrayLength;\n                this.maxMapLength = maxMapLength;\n                this.maxExtLength = maxExtLength;\n                this.keyDecoder = keyDecoder;\n                this.totalPos = 0;\n                this.pos = 0;\n                this.view = EMPTY_VIEW;\n                this.bytes = EMPTY_BYTES;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack = [];\n              }\n              Decoder2.prototype.reinitializeState = function() {\n                this.totalPos = 0;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack.length = 0;\n              };\n              Decoder2.prototype.setBuffer = function(buffer) {\n                this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n                this.pos = 0;\n              };\n              Decoder2.prototype.appendBuffer = function(buffer) {\n                if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                  this.setBuffer(buffer);\n                } else {\n                  var remainingData = this.bytes.subarray(this.pos);\n                  var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                  var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                  newBuffer.set(remainingData);\n                  newBuffer.set(newData, remainingData.length);\n                  this.setBuffer(newBuffer);\n                }\n              };\n              Decoder2.prototype.hasRemaining = function(size) {\n                return this.view.byteLength - this.pos >= size;\n              };\n              Decoder2.prototype.createExtraByteError = function(posToShow) {\n                var _a = this, view = _a.view, pos = _a.pos;\n                return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n              };\n              Decoder2.prototype.decode = function(buffer) {\n                this.reinitializeState();\n                this.setBuffer(buffer);\n                var object = this.doDecodeSync();\n                if (this.hasRemaining(1)) {\n                  throw this.createExtraByteError(this.pos);\n                }\n                return object;\n              };\n              Decoder2.prototype.decodeMulti = function(buffer) {\n                return __generator(this, function(_a) {\n                  switch (_a.label) {\n                    case 0:\n                      this.reinitializeState();\n                      this.setBuffer(buffer);\n                      _a.label = 1;\n                    case 1:\n                      if (!this.hasRemaining(1))\n                        return [3, 3];\n                      return [4, this.doDecodeSync()];\n                    case 2:\n                      _a.sent();\n                      return [3, 1];\n                    case 3:\n                      return [\n                        2\n                        /*return*/\n                      ];\n                  }\n                });\n              };\n              Decoder2.prototype.decodeAsync = function(stream) {\n                var stream_1, stream_1_1;\n                var e_1, _a;\n                return __awaiter(this, void 0, void 0, function() {\n                  var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                  return __generator(this, function(_c) {\n                    switch (_c.label) {\n                      case 0:\n                        decoded = false;\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                      case 2:\n                        return [4, stream_1.next()];\n                      case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                          return [3, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                          object = this.doDecodeSync();\n                          decoded = true;\n                        } catch (e) {\n                          if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e;\n                          }\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                      case 4:\n                        return [3, 2];\n                      case 5:\n                        return [3, 12];\n                      case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3, 12];\n                      case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                          return [3, 9];\n                        return [4, _a.call(stream_1)];\n                      case 8:\n                        _c.sent();\n                        _c.label = 9;\n                      case 9:\n                        return [3, 11];\n                      case 10:\n                        if (e_1)\n                          throw e_1.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 11:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 12:\n                        if (decoded) {\n                          if (this.hasRemaining(1)) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          return [2, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.decodeArrayStream = function(stream) {\n                return this.decodeMultiAsync(stream, true);\n              };\n              Decoder2.prototype.decodeStream = function(stream) {\n                return this.decodeMultiAsync(stream, false);\n              };\n              Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                  var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                  var e_3, _a;\n                  return __generator(this, function(_b) {\n                    switch (_b.label) {\n                      case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                      case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                      case 2:\n                        return [4, __await(stream_2.next())];\n                      case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                          return [3, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                          arrayItemsLeft = this.readArraySize();\n                          isArrayHeaderRequired = false;\n                          this.complete();\n                        }\n                        _b.label = 4;\n                      case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                      case 5:\n                        if (false) {}\n                        return [4, __await(this.doDecodeSync())];\n                      case 6:\n                        return [4, _b.sent()];\n                      case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                          return [3, 8];\n                        }\n                        return [3, 5];\n                      case 8:\n                        return [3, 10];\n                      case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                          throw e_2;\n                        }\n                        return [3, 10];\n                      case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                      case 11:\n                        return [3, 2];\n                      case 12:\n                        return [3, 19];\n                      case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3, 19];\n                      case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                          return [3, 16];\n                        return [4, __await(_a.call(stream_2))];\n                      case 15:\n                        _b.sent();\n                        _b.label = 16;\n                      case 16:\n                        return [3, 18];\n                      case 17:\n                        if (e_3)\n                          throw e_3.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 18:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 19:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.doDecodeSync = function() {\n                DECODE:\n                  while (true) {\n                    var headByte = this.readHeadByte();\n                    var object = void 0;\n                    if (headByte >= 224) {\n                      object = headByte - 256;\n                    } else if (headByte < 192) {\n                      if (headByte < 128) {\n                        object = headByte;\n                      } else if (headByte < 144) {\n                        var size = headByte - 128;\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte < 160) {\n                        var size = headByte - 144;\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else {\n                        var byteLength = headByte - 160;\n                        object = this.decodeUtf8String(byteLength, 0);\n                      }\n                    } else if (headByte === 192) {\n                      object = null;\n                    } else if (headByte === 194) {\n                      object = false;\n                    } else if (headByte === 195) {\n                      object = true;\n                    } else if (headByte === 202) {\n                      object = this.readF32();\n                    } else if (headByte === 203) {\n                      object = this.readF64();\n                    } else if (headByte === 204) {\n                      object = this.readU8();\n                    } else if (headByte === 205) {\n                      object = this.readU16();\n                    } else if (headByte === 206) {\n                      object = this.readU32();\n                    } else if (headByte === 207) {\n                      object = this.readU64();\n                    } else if (headByte === 208) {\n                      object = this.readI8();\n                    } else if (headByte === 209) {\n                      object = this.readI16();\n                    } else if (headByte === 210) {\n                      object = this.readI32();\n                    } else if (headByte === 211) {\n                      object = this.readI64();\n                    } else if (headByte === 217) {\n                      var byteLength = this.lookU8();\n                      object = this.decodeUtf8String(byteLength, 1);\n                    } else if (headByte === 218) {\n                      var byteLength = this.lookU16();\n                      object = this.decodeUtf8String(byteLength, 2);\n                    } else if (headByte === 219) {\n                      var byteLength = this.lookU32();\n                      object = this.decodeUtf8String(byteLength, 4);\n                    } else if (headByte === 220) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 221) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 222) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 223) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 196) {\n                      var size = this.lookU8();\n                      object = this.decodeBinary(size, 1);\n                    } else if (headByte === 197) {\n                      var size = this.lookU16();\n                      object = this.decodeBinary(size, 2);\n                    } else if (headByte === 198) {\n                      var size = this.lookU32();\n                      object = this.decodeBinary(size, 4);\n                    } else if (headByte === 212) {\n                      object = this.decodeExtension(1, 0);\n                    } else if (headByte === 213) {\n                      object = this.decodeExtension(2, 0);\n                    } else if (headByte === 214) {\n                      object = this.decodeExtension(4, 0);\n                    } else if (headByte === 215) {\n                      object = this.decodeExtension(8, 0);\n                    } else if (headByte === 216) {\n                      object = this.decodeExtension(16, 0);\n                    } else if (headByte === 199) {\n                      var size = this.lookU8();\n                      object = this.decodeExtension(size, 1);\n                    } else if (headByte === 200) {\n                      var size = this.lookU16();\n                      object = this.decodeExtension(size, 2);\n                    } else if (headByte === 201) {\n                      var size = this.lookU32();\n                      object = this.decodeExtension(size, 4);\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                    this.complete();\n                    var stack = this.stack;\n                    while (stack.length > 0) {\n                      var state = stack[stack.length - 1];\n                      if (state.type === 0) {\n                        state.array[state.position] = object;\n                        state.position++;\n                        if (state.position === state.size) {\n                          stack.pop();\n                          object = state.array;\n                        } else {\n                          continue DECODE;\n                        }\n                      } else if (state.type === 1) {\n                        if (!isValidMapKeyType(object)) {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                        }\n                        if (object === \"__proto__\") {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                        }\n                        state.key = object;\n                        state.type = 2;\n                        continue DECODE;\n                      } else {\n                        state.map[state.key] = object;\n                        state.readCount++;\n                        if (state.readCount === state.size) {\n                          stack.pop();\n                          object = state.map;\n                        } else {\n                          state.key = null;\n                          state.type = 1;\n                          continue DECODE;\n                        }\n                      }\n                    }\n                    return object;\n                  }\n              };\n              Decoder2.prototype.readHeadByte = function() {\n                if (this.headByte === HEAD_BYTE_REQUIRED) {\n                  this.headByte = this.readU8();\n                }\n                return this.headByte;\n              };\n              Decoder2.prototype.complete = function() {\n                this.headByte = HEAD_BYTE_REQUIRED;\n              };\n              Decoder2.prototype.readArraySize = function() {\n                var headByte = this.readHeadByte();\n                switch (headByte) {\n                  case 220:\n                    return this.readU16();\n                  case 221:\n                    return this.readU32();\n                  default: {\n                    if (headByte < 160) {\n                      return headByte - 144;\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                  }\n                }\n              };\n              Decoder2.prototype.pushMapState = function(size) {\n                if (size > this.maxMapLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n                }\n                this.stack.push({\n                  type: 1,\n                  size,\n                  key: null,\n                  readCount: 0,\n                  map: {}\n                });\n              };\n              Decoder2.prototype.pushArrayState = function(size) {\n                if (size > this.maxArrayLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n                }\n                this.stack.push({\n                  type: 0,\n                  size,\n                  array: new Array(size),\n                  position: 0\n                });\n              };\n              Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                var _a;\n                if (byteLength > this.maxStrLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n                }\n                if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headerOffset;\n                var object;\n                if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                  object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n                } else {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n                }\n                this.pos += headerOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.stateIsMapKey = function() {\n                if (this.stack.length > 0) {\n                  var state = this.stack[this.stack.length - 1];\n                  return state.type === 1;\n                }\n                return false;\n              };\n              Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                if (byteLength > this.maxBinLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n                }\n                if (!this.hasRemaining(byteLength + headOffset)) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headOffset;\n                var object = this.bytes.subarray(offset, offset + byteLength);\n                this.pos += headOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                if (size > this.maxExtLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n                }\n                var extType = this.view.getInt8(this.pos + headOffset);\n                var data = this.decodeBinary(\n                  size,\n                  headOffset + 1\n                  /* extType */\n                );\n                return this.extensionCodec.decode(data, extType, this.context);\n              };\n              Decoder2.prototype.lookU8 = function() {\n                return this.view.getUint8(this.pos);\n              };\n              Decoder2.prototype.lookU16 = function() {\n                return this.view.getUint16(this.pos);\n              };\n              Decoder2.prototype.lookU32 = function() {\n                return this.view.getUint32(this.pos);\n              };\n              Decoder2.prototype.readU8 = function() {\n                var value = this.view.getUint8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readI8 = function() {\n                var value = this.view.getInt8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readU16 = function() {\n                var value = this.view.getUint16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readI16 = function() {\n                var value = this.view.getInt16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readU32 = function() {\n                var value = this.view.getUint32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readI32 = function() {\n                var value = this.view.getInt32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readU64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readI64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readF32 = function() {\n                var value = this.view.getFloat32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readF64 = function() {\n                var value = this.view.getFloat64(this.pos);\n                this.pos += 8;\n                return value;\n              };\n              return Decoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_MAX_DEPTH\", function() {\n            return DEFAULT_MAX_DEPTH;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() {\n            return DEFAULT_INITIAL_BUFFER_SIZE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var DEFAULT_MAX_DEPTH = 100;\n          var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n          var Encoder = (\n            /** @class */\n            function() {\n              function Encoder2(extensionCodec, context2, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context2 === void 0) {\n                  context2 = void 0;\n                }\n                if (maxDepth === void 0) {\n                  maxDepth = DEFAULT_MAX_DEPTH;\n                }\n                if (initialBufferSize === void 0) {\n                  initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                }\n                if (sortKeys === void 0) {\n                  sortKeys = false;\n                }\n                if (forceFloat32 === void 0) {\n                  forceFloat32 = false;\n                }\n                if (ignoreUndefined === void 0) {\n                  ignoreUndefined = false;\n                }\n                if (forceIntegerToFloat === void 0) {\n                  forceIntegerToFloat = false;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context2;\n                this.maxDepth = maxDepth;\n                this.initialBufferSize = initialBufferSize;\n                this.sortKeys = sortKeys;\n                this.forceFloat32 = forceFloat32;\n                this.ignoreUndefined = ignoreUndefined;\n                this.forceIntegerToFloat = forceIntegerToFloat;\n                this.pos = 0;\n                this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                this.bytes = new Uint8Array(this.view.buffer);\n              }\n              Encoder2.prototype.getUint8Array = function() {\n                return this.bytes.subarray(0, this.pos);\n              };\n              Encoder2.prototype.reinitializeState = function() {\n                this.pos = 0;\n              };\n              Encoder2.prototype.encode = function(object) {\n                this.reinitializeState();\n                this.doEncode(object, 1);\n                return this.getUint8Array();\n              };\n              Encoder2.prototype.doEncode = function(object, depth) {\n                if (depth > this.maxDepth) {\n                  throw new Error(\"Too deep objects in depth \" + depth);\n                }\n                if (object == null) {\n                  this.encodeNil();\n                } else if (typeof object === \"boolean\") {\n                  this.encodeBoolean(object);\n                } else if (typeof object === \"number\") {\n                  this.encodeNumber(object);\n                } else if (typeof object === \"string\") {\n                  this.encodeString(object);\n                } else {\n                  this.encodeObject(object, depth);\n                }\n              };\n              Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                var requiredSize = this.pos + sizeToWrite;\n                if (this.view.byteLength < requiredSize) {\n                  this.resizeBuffer(requiredSize * 2);\n                }\n              };\n              Encoder2.prototype.resizeBuffer = function(newSize) {\n                var newBuffer = new ArrayBuffer(newSize);\n                var newBytes = new Uint8Array(newBuffer);\n                var newView = new DataView(newBuffer);\n                newBytes.set(this.bytes);\n                this.view = newView;\n                this.bytes = newBytes;\n              };\n              Encoder2.prototype.encodeNil = function() {\n                this.writeU8(192);\n              };\n              Encoder2.prototype.encodeBoolean = function(object) {\n                if (object === false) {\n                  this.writeU8(194);\n                } else {\n                  this.writeU8(195);\n                }\n              };\n              Encoder2.prototype.encodeNumber = function(object) {\n                if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                  if (object >= 0) {\n                    if (object < 128) {\n                      this.writeU8(object);\n                    } else if (object < 256) {\n                      this.writeU8(204);\n                      this.writeU8(object);\n                    } else if (object < 65536) {\n                      this.writeU8(205);\n                      this.writeU16(object);\n                    } else if (object < 4294967296) {\n                      this.writeU8(206);\n                      this.writeU32(object);\n                    } else {\n                      this.writeU8(207);\n                      this.writeU64(object);\n                    }\n                  } else {\n                    if (object >= -32) {\n                      this.writeU8(224 | object + 32);\n                    } else if (object >= -128) {\n                      this.writeU8(208);\n                      this.writeI8(object);\n                    } else if (object >= -32768) {\n                      this.writeU8(209);\n                      this.writeI16(object);\n                    } else if (object >= -2147483648) {\n                      this.writeU8(210);\n                      this.writeI32(object);\n                    } else {\n                      this.writeU8(211);\n                      this.writeI64(object);\n                    }\n                  }\n                } else {\n                  if (this.forceFloat32) {\n                    this.writeU8(202);\n                    this.writeF32(object);\n                  } else {\n                    this.writeU8(203);\n                    this.writeF64(object);\n                  }\n                }\n              };\n              Encoder2.prototype.writeStringHeader = function(byteLength) {\n                if (byteLength < 32) {\n                  this.writeU8(160 + byteLength);\n                } else if (byteLength < 256) {\n                  this.writeU8(217);\n                  this.writeU8(byteLength);\n                } else if (byteLength < 65536) {\n                  this.writeU8(218);\n                  this.writeU16(byteLength);\n                } else if (byteLength < 4294967296) {\n                  this.writeU8(219);\n                  this.writeU32(byteLength);\n                } else {\n                  throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n                }\n              };\n              Encoder2.prototype.encodeString = function(object) {\n                var maxHeaderSize = 1 + 4;\n                var strLength = object.length;\n                if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                } else {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                }\n              };\n              Encoder2.prototype.encodeObject = function(object, depth) {\n                var ext = this.extensionCodec.tryToEncode(object, this.context);\n                if (ext != null) {\n                  this.encodeExtension(ext);\n                } else if (Array.isArray(object)) {\n                  this.encodeArray(object, depth);\n                } else if (ArrayBuffer.isView(object)) {\n                  this.encodeBinary(object);\n                } else if (typeof object === \"object\") {\n                  this.encodeMap(object, depth);\n                } else {\n                  throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n                }\n              };\n              Encoder2.prototype.encodeBinary = function(object) {\n                var size = object.byteLength;\n                if (size < 256) {\n                  this.writeU8(196);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(197);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(198);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large binary: \" + size);\n                }\n                var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n                this.writeU8a(bytes);\n              };\n              Encoder2.prototype.encodeArray = function(object, depth) {\n                var size = object.length;\n                if (size < 16) {\n                  this.writeU8(144 + size);\n                } else if (size < 65536) {\n                  this.writeU8(220);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(221);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large array: \" + size);\n                }\n                for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                  var item = object_1[_i];\n                  this.doEncode(item, depth + 1);\n                }\n              };\n              Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                var count = 0;\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                  var key = keys_1[_i];\n                  if (object[key] !== void 0) {\n                    count++;\n                  }\n                }\n                return count;\n              };\n              Encoder2.prototype.encodeMap = function(object, depth) {\n                var keys = Object.keys(object);\n                if (this.sortKeys) {\n                  keys.sort();\n                }\n                var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                if (size < 16) {\n                  this.writeU8(128 + size);\n                } else if (size < 65536) {\n                  this.writeU8(222);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(223);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large map object: \" + size);\n                }\n                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                  var key = keys_2[_i];\n                  var value = object[key];\n                  if (!(this.ignoreUndefined && value === void 0)) {\n                    this.encodeString(key);\n                    this.doEncode(value, depth + 1);\n                  }\n                }\n              };\n              Encoder2.prototype.encodeExtension = function(ext) {\n                var size = ext.data.length;\n                if (size === 1) {\n                  this.writeU8(212);\n                } else if (size === 2) {\n                  this.writeU8(213);\n                } else if (size === 4) {\n                  this.writeU8(214);\n                } else if (size === 8) {\n                  this.writeU8(215);\n                } else if (size === 16) {\n                  this.writeU8(216);\n                } else if (size < 256) {\n                  this.writeU8(199);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(200);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(201);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large extension object: \" + size);\n                }\n                this.writeI8(ext.type);\n                this.writeU8a(ext.data);\n              };\n              Encoder2.prototype.writeU8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setUint8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU8a = function(values) {\n                var size = values.length;\n                this.ensureBufferSizeToWrite(size);\n                this.bytes.set(values, this.pos);\n                this.pos += size;\n              };\n              Encoder2.prototype.writeI8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setInt8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setUint16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeI16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setInt16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeU32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setUint32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeI32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setInt32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setFloat32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                this.view.setFloat64(this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeU64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeI64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              return Encoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: ExtData */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return ExtData;\n          });\n          var ExtData = (\n            /** @class */\n            function() {\n              function ExtData2(type2, data) {\n                this.type = type2;\n                this.data = data;\n              }\n              return ExtData2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n          \\***********************************************************************/\n        /*! exports provided: ExtensionCodec */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return ExtensionCodec;\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          var ExtensionCodec = (\n            /** @class */\n            function() {\n              function ExtensionCodec2() {\n                this.builtInEncoders = [];\n                this.builtInDecoders = [];\n                this.encoders = [];\n                this.decoders = [];\n                this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n              }\n              ExtensionCodec2.prototype.register = function(_a) {\n                var type2 = _a.type, encode = _a.encode, decode = _a.decode;\n                if (type2 >= 0) {\n                  this.encoders[type2] = encode;\n                  this.decoders[type2] = decode;\n                } else {\n                  var index = 1 + type2;\n                  this.builtInEncoders[index] = encode;\n                  this.builtInDecoders[index] = decode;\n                }\n              };\n              ExtensionCodec2.prototype.tryToEncode = function(object, context2) {\n                for (var i = 0; i < this.builtInEncoders.length; i++) {\n                  var encodeExt = this.builtInEncoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context2);\n                    if (data != null) {\n                      var type2 = -1 - i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type2, data);\n                    }\n                  }\n                }\n                for (var i = 0; i < this.encoders.length; i++) {\n                  var encodeExt = this.encoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context2);\n                    if (data != null) {\n                      var type2 = i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type2, data);\n                    }\n                  }\n                }\n                if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n                  return object;\n                }\n                return null;\n              };\n              ExtensionCodec2.prototype.decode = function(data, type2, context2) {\n                var decodeExt = type2 < 0 ? this.builtInDecoders[-1 - type2] : this.decoders[type2];\n                if (decodeExt) {\n                  return decodeExt(data, type2, context2);\n                } else {\n                  return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type2, data);\n                }\n              };\n              ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n              return ExtensionCodec2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"defaultDecodeOptions\", function() {\n            return defaultDecodeOptions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return decodeMulti;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var defaultDecodeOptions = {};\n          function decode(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decode(buffer);\n          }\n          function decodeMulti(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeMulti(buffer);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return decodeAsync;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return decodeArrayStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return decodeMultiStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return decodeStream;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/stream.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\"\n          );\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve2) {\n                resolve2(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve2, reject2) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject2(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          function decodeAsync(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return __awaiter(this, void 0, void 0, function() {\n              var stream, decoder;\n              return __generator(this, function(_a) {\n                stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n                decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n                return [2, decoder.decodeAsync(stream)];\n              });\n            });\n          }\n          function decodeArrayStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeArrayStream(stream);\n          }\n          function decodeMultiStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeStream(stream);\n          }\n          function decodeStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return decodeMultiStream(streamLike, options);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: encode */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          var defaultEncodeOptions = {};\n          function encode(value, options) {\n            if (options === void 0) {\n              options = defaultEncodeOptions;\n            }\n            var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n            return encoder.encode(value);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n          \\**************************************************************/\n        /*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"];\n          });\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"];\n          });\n          var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decodeAsync.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"];\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"];\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"];\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"];\n          });\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"];\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"];\n          });\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"];\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return EXT_TIMESTAMP;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return encodeTimeSpecToTimestamp;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return encodeDateToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return encodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return decodeTimestampToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return decodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"timestampExtension\", function() {\n            return timestampExtension;\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var EXT_TIMESTAMP = -1;\n          var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n          var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n          function encodeTimeSpecToTimestamp(_a) {\n            var sec = _a.sec, nsec = _a.nsec;\n            if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n              if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                var rv = new Uint8Array(4);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, sec);\n                return rv;\n              } else {\n                var secHigh = sec / 4294967296;\n                var secLow = sec & 4294967295;\n                var rv = new Uint8Array(8);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec << 2 | secHigh & 3);\n                view.setUint32(4, secLow);\n                return rv;\n              }\n            } else {\n              var rv = new Uint8Array(12);\n              var view = new DataView(rv.buffer);\n              view.setUint32(0, nsec);\n              Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n              return rv;\n            }\n          }\n          function encodeDateToTimeSpec(date) {\n            var msec = date.getTime();\n            var sec = Math.floor(msec / 1e3);\n            var nsec = (msec - sec * 1e3) * 1e6;\n            var nsecInSec = Math.floor(nsec / 1e9);\n            return {\n              sec: sec + nsecInSec,\n              nsec: nsec - nsecInSec * 1e9\n            };\n          }\n          function encodeTimestampExtension(object) {\n            if (object instanceof Date) {\n              var timeSpec = encodeDateToTimeSpec(object);\n              return encodeTimeSpecToTimestamp(timeSpec);\n            } else {\n              return null;\n            }\n          }\n          function decodeTimestampToTimeSpec(data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            switch (data.byteLength) {\n              case 4: {\n                var sec = view.getUint32(0);\n                var nsec = 0;\n                return { sec, nsec };\n              }\n              case 8: {\n                var nsec30AndSecHigh2 = view.getUint32(0);\n                var secLow32 = view.getUint32(4);\n                var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                var nsec = nsec30AndSecHigh2 >>> 2;\n                return { sec, nsec };\n              }\n              case 12: {\n                var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n                var nsec = view.getUint32(0);\n                return { sec, nsec };\n              }\n              default:\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n            }\n          }\n          function decodeTimestampExtension(data) {\n            var timeSpec = decodeTimestampToTimeSpec(data);\n            return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n          }\n          var timestampExtension = {\n            type: EXT_TIMESTAMP,\n            encode: encodeTimestampExtension,\n            decode: decodeTimestampExtension\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"UINT32_MAX\", function() {\n            return UINT32_MAX;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setUint64\", function() {\n            return setUint64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setInt64\", function() {\n            return setInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getInt64\", function() {\n            return getInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getUint64\", function() {\n            return getUint64;\n          });\n          var UINT32_MAX = 4294967295;\n          function setUint64(view, offset, value) {\n            var high = value / 4294967296;\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function setInt64(view, offset, value) {\n            var high = Math.floor(value / 4294967296);\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function getInt64(view, offset) {\n            var high = view.getInt32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n          function getUint64(view, offset) {\n            var high = view.getUint32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: prettyByte */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"prettyByte\", function() {\n            return prettyByte;\n          });\n          function prettyByte(byte) {\n            return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n          \\*********************************************************************/\n        /*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isAsyncIterable\", function() {\n            return isAsyncIterable;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"asyncIterableFromStream\", function() {\n            return asyncIterableFromStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ensureAsyncIterable\", function() {\n            return ensureAsyncIterable;\n          });\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject2(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          function isAsyncIterable(object) {\n            return object[Symbol.asyncIterator] != null;\n          }\n          function assertNonNull(value) {\n            if (value == null) {\n              throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n            }\n          }\n          function asyncIterableFromStream(stream) {\n            return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n              var reader, _a, done, value;\n              return __generator(this, function(_b) {\n                switch (_b.label) {\n                  case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                  case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                  case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done)\n                      return [3, 5];\n                    return [4, __await(void 0)];\n                  case 4:\n                    return [2, _b.sent()];\n                  case 5:\n                    assertNonNull(value);\n                    return [4, __await(value)];\n                  case 6:\n                    return [4, _b.sent()];\n                  case 7:\n                    _b.sent();\n                    return [3, 2];\n                  case 8:\n                    return [3, 10];\n                  case 9:\n                    reader.releaseLock();\n                    return [\n                      7\n                      /*endfinally*/\n                    ];\n                  case 10:\n                    return [\n                      2\n                      /*return*/\n                    ];\n                }\n              });\n            });\n          }\n          function ensureAsyncIterable(streamLike) {\n            if (isAsyncIterable(streamLike)) {\n              return streamLike;\n            } else {\n              return asyncIterableFromStream(streamLike);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n        /*!**************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n          \\**************************************************************************/\n        /*! exports provided: ensureUint8Array, createDataView */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ensureUint8Array\", function() {\n            return ensureUint8Array;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"createDataView\", function() {\n            return createDataView;\n          });\n          function ensureUint8Array(buffer) {\n            if (buffer instanceof Uint8Array) {\n              return buffer;\n            } else if (ArrayBuffer.isView(buffer)) {\n              return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            } else if (buffer instanceof ArrayBuffer) {\n              return new Uint8Array(buffer);\n            } else {\n              return Uint8Array.from(buffer);\n            }\n          }\n          function createDataView(buffer) {\n            if (buffer instanceof ArrayBuffer) {\n              return new DataView(buffer);\n            }\n            var bufferView = ensureUint8Array(buffer);\n            return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n          \\*******************************************************************/\n        /*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"utf8Count\", function() {\n            return utf8Count;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeJs\", function() {\n            return utf8EncodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_ENCODER_THRESHOLD\", function() {\n            return TEXT_ENCODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeTE\", function() {\n            return utf8EncodeTE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeJs\", function() {\n            return utf8DecodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_DECODER_THRESHOLD\", function() {\n            return TEXT_DECODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeTD\", function() {\n            return utf8DecodeTD;\n          });\n          var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n          function utf8Count(str) {\n            var strLength = str.length;\n            var byteLength = 0;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                byteLength++;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                byteLength += 2;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  byteLength += 3;\n                } else {\n                  byteLength += 4;\n                }\n              }\n            }\n            return byteLength;\n          }\n          function utf8EncodeJs(str, output, outputOffset) {\n            var strLength = str.length;\n            var offset = outputOffset;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                output[offset++] = value;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                output[offset++] = value >> 6 & 31 | 192;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  output[offset++] = value >> 12 & 15 | 224;\n                  output[offset++] = value >> 6 & 63 | 128;\n                } else {\n                  output[offset++] = value >> 18 & 7 | 240;\n                  output[offset++] = value >> 12 & 63 | 128;\n                  output[offset++] = value >> 6 & 63 | 128;\n                }\n              }\n              output[offset++] = value & 63 | 128;\n            }\n          }\n          var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n          var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\" ? 200 : 0;\n          function utf8EncodeTEencode(str, output, outputOffset) {\n            output.set(sharedTextEncoder.encode(str), outputOffset);\n          }\n          function utf8EncodeTEencodeInto(str, output, outputOffset) {\n            sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n          }\n          var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n          var CHUNK_SIZE = 4096;\n          function utf8DecodeJs(bytes, inputOffset, byteLength) {\n            var offset = inputOffset;\n            var end = offset + byteLength;\n            var units = [];\n            var result = \"\";\n            while (offset < end) {\n              var byte1 = bytes[offset++];\n              if ((byte1 & 128) === 0) {\n                units.push(byte1);\n              } else if ((byte1 & 224) === 192) {\n                var byte2 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 6 | byte2);\n              } else if ((byte1 & 240) === 224) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n              } else if ((byte1 & 248) === 240) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                var byte4 = bytes[offset++] & 63;\n                var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                if (unit > 65535) {\n                  unit -= 65536;\n                  units.push(unit >>> 10 & 1023 | 55296);\n                  unit = 56320 | unit & 1023;\n                }\n                units.push(unit);\n              } else {\n                units.push(byte1);\n              }\n              if (units.length >= CHUNK_SIZE) {\n                result += String.fromCharCode.apply(String, units);\n                units.length = 0;\n              }\n            }\n            if (units.length > 0) {\n              result += String.fromCharCode.apply(String, units);\n            }\n            return result;\n          }\n          var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n          var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\" ? 200 : 0;\n          function utf8DecodeTD(bytes, inputOffset, byteLength) {\n            var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n            return sharedTextDecoder.decode(stringBytes);\n          }\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/hypha/rpc.js\": (\n        /*!**************************!*\\\n          !*** ./src/hypha/rpc.js ***!\n          \\**************************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @msgpack/msgpack */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\"\n          );\n          const API_VERSION = \"0.3.0\";\n          const CHUNK_SIZE = 1024 * 500;\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          function getFunctionInfo(func) {\n            const funcString = func.toString();\n            const nameMatch = funcString.match(/function\\s*(\\w*)/);\n            const name2 = nameMatch && nameMatch[1] || \"\";\n            const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n            let params = \"\";\n            if (paramsMatch) {\n              params = paramsMatch[1].split(\",\").map((p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n            }\n            let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n            const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n            docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n            const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n            const docstring = docstringBlock || docstringLine;\n            return name2 && params.length > 0 && {\n              name: name2,\n              sig: params,\n              doc: docstring\n            };\n          }\n          function concatArrayBuffers(buffers) {\n            var buffersLengths = buffers.map(function(b) {\n              return b.byteLength;\n            }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n              return p + c;\n            }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n            buffersLengths.reduce(function(p, c, i) {\n              unit8Arr.set(new Uint8Array(buffers[i]), p);\n              return p + c;\n            }, 0);\n            return unit8Arr.buffer;\n          }\n          class Timer {\n            constructor(timeout, callback, args, label) {\n              this._timeout = timeout;\n              this._callback = callback;\n              this._args = args;\n              this._label = label || \"timer\";\n              this._task = null;\n              this.started = false;\n            }\n            start() {\n              if (this.started) {\n                this.reset();\n              } else {\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            clear() {\n              if (this._task) {\n                clearTimeout(this._task);\n                this._task = null;\n                this.started = false;\n              } else {\n                console.warn(`Clearing a timer (${this._label}) which is not started`);\n              }\n            }\n            reset() {\n              if (this._task) {\n                clearTimeout(this._task);\n              }\n              this._task = setTimeout(() => {\n                this._callback.apply(this, this._args);\n              }, this._timeout * 1e3);\n              this.started = true;\n            }\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, {\n              client_id: client_id2 = null,\n              manager_id = null,\n              default_context = null,\n              name: name2 = null,\n              codecs = null,\n              method_timeout: method_timeout2 = null,\n              max_message_buffer_size = 0,\n              debug = false,\n              workspace: workspace2 = null\n            }) {\n              super(debug);\n              this._codecs = codecs || {};\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2 && typeof client_id2 === \"string\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2, \"client_id is required\");\n              this._client_id = client_id2;\n              this._name = name2;\n              this._connection_info = null;\n              this._workspace = null;\n              this._local_workspace = workspace2;\n              this.manager_id = manager_id;\n              this.default_context = default_context || {};\n              this._method_annotations = /* @__PURE__ */ new WeakMap();\n              this._manager_service = null;\n              this._max_message_buffer_size = max_message_buffer_size;\n              this._chunk_store = {};\n              this._method_timeout = method_timeout2 || 30;\n              this._services = {};\n              this._object_store = {\n                services: this._services\n              };\n              if (connection) {\n                this.add_service({\n                  id: \"built-in\",\n                  type: \"built-in\",\n                  name: \"RPC built-in services\",\n                  config: {\n                    require_context: true,\n                    visibility: \"public\"\n                  },\n                  ping: this._ping.bind(this),\n                  get_service: this.get_local_service.bind(this),\n                  register_service: this.register_service.bind(this),\n                  message_cache: {\n                    create: this._create_message.bind(this),\n                    append: this._append_message.bind(this),\n                    process: this._process_message.bind(this),\n                    remove: this._remove_message.bind(this)\n                  }\n                });\n                this.on(\"method\", this._handle_method.bind(this));\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n                this._emit_message = connection.emit_message.bind(connection);\n                connection.on_message(this._on_message.bind(this));\n                this._connection = connection;\n                this._get_connection_info();\n              } else {\n                this._emit_message = function() {\n                  console.log(\"No connection to emit message\");\n                };\n              }\n            }\n            async _get_connection_info() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  this._connection_info = await this._manager_service.get_connection_info();\n                  if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n                    this._local_workspace = this._connection_info.workspace;\n                  }\n                  if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n                    this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n                    const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8;\n                    this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1e3);\n                  }\n                } catch (exp) {\n                  console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n                }\n              }\n            }\n            register_codec(config2) {\n              if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n              } else {\n                if (config2.type) {\n                  for (let k of Object.keys(this._codecs)) {\n                    if (this._codecs[k].type === config2.type || k === config2.name) {\n                      delete this._codecs[k];\n                      console.warn(\"Remove duplicated codec: \" + k);\n                    }\n                  }\n                }\n                this._codecs[config2[\"name\"]] = config2;\n              }\n            }\n            async _ping(msg, context2) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n              return \"pong\";\n            }\n            async ping(client_id2, timeout) {\n              let method = this._generate_remote_method({\n                _rtarget: client_id2,\n                _rmethod: \"services.built-in.ping\",\n                _rpromise: true,\n                _rdoc: \"Ping a remote client\",\n                _rsig: \"ping(msg)\"\n              });\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(await method(\"ping\", timeout) == \"pong\");\n            }\n            _create_message(key, heartbeat, overwrite, context2) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              if (!this._object_store[\"message_cache\"]) {\n                this._object_store[\"message_cache\"] = {};\n              }\n              if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n              }\n              this._object_store[\"message_cache\"][key] = [];\n            }\n            _append_message(key, data, heartbeat, context2) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n              cache[key].push(data);\n            }\n            _remove_message(key, context2) {\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              delete cache[key];\n            }\n            _process_message(key, heartbeat, context2) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context2, \"Context is required\");\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              cache[key] = concatArrayBuffers(cache[key]);\n              console.debug(`Processing message ${key} (size=${cache[key].length})`);\n              let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n              const {\n                done,\n                value\n              } = unpacker.next();\n              const main = value;\n              Object.assign(main, {\n                from: context2.from,\n                to: context2.to,\n                user: context2.user\n              });\n              main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n              Object.assign(main[\"ctx\"], this.default_context);\n              if (!done) {\n                let extra = unpacker.next();\n                Object.assign(main, extra.value);\n              }\n              this._fire(main[\"type\"], main);\n              delete cache[key];\n            }\n            _on_message(message) {\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n                let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n                const {\n                  done,\n                  value\n                } = unpacker.next();\n                const main = value;\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n              } catch (error) {\n                console.error(error);\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._services = {};\n            }\n            async disconnect() {\n              if (this._get_connection_info_task) {\n                clearTimeout(this._get_connection_info_task);\n                this._get_connection_info_task = null;\n              }\n              this._fire(\"disconnect\");\n            }\n            async get_manager_service(timeout) {\n              if (this.manager_id && !this._manager_service) {\n                this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n              }\n            }\n            get_all_local_services() {\n              return this._services;\n            }\n            get_local_service(service_id, context2) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n              const [ws, client_id2] = context2[\"to\"].split(\"/\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2 === this._client_id, \"Services can only be accessed locally\");\n              const service = this._services[service_id];\n              if (!service) {\n                throw new Error(\"Service not found: \" + service_id);\n              }\n              if (service.config.visibility == \"public\") {\n                return service;\n              }\n              if (context2[\"from\"].startsWith(ws + \"/\")) {\n                return service;\n              }\n              throw new Error(\"Permission denied for service: \" + service_id);\n            }\n            async get_remote_service(service_uri, timeout) {\n              timeout = timeout === void 0 ? this._method_timeout : timeout;\n              if (!service_uri && this.manager_id) {\n                service_uri = this.manager_id;\n              } else if (!service_uri.includes(\":\")) {\n                service_uri = this._client_id + \":\" + service_uri;\n              }\n              const provider = service_uri.split(\":\")[0];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n              try {\n                const method = this._generate_remote_method({\n                  _rtarget: provider,\n                  _rmethod: \"services.built-in.get_service\",\n                  _rpromise: true,\n                  _rdoc: \"Get a remote service\",\n                  _rsig: \"get_service(service_id)\"\n                });\n                const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n                svc.id = service_uri;\n                return svc;\n              } catch (e) {\n                console.error(\"Failed to get remote service: \" + service_uri, e);\n                throw e;\n              }\n            }\n            _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n              if (typeof aObject === \"function\") {\n                let method_name = object_id.split(\".\")[1];\n                this._method_annotations.set(aObject, {\n                  require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                  run_in_executor,\n                  method_id: \"services.\" + object_id,\n                  visibility\n                });\n              } else if (aObject instanceof Array || aObject instanceof Object) {\n                for (let key of Object.keys(aObject)) {\n                  let val = aObject[key];\n                  if (typeof val === \"function\" && val.__rpc_object__) {\n                    let client_id2 = val.__rpc_object__._rtarget;\n                    if (client_id2.includes(\"/\")) {\n                      client_id2 = client_id2.split(\"/\")[1];\n                    }\n                    if (this._client_id === client_id2) {\n                      if (aObject instanceof Array) {\n                        aObject = aObject.slice();\n                      }\n                      aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n                      val = aObject[key];\n                    } else {\n                      throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id2}`);\n                    }\n                  }\n                  this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n                }\n              }\n            }\n            add_service(api, overwrite) {\n              if (!api || Array.isArray(api))\n                throw new Error(\"Invalid service object\");\n              if (api.constructor === Object) {\n                api = Object.assign({}, api);\n              } else {\n                const normApi = {};\n                const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n                for (let k of props) {\n                  if (k !== \"constructor\") {\n                    if (typeof api[k] === \"function\")\n                      normApi[k] = api[k].bind(api);\n                    else\n                      normApi[k] = api[k];\n                  }\n                }\n                api.id = api.id || \"default\";\n                api = normApi;\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n              if (!api.name) {\n                api.name = api.id;\n              }\n              if (!api.config) {\n                api.config = {};\n              }\n              if (!api.type) {\n                api.type = \"generic\";\n              }\n              let require_context = false, run_in_executor = false;\n              if (api.config.require_context)\n                require_context = api.config.require_context;\n              if (api.config.run_in_executor)\n                run_in_executor = true;\n              const visibility = api.config.visibility || \"protected\";\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n              this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n              if (this._services[api.id]) {\n                if (overwrite) {\n                  delete this._services[api.id];\n                } else {\n                  throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n                }\n              }\n              this._services[api.id] = api;\n              return api;\n            }\n            async register_service(api, overwrite, notify, context2) {\n              if (notify === void 0)\n                notify = true;\n              if (context2) {\n                const [workspace2, client_id2] = context2[\"to\"].split(\"/\");\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id2 === this._client_id);\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace2 === context2[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n              }\n              const service = this.add_service(api, overwrite);\n              if (notify) {\n                this._fire(\"service-updated\", {\n                  service_id: service[\"id\"],\n                  api: service,\n                  type: \"add\"\n                });\n                await this._notify_service_update();\n              }\n              return {\n                id: `${this._client_id}:${service[\"id\"]}`,\n                type: service[\"type\"],\n                name: service[\"name\"],\n                description: service[\"description\"] || \"\",\n                config: service[\"config\"]\n              };\n            }\n            async unregister_service(service, notify) {\n              if (service instanceof Object) {\n                service = service.id;\n              }\n              if (!this._services[service]) {\n                throw new Error(`Service not found: ${service}`);\n              }\n              const api = this._services[service];\n              delete this._services[service];\n              this._fire(\"service-updated\", {\n                service_id: service,\n                api,\n                type: \"remove\"\n              });\n              await this._notify_service_update();\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            _encode_callback(name2, callback, session_id, clear_after_called, timer, local_workspace) {\n              let method_id = `${session_id}.${name2}`;\n              let encoded = {\n                _rtype: \"method\",\n                _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                _rmethod: method_id,\n                _rpromise: false\n              };\n              const self2 = this;\n              let wrapped_callback = function() {\n                try {\n                  callback.apply(null, Array.prototype.slice.call(arguments));\n                } catch (error) {\n                  console.error(\"Error in callback:\", method_id, error);\n                } finally {\n                  if (clear_after_called && self2._object_store[session_id]) {\n                    delete self2._object_store[session_id];\n                  }\n                  if (timer && timer.started) {\n                    timer.clear();\n                  }\n                }\n              };\n              return [encoded, wrapped_callback];\n            }\n            async _encode_promise(resolve2, reject2, session_id, clear_after_called, timer, local_workspace) {\n              let store = this._get_session_store(session_id, true);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n              let encoded = {};\n              if (timer && reject2 && this._method_timeout) {\n                encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n                encoded.interval = this._method_timeout / 2;\n                store.timer = timer;\n              } else {\n                timer = null;\n              }\n              [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve2, session_id, clear_after_called, timer, local_workspace);\n              [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject2, session_id, clear_after_called, timer, local_workspace);\n              return encoded;\n            }\n            async _send_chunks(data, target_id, session_id) {\n              let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n              let message_cache = remote_services.message_cache;\n              let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n              await message_cache.create(message_id, !!session_id);\n              let total_size = data.length;\n              let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n              for (let idx = 0; idx < chunk_num; idx++) {\n                let start_byte = idx * CHUNK_SIZE;\n                await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id);\n              }\n              await message_cache.process(message_id, !!session_id);\n            }\n            emit(main_message, extra_data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n              let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n              if (extra_data) {\n                const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                message_package = new Uint8Array([...message_package, ...extra]);\n              }\n              const total_size = message_package.length;\n              if (total_size <= CHUNK_SIZE + 1024) {\n                return this._emit_message(message_package);\n              } else {\n                throw new Error(\"Message is too large to send in one go.\");\n              }\n            }\n            _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n              let target_id = encoded_method._rtarget;\n              if (remote_workspace && !target_id.includes(\"/\")) {\n                if (remote_workspace !== target_id) {\n                  target_id = remote_workspace + \"/\" + target_id;\n                }\n                encoded_method._rtarget = target_id;\n              }\n              let method_id = encoded_method._rmethod;\n              let with_promise = encoded_method._rpromise;\n              const self2 = this;\n              function remote_method() {\n                return new Promise(async (resolve2, reject2) => {\n                  let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  if (local_parent) {\n                    local_session_id = local_parent + \".\" + local_session_id;\n                  }\n                  let store = self2._get_session_store(local_session_id, true);\n                  if (!store) {\n                    reject2(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n                    return;\n                  }\n                  store[\"target_id\"] = target_id;\n                  const args = await self2._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  let main_message = {\n                    type: \"method\",\n                    from: self2._local_workspace ? self2._local_workspace + \"/\" + self2._client_id : self2._client_id,\n                    to: target_id,\n                    method: method_id\n                  };\n                  let extra_data = {};\n                  if (args) {\n                    extra_data[\"args\"] = args;\n                  }\n                  if (withKwargs) {\n                    extra_data[\"with_kwargs\"] = withKwargs;\n                  }\n                  if (remote_parent) {\n                    main_message[\"parent\"] = remote_parent;\n                  }\n                  let timer = null;\n                  if (with_promise) {\n                    main_message[\"session\"] = local_session_id;\n                    let method_name = `${target_id}:${method_id}`;\n                    timer = new Timer(self2._method_timeout, reject2, [`Method call time out: ${method_name}`], method_name);\n                    let clear_after_called = true;\n                    for (let arg of args) {\n                      if (typeof arg === \"object\" && arg._rintf === true) {\n                        clear_after_called = false;\n                        break;\n                      }\n                    }\n                    extra_data[\"promise\"] = await self2._encode_promise(resolve2, reject2, local_session_id, clear_after_called, timer, local_workspace);\n                  }\n                  let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n                  if (extra_data) {\n                    const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                    message_package = new Uint8Array([...message_package, ...extra]);\n                  }\n                  const total_size = message_package.length;\n                  if (total_size <= CHUNK_SIZE + 1024) {\n                    self2._emit_message(message_package).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  } else {\n                    self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  }\n                });\n              }\n              remote_method.__rpc_object__ = encoded_method;\n              const parts = method_id.split(\".\");\n              remote_method.__name__ = parts[parts.length - 1];\n              remote_method.__doc__ = encoded_method._rdoc;\n              remote_method.__sig__ = encoded_method._rsig;\n              return remote_method;\n            }\n            async _notify_service_update() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  await this._manager_service.update_client_info(this.get_client_info());\n                } catch (exp) {\n                  console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n                }\n              }\n            }\n            get_client_info() {\n              const services = [];\n              for (let service of Object.values(this._services)) {\n                services.push({\n                  id: `${this._client_id}:${service[\"id\"]}`,\n                  type: service[\"type\"],\n                  name: service[\"name\"],\n                  description: service[\"description\"] || \"\",\n                  config: service[\"config\"]\n                });\n              }\n              return {\n                id: this._client_id,\n                services\n              };\n            }\n            async _handle_method(data) {\n              let reject2 = null;\n              let heartbeat_task = null;\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n                const method_name = data.from + \":\" + data.method;\n                const remote_workspace = data.from.split(\"/\")[0];\n                data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                data[\"ctx\"][\"to\"] = data[\"to\"];\n                const local_workspace = data.to.split(\"/\")[0];\n                const local_parent = data.parent;\n                let resolve2, reject3;\n                if (data.promise) {\n                  const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n                  resolve2 = promise.resolve;\n                  reject3 = promise.reject;\n                  if (promise.heartbeat && promise.interval) {\n                    async function heartbeat() {\n                      try {\n                        await promise.heartbeat();\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                    heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                  }\n                }\n                let method;\n                try {\n                  method = indexObject(this._object_store, data[\"method\"]);\n                } catch (e) {\n                  console.debug(\"Failed to find method\", method_name, e);\n                  throw new Error(`Method not found: ${method_name}`);\n                }\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name);\n                if (this._method_annotations.has(method)) {\n                  if (this._method_annotations.get(method).visibility === \"protected\") {\n                    if (local_workspace !== remote_workspace) {\n                      throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n                    }\n                  }\n                } else {\n                  let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                  if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                    session_target_id = local_workspace + \"/\" + session_target_id;\n                  }\n                  if (session_target_id !== data.from) {\n                    throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n                  }\n                }\n                if (local_parent) {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n                }\n                let args;\n                if (data.args) {\n                  args = await this._decode(data.args, data.session, null, remote_workspace, null);\n                } else {\n                  args = [];\n                }\n                if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                  args.push(data.ctx);\n                }\n                if (data.promise) {\n                  const result = method.apply(null, args);\n                  if (result instanceof Promise) {\n                    result.then((result2) => {\n                      resolve2(result2);\n                      clearInterval(heartbeat_task);\n                    }).catch((err) => {\n                      reject3(err);\n                      clearInterval(heartbeat_task);\n                    });\n                  } else {\n                    resolve2(result);\n                    clearInterval(heartbeat_task);\n                  }\n                } else {\n                  method.apply(null, args);\n                  clearInterval(heartbeat_task);\n                }\n              } catch (err) {\n                if (reject2) {\n                  reject2(err);\n                  console.debug(\"Error during calling method: \", err);\n                } else {\n                  console.error(\"Error during calling method: \", err);\n                }\n                clearInterval(heartbeat_task);\n              }\n            }\n            encode(aObject, session_id) {\n              return this._encode(aObject, session_id);\n            }\n            _get_session_store(session_id, create) {\n              let store = this._object_store;\n              const levels = session_id.split(\".\");\n              if (create) {\n                const last_index = levels.length - 1;\n                for (let level of levels.slice(0, last_index)) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                if (!store[levels[last_index]]) {\n                  store[levels[last_index]] = {};\n                }\n                return store[levels[last_index]];\n              } else {\n                for (let level of levels) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                return store;\n              }\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, session_id, local_workspace) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                return aObject;\n              }\n              if (aObject instanceof ArrayBuffer) {\n                return {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject)\n                };\n              }\n              if (aObject.__rpc_object__) {\n                return aObject.__rpc_object__;\n              }\n              let bObject;\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                const temp = aObject._rtype;\n                delete aObject._rtype;\n                bObject = await this._encode(aObject, session_id, local_workspace);\n                bObject._rtype = temp;\n                return bObject;\n              }\n              if (typeof aObject === \"function\") {\n                if (this._method_annotations.has(aObject)) {\n                  let annotation = this._method_annotations.get(aObject);\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: annotation.method_id,\n                    _rpromise: true\n                  };\n                } else {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n                  let object_id;\n                  if (aObject.__name__) {\n                    object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n                  } else {\n                    object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  }\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: true\n                  };\n                  let store = this._get_session_store(session_id, true);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n                  store[object_id] = aObject;\n                }\n                bObject._rdoc = aObject.__doc__;\n                bObject._rsig = aObject.__sig__;\n                if (!bObject._rdoc || !bObject._rsig) {\n                  try {\n                    const funcInfo = getFunctionInfo(aObject);\n                    if (funcInfo && !bObject._rdoc) {\n                      bObject._rdoc = `${funcInfo.doc}`;\n                    }\n                    if (funcInfo && !bObject._rsig) {\n                      bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n                    }\n                  } catch (e) {\n                    console.error(\"Failed to extract function docstring:\", aObject);\n                  }\n                }\n                return bObject;\n              }\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (typeof encodedObj === \"object\") {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(v_buffer.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString(),\n                  _rtrace: aObject.stack\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (aObject instanceof Blob) {\n                let seek = function(pos) {\n                  _current_pos = pos;\n                };\n                let _current_pos = 0;\n                async function read(length) {\n                  let blob;\n                  if (length) {\n                    blob = aObject.slice(_current_pos, _current_pos + length);\n                  } else {\n                    blob = aObject.slice(_current_pos);\n                  }\n                  const ret = new Uint8Array(await blob.arrayBuffer());\n                  _current_pos = _current_pos + ret.byteLength;\n                  return ret;\n                }\n                bObject = {\n                  _rtype: \"iostream\",\n                  _rnative: \"js:blob\",\n                  type: aObject.type,\n                  name: aObject.name,\n                  size: aObject.size,\n                  path: aObject._path || aObject.webkitRelativePath,\n                  read: await this._encode(read, session_id, local_workspace),\n                  seek: await this._encode(seek, session_id, local_workspace)\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: new Uint8Array(aObject.buffer),\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject.buffer)\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                const keys = Object.keys(aObject);\n                for (let k of keys) {\n                  bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n                }\n              } else {\n                throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async decode(aObject) {\n              return await this._decode(aObject);\n            }\n            async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject._rtype) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  aObject._rtype = temp;\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"method\") {\n                  bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                  bObject = new arraytype(buffer);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                } else if (aObject._rtype === \"iostream\") {\n                  if (aObject._rnative === \"js:blob\") {\n                    const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n                    const bytes = await read();\n                    bObject = new Blob([bytes], {\n                      type: aObject.type,\n                      name: aObject.name\n                    });\n                  } else {\n                    bObject = {};\n                    for (let k of Object.keys(aObject)) {\n                      if (!k.startsWith(\"_\")) {\n                        bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n                      }\n                    }\n                  }\n                  bObject[\"__rpc_object__\"] = aObject;\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  bObject._rtype = temp;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              return bObject;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/utils.js\": (\n        /*!****************************!*\\\n          !*** ./src/hypha/utils.js ***!\n          \\****************************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_167478__) {\n          \"use strict\";\n          __nested_webpack_require_167478__.r(__nested_webpack_exports__);\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"assert\", function() {\n            return assert;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"waitFor\", function() {\n            return waitFor;\n          });\n          __nested_webpack_require_167478__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve2, reject2) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve2;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve2();\n                  }\n                };\n                scriptTag.onerror = reject2;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config2) {\n            config2.version = config2.version || \"0.1.0\";\n            config2.description = config2.description || `[TODO: add description for ${config2.name} ]`;\n            config2.type = config2.type || \"rpc-window\";\n            config2.id = config2.id || randId();\n            config2.target_origin = config2.target_origin || \"*\";\n            config2.allow_execution = config2.allow_execution || false;\n            config2 = Object.keys(config2).reduce((p, c) => {\n              if (typeof config2[c] !== \"function\")\n                p[c] = config2[c];\n              return p;\n            }, {});\n            return config2;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve2, reject2) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject2(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event2) {\n                if (event2.data && event2.data.error) {\n                  reject2(event2.data.error);\n                } else {\n                  resolve2(event2.data && event2.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject2(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message || \"Assertion failed\");\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          function waitFor(prom, time, error) {\n            let timer;\n            return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n              rej(error || \"Timeout Error\");\n            }, time * 1e3))]).finally(() => clearTimeout(timer));\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event2, handler) {\n              if (!this._event_handlers[event2]) {\n                this._event_handlers[event2] = [];\n              }\n              this._event_handlers[event2].push(handler);\n            }\n            once(event2, handler) {\n              handler.___event_run_once = true;\n              this.on(event2, handler);\n            }\n            off(event2, handler) {\n              if (!event2 && !handler) {\n                this._event_handlers = {};\n              } else if (event2 && !handler) {\n                if (this._event_handlers[event2])\n                  this._event_handlers[event2] = [];\n              } else {\n                if (this._event_handlers[event2]) {\n                  const idx = this._event_handlers[event2].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event2].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event2, data) {\n              if (this._event_handlers[event2]) {\n                var i = this._event_handlers[event2].length;\n                while (i--) {\n                  const handler = this._event_handlers[event2][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event2].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event2, data);\n                }\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/webrtc-client.js\": (\n        /*!************************************!*\\\n          !*** ./src/hypha/webrtc-client.js ***!\n          \\************************************/\n        /*! exports provided: getRTCService, registerRTCService */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"getRTCService\", function() {\n            return getRTCService;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"registerRTCService\", function() {\n            return registerRTCService;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__2 = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          class WebRTCConnection {\n            constructor(channel) {\n              this._data_channel = channel;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._data_channel.onmessage = async (event2) => {\n                let data = event2.data;\n                if (data instanceof Blob) {\n                  data = await data.arrayBuffer();\n                }\n                this._handle_message(data);\n              };\n              const self2 = this;\n              this._data_channel.onclose = function() {\n                console.log(\"websocket closed\");\n                self2._data_channel = null;\n              };\n            }\n            set_reconnection_token(token2) {\n              this._reconnection_token = token2;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(this._handle_message, \"No handler for message\");\n              try {\n                this._data_channel.send(data);\n              } catch (exp) {\n                console.error(`Failed to send data, error: ${exp}`);\n                throw exp;\n              }\n            }\n            async disconnect(reason) {\n              this._data_channel = null;\n              console.info(`data channel connection disconnected (${reason})`);\n            }\n          }\n          async function _setupRPC(config2) {\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(config2.channel, \"No channel provided\");\n            Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"assert\"])(config2.workspace, \"No workspace provided\");\n            const channel = config2.channel;\n            const clientId = config2.client_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"randId\"])();\n            const connection = new WebRTCConnection(channel);\n            config2.context = config2.context || {};\n            config2.context.connection_type = \"webrtc\";\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__2[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: null,\n              default_context: config2.context,\n              name: config2.name,\n              method_timeout: config2.method_timeout || 10,\n              workspace: config2.workspace\n            });\n            return rpc;\n          }\n          async function _createOffer(params, server2, config2, onInit, context2) {\n            config2 = config2 || {};\n            let offer = new RTCSessionDescription({\n              sdp: params.sdp,\n              type: params.type\n            });\n            let pc = new RTCPeerConnection({\n              iceServers: config2.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            if (server2) {\n              pc.addEventListener(\"datachannel\", async (event2) => {\n                const channel = event2.channel;\n                let ctx = null;\n                if (context2 && context2.user)\n                  ctx = {\n                    user: context2.user\n                  };\n                const rpc = await _setupRPC({\n                  channel,\n                  client_id: channel.label,\n                  workspace: server2.config.workspace,\n                  context: ctx\n                });\n                rpc._services = server2.rpc._services;\n              });\n            }\n            if (onInit) {\n              await onInit(pc);\n            }\n            await pc.setRemoteDescription(offer);\n            let answer = await pc.createAnswer();\n            await pc.setLocalDescription(answer);\n            return {\n              sdp: pc.localDescription.sdp,\n              type: pc.localDescription.type,\n              workspace: server2.config.workspace\n            };\n          }\n          async function getRTCService(server2, service_id, config2) {\n            config2 = config2 || {};\n            config2.peer_id = config2.peer_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__2[\"randId\"])();\n            const pc = new RTCPeerConnection({\n              iceServers: config2.ice_servers || [{\n                urls: [\"stun:stun.l.google.com:19302\"]\n              }],\n              sdpSemantics: \"unified-plan\"\n            });\n            return new Promise(async (resolve2, reject2) => {\n              try {\n                pc.addEventListener(\"connectionstatechange\", () => {\n                  if (pc.connectionState === \"failed\") {\n                    pc.close();\n                    reject2(new Error(\"Connection failed\"));\n                  }\n                }, false);\n                if (config2.on_init) {\n                  await config2.on_init(pc);\n                  delete config2.on_init;\n                }\n                let channel = pc.createDataChannel(config2.peer_id, {\n                  ordered: true\n                });\n                channel.binaryType = \"arraybuffer\";\n                const offer = await pc.createOffer();\n                await pc.setLocalDescription(offer);\n                const svc = await server2.getService(service_id);\n                const answer = await svc.offer({\n                  sdp: pc.localDescription.sdp,\n                  type: pc.localDescription.type\n                });\n                channel.onopen = () => {\n                  config2.channel = channel;\n                  config2.workspace = answer.workspace;\n                  setTimeout(async () => {\n                    const rpc = await _setupRPC(config2);\n                    pc.rpc = rpc;\n                    async function getService(name2) {\n                      return await rpc.get_remote_service(config2.peer_id + \":\" + name2);\n                    }\n                    async function disconnect() {\n                      await rpc.disconnect();\n                      pc.close();\n                    }\n                    pc.get_service = getService;\n                    pc.getService = getService;\n                    pc.disconnect = disconnect;\n                    pc.register_codec = rpc.register_codec;\n                    pc.registerCodec = rpc.register_codec;\n                    resolve2(pc);\n                  }, 500);\n                };\n                channel.onclose = () => reject2(new Error(\"Data channel closed\"));\n                await pc.setRemoteDescription(new RTCSessionDescription({\n                  sdp: answer.sdp,\n                  type: answer.type\n                }));\n              } catch (e) {\n                reject2(e);\n              }\n            });\n          }\n          async function registerRTCService(server2, service_id, config2) {\n            config2 = config2 || {\n              visibility: \"protected\",\n              require_context: true\n            };\n            const onInit = config2.on_init;\n            delete config2.on_init;\n            await server2.registerService({\n              id: service_id,\n              config: config2,\n              offer: (params, context2) => _createOffer(params, server2, config2, onInit, context2)\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/websocket-client.js\": (\n        /*!***************************************!*\\\n          !*** ./src/hypha/websocket-client.js ***!\n          \\***************************************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, getRTCService, registerRTCService, login, connectToServer, setupLocalClient */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_190988__) {\n          \"use strict\";\n          __nested_webpack_require_190988__.r(__nested_webpack_exports__);\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"login\", function() {\n            return login;\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"connectToServer\", function() {\n            return connectToServer;\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"setupLocalClient\", function() {\n            return setupLocalClient;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_190988__(\n            /*! ./rpc.js */\n            \"./src/hypha/rpc.js\"\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"];\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"API_VERSION\"];\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_190988__(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"loadRequirements\"];\n          });\n          var _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_190988__(\n            /*! ./webrtc-client.js */\n            \"./src/hypha/webrtc-client.js\"\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"getRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"];\n          });\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"registerRTCService\", function() {\n            return _webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_190988__(\n            /*! ../../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_3___namespace = /* @__PURE__ */ __nested_webpack_require_190988__.t(\n            /*! ../../package.json */\n            \"./package.json\",\n            1\n          );\n          __nested_webpack_require_190988__.d(__nested_webpack_exports__, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_3__[\"version\"];\n          });\n          const MAX_RETRY = 1e4;\n          class WebsocketRPCConnection {\n            constructor(server_url2, client_id2, workspace2, token2, timeout = 60, WebSocketClass = null) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(server_url2 && client_id2, \"server_url and client_id are required\");\n              server_url2 = server_url2 + \"?client_id=\" + client_id2;\n              if (workspace2) {\n                server_url2 += \"&workspace=\" + workspace2;\n              }\n              if (token2) {\n                server_url2 += \"&token=\" + token2;\n              }\n              this._websocket = null;\n              this._handle_message = null;\n              this._reconnection_token = null;\n              this._server_url = server_url2;\n              this._timeout = timeout * 1e3;\n              this._opening = null;\n              this._retry_count = 0;\n              this._closing = false;\n              this._client_id = client_id2;\n              this._workspace = workspace2;\n              this._WebSocketClass = WebSocketClass;\n            }\n            set_reconnection_token(token2) {\n              this._reconnection_token = token2;\n            }\n            on_message(handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(handler, \"handler is required\");\n              this._handle_message = handler;\n            }\n            async open() {\n              if (this._opening) {\n                return this._opening;\n              }\n              this._opening = new Promise((resolve2, reject2) => {\n                const server_url2 = this._reconnection_token ? `${this._server_url}&reconnection_token=${this._reconnection_token}` : this._server_url;\n                console.info(\"Creating a new connection to \", server_url2.split(\"?\")[0]);\n                let websocket = null;\n                if (server_url2.startsWith(\"wss://local-hypha-server:\")) {\n                  if (this._WebSocketClass) {\n                    websocket = new this._WebSocketClass(server_url2);\n                  } else {\n                    console.log(\"Using local websocket\");\n                    console.log(\"Connecting to local websocket \" + server_url2);\n                    websocket = new LocalWebSocket(server_url2, this._client_id, this._workspace);\n                  }\n                } else {\n                  if (this._WebSocketClass) {\n                    websocket = new this._WebSocketClass(server_url2);\n                  } else {\n                    websocket = new WebSocket(server_url2);\n                  }\n                }\n                websocket.binaryType = \"arraybuffer\";\n                websocket.onmessage = (event2) => {\n                  const data = event2.data;\n                  this._handle_message(data);\n                };\n                websocket.onopen = () => {\n                  this._websocket = websocket;\n                  console.info(\"WebSocket connection established\");\n                  this._retry_count = 0;\n                  resolve2();\n                };\n                websocket.onclose = (event2) => {\n                  console.log(\"websocket closed\");\n                  if (!this._closing) {\n                    console.log(\"Websocket connection interrupted, retrying...\");\n                    this._retry_count++;\n                    setTimeout(() => this.open(), this._timeout);\n                  }\n                  this._websocket = null;\n                };\n                websocket.onerror = (event2) => {\n                  console.log(\"Error occurred in websocket connection: \", event2);\n                  reject2(new Error(\"Websocket connection failed.\"));\n                  this._websocket = null;\n                };\n              }).finally(() => {\n                this._opening = null;\n              });\n              return this._opening;\n            }\n            async emit_message(data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(this._handle_message, \"No handler for message\");\n              if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {\n                await this.open();\n              }\n              return new Promise((resolve2, reject2) => {\n                if (!this._websocket) {\n                  reject2(new Error(\"Websocket connection not available\"));\n                } else if (this._websocket.readyState === WebSocket.CONNECTING) {\n                  const timeout = setTimeout(() => {\n                    reject2(new Error(\"WebSocket connection timed out\"));\n                  }, this._timeout);\n                  this._websocket.addEventListener(\"open\", () => {\n                    clearTimeout(timeout);\n                    try {\n                      this._websocket.send(data);\n                      resolve2();\n                    } catch (exp) {\n                      console.error(`Failed to send data, error: ${exp}`);\n                      reject2(exp);\n                    }\n                  });\n                } else if (this._websocket.readyState === WebSocket.OPEN) {\n                  try {\n                    this._websocket.send(data);\n                    resolve2();\n                  } catch (exp) {\n                    console.error(`Failed to send data, error: ${exp}`);\n                    reject2(exp);\n                  }\n                } else {\n                  reject2(new Error(\"WebSocket is not in the OPEN or CONNECTING state\"));\n                }\n              });\n            }\n            disconnect(reason) {\n              this._closing = true;\n              const ws = this._websocket;\n              this._websocket = null;\n              if (ws && ws.readyState === WebSocket.OPEN) {\n                ws.close(1e3, reason);\n              }\n              console.info(`Websocket connection disconnected (${reason})`);\n            }\n          }\n          function normalizeServerUrl(server_url2) {\n            if (!server_url2)\n              throw new Error(\"server_url is required\");\n            if (server_url2.startsWith(\"http://\")) {\n              server_url2 = server_url2.replace(\"http://\", \"ws://\").replace(/\\/$/, \"\") + \"/ws\";\n            } else if (server_url2.startsWith(\"https://\")) {\n              server_url2 = server_url2.replace(\"https://\", \"wss://\").replace(/\\/$/, \"\") + \"/ws\";\n            }\n            return server_url2;\n          }\n          async function login(config2) {\n            const service_id = config2.login_service_id || \"public/*:hypha-login\";\n            const timeout = config2.login_timeout || 60;\n            const callback = config2.login_callback;\n            const server2 = await connectToServer({\n              name: \"initial login client\",\n              server_url: config2.server_url\n            });\n            try {\n              const svc = await server2.get_service(service_id);\n              const context2 = await svc.start();\n              if (callback) {\n                await callback(context2);\n              } else {\n                console.log(`Please open your browser and login at ${context2.login_url}`);\n              }\n              return await svc.check(context2.key, timeout);\n            } catch (error) {\n              throw error;\n            } finally {\n              await server2.disconnect();\n            }\n          }\n          async function connectToServer(config2) {\n            if (config2.server) {\n              config2.server_url = config2.server_url || config2.server.url;\n              config2.WebSocketClass = config2.WebSocketClass || config2.server.WebSocketClass;\n            }\n            let clientId = config2.client_id;\n            if (!clientId) {\n              clientId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"randId\"])();\n              config2.client_id = clientId;\n            }\n            let server_url2 = normalizeServerUrl(config2.server_url);\n            let connection = new WebsocketRPCConnection(server_url2, clientId, config2.workspace, config2.token, config2.method_timeout || 60, config2.WebSocketClass);\n            await connection.open();\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, {\n              client_id: clientId,\n              manager_id: \"workspace-manager\",\n              default_context: {\n                connection_type: \"websocket\"\n              },\n              name: config2.name,\n              method_timeout: config2.method_timeout\n            });\n            const wm = await rpc.get_remote_service(\"workspace-manager:default\");\n            wm.rpc = rpc;\n            async function _export(api) {\n              api.id = \"default\";\n              api.name = config2.name || api.id;\n              await rpc.register_service(api, true);\n            }\n            async function getPlugin(query) {\n              return await wm.get_service(query + \":default\");\n            }\n            async function disconnect() {\n              await rpc.disconnect();\n              await connection.disconnect();\n            }\n            wm.config[\"client_id\"] = clientId;\n            wm.export = _export;\n            wm.getPlugin = getPlugin;\n            wm.listPlugins = wm.listServices;\n            wm.disconnect = disconnect;\n            wm.registerCodec = rpc.register_codec.bind(rpc);\n            wm.emit = async function(message) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(message && typeof message === \"object\", \"message must be a dictionary\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(\"to\" in message, \"message must have a 'to' field\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(\"type\" in message, \"message must have a 'type' field\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(type !== \"method\", \"message type cannot be 'method'\");\n              return await rpc.emit(message);\n            };\n            wm.on = function(type2, handler) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(type2 !== \"method\", \"message type cannot be 'method'\");\n              rpc.on(type2, handler);\n            };\n            if (config2.webrtc) {\n              await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"registerRTCService\"])(wm, clientId + \"-rtc\", config2.webrtc_config);\n            }\n            if (wm.get_service || wm.getService) {\n              const _get_service = wm.get_service || wm.getService;\n              wm.get_service = async function(query, webrtc, webrtc_config) {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])([void 0, true, false, \"auto\"].includes(webrtc), \"webrtc must be true, false or 'auto'\");\n                const svc = await _get_service(query);\n                if (webrtc === true || webrtc === \"auto\") {\n                  if (svc.id.includes(\":\") && svc.id.includes(\"/\")) {\n                    const client = svc.id.split(\":\")[0];\n                    try {\n                      const peer = await Object(_webrtc_client_js__WEBPACK_IMPORTED_MODULE_2__[\"getRTCService\"])(wm, client + \":\" + client.split(\"/\")[1] + \"-rtc\", webrtc_config);\n                      const rtcSvc = await peer.get_service(svc.id.split(\":\")[1]);\n                      rtcSvc._webrtc = true;\n                      rtcSvc._peer = peer;\n                      rtcSvc._service = svc;\n                      return rtcSvc;\n                    } catch (e) {\n                      console.warn(\"Failed to get webrtc service, using websocket connection\", e);\n                    }\n                  }\n                  if (webrtc === true) {\n                    throw new Error(\"Failed to get the service via webrtc\");\n                  }\n                }\n                return svc;\n              };\n              wm.getService = wm.get_service;\n            }\n            return wm;\n          }\n          class LocalWebSocket {\n            constructor(url, client_id2, workspace2) {\n              this.url = url;\n              this.onopen = () => {\n              };\n              this.onmessage = () => {\n              };\n              this.onclose = () => {\n              };\n              this.onerror = () => {\n              };\n              this.client_id = client_id2;\n              this.workspace = workspace2;\n              const context2 = typeof window !== \"undefined\" ? window : self;\n              const isWindow2 = typeof window !== \"undefined\";\n              this.postMessage = (message) => {\n                if (isWindow2) {\n                  window.parent.postMessage(message, \"*\");\n                } else {\n                  self.postMessage(message);\n                }\n              };\n              this.readyState = WebSocket.CONNECTING;\n              context2.addEventListener(\"message\", (event2) => {\n                const {\n                  type: type2,\n                  data,\n                  to\n                } = event2.data;\n                if (to !== this.client_id) {\n                  console.debug(\"message not for me\", to, this.client_id);\n                  return;\n                }\n                switch (type2) {\n                  case \"message\":\n                    if (this.readyState === WebSocket.OPEN && this.onmessage) {\n                      this.onmessage({\n                        data\n                      });\n                    }\n                    break;\n                  case \"connected\":\n                    this.readyState = WebSocket.OPEN;\n                    this.onopen(event2);\n                    break;\n                  case \"closed\":\n                    this.readyState = WebSocket.CLOSED;\n                    this.onclose(event2);\n                    break;\n                  default:\n                    break;\n                }\n              }, false);\n              if (!this.client_id)\n                throw new Error(\"client_id is required\");\n              if (!this.workspace)\n                throw new Error(\"workspace is required\");\n              this.postMessage({\n                type: \"connect\",\n                url: this.url,\n                from: this.client_id,\n                workspace: this.workspace\n              });\n            }\n            send(data) {\n              if (this.readyState === WebSocket.OPEN) {\n                this.postMessage({\n                  type: \"message\",\n                  data,\n                  from: this.client_id,\n                  workspace: this.workspace\n                });\n              }\n            }\n            close() {\n              this.readyState = WebSocket.CLOSING;\n              this.postMessage({\n                type: \"close\",\n                from: this.client_id,\n                workspace: this.workspace\n              });\n              this.onclose();\n            }\n            addEventListener(type2, listener) {\n              if (type2 === \"message\") {\n                this.onmessage = listener;\n              }\n              if (type2 === \"open\") {\n                this.onopen = listener;\n              }\n              if (type2 === \"close\") {\n                this.onclose = listener;\n              }\n              if (type2 === \"error\") {\n                this.onerror = listener;\n              }\n            }\n          }\n          function setupLocalClient({\n            enable_execution = false,\n            on_ready = null\n          }) {\n            return new Promise((resolve, reject) => {\n              const context = typeof window !== \"undefined\" ? window : self;\n              const isWindow = typeof window !== \"undefined\";\n              context.addEventListener(\"message\", (event) => {\n                const {\n                  type,\n                  server_url,\n                  workspace,\n                  client_id,\n                  token,\n                  method_timeout,\n                  name,\n                  config\n                } = event.data;\n                if (type === \"initializeHyphaClient\") {\n                  if (!server_url || !workspace || !client_id) {\n                    console.error(\"server_url, workspace, and client_id are required.\");\n                    return;\n                  }\n                  if (!server_url.startsWith(\"https://local-hypha-server:\")) {\n                    console.error(\"server_url should start with https://local-hypha-server:\");\n                    return;\n                  }\n                  connectToServer({\n                    server_url,\n                    workspace,\n                    client_id,\n                    token,\n                    method_timeout,\n                    name\n                  }).then(async (server) => {\n                    globalThis.api = server;\n                    try {\n                      if (isWindow && enable_execution) {\n                        let loadScript = function(script2) {\n                          return new Promise((resolve2, reject2) => {\n                            const scriptElement = document.createElement(\"script\");\n                            scriptElement.innerHTML = script2.content;\n                            scriptElement.lang = script2.lang;\n                            scriptElement.onload = () => resolve2();\n                            scriptElement.onerror = (e) => reject2(e);\n                            document.head.appendChild(scriptElement);\n                          });\n                        };\n                        if (config.styles && config.styles.length > 0) {\n                          for (const style of config.styles) {\n                            const styleElement = document.createElement(\"style\");\n                            styleElement.innerHTML = style.content;\n                            styleElement.lang = style.lang;\n                            document.head.appendChild(styleElement);\n                          }\n                        }\n                        if (config.links && config.links.length > 0) {\n                          for (const link of config.links) {\n                            const linkElement = document.createElement(\"a\");\n                            linkElement.href = link.url;\n                            linkElement.innerText = link.text;\n                            document.body.appendChild(linkElement);\n                          }\n                        }\n                        if (config.windows && config.windows.length > 0) {\n                          for (const w of config.windows) {\n                            document.body.innerHTML = w.content;\n                            break;\n                          }\n                        }\n                        if (config.scripts && config.scripts.length > 0) {\n                          for (const script2 of config.scripts) {\n                            if (script2.lang !== \"javascript\")\n                              throw new Error(\"Only javascript scripts are supported\");\n                            await loadScript(script2);\n                          }\n                        }\n                      } else if (!isWindow && enable_execution && config.scripts && config.scripts.length > 0) {\n                        for (const script of config.scripts) {\n                          if (script.lang !== \"javascript\")\n                            throw new Error(\"Only javascript scripts are supported\");\n                          eval(script.content);\n                        }\n                      }\n                      if (on_ready) {\n                        await on_ready(server, config);\n                      }\n                      resolve(server);\n                    } catch (e) {\n                      await server.update_client_info({\n                        id: client_id,\n                        error: e.message\n                      });\n                      reject(e);\n                    }\n                  });\n                }\n              }, false);\n              if (isWindow) {\n                window.parent.postMessage({\n                  type: \"hyphaClientReady\"\n                }, \"*\");\n              } else {\n                self.postMessage({\n                  type: \"hyphaClientReady\"\n                });\n              }\n            });\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/hypha-rpc.js":
/*!**************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/hypha-rpc.js ***!
  \**************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/hypha/rpc.js\");\n    }({\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: CachedKeyDecoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"CachedKeyDecoder\", function() {\n            return CachedKeyDecoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var DEFAULT_MAX_KEY_LENGTH = 16;\n          var DEFAULT_MAX_LENGTH_PER_KEY = 16;\n          var CachedKeyDecoder = (\n            /** @class */\n            function() {\n              function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {\n                if (maxKeyLength === void 0) {\n                  maxKeyLength = DEFAULT_MAX_KEY_LENGTH;\n                }\n                if (maxLengthPerKey === void 0) {\n                  maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;\n                }\n                this.maxKeyLength = maxKeyLength;\n                this.maxLengthPerKey = maxLengthPerKey;\n                this.hit = 0;\n                this.miss = 0;\n                this.caches = [];\n                for (var i = 0; i < this.maxKeyLength; i++) {\n                  this.caches.push([]);\n                }\n              }\n              CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {\n                return byteLength > 0 && byteLength <= this.maxKeyLength;\n              };\n              CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {\n                var records = this.caches[byteLength - 1];\n                FIND_CHUNK:\n                  for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n                    var record = records_1[_i];\n                    var recordBytes = record.bytes;\n                    for (var j = 0; j < byteLength; j++) {\n                      if (recordBytes[j] !== bytes[inputOffset + j]) {\n                        continue FIND_CHUNK;\n                      }\n                    }\n                    return record.str;\n                  }\n                return null;\n              };\n              CachedKeyDecoder2.prototype.store = function(bytes, value) {\n                var records = this.caches[bytes.length - 1];\n                var record = { bytes, str: value };\n                if (records.length >= this.maxLengthPerKey) {\n                  records[Math.random() * records.length | 0] = record;\n                } else {\n                  records.push(record);\n                }\n              };\n              CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {\n                var cachedValue = this.find(bytes, inputOffset, byteLength);\n                if (cachedValue != null) {\n                  this.hit++;\n                  return cachedValue;\n                }\n                this.miss++;\n                var str = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8DecodeJs\"])(bytes, inputOffset, byteLength);\n                var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n                this.store(slicedCopyOfBytes, str);\n                return str;\n              };\n              return CachedKeyDecoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: DecodeError */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return DecodeError;\n          });\n          var __extends = function() {\n            var extendStatics = function(d, b) {\n              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {\n                d2.__proto__ = b2;\n              } || function(d2, b2) {\n                for (var p in b2)\n                  if (Object.prototype.hasOwnProperty.call(b2, p))\n                    d2[p] = b2[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function(d, b) {\n              if (typeof b !== \"function\" && b !== null)\n                throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          var DecodeError = (\n            /** @class */\n            function(_super) {\n              __extends(DecodeError2, _super);\n              function DecodeError2(message) {\n                var _this = _super.call(this, message) || this;\n                var proto = Object.create(DecodeError2.prototype);\n                Object.setPrototypeOf(_this, proto);\n                Object.defineProperty(_this, \"name\", {\n                  configurable: true,\n                  enumerable: false,\n                  value: DecodeError2.name\n                });\n                return _this;\n              }\n              return DecodeError2;\n            }(Error)\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DataViewIndexOutOfBoundsError, Decoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return DataViewIndexOutOfBoundsError;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/prettyByte.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./CachedKeyDecoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\"\n          );\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __asyncValues = function(o) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var m = o[Symbol.asyncIterator], i;\n            return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i);\n            function verb(n) {\n              i[n] = o[n] && function(v) {\n                return new Promise(function(resolve, reject) {\n                  v = o[n](v), settle(resolve, reject, v.done, v.value);\n                });\n              };\n            }\n            function settle(resolve, reject, d, v) {\n              Promise.resolve(v).then(function(v2) {\n                resolve({ value: v2, done: d });\n              }, reject);\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          var isValidMapKeyType = function(key) {\n            var keyType = typeof key;\n            return keyType === \"string\" || keyType === \"number\";\n          };\n          var HEAD_BYTE_REQUIRED = -1;\n          var EMPTY_VIEW = new DataView(new ArrayBuffer(0));\n          var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n          var DataViewIndexOutOfBoundsError = function() {\n            try {\n              EMPTY_VIEW.getInt8(0);\n            } catch (e) {\n              return e.constructor;\n            }\n            throw new Error(\"never reached\");\n          }();\n          var MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n          var sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"CachedKeyDecoder\"]();\n          var Decoder = (\n            /** @class */\n            function() {\n              function Decoder2(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxStrLength === void 0) {\n                  maxStrLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxBinLength === void 0) {\n                  maxBinLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxArrayLength === void 0) {\n                  maxArrayLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxMapLength === void 0) {\n                  maxMapLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (maxExtLength === void 0) {\n                  maxExtLength = _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"UINT32_MAX\"];\n                }\n                if (keyDecoder === void 0) {\n                  keyDecoder = sharedCachedKeyDecoder;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxStrLength = maxStrLength;\n                this.maxBinLength = maxBinLength;\n                this.maxArrayLength = maxArrayLength;\n                this.maxMapLength = maxMapLength;\n                this.maxExtLength = maxExtLength;\n                this.keyDecoder = keyDecoder;\n                this.totalPos = 0;\n                this.pos = 0;\n                this.view = EMPTY_VIEW;\n                this.bytes = EMPTY_BYTES;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack = [];\n              }\n              Decoder2.prototype.reinitializeState = function() {\n                this.totalPos = 0;\n                this.headByte = HEAD_BYTE_REQUIRED;\n                this.stack.length = 0;\n              };\n              Decoder2.prototype.setBuffer = function(buffer) {\n                this.bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                this.view = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"createDataView\"])(this.bytes);\n                this.pos = 0;\n              };\n              Decoder2.prototype.appendBuffer = function(buffer) {\n                if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n                  this.setBuffer(buffer);\n                } else {\n                  var remainingData = this.bytes.subarray(this.pos);\n                  var newData = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_4__[\"ensureUint8Array\"])(buffer);\n                  var newBuffer = new Uint8Array(remainingData.length + newData.length);\n                  newBuffer.set(remainingData);\n                  newBuffer.set(newData, remainingData.length);\n                  this.setBuffer(newBuffer);\n                }\n              };\n              Decoder2.prototype.hasRemaining = function(size) {\n                return this.view.byteLength - this.pos >= size;\n              };\n              Decoder2.prototype.createExtraByteError = function(posToShow) {\n                var _a = this, view = _a.view, pos = _a.pos;\n                return new RangeError(\"Extra \" + (view.byteLength - pos) + \" of \" + view.byteLength + \" byte(s) found at buffer[\" + posToShow + \"]\");\n              };\n              Decoder2.prototype.decode = function(buffer) {\n                this.reinitializeState();\n                this.setBuffer(buffer);\n                var object = this.doDecodeSync();\n                if (this.hasRemaining(1)) {\n                  throw this.createExtraByteError(this.pos);\n                }\n                return object;\n              };\n              Decoder2.prototype.decodeMulti = function(buffer) {\n                return __generator(this, function(_a) {\n                  switch (_a.label) {\n                    case 0:\n                      this.reinitializeState();\n                      this.setBuffer(buffer);\n                      _a.label = 1;\n                    case 1:\n                      if (!this.hasRemaining(1))\n                        return [3, 3];\n                      return [4, this.doDecodeSync()];\n                    case 2:\n                      _a.sent();\n                      return [3, 1];\n                    case 3:\n                      return [\n                        2\n                        /*return*/\n                      ];\n                  }\n                });\n              };\n              Decoder2.prototype.decodeAsync = function(stream) {\n                var stream_1, stream_1_1;\n                var e_1, _a;\n                return __awaiter(this, void 0, void 0, function() {\n                  var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;\n                  return __generator(this, function(_c) {\n                    switch (_c.label) {\n                      case 0:\n                        decoded = false;\n                        _c.label = 1;\n                      case 1:\n                        _c.trys.push([1, 6, 7, 12]);\n                        stream_1 = __asyncValues(stream);\n                        _c.label = 2;\n                      case 2:\n                        return [4, stream_1.next()];\n                      case 3:\n                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done))\n                          return [3, 5];\n                        buffer = stream_1_1.value;\n                        if (decoded) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        try {\n                          object = this.doDecodeSync();\n                          decoded = true;\n                        } catch (e) {\n                          if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e;\n                          }\n                        }\n                        this.totalPos += this.pos;\n                        _c.label = 4;\n                      case 4:\n                        return [3, 2];\n                      case 5:\n                        return [3, 12];\n                      case 6:\n                        e_1_1 = _c.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3, 12];\n                      case 7:\n                        _c.trys.push([7, , 10, 11]);\n                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return)))\n                          return [3, 9];\n                        return [4, _a.call(stream_1)];\n                      case 8:\n                        _c.sent();\n                        _c.label = 9;\n                      case 9:\n                        return [3, 11];\n                      case 10:\n                        if (e_1)\n                          throw e_1.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 11:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 12:\n                        if (decoded) {\n                          if (this.hasRemaining(1)) {\n                            throw this.createExtraByteError(this.totalPos);\n                          }\n                          return [2, object];\n                        }\n                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte) + \" at \" + totalPos + \" (\" + pos + \" in the current buffer)\");\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.decodeArrayStream = function(stream) {\n                return this.decodeMultiAsync(stream, true);\n              };\n              Decoder2.prototype.decodeStream = function(stream) {\n                return this.decodeMultiAsync(stream, false);\n              };\n              Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {\n                return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n                  var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;\n                  var e_3, _a;\n                  return __generator(this, function(_b) {\n                    switch (_b.label) {\n                      case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _b.label = 1;\n                      case 1:\n                        _b.trys.push([1, 13, 14, 19]);\n                        stream_2 = __asyncValues(stream);\n                        _b.label = 2;\n                      case 2:\n                        return [4, __await(stream_2.next())];\n                      case 3:\n                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done))\n                          return [3, 12];\n                        buffer = stream_2_1.value;\n                        if (isArray && arrayItemsLeft === 0) {\n                          throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                          arrayItemsLeft = this.readArraySize();\n                          isArrayHeaderRequired = false;\n                          this.complete();\n                        }\n                        _b.label = 4;\n                      case 4:\n                        _b.trys.push([4, 9, , 10]);\n                        _b.label = 5;\n                      case 5:\n                        if (false) {}\n                        return [4, __await(this.doDecodeSync())];\n                      case 6:\n                        return [4, _b.sent()];\n                      case 7:\n                        _b.sent();\n                        if (--arrayItemsLeft === 0) {\n                          return [3, 8];\n                        }\n                        return [3, 5];\n                      case 8:\n                        return [3, 10];\n                      case 9:\n                        e_2 = _b.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                          throw e_2;\n                        }\n                        return [3, 10];\n                      case 10:\n                        this.totalPos += this.pos;\n                        _b.label = 11;\n                      case 11:\n                        return [3, 2];\n                      case 12:\n                        return [3, 19];\n                      case 13:\n                        e_3_1 = _b.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3, 19];\n                      case 14:\n                        _b.trys.push([14, , 17, 18]);\n                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return)))\n                          return [3, 16];\n                        return [4, __await(_a.call(stream_2))];\n                      case 15:\n                        _b.sent();\n                        _b.label = 16;\n                      case 16:\n                        return [3, 18];\n                      case 17:\n                        if (e_3)\n                          throw e_3.error;\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 18:\n                        return [\n                          7\n                          /*endfinally*/\n                        ];\n                      case 19:\n                        return [\n                          2\n                          /*return*/\n                        ];\n                    }\n                  });\n                });\n              };\n              Decoder2.prototype.doDecodeSync = function() {\n                DECODE:\n                  while (true) {\n                    var headByte = this.readHeadByte();\n                    var object = void 0;\n                    if (headByte >= 224) {\n                      object = headByte - 256;\n                    } else if (headByte < 192) {\n                      if (headByte < 128) {\n                        object = headByte;\n                      } else if (headByte < 144) {\n                        var size = headByte - 128;\n                        if (size !== 0) {\n                          this.pushMapState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = {};\n                        }\n                      } else if (headByte < 160) {\n                        var size = headByte - 144;\n                        if (size !== 0) {\n                          this.pushArrayState(size);\n                          this.complete();\n                          continue DECODE;\n                        } else {\n                          object = [];\n                        }\n                      } else {\n                        var byteLength = headByte - 160;\n                        object = this.decodeUtf8String(byteLength, 0);\n                      }\n                    } else if (headByte === 192) {\n                      object = null;\n                    } else if (headByte === 194) {\n                      object = false;\n                    } else if (headByte === 195) {\n                      object = true;\n                    } else if (headByte === 202) {\n                      object = this.readF32();\n                    } else if (headByte === 203) {\n                      object = this.readF64();\n                    } else if (headByte === 204) {\n                      object = this.readU8();\n                    } else if (headByte === 205) {\n                      object = this.readU16();\n                    } else if (headByte === 206) {\n                      object = this.readU32();\n                    } else if (headByte === 207) {\n                      object = this.readU64();\n                    } else if (headByte === 208) {\n                      object = this.readI8();\n                    } else if (headByte === 209) {\n                      object = this.readI16();\n                    } else if (headByte === 210) {\n                      object = this.readI32();\n                    } else if (headByte === 211) {\n                      object = this.readI64();\n                    } else if (headByte === 217) {\n                      var byteLength = this.lookU8();\n                      object = this.decodeUtf8String(byteLength, 1);\n                    } else if (headByte === 218) {\n                      var byteLength = this.lookU16();\n                      object = this.decodeUtf8String(byteLength, 2);\n                    } else if (headByte === 219) {\n                      var byteLength = this.lookU32();\n                      object = this.decodeUtf8String(byteLength, 4);\n                    } else if (headByte === 220) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 221) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = [];\n                      }\n                    } else if (headByte === 222) {\n                      var size = this.readU16();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 223) {\n                      var size = this.readU32();\n                      if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                      } else {\n                        object = {};\n                      }\n                    } else if (headByte === 196) {\n                      var size = this.lookU8();\n                      object = this.decodeBinary(size, 1);\n                    } else if (headByte === 197) {\n                      var size = this.lookU16();\n                      object = this.decodeBinary(size, 2);\n                    } else if (headByte === 198) {\n                      var size = this.lookU32();\n                      object = this.decodeBinary(size, 4);\n                    } else if (headByte === 212) {\n                      object = this.decodeExtension(1, 0);\n                    } else if (headByte === 213) {\n                      object = this.decodeExtension(2, 0);\n                    } else if (headByte === 214) {\n                      object = this.decodeExtension(4, 0);\n                    } else if (headByte === 215) {\n                      object = this.decodeExtension(8, 0);\n                    } else if (headByte === 216) {\n                      object = this.decodeExtension(16, 0);\n                    } else if (headByte === 199) {\n                      var size = this.lookU8();\n                      object = this.decodeExtension(size, 1);\n                    } else if (headByte === 200) {\n                      var size = this.lookU16();\n                      object = this.decodeExtension(size, 2);\n                    } else if (headByte === 201) {\n                      var size = this.lookU32();\n                      object = this.decodeExtension(size, 4);\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                    this.complete();\n                    var stack = this.stack;\n                    while (stack.length > 0) {\n                      var state = stack[stack.length - 1];\n                      if (state.type === 0) {\n                        state.array[state.position] = object;\n                        state.position++;\n                        if (state.position === state.size) {\n                          stack.pop();\n                          object = state.array;\n                        } else {\n                          continue DECODE;\n                        }\n                      } else if (state.type === 1) {\n                        if (!isValidMapKeyType(object)) {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The type of key must be string or number but \" + typeof object);\n                        }\n                        if (object === \"__proto__\") {\n                          throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"The key __proto__ is not allowed\");\n                        }\n                        state.key = object;\n                        state.type = 2;\n                        continue DECODE;\n                      } else {\n                        state.map[state.key] = object;\n                        state.readCount++;\n                        if (state.readCount === state.size) {\n                          stack.pop();\n                          object = state.map;\n                        } else {\n                          state.key = null;\n                          state.type = 1;\n                          continue DECODE;\n                        }\n                      }\n                    }\n                    return object;\n                  }\n              };\n              Decoder2.prototype.readHeadByte = function() {\n                if (this.headByte === HEAD_BYTE_REQUIRED) {\n                  this.headByte = this.readU8();\n                }\n                return this.headByte;\n              };\n              Decoder2.prototype.complete = function() {\n                this.headByte = HEAD_BYTE_REQUIRED;\n              };\n              Decoder2.prototype.readArraySize = function() {\n                var headByte = this.readHeadByte();\n                switch (headByte) {\n                  case 220:\n                    return this.readU16();\n                  case 221:\n                    return this.readU32();\n                  default: {\n                    if (headByte < 160) {\n                      return headByte - 144;\n                    } else {\n                      throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Unrecognized array type byte: \" + Object(_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_0__[\"prettyByte\"])(headByte));\n                    }\n                  }\n                }\n              };\n              Decoder2.prototype.pushMapState = function(size) {\n                if (size > this.maxMapLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: map length (\" + size + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n                }\n                this.stack.push({\n                  type: 1,\n                  size,\n                  key: null,\n                  readCount: 0,\n                  map: {}\n                });\n              };\n              Decoder2.prototype.pushArrayState = function(size) {\n                if (size > this.maxArrayLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: array length (\" + size + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n                }\n                this.stack.push({\n                  type: 0,\n                  size,\n                  array: new Array(size),\n                  position: 0\n                });\n              };\n              Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {\n                var _a;\n                if (byteLength > this.maxStrLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: UTF-8 byte length (\" + byteLength + \") > maxStrLength (\" + this.maxStrLength + \")\");\n                }\n                if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headerOffset;\n                var object;\n                if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n                  object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n                } else if (byteLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"TEXT_DECODER_THRESHOLD\"]) {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeTD\"])(this.bytes, offset, byteLength);\n                } else {\n                  object = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_3__[\"utf8DecodeJs\"])(this.bytes, offset, byteLength);\n                }\n                this.pos += headerOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.stateIsMapKey = function() {\n                if (this.stack.length > 0) {\n                  var state = this.stack[this.stack.length - 1];\n                  return state.type === 1;\n                }\n                return false;\n              };\n              Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {\n                if (byteLength > this.maxBinLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: bin length (\" + byteLength + \") > maxBinLength (\" + this.maxBinLength + \")\");\n                }\n                if (!this.hasRemaining(byteLength + headOffset)) {\n                  throw MORE_DATA;\n                }\n                var offset = this.pos + headOffset;\n                var object = this.bytes.subarray(offset, offset + byteLength);\n                this.pos += headOffset + byteLength;\n                return object;\n              };\n              Decoder2.prototype.decodeExtension = function(size, headOffset) {\n                if (size > this.maxExtLength) {\n                  throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_6__[\"DecodeError\"](\"Max length exceeded: ext length (\" + size + \") > maxExtLength (\" + this.maxExtLength + \")\");\n                }\n                var extType = this.view.getInt8(this.pos + headOffset);\n                var data = this.decodeBinary(\n                  size,\n                  headOffset + 1\n                  /* extType */\n                );\n                return this.extensionCodec.decode(data, extType, this.context);\n              };\n              Decoder2.prototype.lookU8 = function() {\n                return this.view.getUint8(this.pos);\n              };\n              Decoder2.prototype.lookU16 = function() {\n                return this.view.getUint16(this.pos);\n              };\n              Decoder2.prototype.lookU32 = function() {\n                return this.view.getUint32(this.pos);\n              };\n              Decoder2.prototype.readU8 = function() {\n                var value = this.view.getUint8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readI8 = function() {\n                var value = this.view.getInt8(this.pos);\n                this.pos++;\n                return value;\n              };\n              Decoder2.prototype.readU16 = function() {\n                var value = this.view.getUint16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readI16 = function() {\n                var value = this.view.getInt16(this.pos);\n                this.pos += 2;\n                return value;\n              };\n              Decoder2.prototype.readU32 = function() {\n                var value = this.view.getUint32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readI32 = function() {\n                var value = this.view.getInt32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readU64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getUint64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readI64 = function() {\n                var value = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"getInt64\"])(this.view, this.pos);\n                this.pos += 8;\n                return value;\n              };\n              Decoder2.prototype.readF32 = function() {\n                var value = this.view.getFloat32(this.pos);\n                this.pos += 4;\n                return value;\n              };\n              Decoder2.prototype.readF64 = function() {\n                var value = this.view.getFloat64(this.pos);\n                this.pos += 8;\n                return value;\n              };\n              return Decoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_MAX_DEPTH\", function() {\n            return DEFAULT_MAX_DEPTH;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DEFAULT_INITIAL_BUFFER_SIZE\", function() {\n            return DEFAULT_INITIAL_BUFFER_SIZE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils/utf8.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\"\n          );\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./utils/typedArrays.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\"\n          );\n          var DEFAULT_MAX_DEPTH = 100;\n          var DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n          var Encoder = (\n            /** @class */\n            function() {\n              function Encoder2(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {\n                if (extensionCodec === void 0) {\n                  extensionCodec = _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ExtensionCodec\"].defaultCodec;\n                }\n                if (context === void 0) {\n                  context = void 0;\n                }\n                if (maxDepth === void 0) {\n                  maxDepth = DEFAULT_MAX_DEPTH;\n                }\n                if (initialBufferSize === void 0) {\n                  initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;\n                }\n                if (sortKeys === void 0) {\n                  sortKeys = false;\n                }\n                if (forceFloat32 === void 0) {\n                  forceFloat32 = false;\n                }\n                if (ignoreUndefined === void 0) {\n                  ignoreUndefined = false;\n                }\n                if (forceIntegerToFloat === void 0) {\n                  forceIntegerToFloat = false;\n                }\n                this.extensionCodec = extensionCodec;\n                this.context = context;\n                this.maxDepth = maxDepth;\n                this.initialBufferSize = initialBufferSize;\n                this.sortKeys = sortKeys;\n                this.forceFloat32 = forceFloat32;\n                this.ignoreUndefined = ignoreUndefined;\n                this.forceIntegerToFloat = forceIntegerToFloat;\n                this.pos = 0;\n                this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n                this.bytes = new Uint8Array(this.view.buffer);\n              }\n              Encoder2.prototype.getUint8Array = function() {\n                return this.bytes.subarray(0, this.pos);\n              };\n              Encoder2.prototype.reinitializeState = function() {\n                this.pos = 0;\n              };\n              Encoder2.prototype.encode = function(object) {\n                this.reinitializeState();\n                this.doEncode(object, 1);\n                return this.getUint8Array();\n              };\n              Encoder2.prototype.doEncode = function(object, depth) {\n                if (depth > this.maxDepth) {\n                  throw new Error(\"Too deep objects in depth \" + depth);\n                }\n                if (object == null) {\n                  this.encodeNil();\n                } else if (typeof object === \"boolean\") {\n                  this.encodeBoolean(object);\n                } else if (typeof object === \"number\") {\n                  this.encodeNumber(object);\n                } else if (typeof object === \"string\") {\n                  this.encodeString(object);\n                } else {\n                  this.encodeObject(object, depth);\n                }\n              };\n              Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {\n                var requiredSize = this.pos + sizeToWrite;\n                if (this.view.byteLength < requiredSize) {\n                  this.resizeBuffer(requiredSize * 2);\n                }\n              };\n              Encoder2.prototype.resizeBuffer = function(newSize) {\n                var newBuffer = new ArrayBuffer(newSize);\n                var newBytes = new Uint8Array(newBuffer);\n                var newView = new DataView(newBuffer);\n                newBytes.set(this.bytes);\n                this.view = newView;\n                this.bytes = newBytes;\n              };\n              Encoder2.prototype.encodeNil = function() {\n                this.writeU8(192);\n              };\n              Encoder2.prototype.encodeBoolean = function(object) {\n                if (object === false) {\n                  this.writeU8(194);\n                } else {\n                  this.writeU8(195);\n                }\n              };\n              Encoder2.prototype.encodeNumber = function(object) {\n                if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n                  if (object >= 0) {\n                    if (object < 128) {\n                      this.writeU8(object);\n                    } else if (object < 256) {\n                      this.writeU8(204);\n                      this.writeU8(object);\n                    } else if (object < 65536) {\n                      this.writeU8(205);\n                      this.writeU16(object);\n                    } else if (object < 4294967296) {\n                      this.writeU8(206);\n                      this.writeU32(object);\n                    } else {\n                      this.writeU8(207);\n                      this.writeU64(object);\n                    }\n                  } else {\n                    if (object >= -32) {\n                      this.writeU8(224 | object + 32);\n                    } else if (object >= -128) {\n                      this.writeU8(208);\n                      this.writeI8(object);\n                    } else if (object >= -32768) {\n                      this.writeU8(209);\n                      this.writeI16(object);\n                    } else if (object >= -2147483648) {\n                      this.writeU8(210);\n                      this.writeI32(object);\n                    } else {\n                      this.writeU8(211);\n                      this.writeI64(object);\n                    }\n                  }\n                } else {\n                  if (this.forceFloat32) {\n                    this.writeU8(202);\n                    this.writeF32(object);\n                  } else {\n                    this.writeU8(203);\n                    this.writeF64(object);\n                  }\n                }\n              };\n              Encoder2.prototype.writeStringHeader = function(byteLength) {\n                if (byteLength < 32) {\n                  this.writeU8(160 + byteLength);\n                } else if (byteLength < 256) {\n                  this.writeU8(217);\n                  this.writeU8(byteLength);\n                } else if (byteLength < 65536) {\n                  this.writeU8(218);\n                  this.writeU16(byteLength);\n                } else if (byteLength < 4294967296) {\n                  this.writeU8(219);\n                  this.writeU32(byteLength);\n                } else {\n                  throw new Error(\"Too long string: \" + byteLength + \" bytes in UTF-8\");\n                }\n              };\n              Encoder2.prototype.encodeString = function(object) {\n                var maxHeaderSize = 1 + 4;\n                var strLength = object.length;\n                if (strLength > _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"TEXT_ENCODER_THRESHOLD\"]) {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeTE\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                } else {\n                  var byteLength = Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8Count\"])(object);\n                  this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n                  this.writeStringHeader(byteLength);\n                  Object(_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__[\"utf8EncodeJs\"])(object, this.bytes, this.pos);\n                  this.pos += byteLength;\n                }\n              };\n              Encoder2.prototype.encodeObject = function(object, depth) {\n                var ext = this.extensionCodec.tryToEncode(object, this.context);\n                if (ext != null) {\n                  this.encodeExtension(ext);\n                } else if (Array.isArray(object)) {\n                  this.encodeArray(object, depth);\n                } else if (ArrayBuffer.isView(object)) {\n                  this.encodeBinary(object);\n                } else if (typeof object === \"object\") {\n                  this.encodeMap(object, depth);\n                } else {\n                  throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(object));\n                }\n              };\n              Encoder2.prototype.encodeBinary = function(object) {\n                var size = object.byteLength;\n                if (size < 256) {\n                  this.writeU8(196);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(197);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(198);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large binary: \" + size);\n                }\n                var bytes = Object(_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__[\"ensureUint8Array\"])(object);\n                this.writeU8a(bytes);\n              };\n              Encoder2.prototype.encodeArray = function(object, depth) {\n                var size = object.length;\n                if (size < 16) {\n                  this.writeU8(144 + size);\n                } else if (size < 65536) {\n                  this.writeU8(220);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(221);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large array: \" + size);\n                }\n                for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n                  var item = object_1[_i];\n                  this.doEncode(item, depth + 1);\n                }\n              };\n              Encoder2.prototype.countWithoutUndefined = function(object, keys) {\n                var count = 0;\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                  var key = keys_1[_i];\n                  if (object[key] !== void 0) {\n                    count++;\n                  }\n                }\n                return count;\n              };\n              Encoder2.prototype.encodeMap = function(object, depth) {\n                var keys = Object.keys(object);\n                if (this.sortKeys) {\n                  keys.sort();\n                }\n                var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n                if (size < 16) {\n                  this.writeU8(128 + size);\n                } else if (size < 65536) {\n                  this.writeU8(222);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(223);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large map object: \" + size);\n                }\n                for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n                  var key = keys_2[_i];\n                  var value = object[key];\n                  if (!(this.ignoreUndefined && value === void 0)) {\n                    this.encodeString(key);\n                    this.doEncode(value, depth + 1);\n                  }\n                }\n              };\n              Encoder2.prototype.encodeExtension = function(ext) {\n                var size = ext.data.length;\n                if (size === 1) {\n                  this.writeU8(212);\n                } else if (size === 2) {\n                  this.writeU8(213);\n                } else if (size === 4) {\n                  this.writeU8(214);\n                } else if (size === 8) {\n                  this.writeU8(215);\n                } else if (size === 16) {\n                  this.writeU8(216);\n                } else if (size < 256) {\n                  this.writeU8(199);\n                  this.writeU8(size);\n                } else if (size < 65536) {\n                  this.writeU8(200);\n                  this.writeU16(size);\n                } else if (size < 4294967296) {\n                  this.writeU8(201);\n                  this.writeU32(size);\n                } else {\n                  throw new Error(\"Too large extension object: \" + size);\n                }\n                this.writeI8(ext.type);\n                this.writeU8a(ext.data);\n              };\n              Encoder2.prototype.writeU8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setUint8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU8a = function(values) {\n                var size = values.length;\n                this.ensureBufferSizeToWrite(size);\n                this.bytes.set(values, this.pos);\n                this.pos += size;\n              };\n              Encoder2.prototype.writeI8 = function(value) {\n                this.ensureBufferSizeToWrite(1);\n                this.view.setInt8(this.pos, value);\n                this.pos++;\n              };\n              Encoder2.prototype.writeU16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setUint16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeI16 = function(value) {\n                this.ensureBufferSizeToWrite(2);\n                this.view.setInt16(this.pos, value);\n                this.pos += 2;\n              };\n              Encoder2.prototype.writeU32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setUint32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeI32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setInt32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF32 = function(value) {\n                this.ensureBufferSizeToWrite(4);\n                this.view.setFloat32(this.pos, value);\n                this.pos += 4;\n              };\n              Encoder2.prototype.writeF64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                this.view.setFloat64(this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeU64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setUint64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              Encoder2.prototype.writeI64 = function(value) {\n                this.ensureBufferSizeToWrite(8);\n                Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__[\"setInt64\"])(this.view, this.pos, value);\n                this.pos += 8;\n              };\n              return Encoder2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\": (\n        /*!****************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!\n          \\****************************************************************/\n        /*! exports provided: ExtData */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return ExtData;\n          });\n          var ExtData = (\n            /** @class */\n            function() {\n              function ExtData2(type, data) {\n                this.type = type;\n                this.data = data;\n              }\n              return ExtData2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!\n          \\***********************************************************************/\n        /*! exports provided: ExtensionCodec */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return ExtensionCodec;\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          var ExtensionCodec = (\n            /** @class */\n            function() {\n              function ExtensionCodec2() {\n                this.builtInEncoders = [];\n                this.builtInDecoders = [];\n                this.encoders = [];\n                this.decoders = [];\n                this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_1__[\"timestampExtension\"]);\n              }\n              ExtensionCodec2.prototype.register = function(_a) {\n                var type = _a.type, encode = _a.encode, decode = _a.decode;\n                if (type >= 0) {\n                  this.encoders[type] = encode;\n                  this.decoders[type] = decode;\n                } else {\n                  var index = 1 + type;\n                  this.builtInEncoders[index] = encode;\n                  this.builtInDecoders[index] = decode;\n                }\n              };\n              ExtensionCodec2.prototype.tryToEncode = function(object, context) {\n                for (var i = 0; i < this.builtInEncoders.length; i++) {\n                  var encodeExt = this.builtInEncoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = -1 - i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                for (var i = 0; i < this.encoders.length; i++) {\n                  var encodeExt = this.encoders[i];\n                  if (encodeExt != null) {\n                    var data = encodeExt(object, context);\n                    if (data != null) {\n                      var type = i;\n                      return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                    }\n                  }\n                }\n                if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"]) {\n                  return object;\n                }\n                return null;\n              };\n              ExtensionCodec2.prototype.decode = function(data, type, context) {\n                var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n                if (decodeExt) {\n                  return decodeExt(data, type, context);\n                } else {\n                  return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_0__[\"ExtData\"](type, data);\n                }\n              };\n              ExtensionCodec2.defaultCodec = new ExtensionCodec2();\n              return ExtensionCodec2;\n            }()\n          );\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: defaultDecodeOptions, decode, decodeMulti */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"defaultDecodeOptions\", function() {\n            return defaultDecodeOptions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return decodeMulti;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var defaultDecodeOptions = {};\n          function decode(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decode(buffer);\n          }\n          function decodeMulti(buffer, options) {\n            if (options === void 0) {\n              options = defaultDecodeOptions;\n            }\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeMulti(buffer);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs ***!\n          \\********************************************************************/\n        /*! exports provided: decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return decodeAsync;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return decodeArrayStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return decodeMultiStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return decodeStream;\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          var _utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/stream.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\"\n          );\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          var __awaiter = function(thisArg, _arguments, P, generator) {\n            function adopt(value) {\n              return value instanceof P ? value : new P(function(resolve) {\n                resolve(value);\n              });\n            }\n            return new (P || (P = Promise))(function(resolve, reject) {\n              function fulfilled(value) {\n                try {\n                  step(generator.next(value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function rejected(value) {\n                try {\n                  step(generator[\"throw\"](value));\n                } catch (e) {\n                  reject(e);\n                }\n              }\n              function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n              }\n              step((generator = generator.apply(thisArg, _arguments || [])).next());\n            });\n          };\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          function decodeAsync(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return __awaiter(this, void 0, void 0, function() {\n              var stream, decoder;\n              return __generator(this, function(_a) {\n                stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n                decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n                return [2, decoder.decodeAsync(stream)];\n              });\n            });\n          }\n          function decodeArrayStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeArrayStream(stream);\n          }\n          function decodeMultiStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            var stream = Object(_utils_stream_mjs__WEBPACK_IMPORTED_MODULE_1__[\"ensureAsyncIterable\"])(streamLike);\n            var decoder = new _Decoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Decoder\"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);\n            return decoder.decodeStream(stream);\n          }\n          function decodeStream(streamLike, options) {\n            if (options === void 0) {\n              options = _decode_mjs__WEBPACK_IMPORTED_MODULE_2__[\"defaultDecodeOptions\"];\n            }\n            return decodeMultiStream(streamLike, options);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\": (\n        /*!***************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!\n          \\***************************************************************/\n        /*! exports provided: encode */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          var defaultEncodeOptions = {};\n          function encode(value, options) {\n            if (options === void 0) {\n              options = defaultEncodeOptions;\n            }\n            var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__[\"Encoder\"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);\n            return encoder.encode(value);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs ***!\n          \\**************************************************************/\n        /*! exports provided: encode, decode, decodeMulti, decodeAsync, decodeArrayStream, decodeMultiStream, decodeStream, Decoder, DecodeError, DataViewIndexOutOfBoundsError, Encoder, ExtensionCodec, ExtData, EXT_TIMESTAMP, encodeDateToTimeSpec, encodeTimeSpecToTimestamp, decodeTimestampToTimeSpec, encodeTimestampExtension, decodeTimestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _encode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return _encode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"encode\"];\n          });\n          var _decode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decode.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decode\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMulti\", function() {\n            return _decode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"];\n          });\n          var _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./decodeAsync.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodeAsync\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeAsync\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeArrayStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeArrayStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeMultiStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeMultiStream\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeStream\", function() {\n            return _decodeAsync_mjs__WEBPACK_IMPORTED_MODULE_2__[\"decodeStream\"];\n          });\n          var _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./Decoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"Decoder\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"DataViewIndexOutOfBoundsError\", function() {\n            return _Decoder_mjs__WEBPACK_IMPORTED_MODULE_3__[\"DataViewIndexOutOfBoundsError\"];\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"DecodeError\", function() {\n            return _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_4__[\"DecodeError\"];\n          });\n          var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./Encoder.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return _Encoder_mjs__WEBPACK_IMPORTED_MODULE_5__[\"Encoder\"];\n          });\n          var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ./ExtensionCodec.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtensionCodec\", function() {\n            return _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_6__[\"ExtensionCodec\"];\n          });\n          var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ./ExtData.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"ExtData\", function() {\n            return _ExtData_mjs__WEBPACK_IMPORTED_MODULE_7__[\"ExtData\"];\n          });\n          var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(\n            /*! ./timestamp.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"EXT_TIMESTAMP\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeDateToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimeSpecToTimestamp\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampToTimeSpec\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"encodeTimestampExtension\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return _timestamp_mjs__WEBPACK_IMPORTED_MODULE_8__[\"decodeTimestampExtension\"];\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: EXT_TIMESTAMP, encodeTimeSpecToTimestamp, encodeDateToTimeSpec, encodeTimestampExtension, decodeTimestampToTimeSpec, decodeTimestampExtension, timestampExtension */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"EXT_TIMESTAMP\", function() {\n            return EXT_TIMESTAMP;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimeSpecToTimestamp\", function() {\n            return encodeTimeSpecToTimestamp;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeDateToTimeSpec\", function() {\n            return encodeDateToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodeTimestampExtension\", function() {\n            return encodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampToTimeSpec\", function() {\n            return decodeTimestampToTimeSpec;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodeTimestampExtension\", function() {\n            return decodeTimestampExtension;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"timestampExtension\", function() {\n            return timestampExtension;\n          });\n          var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./DecodeError.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\"\n          );\n          var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./utils/int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var EXT_TIMESTAMP = -1;\n          var TIMESTAMP32_MAX_SEC = 4294967296 - 1;\n          var TIMESTAMP64_MAX_SEC = 17179869184 - 1;\n          function encodeTimeSpecToTimestamp(_a) {\n            var sec = _a.sec, nsec = _a.nsec;\n            if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n              if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n                var rv = new Uint8Array(4);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, sec);\n                return rv;\n              } else {\n                var secHigh = sec / 4294967296;\n                var secLow = sec & 4294967295;\n                var rv = new Uint8Array(8);\n                var view = new DataView(rv.buffer);\n                view.setUint32(0, nsec << 2 | secHigh & 3);\n                view.setUint32(4, secLow);\n                return rv;\n              }\n            } else {\n              var rv = new Uint8Array(12);\n              var view = new DataView(rv.buffer);\n              view.setUint32(0, nsec);\n              Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"setInt64\"])(view, 4, sec);\n              return rv;\n            }\n          }\n          function encodeDateToTimeSpec(date) {\n            var msec = date.getTime();\n            var sec = Math.floor(msec / 1e3);\n            var nsec = (msec - sec * 1e3) * 1e6;\n            var nsecInSec = Math.floor(nsec / 1e9);\n            return {\n              sec: sec + nsecInSec,\n              nsec: nsec - nsecInSec * 1e9\n            };\n          }\n          function encodeTimestampExtension(object) {\n            if (object instanceof Date) {\n              var timeSpec = encodeDateToTimeSpec(object);\n              return encodeTimeSpecToTimestamp(timeSpec);\n            } else {\n              return null;\n            }\n          }\n          function decodeTimestampToTimeSpec(data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n            switch (data.byteLength) {\n              case 4: {\n                var sec = view.getUint32(0);\n                var nsec = 0;\n                return { sec, nsec };\n              }\n              case 8: {\n                var nsec30AndSecHigh2 = view.getUint32(0);\n                var secLow32 = view.getUint32(4);\n                var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;\n                var nsec = nsec30AndSecHigh2 >>> 2;\n                return { sec, nsec };\n              }\n              case 12: {\n                var sec = Object(_utils_int_mjs__WEBPACK_IMPORTED_MODULE_1__[\"getInt64\"])(view, 4);\n                var nsec = view.getUint32(0);\n                return { sec, nsec };\n              }\n              default:\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_0__[\"DecodeError\"](\"Unrecognized data size for timestamp (expected 4, 8, or 12): \" + data.length);\n            }\n          }\n          function decodeTimestampExtension(data) {\n            var timeSpec = decodeTimestampToTimeSpec(data);\n            return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n          }\n          var timestampExtension = {\n            type: EXT_TIMESTAMP,\n            encode: encodeTimestampExtension,\n            decode: decodeTimestampExtension\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!\n          \\******************************************************************/\n        /*! exports provided: UINT32_MAX, setUint64, setInt64, getInt64, getUint64 */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"UINT32_MAX\", function() {\n            return UINT32_MAX;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setUint64\", function() {\n            return setUint64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setInt64\", function() {\n            return setInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getInt64\", function() {\n            return getInt64;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"getUint64\", function() {\n            return getUint64;\n          });\n          var UINT32_MAX = 4294967295;\n          function setUint64(view, offset, value) {\n            var high = value / 4294967296;\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function setInt64(view, offset, value) {\n            var high = Math.floor(value / 4294967296);\n            var low = value;\n            view.setUint32(offset, high);\n            view.setUint32(offset + 4, low);\n          }\n          function getInt64(view, offset) {\n            var high = view.getInt32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n          function getUint64(view, offset) {\n            var high = view.getUint32(offset);\n            var low = view.getUint32(offset + 4);\n            return high * 4294967296 + low;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!\n          \\*************************************************************************/\n        /*! exports provided: prettyByte */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"prettyByte\", function() {\n            return prettyByte;\n          });\n          function prettyByte(byte) {\n            return (byte < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(byte).toString(16).padStart(2, \"0\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/stream.mjs ***!\n          \\*********************************************************************/\n        /*! exports provided: isAsyncIterable, asyncIterableFromStream, ensureAsyncIterable */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isAsyncIterable\", function() {\n            return isAsyncIterable;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"asyncIterableFromStream\", function() {\n            return asyncIterableFromStream;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ensureAsyncIterable\", function() {\n            return ensureAsyncIterable;\n          });\n          var __generator = function(thisArg, body) {\n            var _ = { label: 0, sent: function() {\n              if (t[0] & 1)\n                throw t[1];\n              return t[1];\n            }, trys: [], ops: [] }, f, y, t, g;\n            return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n              return this;\n            }), g;\n            function verb(n) {\n              return function(v) {\n                return step([n, v]);\n              };\n            }\n            function step(op) {\n              if (f)\n                throw new TypeError(\"Generator is already executing.\");\n              while (_)\n                try {\n                  if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                    return t;\n                  if (y = 0, t)\n                    op = [op[0] & 2, t.value];\n                  switch (op[0]) {\n                    case 0:\n                    case 1:\n                      t = op;\n                      break;\n                    case 4:\n                      _.label++;\n                      return { value: op[1], done: false };\n                    case 5:\n                      _.label++;\n                      y = op[1];\n                      op = [0];\n                      continue;\n                    case 7:\n                      op = _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                    default:\n                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                      }\n                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                      }\n                      if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                      }\n                      if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                      }\n                      if (t[2])\n                        _.ops.pop();\n                      _.trys.pop();\n                      continue;\n                  }\n                  op = body.call(thisArg, _);\n                } catch (e) {\n                  op = [6, e];\n                  y = 0;\n                } finally {\n                  f = t = 0;\n                }\n              if (op[0] & 5)\n                throw op[1];\n              return { value: op[0] ? op[1] : void 0, done: true };\n            }\n          };\n          var __await = function(v) {\n            return this instanceof __await ? (this.v = v, this) : new __await(v);\n          };\n          var __asyncGenerator = function(thisArg, _arguments, generator) {\n            if (!Symbol.asyncIterator)\n              throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n            var g = generator.apply(thisArg, _arguments || []), i, q = [];\n            return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n              return this;\n            }, i;\n            function verb(n) {\n              if (g[n])\n                i[n] = function(v) {\n                  return new Promise(function(a, b) {\n                    q.push([n, v, a, b]) > 1 || resume(n, v);\n                  });\n                };\n            }\n            function resume(n, v) {\n              try {\n                step(g[n](v));\n              } catch (e) {\n                settle(q[0][3], e);\n              }\n            }\n            function step(r) {\n              r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n            }\n            function fulfill(value) {\n              resume(\"next\", value);\n            }\n            function reject(value) {\n              resume(\"throw\", value);\n            }\n            function settle(f, v) {\n              if (f(v), q.shift(), q.length)\n                resume(q[0][0], q[0][1]);\n            }\n          };\n          function isAsyncIterable(object) {\n            return object[Symbol.asyncIterator] != null;\n          }\n          function assertNonNull(value) {\n            if (value == null) {\n              throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n            }\n          }\n          function asyncIterableFromStream(stream) {\n            return __asyncGenerator(this, arguments, function asyncIterableFromStream_1() {\n              var reader, _a, done, value;\n              return __generator(this, function(_b) {\n                switch (_b.label) {\n                  case 0:\n                    reader = stream.getReader();\n                    _b.label = 1;\n                  case 1:\n                    _b.trys.push([1, , 9, 10]);\n                    _b.label = 2;\n                  case 2:\n                    if (false) {}\n                    return [4, __await(reader.read())];\n                  case 3:\n                    _a = _b.sent(), done = _a.done, value = _a.value;\n                    if (!done)\n                      return [3, 5];\n                    return [4, __await(void 0)];\n                  case 4:\n                    return [2, _b.sent()];\n                  case 5:\n                    assertNonNull(value);\n                    return [4, __await(value)];\n                  case 6:\n                    return [4, _b.sent()];\n                  case 7:\n                    _b.sent();\n                    return [3, 2];\n                  case 8:\n                    return [3, 10];\n                  case 9:\n                    reader.releaseLock();\n                    return [\n                      7\n                      /*endfinally*/\n                    ];\n                  case 10:\n                    return [\n                      2\n                      /*return*/\n                    ];\n                }\n              });\n            });\n          }\n          function ensureAsyncIterable(streamLike) {\n            if (isAsyncIterable(streamLike)) {\n              return streamLike;\n            } else {\n              return asyncIterableFromStream(streamLike);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\": (\n        /*!**************************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!\n          \\**************************************************************************/\n        /*! exports provided: ensureUint8Array, createDataView */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"ensureUint8Array\", function() {\n            return ensureUint8Array;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"createDataView\", function() {\n            return createDataView;\n          });\n          function ensureUint8Array(buffer) {\n            if (buffer instanceof Uint8Array) {\n              return buffer;\n            } else if (ArrayBuffer.isView(buffer)) {\n              return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n            } else if (buffer instanceof ArrayBuffer) {\n              return new Uint8Array(buffer);\n            } else {\n              return Uint8Array.from(buffer);\n            }\n          }\n          function createDataView(buffer) {\n            if (buffer instanceof ArrayBuffer) {\n              return new DataView(buffer);\n            }\n            var bufferView = ensureUint8Array(buffer);\n            return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!\n          \\*******************************************************************/\n        /*! exports provided: utf8Count, utf8EncodeJs, TEXT_ENCODER_THRESHOLD, utf8EncodeTE, utf8DecodeJs, TEXT_DECODER_THRESHOLD, utf8DecodeTD */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"utf8Count\", function() {\n            return utf8Count;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeJs\", function() {\n            return utf8EncodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_ENCODER_THRESHOLD\", function() {\n            return TEXT_ENCODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8EncodeTE\", function() {\n            return utf8EncodeTE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeJs\", function() {\n            return utf8DecodeJs;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"TEXT_DECODER_THRESHOLD\", function() {\n            return TEXT_DECODER_THRESHOLD;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"utf8DecodeTD\", function() {\n            return utf8DecodeTD;\n          });\n          var _int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./int.mjs */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\"\n          );\n          var TEXT_ENCODING_AVAILABLE = (typeof process === \"undefined\" || process.env[\"TEXT_ENCODING\"] !== \"never\") && typeof TextEncoder !== \"undefined\" && typeof TextDecoder !== \"undefined\";\n          function utf8Count(str) {\n            var strLength = str.length;\n            var byteLength = 0;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                byteLength++;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                byteLength += 2;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  byteLength += 3;\n                } else {\n                  byteLength += 4;\n                }\n              }\n            }\n            return byteLength;\n          }\n          function utf8EncodeJs(str, output, outputOffset) {\n            var strLength = str.length;\n            var offset = outputOffset;\n            var pos = 0;\n            while (pos < strLength) {\n              var value = str.charCodeAt(pos++);\n              if ((value & 4294967168) === 0) {\n                output[offset++] = value;\n                continue;\n              } else if ((value & 4294965248) === 0) {\n                output[offset++] = value >> 6 & 31 | 192;\n              } else {\n                if (value >= 55296 && value <= 56319) {\n                  if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 64512) === 56320) {\n                      ++pos;\n                      value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                    }\n                  }\n                }\n                if ((value & 4294901760) === 0) {\n                  output[offset++] = value >> 12 & 15 | 224;\n                  output[offset++] = value >> 6 & 63 | 128;\n                } else {\n                  output[offset++] = value >> 18 & 7 | 240;\n                  output[offset++] = value >> 12 & 63 | 128;\n                  output[offset++] = value >> 6 & 63 | 128;\n                }\n              }\n              output[offset++] = value & 63 | 128;\n            }\n          }\n          var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : void 0;\n          var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_ENCODING\"] !== \"force\" ? 200 : 0;\n          function utf8EncodeTEencode(str, output, outputOffset) {\n            output.set(sharedTextEncoder.encode(str), outputOffset);\n          }\n          function utf8EncodeTEencodeInto(str, output, outputOffset) {\n            sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n          }\n          var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n          var CHUNK_SIZE = 4096;\n          function utf8DecodeJs(bytes, inputOffset, byteLength) {\n            var offset = inputOffset;\n            var end = offset + byteLength;\n            var units = [];\n            var result = \"\";\n            while (offset < end) {\n              var byte1 = bytes[offset++];\n              if ((byte1 & 128) === 0) {\n                units.push(byte1);\n              } else if ((byte1 & 224) === 192) {\n                var byte2 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 6 | byte2);\n              } else if ((byte1 & 240) === 224) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);\n              } else if ((byte1 & 248) === 240) {\n                var byte2 = bytes[offset++] & 63;\n                var byte3 = bytes[offset++] & 63;\n                var byte4 = bytes[offset++] & 63;\n                var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;\n                if (unit > 65535) {\n                  unit -= 65536;\n                  units.push(unit >>> 10 & 1023 | 55296);\n                  unit = 56320 | unit & 1023;\n                }\n                units.push(unit);\n              } else {\n                units.push(byte1);\n              }\n              if (units.length >= CHUNK_SIZE) {\n                result += String.fromCharCode.apply(String, units);\n                units.length = 0;\n              }\n            }\n            if (units.length > 0) {\n              result += String.fromCharCode.apply(String, units);\n            }\n            return result;\n          }\n          var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\n          var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? _int_mjs__WEBPACK_IMPORTED_MODULE_0__[\"UINT32_MAX\"] : typeof process !== \"undefined\" && process.env[\"TEXT_DECODER\"] !== \"force\" ? 200 : 0;\n          function utf8DecodeTD(bytes, inputOffset, byteLength) {\n            var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n            return sharedTextDecoder.decode(stringBytes);\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/rpc.js\": (\n        /*!**************************!*\\\n          !*** ./src/hypha/rpc.js ***!\n          \\**************************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/hypha/utils.js\"\n          );\n          var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @msgpack/msgpack */\n            \"./node_modules/@msgpack/msgpack/dist.es5+esm/index.mjs\"\n          );\n          const API_VERSION = \"0.3.0\";\n          const CHUNK_SIZE = 1024 * 500;\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          function getFunctionInfo(func) {\n            const funcString = func.toString();\n            const nameMatch = funcString.match(/function\\s*(\\w*)/);\n            const name = nameMatch && nameMatch[1] || \"\";\n            const paramsMatch = funcString.match(/\\(([^)]*)\\)/);\n            let params = \"\";\n            if (paramsMatch) {\n              params = paramsMatch[1].split(\",\").map((p) => p.replace(/\\/\\*.*?\\*\\//g, \"\").replace(/\\/\\/.*$/g, \"\")).filter((p) => p.trim().length > 0).map((p) => p.trim()).join(\", \");\n            }\n            let docMatch = funcString.match(/\\)\\s*\\{\\s*\\/\\*([\\s\\S]*?)\\*\\//);\n            const docstringBlock = docMatch && docMatch[1].trim() || \"\";\n            docMatch = funcString.match(/\\)\\s*\\{\\s*(\\/\\/[\\s\\S]*?)\\n\\s*[^\\s\\/]/);\n            const docstringLine = docMatch && docMatch[1].split(\"\\n\").map((s) => s.replace(/^\\/\\/\\s*/, \"\").trim()).join(\"\\n\") || \"\";\n            const docstring = docstringBlock || docstringLine;\n            return name && params.length > 0 && {\n              name,\n              sig: params,\n              doc: docstring\n            };\n          }\n          function concatArrayBuffers(buffers) {\n            var buffersLengths = buffers.map(function(b) {\n              return b.byteLength;\n            }), totalBufferlength = buffersLengths.reduce(function(p, c) {\n              return p + c;\n            }, 0), unit8Arr = new Uint8Array(totalBufferlength);\n            buffersLengths.reduce(function(p, c, i) {\n              unit8Arr.set(new Uint8Array(buffers[i]), p);\n              return p + c;\n            }, 0);\n            return unit8Arr.buffer;\n          }\n          class Timer {\n            constructor(timeout, callback, args, label) {\n              this._timeout = timeout;\n              this._callback = callback;\n              this._args = args;\n              this._label = label || \"timer\";\n              this._task = null;\n              this.started = false;\n            }\n            start() {\n              if (this.started) {\n                this.reset();\n              } else {\n                this._task = setTimeout(() => {\n                  this._callback.apply(this, this._args);\n                }, this._timeout * 1e3);\n                this.started = true;\n              }\n            }\n            clear() {\n              if (this._task) {\n                clearTimeout(this._task);\n                this._task = null;\n                this.started = false;\n              } else {\n                console.warn(`Clearing a timer (${this._label}) which is not started`);\n              }\n            }\n            reset() {\n              if (this._task) {\n                clearTimeout(this._task);\n              }\n              this._task = setTimeout(() => {\n                this._callback.apply(this, this._args);\n              }, this._timeout * 1e3);\n              this.started = true;\n            }\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, {\n              client_id = null,\n              manager_id = null,\n              default_context = null,\n              name = null,\n              codecs = null,\n              method_timeout = null,\n              max_message_buffer_size = 0,\n              debug = false,\n              workspace = null\n            }) {\n              super(debug);\n              this._codecs = codecs || {};\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id && typeof client_id === \"string\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id, \"client_id is required\");\n              this._client_id = client_id;\n              this._name = name;\n              this._connection_info = null;\n              this._workspace = null;\n              this._local_workspace = workspace;\n              this.manager_id = manager_id;\n              this.default_context = default_context || {};\n              this._method_annotations = /* @__PURE__ */ new WeakMap();\n              this._manager_service = null;\n              this._max_message_buffer_size = max_message_buffer_size;\n              this._chunk_store = {};\n              this._method_timeout = method_timeout || 30;\n              this._services = {};\n              this._object_store = {\n                services: this._services\n              };\n              if (connection) {\n                this.add_service({\n                  id: \"built-in\",\n                  type: \"built-in\",\n                  name: \"RPC built-in services\",\n                  config: {\n                    require_context: true,\n                    visibility: \"public\"\n                  },\n                  ping: this._ping.bind(this),\n                  get_service: this.get_local_service.bind(this),\n                  register_service: this.register_service.bind(this),\n                  message_cache: {\n                    create: this._create_message.bind(this),\n                    append: this._append_message.bind(this),\n                    process: this._process_message.bind(this),\n                    remove: this._remove_message.bind(this)\n                  }\n                });\n                this.on(\"method\", this._handle_method.bind(this));\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(connection.emit_message && connection.on_message);\n                this._emit_message = connection.emit_message.bind(connection);\n                connection.on_message(this._on_message.bind(this));\n                this._connection = connection;\n                this._get_connection_info();\n              } else {\n                this._emit_message = function() {\n                  console.log(\"No connection to emit message\");\n                };\n              }\n            }\n            async _get_connection_info() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  this._connection_info = await this._manager_service.get_connection_info();\n                  if (!this._local_workspace && this._connection_info && this._connection_info.workspace) {\n                    this._local_workspace = this._connection_info.workspace;\n                  }\n                  if (this._connection_info.reconnection_token && this._connection.set_reconnection_token) {\n                    this._connection.set_reconnection_token(this._connection_info.reconnection_token);\n                    const reconnection_expires_in = this._connection_info.reconnection_expires_in * 0.8;\n                    this._get_connection_info_task = setTimeout(this._get_connection_info.bind(this), reconnection_expires_in * 1e3);\n                  }\n                } catch (exp) {\n                  console.warn(\"Failed to fetch user info from \", this.manager_id, exp);\n                }\n              }\n            }\n            register_codec(config) {\n              if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\n                throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n              } else {\n                if (config.type) {\n                  for (let k of Object.keys(this._codecs)) {\n                    if (this._codecs[k].type === config.type || k === config.name) {\n                      delete this._codecs[k];\n                      console.warn(\"Remove duplicated codec: \" + k);\n                    }\n                  }\n                }\n                this._codecs[config[\"name\"]] = config;\n              }\n            }\n            async _ping(msg, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(msg == \"ping\");\n              return \"pong\";\n            }\n            async ping(client_id, timeout) {\n              let method = this._generate_remote_method({\n                _rtarget: client_id,\n                _rmethod: \"services.built-in.ping\",\n                _rpromise: true,\n                _rdoc: \"Ping a remote client\",\n                _rsig: \"ping(msg)\"\n              });\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(await method(\"ping\", timeout) == \"pong\");\n            }\n            _create_message(key, heartbeat, overwrite, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              if (!this._object_store[\"message_cache\"]) {\n                this._object_store[\"message_cache\"] = {};\n              }\n              if (!overwrite && this._object_store[\"message_cache\"][key]) {\n                throw new Error(`Message with the same key (${key}) already exists in the cache store, please use overwrite=true or remove it first.`);\n              }\n              this._object_store[\"message_cache\"][key] = [];\n            }\n            _append_message(key, data, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data instanceof ArrayBufferView);\n              cache[key].push(data);\n            }\n            _remove_message(key, context) {\n              const cache = this._object_store[\"message_cache\"];\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              delete cache[key];\n            }\n            _process_message(key, heartbeat, context) {\n              if (heartbeat) {\n                if (!this._object_store[key]) {\n                  throw new Error(`session does not exist anymore: ${key}`);\n                }\n                this._object_store[key][\"timer\"].reset();\n              }\n              const cache = this._object_store[\"message_cache\"];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(!!context, \"Context is required\");\n              if (!cache[key]) {\n                throw new Error(`Message with key ${key} does not exists.`);\n              }\n              cache[key] = concatArrayBuffers(cache[key]);\n              console.debug(`Processing message ${key} (size=${cache[key].length})`);\n              let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(cache[key]);\n              const {\n                done,\n                value\n              } = unpacker.next();\n              const main = value;\n              Object.assign(main, {\n                from: context.from,\n                to: context.to,\n                user: context.user\n              });\n              main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n              Object.assign(main[\"ctx\"], this.default_context);\n              if (!done) {\n                let extra = unpacker.next();\n                Object.assign(main, extra.value);\n              }\n              this._fire(main[\"type\"], main);\n              delete cache[key];\n            }\n            _on_message(message) {\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(message instanceof ArrayBuffer);\n                let unpacker = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"decodeMulti\"])(message);\n                const {\n                  done,\n                  value\n                } = unpacker.next();\n                const main = value;\n                main[\"ctx\"] = JSON.parse(JSON.stringify(main));\n                Object.assign(main[\"ctx\"], this.default_context);\n                if (!done) {\n                  let extra = unpacker.next();\n                  Object.assign(main, extra.value);\n                }\n                this._fire(main[\"type\"], main);\n              } catch (error) {\n                console.error(error);\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._services = {};\n            }\n            async disconnect() {\n              if (this._get_connection_info_task) {\n                clearTimeout(this._get_connection_info_task);\n                this._get_connection_info_task = null;\n              }\n              this._fire(\"disconnect\");\n            }\n            async get_manager_service(timeout) {\n              if (this.manager_id && !this._manager_service) {\n                this._manager_service = await this.get_remote_service(`${this.manager_id}:default`, timeout);\n              }\n            }\n            get_all_local_services() {\n              return this._services;\n            }\n            get_local_service(service_id, context) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(service_id);\n              const [ws, client_id] = context[\"to\"].split(\"/\");\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id, \"Services can only be accessed locally\");\n              const service = this._services[service_id];\n              if (!service) {\n                throw new Error(\"Service not found: \" + service_id);\n              }\n              if (service.config.visibility == \"public\") {\n                return service;\n              }\n              if (context[\"from\"].startsWith(ws + \"/\")) {\n                return service;\n              }\n              throw new Error(\"Permission denied for service: \" + service_id);\n            }\n            async get_remote_service(service_uri, timeout) {\n              timeout = timeout === void 0 ? this._method_timeout : timeout;\n              if (!service_uri && this.manager_id) {\n                service_uri = this.manager_id;\n              } else if (!service_uri.includes(\":\")) {\n                service_uri = this._client_id + \":\" + service_uri;\n              }\n              const provider = service_uri.split(\":\")[0];\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(provider);\n              try {\n                const method = this._generate_remote_method({\n                  _rtarget: provider,\n                  _rmethod: \"services.built-in.get_service\",\n                  _rpromise: true,\n                  _rdoc: \"Get a remote service\",\n                  _rsig: \"get_service(service_id)\"\n                });\n                const svc = await Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"waitFor\"])(method(service_uri.split(\":\")[1]), timeout, \"Timeout Error: Failed to get remote service: \" + service_uri);\n                svc.id = service_uri;\n                return svc;\n              } catch (e) {\n                console.error(\"Failed to get remote service: \" + service_uri, e);\n                throw e;\n              }\n            }\n            _annotate_service_methods(aObject, object_id, require_context, run_in_executor, visibility) {\n              if (typeof aObject === \"function\") {\n                let method_name = object_id.split(\".\")[1];\n                this._method_annotations.set(aObject, {\n                  require_context: Array.isArray(require_context) ? require_context.includes(method_name) : !!require_context,\n                  run_in_executor,\n                  method_id: \"services.\" + object_id,\n                  visibility\n                });\n              } else if (aObject instanceof Array || aObject instanceof Object) {\n                for (let key of Object.keys(aObject)) {\n                  let val = aObject[key];\n                  if (typeof val === \"function\" && val.__rpc_object__) {\n                    let client_id = val.__rpc_object__._rtarget;\n                    if (client_id.includes(\"/\")) {\n                      client_id = client_id.split(\"/\")[1];\n                    }\n                    if (this._client_id === client_id) {\n                      if (aObject instanceof Array) {\n                        aObject = aObject.slice();\n                      }\n                      aObject[key] = indexObject(this._object_store, val.__rpc_object__._rmethod);\n                      val = aObject[key];\n                    } else {\n                      throw new Error(`Local method not found: ${val.__rpc_object__._rmethod}, client id mismatch ${this._client_id} != ${client_id}`);\n                    }\n                  }\n                  this._annotate_service_methods(val, object_id + \".\" + key, require_context, run_in_executor, visibility);\n                }\n              }\n            }\n            add_service(api, overwrite) {\n              if (!api || Array.isArray(api))\n                throw new Error(\"Invalid service object\");\n              if (api.constructor === Object) {\n                api = Object.assign({}, api);\n              } else {\n                const normApi = {};\n                const props = Object.getOwnPropertyNames(api).concat(Object.getOwnPropertyNames(Object.getPrototypeOf(api)));\n                for (let k of props) {\n                  if (k !== \"constructor\") {\n                    if (typeof api[k] === \"function\")\n                      normApi[k] = api[k].bind(api);\n                    else\n                      normApi[k] = api[k];\n                  }\n                }\n                api.id = api.id || \"default\";\n                api = normApi;\n              }\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(api.id && typeof api.id === \"string\", `Service id not found: ${api}`);\n              if (!api.name) {\n                api.name = api.id;\n              }\n              if (!api.config) {\n                api.config = {};\n              }\n              if (!api.type) {\n                api.type = \"generic\";\n              }\n              let require_context = false, run_in_executor = false;\n              if (api.config.require_context)\n                require_context = api.config.require_context;\n              if (api.config.run_in_executor)\n                run_in_executor = true;\n              const visibility = api.config.visibility || \"protected\";\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])([\"protected\", \"public\"].includes(visibility));\n              this._annotate_service_methods(api, api[\"id\"], require_context, run_in_executor, visibility);\n              if (this._services[api.id]) {\n                if (overwrite) {\n                  delete this._services[api.id];\n                } else {\n                  throw new Error(`Service already exists: ${api.id}, please specify a different id (not ${api.id}) or overwrite=true`);\n                }\n              }\n              this._services[api.id] = api;\n              return api;\n            }\n            async register_service(api, overwrite, notify, context) {\n              if (notify === void 0)\n                notify = true;\n              if (context) {\n                const [workspace, client_id] = context[\"to\"].split(\"/\");\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(client_id === this._client_id);\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(workspace === context[\"from\"].split(\"/\")[0], \"Services can only be registered from the same workspace\");\n              }\n              const service = this.add_service(api, overwrite);\n              if (notify) {\n                this._fire(\"service-updated\", {\n                  service_id: service[\"id\"],\n                  api: service,\n                  type: \"add\"\n                });\n                await this._notify_service_update();\n              }\n              return {\n                id: `${this._client_id}:${service[\"id\"]}`,\n                type: service[\"type\"],\n                name: service[\"name\"],\n                description: service[\"description\"] || \"\",\n                config: service[\"config\"]\n              };\n            }\n            async unregister_service(service, notify) {\n              if (service instanceof Object) {\n                service = service.id;\n              }\n              if (!this._services[service]) {\n                throw new Error(`Service not found: ${service}`);\n              }\n              const api = this._services[service];\n              delete this._services[service];\n              this._fire(\"service-updated\", {\n                service_id: service,\n                api,\n                type: \"remove\"\n              });\n              await this._notify_service_update();\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            _encode_callback(name, callback, session_id, clear_after_called, timer, local_workspace) {\n              let method_id = `${session_id}.${name}`;\n              let encoded = {\n                _rtype: \"method\",\n                _rtarget: local_workspace ? `${local_workspace}/${this._client_id}` : this._client_id,\n                _rmethod: method_id,\n                _rpromise: false\n              };\n              const self2 = this;\n              let wrapped_callback = function() {\n                try {\n                  callback.apply(null, Array.prototype.slice.call(arguments));\n                } catch (error) {\n                  console.error(\"Error in callback:\", method_id, error);\n                } finally {\n                  if (clear_after_called && self2._object_store[session_id]) {\n                    delete self2._object_store[session_id];\n                  }\n                  if (timer && timer.started) {\n                    timer.clear();\n                  }\n                }\n              };\n              return [encoded, wrapped_callback];\n            }\n            async _encode_promise(resolve, reject, session_id, clear_after_called, timer, local_workspace) {\n              let store = this._get_session_store(session_id, true);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store, `Failed to create session store ${session_id} due to invalid parent`);\n              let encoded = {};\n              if (timer && reject && this._method_timeout) {\n                encoded.heartbeat = await this._encode(timer.reset.bind(timer), session_id, local_workspace);\n                encoded.interval = this._method_timeout / 2;\n                store.timer = timer;\n              } else {\n                timer = null;\n              }\n              [encoded.resolve, store.resolve] = this._encode_callback(\"resolve\", resolve, session_id, clear_after_called, timer, local_workspace);\n              [encoded.reject, store.reject] = this._encode_callback(\"reject\", reject, session_id, clear_after_called, timer, local_workspace);\n              return encoded;\n            }\n            async _send_chunks(data, target_id, session_id) {\n              let remote_services = await this.get_remote_service(`${target_id}:built-in`);\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(remote_services.message_cache, \"Remote client does not support message caching for long message.\");\n              let message_cache = remote_services.message_cache;\n              let message_id = session_id || Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n              await message_cache.create(message_id, !!session_id);\n              let total_size = data.length;\n              let chunk_num = Math.ceil(total_size / CHUNK_SIZE);\n              for (let idx = 0; idx < chunk_num; idx++) {\n                let start_byte = idx * CHUNK_SIZE;\n                await message_cache.append(message_id, data.slice(start_byte, start_byte + CHUNK_SIZE), !!session_id);\n              }\n              await message_cache.process(message_id, !!session_id);\n            }\n            emit(main_message, extra_data) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof main_message === \"object\" && main_message.type, \"Invalid message, must be an object with a type field.\");\n              let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n              if (extra_data) {\n                const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                message_package = new Uint8Array([...message_package, ...extra]);\n              }\n              const total_size = message_package.length;\n              if (total_size <= CHUNK_SIZE + 1024) {\n                return this._emit_message(message_package);\n              } else {\n                throw new Error(\"Message is too large to send in one go.\");\n              }\n            }\n            _generate_remote_method(encoded_method, remote_parent, local_parent, remote_workspace, local_workspace) {\n              let target_id = encoded_method._rtarget;\n              if (remote_workspace && !target_id.includes(\"/\")) {\n                if (remote_workspace !== target_id) {\n                  target_id = remote_workspace + \"/\" + target_id;\n                }\n                encoded_method._rtarget = target_id;\n              }\n              let method_id = encoded_method._rmethod;\n              let with_promise = encoded_method._rpromise;\n              const self2 = this;\n              function remote_method() {\n                return new Promise(async (resolve, reject) => {\n                  let local_session_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  if (local_parent) {\n                    local_session_id = local_parent + \".\" + local_session_id;\n                  }\n                  let store = self2._get_session_store(local_session_id, true);\n                  if (!store) {\n                    reject(new Error(`Runtime Error: Failed to get session store ${local_session_id}`));\n                    return;\n                  }\n                  store[\"target_id\"] = target_id;\n                  const args = await self2._encode(Array.prototype.slice.call(arguments), local_session_id, local_workspace);\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  let main_message = {\n                    type: \"method\",\n                    from: self2._local_workspace ? self2._local_workspace + \"/\" + self2._client_id : self2._client_id,\n                    to: target_id,\n                    method: method_id\n                  };\n                  let extra_data = {};\n                  if (args) {\n                    extra_data[\"args\"] = args;\n                  }\n                  if (withKwargs) {\n                    extra_data[\"with_kwargs\"] = withKwargs;\n                  }\n                  if (remote_parent) {\n                    main_message[\"parent\"] = remote_parent;\n                  }\n                  let timer = null;\n                  if (with_promise) {\n                    main_message[\"session\"] = local_session_id;\n                    let method_name = `${target_id}:${method_id}`;\n                    timer = new Timer(self2._method_timeout, reject, [`Method call time out: ${method_name}`], method_name);\n                    let clear_after_called = true;\n                    for (let arg of args) {\n                      if (typeof arg === \"object\" && arg._rintf === true) {\n                        clear_after_called = false;\n                        break;\n                      }\n                    }\n                    extra_data[\"promise\"] = await self2._encode_promise(resolve, reject, local_session_id, clear_after_called, timer, local_workspace);\n                  }\n                  let message_package = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(main_message);\n                  if (extra_data) {\n                    const extra = Object(_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(extra_data);\n                    message_package = new Uint8Array([...message_package, ...extra]);\n                  }\n                  const total_size = message_package.length;\n                  if (total_size <= CHUNK_SIZE + 1024) {\n                    self2._emit_message(message_package).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  } else {\n                    self2._send_chunks(message_package, target_id, remote_parent).then(function() {\n                      if (timer) {\n                        timer.start();\n                      }\n                    });\n                  }\n                });\n              }\n              remote_method.__rpc_object__ = encoded_method;\n              const parts = method_id.split(\".\");\n              remote_method.__name__ = parts[parts.length - 1];\n              remote_method.__doc__ = encoded_method._rdoc;\n              remote_method.__sig__ = encoded_method._rsig;\n              return remote_method;\n            }\n            async _notify_service_update() {\n              if (this.manager_id) {\n                try {\n                  await this.get_manager_service(30);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._manager_service);\n                  await this._manager_service.update_client_info(this.get_client_info());\n                } catch (exp) {\n                  console.warn(\"Failed to notify service update to\", this.manager_id, exp);\n                }\n              }\n            }\n            get_client_info() {\n              const services = [];\n              for (let service of Object.values(this._services)) {\n                services.push({\n                  id: `${this._client_id}:${service[\"id\"]}`,\n                  type: service[\"type\"],\n                  name: service[\"name\"],\n                  description: service[\"description\"] || \"\",\n                  config: service[\"config\"]\n                });\n              }\n              return {\n                id: this._client_id,\n                services\n              };\n            }\n            async _handle_method(data) {\n              let reject = null;\n              let heartbeat_task = null;\n              try {\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(data[\"method\"] && data[\"ctx\"] && data[\"from\"]);\n                const method_name = data.from + \":\" + data.method;\n                const remote_workspace = data.from.split(\"/\")[0];\n                data[\"to\"] = data[\"to\"].includes(\"/\") ? data[\"to\"] : remote_workspace + \"/\" + data[\"to\"];\n                data[\"ctx\"][\"to\"] = data[\"to\"];\n                const local_workspace = data.to.split(\"/\")[0];\n                const local_parent = data.parent;\n                let resolve, reject2;\n                if (data.promise) {\n                  const promise = await this._decode(data.promise, data.session, local_parent, remote_workspace, local_workspace);\n                  resolve = promise.resolve;\n                  reject2 = promise.reject;\n                  if (promise.heartbeat && promise.interval) {\n                    async function heartbeat() {\n                      try {\n                        await promise.heartbeat();\n                      } catch (err) {\n                        console.error(err);\n                      }\n                    }\n                    heartbeat_task = setInterval(heartbeat, promise.interval * 1e3);\n                  }\n                }\n                let method;\n                try {\n                  method = indexObject(this._object_store, data[\"method\"]);\n                } catch (e) {\n                  console.debug(\"Failed to find method\", method_name, e);\n                  throw new Error(`Method not found: ${method_name}`);\n                }\n                Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(method && typeof method === \"function\", \"Invalid method: \" + method_name);\n                if (this._method_annotations.has(method)) {\n                  if (this._method_annotations.get(method).visibility === \"protected\") {\n                    if (local_workspace !== remote_workspace) {\n                      throw new Error(\"Permission denied for protected method \" + method_name + \", workspace mismatch: \" + local_workspace + \" != \" + remote_workspace);\n                    }\n                  }\n                } else {\n                  let session_target_id = this._object_store[data.method.split(\".\")[0]].target_id;\n                  if (local_workspace === remote_workspace && session_target_id && session_target_id.indexOf(\"/\") === -1) {\n                    session_target_id = local_workspace + \"/\" + session_target_id;\n                  }\n                  if (session_target_id !== data.from) {\n                    throw new Error(\"Access denied for method call (\" + method_name + \") from \" + data.from);\n                  }\n                }\n                if (local_parent) {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this._get_session_store(local_parent, true) !== null, \"Parent session was closed: \" + local_parent);\n                }\n                let args;\n                if (data.args) {\n                  args = await this._decode(data.args, data.session, null, remote_workspace, null);\n                } else {\n                  args = [];\n                }\n                if (this._method_annotations.has(method) && this._method_annotations.get(method).require_context) {\n                  args.push(data.ctx);\n                }\n                if (data.promise) {\n                  const result = method.apply(null, args);\n                  if (result instanceof Promise) {\n                    result.then((result2) => {\n                      resolve(result2);\n                      clearInterval(heartbeat_task);\n                    }).catch((err) => {\n                      reject2(err);\n                      clearInterval(heartbeat_task);\n                    });\n                  } else {\n                    resolve(result);\n                    clearInterval(heartbeat_task);\n                  }\n                } else {\n                  method.apply(null, args);\n                  clearInterval(heartbeat_task);\n                }\n              } catch (err) {\n                if (reject) {\n                  reject(err);\n                  console.debug(\"Error during calling method: \", err);\n                } else {\n                  console.error(\"Error during calling method: \", err);\n                }\n                clearInterval(heartbeat_task);\n              }\n            }\n            encode(aObject, session_id) {\n              return this._encode(aObject, session_id);\n            }\n            _get_session_store(session_id, create) {\n              let store = this._object_store;\n              const levels = session_id.split(\".\");\n              if (create) {\n                const last_index = levels.length - 1;\n                for (let level of levels.slice(0, last_index)) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                if (!store[levels[last_index]]) {\n                  store[levels[last_index]] = {};\n                }\n                return store[levels[last_index]];\n              } else {\n                for (let level of levels) {\n                  if (!store[level]) {\n                    return null;\n                  }\n                  store = store[level];\n                }\n                return store;\n              }\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, session_id, local_workspace) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof Uint8Array) {\n                return aObject;\n              }\n              if (aObject instanceof ArrayBuffer) {\n                return {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject)\n                };\n              }\n              if (aObject.__rpc_object__) {\n                return aObject.__rpc_object__;\n              }\n              let bObject;\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                const temp = aObject._rtype;\n                delete aObject._rtype;\n                bObject = await this._encode(aObject, session_id, local_workspace);\n                bObject._rtype = temp;\n                return bObject;\n              }\n              if (typeof aObject === \"function\") {\n                if (this._method_annotations.has(aObject)) {\n                  let annotation = this._method_annotations.get(aObject);\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: annotation.method_id,\n                    _rpromise: true\n                  };\n                } else {\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(typeof session_id === \"string\");\n                  let object_id;\n                  if (aObject.__name__) {\n                    object_id = `${Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])()}-${aObject.__name__}`;\n                  } else {\n                    object_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                  }\n                  bObject = {\n                    _rtype: \"method\",\n                    _rtarget: this._client_id,\n                    _rmethod: `${session_id}.${object_id}`,\n                    _rpromise: true\n                  };\n                  let store = this._get_session_store(session_id, true);\n                  Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(store !== null, `Failed to create session store ${session_id} due to invalid parent`);\n                  store[object_id] = aObject;\n                }\n                bObject._rdoc = aObject.__doc__;\n                bObject._rsig = aObject.__sig__;\n                if (!bObject._rdoc || !bObject._rsig) {\n                  try {\n                    const funcInfo = getFunctionInfo(aObject);\n                    if (funcInfo && !bObject._rdoc) {\n                      bObject._rdoc = `${funcInfo.doc}`;\n                    }\n                    if (funcInfo && !bObject._rsig) {\n                      bObject._rsig = `${funcInfo.name}(${funcInfo.sig})`;\n                    }\n                  } catch (e) {\n                    console.error(\"Failed to extract function docstring:\", aObject);\n                  }\n                }\n                return bObject;\n              }\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (typeof encodedObj === \"object\") {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, session_id, local_workspace);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(v_buffer.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: new Uint8Array(aObject.selection.data.buffer),\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString(),\n                  _rtrace: aObject.stack\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (aObject instanceof Blob) {\n                let seek = function(pos) {\n                  _current_pos = pos;\n                };\n                let _current_pos = 0;\n                async function read(length) {\n                  let blob;\n                  if (length) {\n                    blob = aObject.slice(_current_pos, _current_pos + length);\n                  } else {\n                    blob = aObject.slice(_current_pos);\n                  }\n                  const ret = new Uint8Array(await blob.arrayBuffer());\n                  _current_pos = _current_pos + ret.byteLength;\n                  return ret;\n                }\n                bObject = {\n                  _rtype: \"iostream\",\n                  _rnative: \"js:blob\",\n                  type: aObject.type,\n                  name: aObject.name,\n                  size: aObject.size,\n                  path: aObject._path || aObject.webkitRelativePath,\n                  read: await this._encode(read, session_id, local_workspace),\n                  seek: await this._encode(seek, session_id, local_workspace)\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: new Uint8Array(aObject.buffer),\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: new Uint8Array(aObject.buffer)\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), session_id, local_workspace)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                const keys = Object.keys(aObject);\n                for (let k of keys) {\n                  bObject[k] = await this._encode(aObject[k], session_id, local_workspace);\n                }\n              } else {\n                throw `imjoy-rpc: Unsupported data type: ${aObject}, you can register a custom codec to encode/decode the object.`;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async decode(aObject) {\n              return await this._decode(aObject);\n            }\n            async _decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject._rtype) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  aObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  aObject._rtype = temp;\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"method\") {\n                  bObject = this._generate_remote_method(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(\"RemoteError: \" + aObject._rvalue + \"\\n\" + (aObject._rtrace || \"\"));\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  const buffer = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                  bObject = new arraytype(buffer);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = aObject._rvalue.buffer.slice(aObject._rvalue.byteOffset, aObject._rvalue.byteOffset + aObject._rvalue.byteLength);\n                } else if (aObject._rtype === \"iostream\") {\n                  if (aObject._rnative === \"js:blob\") {\n                    const read = await this._generate_remote_method(aObject.read, remote_parent, local_parent, remote_workspace, local_workspace);\n                    const bytes = await read();\n                    bObject = new Blob([bytes], {\n                      type: aObject.type,\n                      name: aObject.name\n                    });\n                  } else {\n                    bObject = {};\n                    for (let k of Object.keys(aObject)) {\n                      if (!k.startsWith(\"_\")) {\n                        bObject[k] = await this._decode(aObject[k], remote_parent, local_parent, remote_workspace, local_workspace);\n                      }\n                    }\n                  }\n                  bObject[\"__rpc_object__\"] = aObject;\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, remote_parent, local_parent, remote_workspace, local_workspace));\n                } else {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._decode(aObject, remote_parent, local_parent, remote_workspace, local_workspace);\n                  bObject._rtype = temp;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, remote_parent, local_parent, remote_workspace, local_workspace);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              return bObject;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/hypha/utils.js\": (\n        /*!****************************!*\\\n          !*** ./src/hypha/utils.js ***!\n          \\****************************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, assert, urlJoin, waitFor, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_163997__) {\n          \"use strict\";\n          __nested_webpack_require_163997__.r(__nested_webpack_exports__);\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"assert\", function() {\n            return assert;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"waitFor\", function() {\n            return waitFor;\n          });\n          __nested_webpack_require_163997__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message || \"Assertion failed\");\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          function waitFor(prom, time, error) {\n            let timer;\n            return Promise.race([prom, new Promise((_r, rej) => timer = setTimeout(() => {\n              rej(error || \"Timeout Error\");\n            }, time * 1e3))]).finally(() => clearTimeout(timer));\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/hypha-rpc.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js":
/*!***********************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js ***!
  \***********************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/socketIOMain.js\");\n    }({\n      /***/\n      \"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js\": (\n        /*!***********************************************************************************!*\\\n          !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!\n          \\***********************************************************************************/\n        /*! exports provided: decode, encode */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n          var lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\n          for (var i = 0; i < chars.length; i++) {\n            lookup[chars.charCodeAt(i)] = i;\n          }\n          var encode = function(arraybuffer) {\n            var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n            for (i2 = 0; i2 < len; i2 += 3) {\n              base64 += chars[bytes[i2] >> 2];\n              base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n              base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n              base64 += chars[bytes[i2 + 2] & 63];\n            }\n            if (len % 3 === 2) {\n              base64 = base64.substring(0, base64.length - 1) + \"=\";\n            } else if (len % 3 === 1) {\n              base64 = base64.substring(0, base64.length - 2) + \"==\";\n            }\n            return base64;\n          };\n          var decode = function(base64) {\n            var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;\n            if (base64[base64.length - 1] === \"=\") {\n              bufferLength--;\n              if (base64[base64.length - 2] === \"=\") {\n                bufferLength--;\n              }\n            }\n            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n            for (i2 = 0; i2 < len; i2 += 4) {\n              encoded1 = lookup[base64.charCodeAt(i2)];\n              encoded2 = lookup[base64.charCodeAt(i2 + 1)];\n              encoded3 = lookup[base64.charCodeAt(i2 + 2)];\n              encoded4 = lookup[base64.charCodeAt(i2 + 3)];\n              bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n              bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n              bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n            }\n            return arraybuffer;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/@socket.io/component-emitter/index.mjs\": (\n        /*!*************************************************************!*\\\n          !*** ./node_modules/@socket.io/component-emitter/index.mjs ***!\n          \\*************************************************************/\n        /*! exports provided: Emitter */\n        /***/\n        function(__webpack_module__, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Emitter\", function() {\n            return Emitter;\n          });\n          function Emitter(obj) {\n            if (obj)\n              return mixin(obj);\n          }\n          function mixin(obj) {\n            for (var key in Emitter.prototype) {\n              obj[key] = Emitter.prototype[key];\n            }\n            return obj;\n          }\n          Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {\n            this._callbacks = this._callbacks || {};\n            (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn);\n            return this;\n          };\n          Emitter.prototype.once = function(event, fn) {\n            function on() {\n              this.off(event, on);\n              fn.apply(this, arguments);\n            }\n            on.fn = fn;\n            this.on(event, on);\n            return this;\n          };\n          Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {\n            this._callbacks = this._callbacks || {};\n            if (0 == arguments.length) {\n              this._callbacks = {};\n              return this;\n            }\n            var callbacks = this._callbacks[\"$\" + event];\n            if (!callbacks)\n              return this;\n            if (1 == arguments.length) {\n              delete this._callbacks[\"$\" + event];\n              return this;\n            }\n            var cb;\n            for (var i = 0; i < callbacks.length; i++) {\n              cb = callbacks[i];\n              if (cb === fn || cb.fn === fn) {\n                callbacks.splice(i, 1);\n                break;\n              }\n            }\n            if (callbacks.length === 0) {\n              delete this._callbacks[\"$\" + event];\n            }\n            return this;\n          };\n          Emitter.prototype.emit = function(event) {\n            this._callbacks = this._callbacks || {};\n            var args = new Array(arguments.length - 1), callbacks = this._callbacks[\"$\" + event];\n            for (var i = 1; i < arguments.length; i++) {\n              args[i - 1] = arguments[i];\n            }\n            if (callbacks) {\n              callbacks = callbacks.slice(0);\n              for (var i = 0, len = callbacks.length; i < len; ++i) {\n                callbacks[i].apply(this, args);\n              }\n            }\n            return this;\n          };\n          Emitter.prototype.emitReserved = Emitter.prototype.emit;\n          Emitter.prototype.listeners = function(event) {\n            this._callbacks = this._callbacks || {};\n            return this._callbacks[\"$\" + event] || [];\n          };\n          Emitter.prototype.hasListeners = function(event) {\n            return !!this.listeners(event).length;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/base64-js/index.js\": (\n        /*!*****************************************!*\\\n          !*** ./node_modules/base64-js/index.js ***!\n          \\*****************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          exports2.byteLength = byteLength;\n          exports2.toByteArray = toByteArray;\n          exports2.fromByteArray = fromByteArray;\n          var lookup = [];\n          var revLookup = [];\n          var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n          var code2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n          for (var i = 0, len = code2.length; i < len; ++i) {\n            lookup[i] = code2[i];\n            revLookup[code2.charCodeAt(i)] = i;\n          }\n          revLookup[\"-\".charCodeAt(0)] = 62;\n          revLookup[\"_\".charCodeAt(0)] = 63;\n          function getLens(b64) {\n            var len2 = b64.length;\n            if (len2 % 4 > 0) {\n              throw new Error(\"Invalid string. Length must be a multiple of 4\");\n            }\n            var validLen = b64.indexOf(\"=\");\n            if (validLen === -1)\n              validLen = len2;\n            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n            return [validLen, placeHoldersLen];\n          }\n          function byteLength(b64) {\n            var lens = getLens(b64);\n            var validLen = lens[0];\n            var placeHoldersLen = lens[1];\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n          function _byteLength(b64, validLen, placeHoldersLen) {\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n          function toByteArray(b64) {\n            var tmp;\n            var lens = getLens(b64);\n            var validLen = lens[0];\n            var placeHoldersLen = lens[1];\n            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n            var curByte = 0;\n            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n            var i2;\n            for (i2 = 0; i2 < len2; i2 += 4) {\n              tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n              arr[curByte++] = tmp >> 16 & 255;\n              arr[curByte++] = tmp >> 8 & 255;\n              arr[curByte++] = tmp & 255;\n            }\n            if (placeHoldersLen === 2) {\n              tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n              arr[curByte++] = tmp & 255;\n            }\n            if (placeHoldersLen === 1) {\n              tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n              arr[curByte++] = tmp >> 8 & 255;\n              arr[curByte++] = tmp & 255;\n            }\n            return arr;\n          }\n          function tripletToBase64(num) {\n            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n          }\n          function encodeChunk(uint8, start, end) {\n            var tmp;\n            var output = [];\n            for (var i2 = start; i2 < end; i2 += 3) {\n              tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n              output.push(tripletToBase64(tmp));\n            }\n            return output.join(\"\");\n          }\n          function fromByteArray(uint8) {\n            var tmp;\n            var len2 = uint8.length;\n            var extraBytes = len2 % 3;\n            var parts = [];\n            var maxChunkLength = 16383;\n            for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n              parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n            }\n            if (extraBytes === 1) {\n              tmp = uint8[len2 - 1];\n              parts.push(\n                lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n              );\n            } else if (extraBytes === 2) {\n              tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n              parts.push(\n                lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n              );\n            }\n            return parts.join(\"\");\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/buffer/index.js\": (\n        /*!**************************************!*\\\n          !*** ./node_modules/buffer/index.js ***!\n          \\**************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          (function(global) {\n            /*!\n            * The buffer module from node.js, for the browser.\n            *\n            * @author   Feross Aboukhadijeh <http://feross.org>\n            * @license  MIT\n            */\n            var base64 = __webpack_require__2(\n              /*! base64-js */\n              \"./node_modules/base64-js/index.js\"\n            );\n            var ieee754 = __webpack_require__2(\n              /*! ieee754 */\n              \"./node_modules/ieee754/index.js\"\n            );\n            var isArray = __webpack_require__2(\n              /*! isarray */\n              \"./node_modules/isarray/index.js\"\n            );\n            exports2.Buffer = Buffer;\n            exports2.SlowBuffer = SlowBuffer;\n            exports2.INSPECT_MAX_BYTES = 50;\n            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n            exports2.kMaxLength = kMaxLength();\n            function typedArraySupport() {\n              try {\n                var arr = new Uint8Array(1);\n                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {\n                  return 42;\n                } };\n                return arr.foo() === 42 && // typed array instances can be augmented\n                typeof arr.subarray === \"function\" && // chrome 9-10 lack `subarray`\n                arr.subarray(1, 1).byteLength === 0;\n              } catch (e) {\n                return false;\n              }\n            }\n            function kMaxLength() {\n              return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\n            }\n            function createBuffer(that, length) {\n              if (kMaxLength() < length) {\n                throw new RangeError(\"Invalid typed array length\");\n              }\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                that = new Uint8Array(length);\n                that.__proto__ = Buffer.prototype;\n              } else {\n                if (that === null) {\n                  that = new Buffer(length);\n                }\n                that.length = length;\n              }\n              return that;\n            }\n            function Buffer(arg, encodingOrOffset, length) {\n              if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n                return new Buffer(arg, encodingOrOffset, length);\n              }\n              if (typeof arg === \"number\") {\n                if (typeof encodingOrOffset === \"string\") {\n                  throw new Error(\n                    \"If encoding is specified then the first argument must be a string\"\n                  );\n                }\n                return allocUnsafe(this, arg);\n              }\n              return from(this, arg, encodingOrOffset, length);\n            }\n            Buffer.poolSize = 8192;\n            Buffer._augment = function(arr) {\n              arr.__proto__ = Buffer.prototype;\n              return arr;\n            };\n            function from(that, value, encodingOrOffset, length) {\n              if (typeof value === \"number\") {\n                throw new TypeError('\"value\" argument must not be a number');\n              }\n              if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n                return fromArrayBuffer(that, value, encodingOrOffset, length);\n              }\n              if (typeof value === \"string\") {\n                return fromString(that, value, encodingOrOffset);\n              }\n              return fromObject(that, value);\n            }\n            Buffer.from = function(value, encodingOrOffset, length) {\n              return from(null, value, encodingOrOffset, length);\n            };\n            if (Buffer.TYPED_ARRAY_SUPPORT) {\n              Buffer.prototype.__proto__ = Uint8Array.prototype;\n              Buffer.__proto__ = Uint8Array;\n              if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) {\n                Object.defineProperty(Buffer, Symbol.species, {\n                  value: null,\n                  configurable: true\n                });\n              }\n            }\n            function assertSize(size) {\n              if (typeof size !== \"number\") {\n                throw new TypeError('\"size\" argument must be a number');\n              } else if (size < 0) {\n                throw new RangeError('\"size\" argument must not be negative');\n              }\n            }\n            function alloc(that, size, fill, encoding) {\n              assertSize(size);\n              if (size <= 0) {\n                return createBuffer(that, size);\n              }\n              if (fill !== void 0) {\n                return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n              }\n              return createBuffer(that, size);\n            }\n            Buffer.alloc = function(size, fill, encoding) {\n              return alloc(null, size, fill, encoding);\n            };\n            function allocUnsafe(that, size) {\n              assertSize(size);\n              that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n              if (!Buffer.TYPED_ARRAY_SUPPORT) {\n                for (var i = 0; i < size; ++i) {\n                  that[i] = 0;\n                }\n              }\n              return that;\n            }\n            Buffer.allocUnsafe = function(size) {\n              return allocUnsafe(null, size);\n            };\n            Buffer.allocUnsafeSlow = function(size) {\n              return allocUnsafe(null, size);\n            };\n            function fromString(that, string, encoding) {\n              if (typeof encoding !== \"string\" || encoding === \"\") {\n                encoding = \"utf8\";\n              }\n              if (!Buffer.isEncoding(encoding)) {\n                throw new TypeError('\"encoding\" must be a valid string encoding');\n              }\n              var length = byteLength(string, encoding) | 0;\n              that = createBuffer(that, length);\n              var actual = that.write(string, encoding);\n              if (actual !== length) {\n                that = that.slice(0, actual);\n              }\n              return that;\n            }\n            function fromArrayLike(that, array) {\n              var length = array.length < 0 ? 0 : checked(array.length) | 0;\n              that = createBuffer(that, length);\n              for (var i = 0; i < length; i += 1) {\n                that[i] = array[i] & 255;\n              }\n              return that;\n            }\n            function fromArrayBuffer(that, array, byteOffset, length) {\n              array.byteLength;\n              if (byteOffset < 0 || array.byteLength < byteOffset) {\n                throw new RangeError(\"'offset' is out of bounds\");\n              }\n              if (array.byteLength < byteOffset + (length || 0)) {\n                throw new RangeError(\"'length' is out of bounds\");\n              }\n              if (byteOffset === void 0 && length === void 0) {\n                array = new Uint8Array(array);\n              } else if (length === void 0) {\n                array = new Uint8Array(array, byteOffset);\n              } else {\n                array = new Uint8Array(array, byteOffset, length);\n              }\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                that = array;\n                that.__proto__ = Buffer.prototype;\n              } else {\n                that = fromArrayLike(that, array);\n              }\n              return that;\n            }\n            function fromObject(that, obj) {\n              if (Buffer.isBuffer(obj)) {\n                var len = checked(obj.length) | 0;\n                that = createBuffer(that, len);\n                if (that.length === 0) {\n                  return that;\n                }\n                obj.copy(that, 0, 0, len);\n                return that;\n              }\n              if (obj) {\n                if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n                  if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                    return createBuffer(that, 0);\n                  }\n                  return fromArrayLike(that, obj);\n                }\n                if (obj.type === \"Buffer\" && isArray(obj.data)) {\n                  return fromArrayLike(that, obj.data);\n                }\n              }\n              throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n            }\n            function checked(length) {\n              if (length >= kMaxLength()) {\n                throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n              }\n              return length | 0;\n            }\n            function SlowBuffer(length) {\n              if (+length != length) {\n                length = 0;\n              }\n              return Buffer.alloc(+length);\n            }\n            Buffer.isBuffer = function isBuffer(b) {\n              return !!(b != null && b._isBuffer);\n            };\n            Buffer.compare = function compare(a, b) {\n              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n                throw new TypeError(\"Arguments must be Buffers\");\n              }\n              if (a === b)\n                return 0;\n              var x = a.length;\n              var y = b.length;\n              for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n                if (a[i] !== b[i]) {\n                  x = a[i];\n                  y = b[i];\n                  break;\n                }\n              }\n              if (x < y)\n                return -1;\n              if (y < x)\n                return 1;\n              return 0;\n            };\n            Buffer.isEncoding = function isEncoding(encoding) {\n              switch (String(encoding).toLowerCase()) {\n                case \"hex\":\n                case \"utf8\":\n                case \"utf-8\":\n                case \"ascii\":\n                case \"latin1\":\n                case \"binary\":\n                case \"base64\":\n                case \"ucs2\":\n                case \"ucs-2\":\n                case \"utf16le\":\n                case \"utf-16le\":\n                  return true;\n                default:\n                  return false;\n              }\n            };\n            Buffer.concat = function concat(list, length) {\n              if (!isArray(list)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n              if (list.length === 0) {\n                return Buffer.alloc(0);\n              }\n              var i;\n              if (length === void 0) {\n                length = 0;\n                for (i = 0; i < list.length; ++i) {\n                  length += list[i].length;\n                }\n              }\n              var buffer = Buffer.allocUnsafe(length);\n              var pos = 0;\n              for (i = 0; i < list.length; ++i) {\n                var buf = list[i];\n                if (!Buffer.isBuffer(buf)) {\n                  throw new TypeError('\"list\" argument must be an Array of Buffers');\n                }\n                buf.copy(buffer, pos);\n                pos += buf.length;\n              }\n              return buffer;\n            };\n            function byteLength(string, encoding) {\n              if (Buffer.isBuffer(string)) {\n                return string.length;\n              }\n              if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n                return string.byteLength;\n              }\n              if (typeof string !== \"string\") {\n                string = \"\" + string;\n              }\n              var len = string.length;\n              if (len === 0)\n                return 0;\n              var loweredCase = false;\n              for (; ; ) {\n                switch (encoding) {\n                  case \"ascii\":\n                  case \"latin1\":\n                  case \"binary\":\n                    return len;\n                  case \"utf8\":\n                  case \"utf-8\":\n                  case void 0:\n                    return utf8ToBytes(string).length;\n                  case \"ucs2\":\n                  case \"ucs-2\":\n                  case \"utf16le\":\n                  case \"utf-16le\":\n                    return len * 2;\n                  case \"hex\":\n                    return len >>> 1;\n                  case \"base64\":\n                    return base64ToBytes(string).length;\n                  default:\n                    if (loweredCase)\n                      return utf8ToBytes(string).length;\n                    encoding = (\"\" + encoding).toLowerCase();\n                    loweredCase = true;\n                }\n              }\n            }\n            Buffer.byteLength = byteLength;\n            function slowToString(encoding, start, end) {\n              var loweredCase = false;\n              if (start === void 0 || start < 0) {\n                start = 0;\n              }\n              if (start > this.length) {\n                return \"\";\n              }\n              if (end === void 0 || end > this.length) {\n                end = this.length;\n              }\n              if (end <= 0) {\n                return \"\";\n              }\n              end >>>= 0;\n              start >>>= 0;\n              if (end <= start) {\n                return \"\";\n              }\n              if (!encoding)\n                encoding = \"utf8\";\n              while (true) {\n                switch (encoding) {\n                  case \"hex\":\n                    return hexSlice(this, start, end);\n                  case \"utf8\":\n                  case \"utf-8\":\n                    return utf8Slice(this, start, end);\n                  case \"ascii\":\n                    return asciiSlice(this, start, end);\n                  case \"latin1\":\n                  case \"binary\":\n                    return latin1Slice(this, start, end);\n                  case \"base64\":\n                    return base64Slice(this, start, end);\n                  case \"ucs2\":\n                  case \"ucs-2\":\n                  case \"utf16le\":\n                  case \"utf-16le\":\n                    return utf16leSlice(this, start, end);\n                  default:\n                    if (loweredCase)\n                      throw new TypeError(\"Unknown encoding: \" + encoding);\n                    encoding = (encoding + \"\").toLowerCase();\n                    loweredCase = true;\n                }\n              }\n            }\n            Buffer.prototype._isBuffer = true;\n            function swap(b, n, m) {\n              var i = b[n];\n              b[n] = b[m];\n              b[m] = i;\n            }\n            Buffer.prototype.swap16 = function swap16() {\n              var len = this.length;\n              if (len % 2 !== 0) {\n                throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n              }\n              for (var i = 0; i < len; i += 2) {\n                swap(this, i, i + 1);\n              }\n              return this;\n            };\n            Buffer.prototype.swap32 = function swap32() {\n              var len = this.length;\n              if (len % 4 !== 0) {\n                throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n              }\n              for (var i = 0; i < len; i += 4) {\n                swap(this, i, i + 3);\n                swap(this, i + 1, i + 2);\n              }\n              return this;\n            };\n            Buffer.prototype.swap64 = function swap64() {\n              var len = this.length;\n              if (len % 8 !== 0) {\n                throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n              }\n              for (var i = 0; i < len; i += 8) {\n                swap(this, i, i + 7);\n                swap(this, i + 1, i + 6);\n                swap(this, i + 2, i + 5);\n                swap(this, i + 3, i + 4);\n              }\n              return this;\n            };\n            Buffer.prototype.toString = function toString() {\n              var length = this.length | 0;\n              if (length === 0)\n                return \"\";\n              if (arguments.length === 0)\n                return utf8Slice(this, 0, length);\n              return slowToString.apply(this, arguments);\n            };\n            Buffer.prototype.equals = function equals(b) {\n              if (!Buffer.isBuffer(b))\n                throw new TypeError(\"Argument must be a Buffer\");\n              if (this === b)\n                return true;\n              return Buffer.compare(this, b) === 0;\n            };\n            Buffer.prototype.inspect = function inspect() {\n              var str = \"\";\n              var max = exports2.INSPECT_MAX_BYTES;\n              if (this.length > 0) {\n                str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n                if (this.length > max)\n                  str += \" ... \";\n              }\n              return \"<Buffer \" + str + \">\";\n            };\n            Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n              if (!Buffer.isBuffer(target)) {\n                throw new TypeError(\"Argument must be a Buffer\");\n              }\n              if (start === void 0) {\n                start = 0;\n              }\n              if (end === void 0) {\n                end = target ? target.length : 0;\n              }\n              if (thisStart === void 0) {\n                thisStart = 0;\n              }\n              if (thisEnd === void 0) {\n                thisEnd = this.length;\n              }\n              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n                throw new RangeError(\"out of range index\");\n              }\n              if (thisStart >= thisEnd && start >= end) {\n                return 0;\n              }\n              if (thisStart >= thisEnd) {\n                return -1;\n              }\n              if (start >= end) {\n                return 1;\n              }\n              start >>>= 0;\n              end >>>= 0;\n              thisStart >>>= 0;\n              thisEnd >>>= 0;\n              if (this === target)\n                return 0;\n              var x = thisEnd - thisStart;\n              var y = end - start;\n              var len = Math.min(x, y);\n              var thisCopy = this.slice(thisStart, thisEnd);\n              var targetCopy = target.slice(start, end);\n              for (var i = 0; i < len; ++i) {\n                if (thisCopy[i] !== targetCopy[i]) {\n                  x = thisCopy[i];\n                  y = targetCopy[i];\n                  break;\n                }\n              }\n              if (x < y)\n                return -1;\n              if (y < x)\n                return 1;\n              return 0;\n            };\n            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n              if (buffer.length === 0)\n                return -1;\n              if (typeof byteOffset === \"string\") {\n                encoding = byteOffset;\n                byteOffset = 0;\n              } else if (byteOffset > 2147483647) {\n                byteOffset = 2147483647;\n              } else if (byteOffset < -2147483648) {\n                byteOffset = -2147483648;\n              }\n              byteOffset = +byteOffset;\n              if (isNaN(byteOffset)) {\n                byteOffset = dir ? 0 : buffer.length - 1;\n              }\n              if (byteOffset < 0)\n                byteOffset = buffer.length + byteOffset;\n              if (byteOffset >= buffer.length) {\n                if (dir)\n                  return -1;\n                else\n                  byteOffset = buffer.length - 1;\n              } else if (byteOffset < 0) {\n                if (dir)\n                  byteOffset = 0;\n                else\n                  return -1;\n              }\n              if (typeof val === \"string\") {\n                val = Buffer.from(val, encoding);\n              }\n              if (Buffer.isBuffer(val)) {\n                if (val.length === 0) {\n                  return -1;\n                }\n                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n              } else if (typeof val === \"number\") {\n                val = val & 255;\n                if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n                  if (dir) {\n                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                  } else {\n                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                  }\n                }\n                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n              }\n              throw new TypeError(\"val must be string, number or Buffer\");\n            }\n            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n              var indexSize = 1;\n              var arrLength = arr.length;\n              var valLength = val.length;\n              if (encoding !== void 0) {\n                encoding = String(encoding).toLowerCase();\n                if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n                  if (arr.length < 2 || val.length < 2) {\n                    return -1;\n                  }\n                  indexSize = 2;\n                  arrLength /= 2;\n                  valLength /= 2;\n                  byteOffset /= 2;\n                }\n              }\n              function read(buf, i2) {\n                if (indexSize === 1) {\n                  return buf[i2];\n                } else {\n                  return buf.readUInt16BE(i2 * indexSize);\n                }\n              }\n              var i;\n              if (dir) {\n                var foundIndex = -1;\n                for (i = byteOffset; i < arrLength; i++) {\n                  if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                    if (foundIndex === -1)\n                      foundIndex = i;\n                    if (i - foundIndex + 1 === valLength)\n                      return foundIndex * indexSize;\n                  } else {\n                    if (foundIndex !== -1)\n                      i -= i - foundIndex;\n                    foundIndex = -1;\n                  }\n                }\n              } else {\n                if (byteOffset + valLength > arrLength)\n                  byteOffset = arrLength - valLength;\n                for (i = byteOffset; i >= 0; i--) {\n                  var found = true;\n                  for (var j = 0; j < valLength; j++) {\n                    if (read(arr, i + j) !== read(val, j)) {\n                      found = false;\n                      break;\n                    }\n                  }\n                  if (found)\n                    return i;\n                }\n              }\n              return -1;\n            }\n            Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n              return this.indexOf(val, byteOffset, encoding) !== -1;\n            };\n            Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n            };\n            Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n            };\n            function hexWrite(buf, string, offset, length) {\n              offset = Number(offset) || 0;\n              var remaining = buf.length - offset;\n              if (!length) {\n                length = remaining;\n              } else {\n                length = Number(length);\n                if (length > remaining) {\n                  length = remaining;\n                }\n              }\n              var strLen = string.length;\n              if (strLen % 2 !== 0)\n                throw new TypeError(\"Invalid hex string\");\n              if (length > strLen / 2) {\n                length = strLen / 2;\n              }\n              for (var i = 0; i < length; ++i) {\n                var parsed = parseInt(string.substr(i * 2, 2), 16);\n                if (isNaN(parsed))\n                  return i;\n                buf[offset + i] = parsed;\n              }\n              return i;\n            }\n            function utf8Write(buf, string, offset, length) {\n              return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n            }\n            function asciiWrite(buf, string, offset, length) {\n              return blitBuffer(asciiToBytes(string), buf, offset, length);\n            }\n            function latin1Write(buf, string, offset, length) {\n              return asciiWrite(buf, string, offset, length);\n            }\n            function base64Write(buf, string, offset, length) {\n              return blitBuffer(base64ToBytes(string), buf, offset, length);\n            }\n            function ucs2Write(buf, string, offset, length) {\n              return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n            }\n            Buffer.prototype.write = function write(string, offset, length, encoding) {\n              if (offset === void 0) {\n                encoding = \"utf8\";\n                length = this.length;\n                offset = 0;\n              } else if (length === void 0 && typeof offset === \"string\") {\n                encoding = offset;\n                length = this.length;\n                offset = 0;\n              } else if (isFinite(offset)) {\n                offset = offset | 0;\n                if (isFinite(length)) {\n                  length = length | 0;\n                  if (encoding === void 0)\n                    encoding = \"utf8\";\n                } else {\n                  encoding = length;\n                  length = void 0;\n                }\n              } else {\n                throw new Error(\n                  \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n                );\n              }\n              var remaining = this.length - offset;\n              if (length === void 0 || length > remaining)\n                length = remaining;\n              if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n                throw new RangeError(\"Attempt to write outside buffer bounds\");\n              }\n              if (!encoding)\n                encoding = \"utf8\";\n              var loweredCase = false;\n              for (; ; ) {\n                switch (encoding) {\n                  case \"hex\":\n                    return hexWrite(this, string, offset, length);\n                  case \"utf8\":\n                  case \"utf-8\":\n                    return utf8Write(this, string, offset, length);\n                  case \"ascii\":\n                    return asciiWrite(this, string, offset, length);\n                  case \"latin1\":\n                  case \"binary\":\n                    return latin1Write(this, string, offset, length);\n                  case \"base64\":\n                    return base64Write(this, string, offset, length);\n                  case \"ucs2\":\n                  case \"ucs-2\":\n                  case \"utf16le\":\n                  case \"utf-16le\":\n                    return ucs2Write(this, string, offset, length);\n                  default:\n                    if (loweredCase)\n                      throw new TypeError(\"Unknown encoding: \" + encoding);\n                    encoding = (\"\" + encoding).toLowerCase();\n                    loweredCase = true;\n                }\n              }\n            };\n            Buffer.prototype.toJSON = function toJSON() {\n              return {\n                type: \"Buffer\",\n                data: Array.prototype.slice.call(this._arr || this, 0)\n              };\n            };\n            function base64Slice(buf, start, end) {\n              if (start === 0 && end === buf.length) {\n                return base64.fromByteArray(buf);\n              } else {\n                return base64.fromByteArray(buf.slice(start, end));\n              }\n            }\n            function utf8Slice(buf, start, end) {\n              end = Math.min(buf.length, end);\n              var res = [];\n              var i = start;\n              while (i < end) {\n                var firstByte = buf[i];\n                var codePoint = null;\n                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n                if (i + bytesPerSequence <= end) {\n                  var secondByte, thirdByte, fourthByte, tempCodePoint;\n                  switch (bytesPerSequence) {\n                    case 1:\n                      if (firstByte < 128) {\n                        codePoint = firstByte;\n                      }\n                      break;\n                    case 2:\n                      secondByte = buf[i + 1];\n                      if ((secondByte & 192) === 128) {\n                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                        if (tempCodePoint > 127) {\n                          codePoint = tempCodePoint;\n                        }\n                      }\n                      break;\n                    case 3:\n                      secondByte = buf[i + 1];\n                      thirdByte = buf[i + 2];\n                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                          codePoint = tempCodePoint;\n                        }\n                      }\n                      break;\n                    case 4:\n                      secondByte = buf[i + 1];\n                      thirdByte = buf[i + 2];\n                      fourthByte = buf[i + 3];\n                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                          codePoint = tempCodePoint;\n                        }\n                      }\n                  }\n                }\n                if (codePoint === null) {\n                  codePoint = 65533;\n                  bytesPerSequence = 1;\n                } else if (codePoint > 65535) {\n                  codePoint -= 65536;\n                  res.push(codePoint >>> 10 & 1023 | 55296);\n                  codePoint = 56320 | codePoint & 1023;\n                }\n                res.push(codePoint);\n                i += bytesPerSequence;\n              }\n              return decodeCodePointsArray(res);\n            }\n            var MAX_ARGUMENTS_LENGTH = 4096;\n            function decodeCodePointsArray(codePoints) {\n              var len = codePoints.length;\n              if (len <= MAX_ARGUMENTS_LENGTH) {\n                return String.fromCharCode.apply(String, codePoints);\n              }\n              var res = \"\";\n              var i = 0;\n              while (i < len) {\n                res += String.fromCharCode.apply(\n                  String,\n                  codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n                );\n              }\n              return res;\n            }\n            function asciiSlice(buf, start, end) {\n              var ret = \"\";\n              end = Math.min(buf.length, end);\n              for (var i = start; i < end; ++i) {\n                ret += String.fromCharCode(buf[i] & 127);\n              }\n              return ret;\n            }\n            function latin1Slice(buf, start, end) {\n              var ret = \"\";\n              end = Math.min(buf.length, end);\n              for (var i = start; i < end; ++i) {\n                ret += String.fromCharCode(buf[i]);\n              }\n              return ret;\n            }\n            function hexSlice(buf, start, end) {\n              var len = buf.length;\n              if (!start || start < 0)\n                start = 0;\n              if (!end || end < 0 || end > len)\n                end = len;\n              var out = \"\";\n              for (var i = start; i < end; ++i) {\n                out += toHex(buf[i]);\n              }\n              return out;\n            }\n            function utf16leSlice(buf, start, end) {\n              var bytes = buf.slice(start, end);\n              var res = \"\";\n              for (var i = 0; i < bytes.length; i += 2) {\n                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n              }\n              return res;\n            }\n            Buffer.prototype.slice = function slice(start, end) {\n              var len = this.length;\n              start = ~~start;\n              end = end === void 0 ? len : ~~end;\n              if (start < 0) {\n                start += len;\n                if (start < 0)\n                  start = 0;\n              } else if (start > len) {\n                start = len;\n              }\n              if (end < 0) {\n                end += len;\n                if (end < 0)\n                  end = 0;\n              } else if (end > len) {\n                end = len;\n              }\n              if (end < start)\n                end = start;\n              var newBuf;\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                newBuf = this.subarray(start, end);\n                newBuf.__proto__ = Buffer.prototype;\n              } else {\n                var sliceLen = end - start;\n                newBuf = new Buffer(sliceLen, void 0);\n                for (var i = 0; i < sliceLen; ++i) {\n                  newBuf[i] = this[i + start];\n                }\n              }\n              return newBuf;\n            };\n            function checkOffset(offset, ext, length) {\n              if (offset % 1 !== 0 || offset < 0)\n                throw new RangeError(\"offset is not uint\");\n              if (offset + ext > length)\n                throw new RangeError(\"Trying to access beyond buffer length\");\n            }\n            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert)\n                checkOffset(offset, byteLength2, this.length);\n              var val = this[offset];\n              var mul = 1;\n              var i = 0;\n              while (++i < byteLength2 && (mul *= 256)) {\n                val += this[offset + i] * mul;\n              }\n              return val;\n            };\n            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert) {\n                checkOffset(offset, byteLength2, this.length);\n              }\n              var val = this[offset + --byteLength2];\n              var mul = 1;\n              while (byteLength2 > 0 && (mul *= 256)) {\n                val += this[offset + --byteLength2] * mul;\n              }\n              return val;\n            };\n            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 1, this.length);\n              return this[offset];\n            };\n            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              return this[offset] | this[offset + 1] << 8;\n            };\n            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              return this[offset] << 8 | this[offset + 1];\n            };\n            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n            };\n            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n            };\n            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert)\n                checkOffset(offset, byteLength2, this.length);\n              var val = this[offset];\n              var mul = 1;\n              var i = 0;\n              while (++i < byteLength2 && (mul *= 256)) {\n                val += this[offset + i] * mul;\n              }\n              mul *= 128;\n              if (val >= mul)\n                val -= Math.pow(2, 8 * byteLength2);\n              return val;\n            };\n            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert)\n                checkOffset(offset, byteLength2, this.length);\n              var i = byteLength2;\n              var mul = 1;\n              var val = this[offset + --i];\n              while (i > 0 && (mul *= 256)) {\n                val += this[offset + --i] * mul;\n              }\n              mul *= 128;\n              if (val >= mul)\n                val -= Math.pow(2, 8 * byteLength2);\n              return val;\n            };\n            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 1, this.length);\n              if (!(this[offset] & 128))\n                return this[offset];\n              return (255 - this[offset] + 1) * -1;\n            };\n            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              var val = this[offset] | this[offset + 1] << 8;\n              return val & 32768 ? val | 4294901760 : val;\n            };\n            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 2, this.length);\n              var val = this[offset + 1] | this[offset] << 8;\n              return val & 32768 ? val | 4294901760 : val;\n            };\n            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n            };\n            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n            };\n            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return ieee754.read(this, offset, true, 23, 4);\n            };\n            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 4, this.length);\n              return ieee754.read(this, offset, false, 23, 4);\n            };\n            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 8, this.length);\n              return ieee754.read(this, offset, true, 52, 8);\n            };\n            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n              if (!noAssert)\n                checkOffset(offset, 8, this.length);\n              return ieee754.read(this, offset, false, 52, 8);\n            };\n            function checkInt(buf, value, offset, ext, max, min) {\n              if (!Buffer.isBuffer(buf))\n                throw new TypeError('\"buffer\" argument must be a Buffer instance');\n              if (value > max || value < min)\n                throw new RangeError('\"value\" argument is out of bounds');\n              if (offset + ext > buf.length)\n                throw new RangeError(\"Index out of range\");\n            }\n            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert) {\n                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n                checkInt(this, value, offset, byteLength2, maxBytes, 0);\n              }\n              var mul = 1;\n              var i = 0;\n              this[offset] = value & 255;\n              while (++i < byteLength2 && (mul *= 256)) {\n                this[offset + i] = value / mul & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              byteLength2 = byteLength2 | 0;\n              if (!noAssert) {\n                var maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n                checkInt(this, value, offset, byteLength2, maxBytes, 0);\n              }\n              var i = byteLength2 - 1;\n              var mul = 1;\n              this[offset + i] = value & 255;\n              while (--i >= 0 && (mul *= 256)) {\n                this[offset + i] = value / mul & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 1, 255, 0);\n              if (!Buffer.TYPED_ARRAY_SUPPORT)\n                value = Math.floor(value);\n              this[offset] = value & 255;\n              return offset + 1;\n            };\n            function objectWriteUInt16(buf, value, offset, littleEndian) {\n              if (value < 0)\n                value = 65535 + value + 1;\n              for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n                buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n              }\n            }\n            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 65535, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value & 255;\n                this[offset + 1] = value >>> 8;\n              } else {\n                objectWriteUInt16(this, value, offset, true);\n              }\n              return offset + 2;\n            };\n            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 65535, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 8;\n                this[offset + 1] = value & 255;\n              } else {\n                objectWriteUInt16(this, value, offset, false);\n              }\n              return offset + 2;\n            };\n            function objectWriteUInt32(buf, value, offset, littleEndian) {\n              if (value < 0)\n                value = 4294967295 + value + 1;\n              for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n                buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;\n              }\n            }\n            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 4294967295, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset + 3] = value >>> 24;\n                this[offset + 2] = value >>> 16;\n                this[offset + 1] = value >>> 8;\n                this[offset] = value & 255;\n              } else {\n                objectWriteUInt32(this, value, offset, true);\n              }\n              return offset + 4;\n            };\n            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 4294967295, 0);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 24;\n                this[offset + 1] = value >>> 16;\n                this[offset + 2] = value >>> 8;\n                this[offset + 3] = value & 255;\n              } else {\n                objectWriteUInt32(this, value, offset, false);\n              }\n              return offset + 4;\n            };\n            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert) {\n                var limit = Math.pow(2, 8 * byteLength2 - 1);\n                checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n              }\n              var i = 0;\n              var mul = 1;\n              var sub = 0;\n              this[offset] = value & 255;\n              while (++i < byteLength2 && (mul *= 256)) {\n                if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                  sub = 1;\n                }\n                this[offset + i] = (value / mul >> 0) - sub & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert) {\n                var limit = Math.pow(2, 8 * byteLength2 - 1);\n                checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n              }\n              var i = byteLength2 - 1;\n              var mul = 1;\n              var sub = 0;\n              this[offset + i] = value & 255;\n              while (--i >= 0 && (mul *= 256)) {\n                if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                  sub = 1;\n                }\n                this[offset + i] = (value / mul >> 0) - sub & 255;\n              }\n              return offset + byteLength2;\n            };\n            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 1, 127, -128);\n              if (!Buffer.TYPED_ARRAY_SUPPORT)\n                value = Math.floor(value);\n              if (value < 0)\n                value = 255 + value + 1;\n              this[offset] = value & 255;\n              return offset + 1;\n            };\n            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 32767, -32768);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value & 255;\n                this[offset + 1] = value >>> 8;\n              } else {\n                objectWriteUInt16(this, value, offset, true);\n              }\n              return offset + 2;\n            };\n            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 2, 32767, -32768);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 8;\n                this[offset + 1] = value & 255;\n              } else {\n                objectWriteUInt16(this, value, offset, false);\n              }\n              return offset + 2;\n            };\n            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 2147483647, -2147483648);\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value & 255;\n                this[offset + 1] = value >>> 8;\n                this[offset + 2] = value >>> 16;\n                this[offset + 3] = value >>> 24;\n              } else {\n                objectWriteUInt32(this, value, offset, true);\n              }\n              return offset + 4;\n            };\n            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n              value = +value;\n              offset = offset | 0;\n              if (!noAssert)\n                checkInt(this, value, offset, 4, 2147483647, -2147483648);\n              if (value < 0)\n                value = 4294967295 + value + 1;\n              if (Buffer.TYPED_ARRAY_SUPPORT) {\n                this[offset] = value >>> 24;\n                this[offset + 1] = value >>> 16;\n                this[offset + 2] = value >>> 8;\n                this[offset + 3] = value & 255;\n              } else {\n                objectWriteUInt32(this, value, offset, false);\n              }\n              return offset + 4;\n            };\n            function checkIEEE754(buf, value, offset, ext, max, min) {\n              if (offset + ext > buf.length)\n                throw new RangeError(\"Index out of range\");\n              if (offset < 0)\n                throw new RangeError(\"Index out of range\");\n            }\n            function writeFloat(buf, value, offset, littleEndian, noAssert) {\n              if (!noAssert) {\n                checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n              }\n              ieee754.write(buf, value, offset, littleEndian, 23, 4);\n              return offset + 4;\n            }\n            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n              return writeFloat(this, value, offset, true, noAssert);\n            };\n            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n              return writeFloat(this, value, offset, false, noAssert);\n            };\n            function writeDouble(buf, value, offset, littleEndian, noAssert) {\n              if (!noAssert) {\n                checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n              }\n              ieee754.write(buf, value, offset, littleEndian, 52, 8);\n              return offset + 8;\n            }\n            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n              return writeDouble(this, value, offset, true, noAssert);\n            };\n            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n              return writeDouble(this, value, offset, false, noAssert);\n            };\n            Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n              if (!start)\n                start = 0;\n              if (!end && end !== 0)\n                end = this.length;\n              if (targetStart >= target.length)\n                targetStart = target.length;\n              if (!targetStart)\n                targetStart = 0;\n              if (end > 0 && end < start)\n                end = start;\n              if (end === start)\n                return 0;\n              if (target.length === 0 || this.length === 0)\n                return 0;\n              if (targetStart < 0) {\n                throw new RangeError(\"targetStart out of bounds\");\n              }\n              if (start < 0 || start >= this.length)\n                throw new RangeError(\"sourceStart out of bounds\");\n              if (end < 0)\n                throw new RangeError(\"sourceEnd out of bounds\");\n              if (end > this.length)\n                end = this.length;\n              if (target.length - targetStart < end - start) {\n                end = target.length - targetStart + start;\n              }\n              var len = end - start;\n              var i;\n              if (this === target && start < targetStart && targetStart < end) {\n                for (i = len - 1; i >= 0; --i) {\n                  target[i + targetStart] = this[i + start];\n                }\n              } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {\n                for (i = 0; i < len; ++i) {\n                  target[i + targetStart] = this[i + start];\n                }\n              } else {\n                Uint8Array.prototype.set.call(\n                  target,\n                  this.subarray(start, start + len),\n                  targetStart\n                );\n              }\n              return len;\n            };\n            Buffer.prototype.fill = function fill(val, start, end, encoding) {\n              if (typeof val === \"string\") {\n                if (typeof start === \"string\") {\n                  encoding = start;\n                  start = 0;\n                  end = this.length;\n                } else if (typeof end === \"string\") {\n                  encoding = end;\n                  end = this.length;\n                }\n                if (val.length === 1) {\n                  var code2 = val.charCodeAt(0);\n                  if (code2 < 256) {\n                    val = code2;\n                  }\n                }\n                if (encoding !== void 0 && typeof encoding !== \"string\") {\n                  throw new TypeError(\"encoding must be a string\");\n                }\n                if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n                  throw new TypeError(\"Unknown encoding: \" + encoding);\n                }\n              } else if (typeof val === \"number\") {\n                val = val & 255;\n              }\n              if (start < 0 || this.length < start || this.length < end) {\n                throw new RangeError(\"Out of range index\");\n              }\n              if (end <= start) {\n                return this;\n              }\n              start = start >>> 0;\n              end = end === void 0 ? this.length : end >>> 0;\n              if (!val)\n                val = 0;\n              var i;\n              if (typeof val === \"number\") {\n                for (i = start; i < end; ++i) {\n                  this[i] = val;\n                }\n              } else {\n                var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n                var len = bytes.length;\n                for (i = 0; i < end - start; ++i) {\n                  this[i + start] = bytes[i % len];\n                }\n              }\n              return this;\n            };\n            var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n            function base64clean(str) {\n              str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n              if (str.length < 2)\n                return \"\";\n              while (str.length % 4 !== 0) {\n                str = str + \"=\";\n              }\n              return str;\n            }\n            function stringtrim(str) {\n              if (str.trim)\n                return str.trim();\n              return str.replace(/^\\s+|\\s+$/g, \"\");\n            }\n            function toHex(n) {\n              if (n < 16)\n                return \"0\" + n.toString(16);\n              return n.toString(16);\n            }\n            function utf8ToBytes(string, units) {\n              units = units || Infinity;\n              var codePoint;\n              var length = string.length;\n              var leadSurrogate = null;\n              var bytes = [];\n              for (var i = 0; i < length; ++i) {\n                codePoint = string.charCodeAt(i);\n                if (codePoint > 55295 && codePoint < 57344) {\n                  if (!leadSurrogate) {\n                    if (codePoint > 56319) {\n                      if ((units -= 3) > -1)\n                        bytes.push(239, 191, 189);\n                      continue;\n                    } else if (i + 1 === length) {\n                      if ((units -= 3) > -1)\n                        bytes.push(239, 191, 189);\n                      continue;\n                    }\n                    leadSurrogate = codePoint;\n                    continue;\n                  }\n                  if (codePoint < 56320) {\n                    if ((units -= 3) > -1)\n                      bytes.push(239, 191, 189);\n                    leadSurrogate = codePoint;\n                    continue;\n                  }\n                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n                } else if (leadSurrogate) {\n                  if ((units -= 3) > -1)\n                    bytes.push(239, 191, 189);\n                }\n                leadSurrogate = null;\n                if (codePoint < 128) {\n                  if ((units -= 1) < 0)\n                    break;\n                  bytes.push(codePoint);\n                } else if (codePoint < 2048) {\n                  if ((units -= 2) < 0)\n                    break;\n                  bytes.push(\n                    codePoint >> 6 | 192,\n                    codePoint & 63 | 128\n                  );\n                } else if (codePoint < 65536) {\n                  if ((units -= 3) < 0)\n                    break;\n                  bytes.push(\n                    codePoint >> 12 | 224,\n                    codePoint >> 6 & 63 | 128,\n                    codePoint & 63 | 128\n                  );\n                } else if (codePoint < 1114112) {\n                  if ((units -= 4) < 0)\n                    break;\n                  bytes.push(\n                    codePoint >> 18 | 240,\n                    codePoint >> 12 & 63 | 128,\n                    codePoint >> 6 & 63 | 128,\n                    codePoint & 63 | 128\n                  );\n                } else {\n                  throw new Error(\"Invalid code point\");\n                }\n              }\n              return bytes;\n            }\n            function asciiToBytes(str) {\n              var byteArray = [];\n              for (var i = 0; i < str.length; ++i) {\n                byteArray.push(str.charCodeAt(i) & 255);\n              }\n              return byteArray;\n            }\n            function utf16leToBytes(str, units) {\n              var c, hi, lo;\n              var byteArray = [];\n              for (var i = 0; i < str.length; ++i) {\n                if ((units -= 2) < 0)\n                  break;\n                c = str.charCodeAt(i);\n                hi = c >> 8;\n                lo = c % 256;\n                byteArray.push(lo);\n                byteArray.push(hi);\n              }\n              return byteArray;\n            }\n            function base64ToBytes(str) {\n              return base64.toByteArray(base64clean(str));\n            }\n            function blitBuffer(src, dst, offset, length) {\n              for (var i = 0; i < length; ++i) {\n                if (i + offset >= dst.length || i >= src.length)\n                  break;\n                dst[i + offset] = src[i];\n              }\n              return i;\n            }\n            function isnan(val) {\n              return val !== val;\n            }\n          }).call(this, __webpack_require__2(\n            /*! ./../webpack/buildin/global.js */\n            \"./node_modules/webpack/buildin/global.js\"\n          ));\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/has-cors.js\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/has-cors.js ***!\n          \\*********************************************************************/\n        /*! exports provided: hasCORS */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"hasCORS\", function() {\n            return hasCORS;\n          });\n          let value = false;\n          try {\n            value = typeof XMLHttpRequest !== \"undefined\" && \"withCredentials\" in new XMLHttpRequest();\n          } catch (err) {\n          }\n          const hasCORS = value;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\": (\n        /*!********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/parseqs.js ***!\n          \\********************************************************************/\n        /*! exports provided: encode, decode */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          function encode(obj) {\n            let str = \"\";\n            for (let i in obj) {\n              if (obj.hasOwnProperty(i)) {\n                if (str.length)\n                  str += \"&\";\n                str += encodeURIComponent(i) + \"=\" + encodeURIComponent(obj[i]);\n              }\n            }\n            return str;\n          }\n          function decode(qs) {\n            let qry = {};\n            let pairs = qs.split(\"&\");\n            for (let i = 0, l = pairs.length; i < l; i++) {\n              let pair = pairs[i].split(\"=\");\n              qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n            }\n            return qry;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/parseuri.js ***!\n          \\*********************************************************************/\n        /*! exports provided: parse */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"parse\", function() {\n            return parse;\n          });\n          const re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n          const parts = [\n            \"source\",\n            \"protocol\",\n            \"authority\",\n            \"userInfo\",\n            \"user\",\n            \"password\",\n            \"host\",\n            \"port\",\n            \"relative\",\n            \"path\",\n            \"directory\",\n            \"file\",\n            \"query\",\n            \"anchor\"\n          ];\n          function parse(str) {\n            const src = str, b = str.indexOf(\"[\"), e = str.indexOf(\"]\");\n            if (b != -1 && e != -1) {\n              str = str.substring(0, b) + str.substring(b, e).replace(/:/g, \";\") + str.substring(e, str.length);\n            }\n            let m = re.exec(str || \"\"), uri = {}, i = 14;\n            while (i--) {\n              uri[parts[i]] = m[i] || \"\";\n            }\n            if (b != -1 && e != -1) {\n              uri.source = src;\n              uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \":\");\n              uri.authority = uri.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\");\n              uri.ipv6uri = true;\n            }\n            uri.pathNames = pathNames(uri, uri[\"path\"]);\n            uri.queryKey = queryKey(uri, uri[\"query\"]);\n            return uri;\n          }\n          function pathNames(obj, path) {\n            const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n            if (path.slice(0, 1) == \"/\" || path.length === 0) {\n              names.splice(0, 1);\n            }\n            if (path.slice(-1) == \"/\") {\n              names.splice(names.length - 1, 1);\n            }\n            return names;\n          }\n          function queryKey(uri, query) {\n            const data = {};\n            query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {\n              if ($1) {\n                data[$1] = $2;\n              }\n            });\n            return data;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\": (\n        /*!******************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/contrib/yeast.js ***!\n          \\******************************************************************/\n        /*! exports provided: encode, decode, yeast */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"encode\", function() {\n            return encode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decode\", function() {\n            return decode;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"yeast\", function() {\n            return yeast;\n          });\n          const alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\n          let seed = 0, i = 0, prev;\n          function encode(num) {\n            let encoded = \"\";\n            do {\n              encoded = alphabet[num % length] + encoded;\n              num = Math.floor(num / length);\n            } while (num > 0);\n            return encoded;\n          }\n          function decode(str) {\n            let decoded = 0;\n            for (i = 0; i < str.length; i++) {\n              decoded = decoded * length + map[str.charAt(i)];\n            }\n            return decoded;\n          }\n          function yeast() {\n            const now = encode(+/* @__PURE__ */ new Date());\n            if (now !== prev)\n              return seed = 0, prev = now;\n            return now + \".\" + encode(seed++);\n          }\n          for (; i < length; i++)\n            map[alphabet[i]] = i;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/globalThis.browser.js ***!\n          \\***********************************************************************/\n        /*! exports provided: globalThisShim */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"globalThisShim\", function() {\n            return globalThisShim;\n          });\n          const globalThisShim = (() => {\n            if (typeof self !== \"undefined\") {\n              return self;\n            } else if (typeof window !== \"undefined\") {\n              return window;\n            } else {\n              return Function(\"return this\")();\n            }\n          })();\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: Socket, protocol, Transport, transports, installTimerFunctions, parse, nextTick */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return protocol;\n          });\n          var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./socket.js */\n            \"./node_modules/engine.io-client/build/esm/socket.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return _socket_js__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"];\n          });\n          var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./transport.js */\n            \"./node_modules/engine.io-client/build/esm/transport.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Transport\", function() {\n            return _transport_js__WEBPACK_IMPORTED_MODULE_1__[\"Transport\"];\n          });\n          var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./transports/index.js */\n            \"./node_modules/engine.io-client/build/esm/transports/index.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"transports\", function() {\n            return _transports_index_js__WEBPACK_IMPORTED_MODULE_2__[\"transports\"];\n          });\n          var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"installTimerFunctions\", function() {\n            return _util_js__WEBPACK_IMPORTED_MODULE_3__[\"installTimerFunctions\"];\n          });\n          var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./contrib/parseuri.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"parse\", function() {\n            return _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__[\"parse\"];\n          });\n          var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ./transports/websocket-constructor.js */\n            \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"nextTick\", function() {\n            return _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__[\"nextTick\"];\n          });\n          const protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"].protocol;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/socket.js\": (\n        /*!***********************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/socket.js ***!\n          \\***********************************************************/\n        /*! exports provided: Socket */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return Socket;\n          });\n          var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./transports/index.js */\n            \"./node_modules/engine.io-client/build/esm/transports/index.js\"\n          );\n          var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./contrib/parseqs.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\"\n          );\n          var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./contrib/parseuri.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseuri.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! engine.io-parser */\n            \"./node_modules/engine.io-parser/build/esm/index.js\"\n          );\n          class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__[\"Emitter\"] {\n            /**\n             * Socket constructor.\n             *\n             * @param {String|Object} uri - uri or options\n             * @param {Object} opts - options\n             */\n            constructor(uri, opts = {}) {\n              super();\n              this.writeBuffer = [];\n              if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = null;\n              }\n              if (uri) {\n                uri = Object(_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(uri);\n                opts.hostname = uri.host;\n                opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n                opts.port = uri.port;\n                if (uri.query)\n                  opts.query = uri.query;\n              } else if (opts.host) {\n                opts.hostname = Object(_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__[\"parse\"])(opts.host).host;\n              }\n              Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"installTimerFunctions\"])(this, opts);\n              this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n              if (opts.hostname && !opts.port) {\n                opts.port = this.secure ? \"443\" : \"80\";\n              }\n              this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n              this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : this.secure ? \"443\" : \"80\");\n              this.transports = opts.transports || [\"polling\", \"websocket\"];\n              this.writeBuffer = [];\n              this.prevBufferLen = 0;\n              this.opts = Object.assign({\n                path: \"/engine.io\",\n                agent: false,\n                withCredentials: false,\n                upgrade: true,\n                timestampParam: \"t\",\n                rememberUpgrade: false,\n                addTrailingSlash: true,\n                rejectUnauthorized: true,\n                perMessageDeflate: {\n                  threshold: 1024\n                },\n                transportOptions: {},\n                closeOnBeforeunload: true\n              }, opts);\n              this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\");\n              if (typeof this.opts.query === \"string\") {\n                this.opts.query = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__[\"decode\"])(this.opts.query);\n              }\n              this.id = null;\n              this.upgrades = null;\n              this.pingInterval = null;\n              this.pingTimeout = null;\n              this.pingTimeoutTimer = null;\n              if (typeof addEventListener === \"function\") {\n                if (this.opts.closeOnBeforeunload) {\n                  this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                      this.transport.removeAllListeners();\n                      this.transport.close();\n                    }\n                  };\n                  addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                }\n                if (this.hostname !== \"localhost\") {\n                  this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                      description: \"network connection lost\"\n                    });\n                  };\n                  addEventListener(\"offline\", this.offlineEventListener, false);\n                }\n              }\n              this.open();\n            }\n            /**\n             * Creates transport of the given type.\n             *\n             * @param {String} name - transport name\n             * @return {Transport}\n             * @private\n             */\n            createTransport(name) {\n              const query = Object.assign({}, this.opts.query);\n              query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"protocol\"];\n              query.transport = name;\n              if (this.id)\n                query.sid = this.id;\n              const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n                query,\n                socket: this,\n                hostname: this.hostname,\n                secure: this.secure,\n                port: this.port\n              });\n              return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__[\"transports\"][name](opts);\n            }\n            /**\n             * Initializes transport to use and starts probe.\n             *\n             * @private\n             */\n            open() {\n              let transport;\n              if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) {\n                transport = \"websocket\";\n              } else if (0 === this.transports.length) {\n                this.setTimeoutFn(() => {\n                  this.emitReserved(\"error\", \"No transports available\");\n                }, 0);\n                return;\n              } else {\n                transport = this.transports[0];\n              }\n              this.readyState = \"opening\";\n              try {\n                transport = this.createTransport(transport);\n              } catch (e) {\n                this.transports.shift();\n                this.open();\n                return;\n              }\n              transport.open();\n              this.setTransport(transport);\n            }\n            /**\n             * Sets the current transport. Disables the existing one (if any).\n             *\n             * @private\n             */\n            setTransport(transport) {\n              if (this.transport) {\n                this.transport.removeAllListeners();\n              }\n              this.transport = transport;\n              transport.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n            }\n            /**\n             * Probes a transport.\n             *\n             * @param {String} name - transport name\n             * @private\n             */\n            probe(name) {\n              let transport = this.createTransport(name);\n              let failed = false;\n              Socket.priorWebsocketSuccess = false;\n              const onTransportOpen = () => {\n                if (failed)\n                  return;\n                transport.send([{ type: \"ping\", data: \"probe\" }]);\n                transport.once(\"packet\", (msg) => {\n                  if (failed)\n                    return;\n                  if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                      return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                      if (failed)\n                        return;\n                      if (\"closed\" === this.readyState)\n                        return;\n                      cleanup();\n                      this.setTransport(transport);\n                      transport.send([{ type: \"upgrade\" }]);\n                      this.emitReserved(\"upgrade\", transport);\n                      transport = null;\n                      this.upgrading = false;\n                      this.flush();\n                    });\n                  } else {\n                    const err = new Error(\"probe error\");\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                  }\n                });\n              };\n              function freezeTransport() {\n                if (failed)\n                  return;\n                failed = true;\n                cleanup();\n                transport.close();\n                transport = null;\n              }\n              const onerror = (err) => {\n                const error = new Error(\"probe error: \" + err);\n                error.transport = transport.name;\n                freezeTransport();\n                this.emitReserved(\"upgradeError\", error);\n              };\n              function onTransportClose() {\n                onerror(\"transport closed\");\n              }\n              function onclose() {\n                onerror(\"socket closed\");\n              }\n              function onupgrade(to) {\n                if (transport && to.name !== transport.name) {\n                  freezeTransport();\n                }\n              }\n              const cleanup = () => {\n                transport.removeListener(\"open\", onTransportOpen);\n                transport.removeListener(\"error\", onerror);\n                transport.removeListener(\"close\", onTransportClose);\n                this.off(\"close\", onclose);\n                this.off(\"upgrading\", onupgrade);\n              };\n              transport.once(\"open\", onTransportOpen);\n              transport.once(\"error\", onerror);\n              transport.once(\"close\", onTransportClose);\n              this.once(\"close\", onclose);\n              this.once(\"upgrading\", onupgrade);\n              transport.open();\n            }\n            /**\n             * Called when connection is deemed open.\n             *\n             * @private\n             */\n            onOpen() {\n              this.readyState = \"open\";\n              Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n              this.emitReserved(\"open\");\n              this.flush();\n              if (\"open\" === this.readyState && this.opts.upgrade) {\n                let i = 0;\n                const l = this.upgrades.length;\n                for (; i < l; i++) {\n                  this.probe(this.upgrades[i]);\n                }\n              }\n            }\n            /**\n             * Handles a packet.\n             *\n             * @private\n             */\n            onPacket(packet) {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                this.emitReserved(\"packet\", packet);\n                this.emitReserved(\"heartbeat\");\n                switch (packet.type) {\n                  case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                  case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                  case \"error\":\n                    const err = new Error(\"server error\");\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                  case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n                }\n              } else {\n              }\n            }\n            /**\n             * Called upon handshake completion.\n             *\n             * @param {Object} data - handshake obj\n             * @private\n             */\n            onHandshake(data) {\n              this.emitReserved(\"handshake\", data);\n              this.id = data.sid;\n              this.transport.query.sid = data.sid;\n              this.upgrades = this.filterUpgrades(data.upgrades);\n              this.pingInterval = data.pingInterval;\n              this.pingTimeout = data.pingTimeout;\n              this.maxPayload = data.maxPayload;\n              this.onOpen();\n              if (\"closed\" === this.readyState)\n                return;\n              this.resetPingTimeout();\n            }\n            /**\n             * Sets and resets ping timeout timer based on server pings.\n             *\n             * @private\n             */\n            resetPingTimeout() {\n              this.clearTimeoutFn(this.pingTimeoutTimer);\n              this.pingTimeoutTimer = this.setTimeoutFn(() => {\n                this.onClose(\"ping timeout\");\n              }, this.pingInterval + this.pingTimeout);\n              if (this.opts.autoUnref) {\n                this.pingTimeoutTimer.unref();\n              }\n            }\n            /**\n             * Called on `drain` event\n             *\n             * @private\n             */\n            onDrain() {\n              this.writeBuffer.splice(0, this.prevBufferLen);\n              this.prevBufferLen = 0;\n              if (0 === this.writeBuffer.length) {\n                this.emitReserved(\"drain\");\n              } else {\n                this.flush();\n              }\n            }\n            /**\n             * Flush write buffers.\n             *\n             * @private\n             */\n            flush() {\n              if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n                const packets = this.getWritablePackets();\n                this.transport.send(packets);\n                this.prevBufferLen = packets.length;\n                this.emitReserved(\"flush\");\n              }\n            }\n            /**\n             * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n             * long-polling)\n             *\n             * @private\n             */\n            getWritablePackets() {\n              const shouldCheckPayloadSize = this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1;\n              if (!shouldCheckPayloadSize) {\n                return this.writeBuffer;\n              }\n              let payloadSize = 1;\n              for (let i = 0; i < this.writeBuffer.length; i++) {\n                const data = this.writeBuffer[i].data;\n                if (data) {\n                  payloadSize += Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[\"byteLength\"])(data);\n                }\n                if (i > 0 && payloadSize > this.maxPayload) {\n                  return this.writeBuffer.slice(0, i);\n                }\n                payloadSize += 2;\n              }\n              return this.writeBuffer;\n            }\n            /**\n             * Sends a message.\n             *\n             * @param {String} msg - message.\n             * @param {Object} options.\n             * @param {Function} callback function.\n             * @return {Socket} for chaining.\n             */\n            write(msg, options, fn) {\n              this.sendPacket(\"message\", msg, options, fn);\n              return this;\n            }\n            send(msg, options, fn) {\n              this.sendPacket(\"message\", msg, options, fn);\n              return this;\n            }\n            /**\n             * Sends a packet.\n             *\n             * @param {String} type: packet type.\n             * @param {String} data.\n             * @param {Object} options.\n             * @param {Function} fn - callback function.\n             * @private\n             */\n            sendPacket(type, data, options, fn) {\n              if (\"function\" === typeof data) {\n                fn = data;\n                data = void 0;\n              }\n              if (\"function\" === typeof options) {\n                fn = options;\n                options = null;\n              }\n              if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n                return;\n              }\n              options = options || {};\n              options.compress = false !== options.compress;\n              const packet = {\n                type,\n                data,\n                options\n              };\n              this.emitReserved(\"packetCreate\", packet);\n              this.writeBuffer.push(packet);\n              if (fn)\n                this.once(\"flush\", fn);\n              this.flush();\n            }\n            /**\n             * Closes the connection.\n             */\n            close() {\n              const close = () => {\n                this.onClose(\"forced close\");\n                this.transport.close();\n              };\n              const cleanupAndClose = () => {\n                this.off(\"upgrade\", cleanupAndClose);\n                this.off(\"upgradeError\", cleanupAndClose);\n                close();\n              };\n              const waitForUpgrade = () => {\n                this.once(\"upgrade\", cleanupAndClose);\n                this.once(\"upgradeError\", cleanupAndClose);\n              };\n              if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                this.readyState = \"closing\";\n                if (this.writeBuffer.length) {\n                  this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                      waitForUpgrade();\n                    } else {\n                      close();\n                    }\n                  });\n                } else if (this.upgrading) {\n                  waitForUpgrade();\n                } else {\n                  close();\n                }\n              }\n              return this;\n            }\n            /**\n             * Called upon transport error\n             *\n             * @private\n             */\n            onError(err) {\n              Socket.priorWebsocketSuccess = false;\n              this.emitReserved(\"error\", err);\n              this.onClose(\"transport error\", err);\n            }\n            /**\n             * Called upon transport close.\n             *\n             * @private\n             */\n            onClose(reason, description) {\n              if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                this.clearTimeoutFn(this.pingTimeoutTimer);\n                this.transport.removeAllListeners(\"close\");\n                this.transport.close();\n                this.transport.removeAllListeners();\n                if (typeof removeEventListener === \"function\") {\n                  removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                  removeEventListener(\"offline\", this.offlineEventListener, false);\n                }\n                this.readyState = \"closed\";\n                this.id = null;\n                this.emitReserved(\"close\", reason, description);\n                this.writeBuffer = [];\n                this.prevBufferLen = 0;\n              }\n            }\n            /**\n             * Filters upgrades, returning only those matching client transports.\n             *\n             * @param {Array} upgrades - server upgrades\n             * @private\n             */\n            filterUpgrades(upgrades) {\n              const filteredUpgrades = [];\n              let i = 0;\n              const j = upgrades.length;\n              for (; i < j; i++) {\n                if (~this.transports.indexOf(upgrades[i]))\n                  filteredUpgrades.push(upgrades[i]);\n              }\n              return filteredUpgrades;\n            }\n          }\n          Socket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"protocol\"];\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transport.js\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transport.js ***!\n          \\**************************************************************/\n        /*! exports provided: Transport */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Transport\", function() {\n            return Transport;\n          });\n          var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! engine.io-parser */\n            \"./node_modules/engine.io-parser/build/esm/index.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          class TransportError extends Error {\n            constructor(reason, description, context) {\n              super(reason);\n              this.description = description;\n              this.context = context;\n              this.type = \"TransportError\";\n            }\n          }\n          class Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__[\"Emitter\"] {\n            /**\n             * Transport abstract constructor.\n             *\n             * @param {Object} opts - options\n             * @protected\n             */\n            constructor(opts) {\n              super();\n              this.writable = false;\n              Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[\"installTimerFunctions\"])(this, opts);\n              this.opts = opts;\n              this.query = opts.query;\n              this.socket = opts.socket;\n            }\n            /**\n             * Emits an error.\n             *\n             * @param {String} reason\n             * @param description\n             * @param context - the error context\n             * @return {Transport} for chaining\n             * @protected\n             */\n            onError(reason, description, context) {\n              super.emitReserved(\"error\", new TransportError(reason, description, context));\n              return this;\n            }\n            /**\n             * Opens the transport.\n             */\n            open() {\n              this.readyState = \"opening\";\n              this.doOpen();\n              return this;\n            }\n            /**\n             * Closes the transport.\n             */\n            close() {\n              if (this.readyState === \"opening\" || this.readyState === \"open\") {\n                this.doClose();\n                this.onClose();\n              }\n              return this;\n            }\n            /**\n             * Sends multiple packets.\n             *\n             * @param {Array} packets\n             */\n            send(packets) {\n              if (this.readyState === \"open\") {\n                this.write(packets);\n              } else {\n              }\n            }\n            /**\n             * Called upon open\n             *\n             * @protected\n             */\n            onOpen() {\n              this.readyState = \"open\";\n              this.writable = true;\n              super.emitReserved(\"open\");\n            }\n            /**\n             * Called with data.\n             *\n             * @param {String} data\n             * @protected\n             */\n            onData(data) {\n              const packet = Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"decodePacket\"])(data, this.socket.binaryType);\n              this.onPacket(packet);\n            }\n            /**\n             * Called with a decoded packet.\n             *\n             * @protected\n             */\n            onPacket(packet) {\n              super.emitReserved(\"packet\", packet);\n            }\n            /**\n             * Called upon close.\n             *\n             * @protected\n             */\n            onClose(details) {\n              this.readyState = \"closed\";\n              super.emitReserved(\"close\", details);\n            }\n            /**\n             * Pauses the transport, in order not to lose packets during an upgrade.\n             *\n             * @param onPause\n             */\n            pause(onPause) {\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/index.js\": (\n        /*!*********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/index.js ***!\n          \\*********************************************************************/\n        /*! exports provided: transports */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"transports\", function() {\n            return transports;\n          });\n          var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./polling.js */\n            \"./node_modules/engine.io-client/build/esm/transports/polling.js\"\n          );\n          var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./websocket.js */\n            \"./node_modules/engine.io-client/build/esm/transports/websocket.js\"\n          );\n          const transports = {\n            websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__[\"WS\"],\n            polling: _polling_js__WEBPACK_IMPORTED_MODULE_0__[\"Polling\"]\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/polling.js\": (\n        /*!***********************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/polling.js ***!\n          \\***********************************************************************/\n        /*! exports provided: Polling, Request */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Polling\", function() {\n            return Polling;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Request\", function() {\n            return Request;\n          });\n          var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ../transport.js */\n            \"./node_modules/engine.io-client/build/esm/transport.js\"\n          );\n          var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ../contrib/yeast.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\"\n          );\n          var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ../contrib/parseqs.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\"\n          );\n          var engine_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! engine.io-parser */\n            \"./node_modules/engine.io-parser/build/esm/index.js\"\n          );\n          var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./xmlhttprequest.js */\n            \"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(\n            /*! ../util.js */\n            \"./node_modules/engine.io-client/build/esm/util.js\"\n          );\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(\n            /*! ../globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          function empty() {\n          }\n          const hasXHR2 = function() {\n            const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__[\"XHR\"]({\n              xdomain: false\n            });\n            return null != xhr.responseType;\n          }();\n          class Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__[\"Transport\"] {\n            /**\n             * XHR Polling constructor.\n             *\n             * @param {Object} opts\n             * @package\n             */\n            constructor(opts) {\n              super(opts);\n              this.polling = false;\n              if (typeof location !== \"undefined\") {\n                const isSSL = \"https:\" === location.protocol;\n                let port = location.port;\n                if (!port) {\n                  port = isSSL ? \"443\" : \"80\";\n                }\n                this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n                this.xs = opts.secure !== isSSL;\n              }\n              const forceBase64 = opts && opts.forceBase64;\n              this.supportsBinary = hasXHR2 && !forceBase64;\n            }\n            get name() {\n              return \"polling\";\n            }\n            /**\n             * Opens the socket (triggers polling). We write a PING message to determine\n             * when the transport is open.\n             *\n             * @protected\n             */\n            doOpen() {\n              this.poll();\n            }\n            /**\n             * Pauses polling.\n             *\n             * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n             * @package\n             */\n            pause(onPause) {\n              this.readyState = \"pausing\";\n              const pause = () => {\n                this.readyState = \"paused\";\n                onPause();\n              };\n              if (this.polling || !this.writable) {\n                let total = 0;\n                if (this.polling) {\n                  total++;\n                  this.once(\"pollComplete\", function() {\n                    --total || pause();\n                  });\n                }\n                if (!this.writable) {\n                  total++;\n                  this.once(\"drain\", function() {\n                    --total || pause();\n                  });\n                }\n              } else {\n                pause();\n              }\n            }\n            /**\n             * Starts polling cycle.\n             *\n             * @private\n             */\n            poll() {\n              this.polling = true;\n              this.doPoll();\n              this.emitReserved(\"poll\");\n            }\n            /**\n             * Overloads onData to detect payloads.\n             *\n             * @protected\n             */\n            onData(data) {\n              const callback = (packet) => {\n                if (\"opening\" === this.readyState && packet.type === \"open\") {\n                  this.onOpen();\n                }\n                if (\"close\" === packet.type) {\n                  this.onClose({ description: \"transport closed by the server\" });\n                  return false;\n                }\n                this.onPacket(packet);\n              };\n              Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"decodePayload\"])(data, this.socket.binaryType).forEach(callback);\n              if (\"closed\" !== this.readyState) {\n                this.polling = false;\n                this.emitReserved(\"pollComplete\");\n                if (\"open\" === this.readyState) {\n                  this.poll();\n                } else {\n                }\n              }\n            }\n            /**\n             * For polling, send a close packet.\n             *\n             * @protected\n             */\n            doClose() {\n              const close = () => {\n                this.write([{ type: \"close\" }]);\n              };\n              if (\"open\" === this.readyState) {\n                close();\n              } else {\n                this.once(\"open\", close);\n              }\n            }\n            /**\n             * Writes a packets payload.\n             *\n             * @param {Array} packets - data packets\n             * @protected\n             */\n            write(packets) {\n              this.writable = false;\n              Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"encodePayload\"])(packets, (data) => {\n                this.doWrite(data, () => {\n                  this.writable = true;\n                  this.emitReserved(\"drain\");\n                });\n              });\n            }\n            /**\n             * Generates uri for connection.\n             *\n             * @private\n             */\n            uri() {\n              let query = this.query || {};\n              const schema = this.opts.secure ? \"https\" : \"http\";\n              let port = \"\";\n              if (false !== this.opts.timestampRequests) {\n                query[this.opts.timestampParam] = Object(_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__[\"yeast\"])();\n              }\n              if (!this.supportsBinary && !query.sid) {\n                query.b64 = 1;\n              }\n              if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n                port = \":\" + this.opts.port;\n              }\n              const encodedQuery = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__[\"encode\"])(query);\n              const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n              return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n            }\n            /**\n             * Creates a request.\n             *\n             * @param {String} method\n             * @private\n             */\n            request(opts = {}) {\n              Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n              return new Request(this.uri(), opts);\n            }\n            /**\n             * Sends data.\n             *\n             * @param {String} data to send.\n             * @param {Function} called upon flush.\n             * @private\n             */\n            doWrite(data, fn) {\n              const req = this.request({\n                method: \"POST\",\n                data\n              });\n              req.on(\"success\", fn);\n              req.on(\"error\", (xhrStatus, context) => {\n                this.onError(\"xhr post error\", xhrStatus, context);\n              });\n            }\n            /**\n             * Starts a poll cycle.\n             *\n             * @private\n             */\n            doPoll() {\n              const req = this.request();\n              req.on(\"data\", this.onData.bind(this));\n              req.on(\"error\", (xhrStatus, context) => {\n                this.onError(\"xhr poll error\", xhrStatus, context);\n              });\n              this.pollXhr = req;\n            }\n          }\n          class Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__[\"Emitter\"] {\n            /**\n             * Request constructor\n             *\n             * @param {Object} options\n             * @package\n             */\n            constructor(uri, opts) {\n              super();\n              Object(_util_js__WEBPACK_IMPORTED_MODULE_6__[\"installTimerFunctions\"])(this, opts);\n              this.opts = opts;\n              this.method = opts.method || \"GET\";\n              this.uri = uri;\n              this.async = false !== opts.async;\n              this.data = void 0 !== opts.data ? opts.data : null;\n              this.create();\n            }\n            /**\n             * Creates the XHR object and sends the request.\n             *\n             * @private\n             */\n            create() {\n              const opts = Object(_util_js__WEBPACK_IMPORTED_MODULE_6__[\"pick\"])(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n              opts.xdomain = !!this.opts.xd;\n              opts.xscheme = !!this.opts.xs;\n              const xhr = this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__[\"XHR\"](opts);\n              try {\n                xhr.open(this.method, this.uri, this.async);\n                try {\n                  if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                      if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                        xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                      }\n                    }\n                  }\n                } catch (e) {\n                }\n                if (\"POST\" === this.method) {\n                  try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                  } catch (e) {\n                  }\n                }\n                try {\n                  xhr.setRequestHeader(\"Accept\", \"*/*\");\n                } catch (e) {\n                }\n                if (\"withCredentials\" in xhr) {\n                  xhr.withCredentials = this.opts.withCredentials;\n                }\n                if (this.opts.requestTimeout) {\n                  xhr.timeout = this.opts.requestTimeout;\n                }\n                xhr.onreadystatechange = () => {\n                  if (4 !== xhr.readyState)\n                    return;\n                  if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                  } else {\n                    this.setTimeoutFn(() => {\n                      this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                  }\n                };\n                xhr.send(this.data);\n              } catch (e) {\n                this.setTimeoutFn(() => {\n                  this.onError(e);\n                }, 0);\n                return;\n              }\n              if (typeof document !== \"undefined\") {\n                this.index = Request.requestsCount++;\n                Request.requests[this.index] = this;\n              }\n            }\n            /**\n             * Called upon error.\n             *\n             * @private\n             */\n            onError(err) {\n              this.emitReserved(\"error\", err, this.xhr);\n              this.cleanup(true);\n            }\n            /**\n             * Cleans up house.\n             *\n             * @private\n             */\n            cleanup(fromError) {\n              if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n                return;\n              }\n              this.xhr.onreadystatechange = empty;\n              if (fromError) {\n                try {\n                  this.xhr.abort();\n                } catch (e) {\n                }\n              }\n              if (typeof document !== \"undefined\") {\n                delete Request.requests[this.index];\n              }\n              this.xhr = null;\n            }\n            /**\n             * Called upon load.\n             *\n             * @private\n             */\n            onLoad() {\n              const data = this.xhr.responseText;\n              if (data !== null) {\n                this.emitReserved(\"data\", data);\n                this.emitReserved(\"success\");\n                this.cleanup();\n              }\n            }\n            /**\n             * Aborts the request.\n             *\n             * @package\n             */\n            abort() {\n              this.cleanup();\n            }\n          }\n          Request.requestsCount = 0;\n          Request.requests = {};\n          if (typeof document !== \"undefined\") {\n            if (typeof attachEvent === \"function\") {\n              attachEvent(\"onunload\", unloadHandler);\n            } else if (typeof addEventListener === \"function\") {\n              const terminationEvent = \"onpagehide\" in _globalThis_js__WEBPACK_IMPORTED_MODULE_7__[\"globalThisShim\"] ? \"pagehide\" : \"unload\";\n              addEventListener(terminationEvent, unloadHandler, false);\n            }\n          }\n          function unloadHandler() {\n            for (let i in Request.requests) {\n              if (Request.requests.hasOwnProperty(i)) {\n                Request.requests[i].abort();\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\": (\n        /*!*********************************************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js ***!\n          \\*********************************************************************************************/\n        /*! exports provided: nextTick, WebSocket, usingBrowserWebSocket, defaultBinaryType */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"nextTick\", function() {\n            return nextTick;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"WebSocket\", function() {\n            return WebSocket;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"usingBrowserWebSocket\", function() {\n            return usingBrowserWebSocket;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"defaultBinaryType\", function() {\n            return defaultBinaryType;\n          });\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ../globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          const nextTick = (() => {\n            const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n            if (isPromiseAvailable) {\n              return (cb) => Promise.resolve().then(cb);\n            } else {\n              return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n            }\n          })();\n          const WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].MozWebSocket;\n          const usingBrowserWebSocket = true;\n          const defaultBinaryType = \"arraybuffer\";\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/websocket.js\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/websocket.js ***!\n          \\*************************************************************************/\n        /*! exports provided: WS */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          (function(Buffer) {\n            __webpack_require__2.d(__webpack_exports__2, \"WS\", function() {\n              return WS;\n            });\n            var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n              /*! ../transport.js */\n              \"./node_modules/engine.io-client/build/esm/transport.js\"\n            );\n            var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n              /*! ../contrib/parseqs.js */\n              \"./node_modules/engine.io-client/build/esm/contrib/parseqs.js\"\n            );\n            var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n              /*! ../contrib/yeast.js */\n              \"./node_modules/engine.io-client/build/esm/contrib/yeast.js\"\n            );\n            var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n              /*! ../util.js */\n              \"./node_modules/engine.io-client/build/esm/util.js\"\n            );\n            var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n              /*! ./websocket-constructor.js */\n              \"./node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\"\n            );\n            var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n              /*! engine.io-parser */\n              \"./node_modules/engine.io-parser/build/esm/index.js\"\n            );\n            const isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\n            class WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__[\"Transport\"] {\n              /**\n               * WebSocket transport constructor.\n               *\n               * @param {Object} opts - connection options\n               * @protected\n               */\n              constructor(opts) {\n                super(opts);\n                this.supportsBinary = !opts.forceBase64;\n              }\n              get name() {\n                return \"websocket\";\n              }\n              doOpen() {\n                if (!this.check()) {\n                  return;\n                }\n                const uri = this.uri();\n                const protocols = this.opts.protocols;\n                const opts = isReactNative ? {} : Object(_util_js__WEBPACK_IMPORTED_MODULE_3__[\"pick\"])(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n                if (this.opts.extraHeaders) {\n                  opts.headers = this.opts.extraHeaders;\n                }\n                try {\n                  this.ws = _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"] && !isReactNative ? protocols ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri, protocols) : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri) : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"](uri, protocols, opts);\n                } catch (err) {\n                  return this.emitReserved(\"error\", err);\n                }\n                this.ws.binaryType = this.socket.binaryType || _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"defaultBinaryType\"];\n                this.addEventListeners();\n              }\n              /**\n               * Adds event listeners to the socket\n               *\n               * @private\n               */\n              addEventListeners() {\n                this.ws.onopen = () => {\n                  if (this.opts.autoUnref) {\n                    this.ws._socket.unref();\n                  }\n                  this.onOpen();\n                };\n                this.ws.onclose = (closeEvent) => this.onClose({\n                  description: \"websocket connection closed\",\n                  context: closeEvent\n                });\n                this.ws.onmessage = (ev) => this.onData(ev.data);\n                this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n              }\n              write(packets) {\n                this.writable = false;\n                for (let i = 0; i < packets.length; i++) {\n                  const packet = packets[i];\n                  const lastPacket = i === packets.length - 1;\n                  Object(engine_io_parser__WEBPACK_IMPORTED_MODULE_5__[\"encodePacket\"])(packet, this.supportsBinary, (data) => {\n                    const opts = {};\n                    if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"]) {\n                      if (packet.options) {\n                        opts.compress = packet.options.compress;\n                      }\n                      if (this.opts.perMessageDeflate) {\n                        const len = (\n                          // @ts-ignore\n                          \"string\" === typeof data ? Buffer.byteLength(data) : data.length\n                        );\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                          opts.compress = false;\n                        }\n                      }\n                    }\n                    try {\n                      if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"usingBrowserWebSocket\"]) {\n                        this.ws.send(data);\n                      } else {\n                        this.ws.send(data, opts);\n                      }\n                    } catch (e) {\n                    }\n                    if (lastPacket) {\n                      Object(_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"nextTick\"])(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                      }, this.setTimeoutFn);\n                    }\n                  });\n                }\n              }\n              doClose() {\n                if (typeof this.ws !== \"undefined\") {\n                  this.ws.close();\n                  this.ws = null;\n                }\n              }\n              /**\n               * Generates uri for connection.\n               *\n               * @private\n               */\n              uri() {\n                let query = this.query || {};\n                const schema = this.opts.secure ? \"wss\" : \"ws\";\n                let port = \"\";\n                if (this.opts.port && (\"wss\" === schema && Number(this.opts.port) !== 443 || \"ws\" === schema && Number(this.opts.port) !== 80)) {\n                  port = \":\" + this.opts.port;\n                }\n                if (this.opts.timestampRequests) {\n                  query[this.opts.timestampParam] = Object(_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__[\"yeast\"])();\n                }\n                if (!this.supportsBinary) {\n                  query.b64 = 1;\n                }\n                const encodedQuery = Object(_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__[\"encode\"])(query);\n                const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n                return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? \"?\" + encodedQuery : \"\");\n              }\n              /**\n               * Feature detection for WebSocket.\n               *\n               * @return {Boolean} whether this transport is available.\n               * @private\n               */\n              check() {\n                return !!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__[\"WebSocket\"];\n              }\n            }\n          }).call(this, __webpack_require__2(\n            /*! ./../../../../buffer/index.js */\n            \"./node_modules/buffer/index.js\"\n          ).Buffer);\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\": (\n        /*!**************************************************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js ***!\n          \\**************************************************************************************/\n        /*! exports provided: XHR */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"XHR\", function() {\n            return XHR;\n          });\n          var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ../contrib/has-cors.js */\n            \"./node_modules/engine.io-client/build/esm/contrib/has-cors.js\"\n          );\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ../globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          function XHR(opts) {\n            const xdomain = opts.xdomain;\n            try {\n              if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__[\"hasCORS\"])) {\n                return new XMLHttpRequest();\n              }\n            } catch (e) {\n            }\n            if (!xdomain) {\n              try {\n                return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__[\"globalThisShim\"][[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n              } catch (e) {\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-client/build/esm/util.js\": (\n        /*!*********************************************************!*\\\n          !*** ./node_modules/engine.io-client/build/esm/util.js ***!\n          \\*********************************************************/\n        /*! exports provided: pick, installTimerFunctions, byteLength */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"pick\", function() {\n            return pick;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"installTimerFunctions\", function() {\n            return installTimerFunctions;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"byteLength\", function() {\n            return byteLength;\n          });\n          var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./globalThis.js */\n            \"./node_modules/engine.io-client/build/esm/globalThis.browser.js\"\n          );\n          function pick(obj, ...attr) {\n            return attr.reduce((acc, k) => {\n              if (obj.hasOwnProperty(k)) {\n                acc[k] = obj[k];\n              }\n              return acc;\n            }, {});\n          }\n          const NATIVE_SET_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].setTimeout;\n          const NATIVE_CLEAR_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].clearTimeout;\n          function installTimerFunctions(obj, opts) {\n            if (opts.useNativeTimers) {\n              obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n              obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n            } else {\n              obj.setTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n              obj.clearTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"].clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__[\"globalThisShim\"]);\n            }\n          }\n          const BASE64_OVERHEAD = 1.33;\n          function byteLength(obj) {\n            if (typeof obj === \"string\") {\n              return utf8Length(obj);\n            }\n            return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n          }\n          function utf8Length(str) {\n            let c = 0, length = 0;\n            for (let i = 0, l = str.length; i < l; i++) {\n              c = str.charCodeAt(i);\n              if (c < 128) {\n                length += 1;\n              } else if (c < 2048) {\n                length += 2;\n              } else if (c < 55296 || c >= 57344) {\n                length += 3;\n              } else {\n                i++;\n                length += 4;\n              }\n            }\n            return length;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/commons.js\": (\n        /*!************************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/commons.js ***!\n          \\************************************************************/\n        /*! exports provided: PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"PACKET_TYPES\", function() {\n            return PACKET_TYPES;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"PACKET_TYPES_REVERSE\", function() {\n            return PACKET_TYPES_REVERSE;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"ERROR_PACKET\", function() {\n            return ERROR_PACKET;\n          });\n          const PACKET_TYPES = /* @__PURE__ */ Object.create(null);\n          PACKET_TYPES[\"open\"] = \"0\";\n          PACKET_TYPES[\"close\"] = \"1\";\n          PACKET_TYPES[\"ping\"] = \"2\";\n          PACKET_TYPES[\"pong\"] = \"3\";\n          PACKET_TYPES[\"message\"] = \"4\";\n          PACKET_TYPES[\"upgrade\"] = \"5\";\n          PACKET_TYPES[\"noop\"] = \"6\";\n          const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);\n          Object.keys(PACKET_TYPES).forEach((key) => {\n            PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n          });\n          const ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!\n          \\*************************************************************************/\n        /*! exports provided: default */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./commons.js */\n            \"./node_modules/engine.io-parser/build/esm/commons.js\"\n          );\n          var _socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! @socket.io/base64-arraybuffer */\n            \"./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js\"\n          );\n          const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n          const decodePacket = (encodedPacket, binaryType) => {\n            if (typeof encodedPacket !== \"string\") {\n              return {\n                type: \"message\",\n                data: mapBinary(encodedPacket, binaryType)\n              };\n            }\n            const type = encodedPacket.charAt(0);\n            if (type === \"b\") {\n              return {\n                type: \"message\",\n                data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n              };\n            }\n            const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type];\n            if (!packetType) {\n              return _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"ERROR_PACKET\"];\n            }\n            return encodedPacket.length > 1 ? {\n              type: _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type],\n              data: encodedPacket.substring(1)\n            } : {\n              type: _commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES_REVERSE\"][type]\n            };\n          };\n          const decodeBase64Packet = (data, binaryType) => {\n            if (withNativeArrayBuffer) {\n              const decoded = Object(_socket_io_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__[\"decode\"])(data);\n              return mapBinary(decoded, binaryType);\n            } else {\n              return { base64: true, data };\n            }\n          };\n          const mapBinary = (data, binaryType) => {\n            switch (binaryType) {\n              case \"blob\":\n                return data instanceof ArrayBuffer ? new Blob([data]) : data;\n              case \"arraybuffer\":\n              default:\n                return data;\n            }\n          };\n          __webpack_exports__2[\"default\"] = decodePacket;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\": (\n        /*!*************************************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!\n          \\*************************************************************************/\n        /*! exports provided: default */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./commons.js */\n            \"./node_modules/engine.io-parser/build/esm/commons.js\"\n          );\n          const withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\";\n          const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n          const isView = (obj) => {\n            return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;\n          };\n          const encodePacket = ({ type, data }, supportsBinary, callback) => {\n            if (withNativeBlob && data instanceof Blob) {\n              if (supportsBinary) {\n                return callback(data);\n              } else {\n                return encodeBlobAsBase64(data, callback);\n              }\n            } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {\n              if (supportsBinary) {\n                return callback(data);\n              } else {\n                return encodeBlobAsBase64(new Blob([data]), callback);\n              }\n            }\n            return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__[\"PACKET_TYPES\"][type] + (data || \"\"));\n          };\n          const encodeBlobAsBase64 = (data, callback) => {\n            const fileReader = new FileReader();\n            fileReader.onload = function() {\n              const content = fileReader.result.split(\",\")[1];\n              callback(\"b\" + content);\n            };\n            return fileReader.readAsDataURL(data);\n          };\n          __webpack_exports__2[\"default\"] = encodePacket;\n        }\n      ),\n      /***/\n      \"./node_modules/engine.io-parser/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/engine.io-parser/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: protocol, encodePacket, encodePayload, decodePacket, decodePayload */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return protocol;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"encodePayload\", function() {\n            return encodePayload;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"decodePayload\", function() {\n            return decodePayload;\n          });\n          var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./encodePacket.js */\n            \"./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"encodePacket\", function() {\n            return _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n          });\n          var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./decodePacket.js */\n            \"./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"decodePacket\", function() {\n            return _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n          });\n          const SEPARATOR = String.fromCharCode(30);\n          const encodePayload = (packets, callback) => {\n            const length = packets.length;\n            const encodedPackets = new Array(length);\n            let count = 0;\n            packets.forEach((packet, i) => {\n              Object(_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(packet, false, (encodedPacket) => {\n                encodedPackets[i] = encodedPacket;\n                if (++count === length) {\n                  callback(encodedPackets.join(SEPARATOR));\n                }\n              });\n            });\n          };\n          const decodePayload = (encodedPayload, binaryType) => {\n            const encodedPackets = encodedPayload.split(SEPARATOR);\n            const packets = [];\n            for (let i = 0; i < encodedPackets.length; i++) {\n              const decodedPacket = Object(_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(encodedPackets[i], binaryType);\n              packets.push(decodedPacket);\n              if (decodedPacket.type === \"error\") {\n                break;\n              }\n            }\n            return packets;\n          };\n          const protocol = 4;\n        }\n      ),\n      /***/\n      \"./node_modules/ieee754/index.js\": (\n        /*!***************************************!*\\\n          !*** ./node_modules/ieee754/index.js ***!\n          \\***************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2) {\n          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n          exports2.read = function(buffer, offset, isLE, mLen, nBytes) {\n            var e, m;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var nBits = -7;\n            var i = isLE ? nBytes - 1 : 0;\n            var d = isLE ? -1 : 1;\n            var s = buffer[offset + i];\n            i += d;\n            e = s & (1 << -nBits) - 1;\n            s >>= -nBits;\n            nBits += eLen;\n            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n            }\n            m = e & (1 << -nBits) - 1;\n            e >>= -nBits;\n            nBits += mLen;\n            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n            }\n            if (e === 0) {\n              e = 1 - eBias;\n            } else if (e === eMax) {\n              return m ? NaN : (s ? -1 : 1) * Infinity;\n            } else {\n              m = m + Math.pow(2, mLen);\n              e = e - eBias;\n            }\n            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n          };\n          exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n            var e, m, c;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n            var i = isLE ? 0 : nBytes - 1;\n            var d = isLE ? 1 : -1;\n            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n            value = Math.abs(value);\n            if (isNaN(value) || value === Infinity) {\n              m = isNaN(value) ? 1 : 0;\n              e = eMax;\n            } else {\n              e = Math.floor(Math.log(value) / Math.LN2);\n              if (value * (c = Math.pow(2, -e)) < 1) {\n                e--;\n                c *= 2;\n              }\n              if (e + eBias >= 1) {\n                value += rt / c;\n              } else {\n                value += rt * Math.pow(2, 1 - eBias);\n              }\n              if (value * c >= 2) {\n                e++;\n                c /= 2;\n              }\n              if (e + eBias >= eMax) {\n                m = 0;\n                e = eMax;\n              } else if (e + eBias >= 1) {\n                m = (value * c - 1) * Math.pow(2, mLen);\n                e = e + eBias;\n              } else {\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n                e = 0;\n              }\n            }\n            for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n            }\n            e = e << mLen | m;\n            eLen += mLen;\n            for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n            }\n            buffer[offset + i - d] |= s * 128;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/isarray/index.js\": (\n        /*!***************************************!*\\\n          !*** ./node_modules/isarray/index.js ***!\n          \\***************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2) {\n          var toString = {}.toString;\n          module2.exports = Array.isArray || function(arr) {\n            return toString.call(arr) == \"[object Array]\";\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/contrib/backo2.js\": (\n        /*!*******************************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/contrib/backo2.js ***!\n          \\*******************************************************************/\n        /*! exports provided: Backoff */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Backoff\", function() {\n            return Backoff;\n          });\n          function Backoff(opts) {\n            opts = opts || {};\n            this.ms = opts.min || 100;\n            this.max = opts.max || 1e4;\n            this.factor = opts.factor || 2;\n            this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n            this.attempts = 0;\n          }\n          Backoff.prototype.duration = function() {\n            var ms = this.ms * Math.pow(this.factor, this.attempts++);\n            if (this.jitter) {\n              var rand = Math.random();\n              var deviation = Math.floor(rand * this.jitter * ms);\n              ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n            }\n            return Math.min(ms, this.max) | 0;\n          };\n          Backoff.prototype.reset = function() {\n            this.attempts = 0;\n          };\n          Backoff.prototype.setMin = function(min) {\n            this.ms = min;\n          };\n          Backoff.prototype.setMax = function(max) {\n            this.max = max;\n          };\n          Backoff.prototype.setJitter = function(jitter) {\n            this.jitter = jitter;\n          };\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: protocol, Manager, Socket, io, connect, default */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"io\", function() {\n            return lookup;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"connect\", function() {\n            return lookup;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"default\", function() {\n            return lookup;\n          });\n          var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./url.js */\n            \"./node_modules/socket.io-client/build/esm/url.js\"\n          );\n          var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./manager.js */\n            \"./node_modules/socket.io-client/build/esm/manager.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Manager\", function() {\n            return _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"];\n          });\n          var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./socket.js */\n            \"./node_modules/socket.io-client/build/esm/socket.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"];\n          });\n          var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! socket.io-parser */\n            \"./node_modules/socket.io-parser/build/esm/index.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return socket_io_parser__WEBPACK_IMPORTED_MODULE_3__[\"protocol\"];\n          });\n          const cache = {};\n          function lookup(uri, opts) {\n            if (typeof uri === \"object\") {\n              opts = uri;\n              uri = void 0;\n            }\n            opts = opts || {};\n            const parsed = Object(_url_js__WEBPACK_IMPORTED_MODULE_0__[\"url\"])(uri, opts.path || \"/socket.io\");\n            const source = parsed.source;\n            const id = parsed.id;\n            const path = parsed.path;\n            const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n            const newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n            let io;\n            if (newConnection) {\n              io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"](source, opts);\n            } else {\n              if (!cache[id]) {\n                cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"](source, opts);\n              }\n              io = cache[id];\n            }\n            if (parsed.query && !opts.query) {\n              opts.query = parsed.queryKey;\n            }\n            return io.socket(parsed.path, opts);\n          }\n          Object.assign(lookup, {\n            Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__[\"Manager\"],\n            Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"],\n            io: lookup,\n            connect: lookup\n          });\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/manager.js\": (\n        /*!************************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/manager.js ***!\n          \\************************************************************/\n        /*! exports provided: Manager */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Manager\", function() {\n            return Manager;\n          });\n          var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! engine.io-client */\n            \"./node_modules/engine.io-client/build/esm/index.js\"\n          );\n          var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./socket.js */\n            \"./node_modules/socket.io-client/build/esm/socket.js\"\n          );\n          var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! socket.io-parser */\n            \"./node_modules/socket.io-parser/build/esm/index.js\"\n          );\n          var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./on.js */\n            \"./node_modules/socket.io-client/build/esm/on.js\"\n          );\n          var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./contrib/backo2.js */\n            \"./node_modules/socket.io-client/build/esm/contrib/backo2.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          class Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__[\"Emitter\"] {\n            constructor(uri, opts) {\n              var _a;\n              super();\n              this.nsps = {};\n              this.subs = [];\n              if (uri && \"object\" === typeof uri) {\n                opts = uri;\n                uri = void 0;\n              }\n              opts = opts || {};\n              opts.path = opts.path || \"/socket.io\";\n              this.opts = opts;\n              Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"installTimerFunctions\"])(this, opts);\n              this.reconnection(opts.reconnection !== false);\n              this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n              this.reconnectionDelay(opts.reconnectionDelay || 1e3);\n              this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);\n              this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n              this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__[\"Backoff\"]({\n                min: this.reconnectionDelay(),\n                max: this.reconnectionDelayMax(),\n                jitter: this.randomizationFactor()\n              });\n              this.timeout(null == opts.timeout ? 2e4 : opts.timeout);\n              this._readyState = \"closed\";\n              this.uri = uri;\n              const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;\n              this.encoder = new _parser.Encoder();\n              this.decoder = new _parser.Decoder();\n              this._autoConnect = opts.autoConnect !== false;\n              if (this._autoConnect)\n                this.open();\n            }\n            reconnection(v) {\n              if (!arguments.length)\n                return this._reconnection;\n              this._reconnection = !!v;\n              return this;\n            }\n            reconnectionAttempts(v) {\n              if (v === void 0)\n                return this._reconnectionAttempts;\n              this._reconnectionAttempts = v;\n              return this;\n            }\n            reconnectionDelay(v) {\n              var _a;\n              if (v === void 0)\n                return this._reconnectionDelay;\n              this._reconnectionDelay = v;\n              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n              return this;\n            }\n            randomizationFactor(v) {\n              var _a;\n              if (v === void 0)\n                return this._randomizationFactor;\n              this._randomizationFactor = v;\n              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n              return this;\n            }\n            reconnectionDelayMax(v) {\n              var _a;\n              if (v === void 0)\n                return this._reconnectionDelayMax;\n              this._reconnectionDelayMax = v;\n              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n              return this;\n            }\n            timeout(v) {\n              if (!arguments.length)\n                return this._timeout;\n              this._timeout = v;\n              return this;\n            }\n            /**\n             * Starts trying to reconnect if reconnection is enabled and we have not\n             * started reconnecting yet\n             *\n             * @private\n             */\n            maybeReconnectOnOpen() {\n              if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n                this.reconnect();\n              }\n            }\n            /**\n             * Sets the current transport `socket`.\n             *\n             * @param {Function} fn - optional, callback\n             * @return self\n             * @public\n             */\n            open(fn) {\n              if (~this._readyState.indexOf(\"open\"))\n                return this;\n              this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"Socket\"](this.uri, this.opts);\n              const socket = this.engine;\n              const self2 = this;\n              this._readyState = \"opening\";\n              this.skipReconnect = false;\n              const openSubDestroy = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"open\", function() {\n                self2.onopen();\n                fn && fn();\n              });\n              const errorSub = Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"error\", (err) => {\n                self2.cleanup();\n                self2._readyState = \"closed\";\n                this.emitReserved(\"error\", err);\n                if (fn) {\n                  fn(err);\n                } else {\n                  self2.maybeReconnectOnOpen();\n                }\n              });\n              if (false !== this._timeout) {\n                const timeout = this._timeout;\n                if (timeout === 0) {\n                  openSubDestroy();\n                }\n                const timer = this.setTimeoutFn(() => {\n                  openSubDestroy();\n                  socket.close();\n                  socket.emit(\"error\", new Error(\"timeout\"));\n                }, timeout);\n                if (this.opts.autoUnref) {\n                  timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                  clearTimeout(timer);\n                });\n              }\n              this.subs.push(openSubDestroy);\n              this.subs.push(errorSub);\n              return this;\n            }\n            /**\n             * Alias for open()\n             *\n             * @return self\n             * @public\n             */\n            connect(fn) {\n              return this.open(fn);\n            }\n            /**\n             * Called upon transport open.\n             *\n             * @private\n             */\n            onopen() {\n              this.cleanup();\n              this._readyState = \"open\";\n              this.emitReserved(\"open\");\n              const socket = this.engine;\n              this.subs.push(Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"ping\", this.onping.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"data\", this.ondata.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"error\", this.onerror.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(socket, \"close\", this.onclose.bind(this)), Object(_on_js__WEBPACK_IMPORTED_MODULE_3__[\"on\"])(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n            }\n            /**\n             * Called upon a ping.\n             *\n             * @private\n             */\n            onping() {\n              this.emitReserved(\"ping\");\n            }\n            /**\n             * Called with data.\n             *\n             * @private\n             */\n            ondata(data) {\n              try {\n                this.decoder.add(data);\n              } catch (e) {\n                this.onclose(\"parse error\", e);\n              }\n            }\n            /**\n             * Called when parser fully decodes a packet.\n             *\n             * @private\n             */\n            ondecoded(packet) {\n              Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"nextTick\"])(() => {\n                this.emitReserved(\"packet\", packet);\n              }, this.setTimeoutFn);\n            }\n            /**\n             * Called upon socket error.\n             *\n             * @private\n             */\n            onerror(err) {\n              this.emitReserved(\"error\", err);\n            }\n            /**\n             * Creates a new socket for the given `nsp`.\n             *\n             * @return {Socket}\n             * @public\n             */\n            socket(nsp, opts) {\n              let socket = this.nsps[nsp];\n              if (!socket) {\n                socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__[\"Socket\"](this, nsp, opts);\n                this.nsps[nsp] = socket;\n              } else if (this._autoConnect && !socket.active) {\n                socket.connect();\n              }\n              return socket;\n            }\n            /**\n             * Called upon a socket close.\n             *\n             * @param socket\n             * @private\n             */\n            _destroy(socket) {\n              const nsps = Object.keys(this.nsps);\n              for (const nsp of nsps) {\n                const socket2 = this.nsps[nsp];\n                if (socket2.active) {\n                  return;\n                }\n              }\n              this._close();\n            }\n            /**\n             * Writes a packet.\n             *\n             * @param packet\n             * @private\n             */\n            _packet(packet) {\n              const encodedPackets = this.encoder.encode(packet);\n              for (let i = 0; i < encodedPackets.length; i++) {\n                this.engine.write(encodedPackets[i], packet.options);\n              }\n            }\n            /**\n             * Clean up transport subscriptions and packet buffer.\n             *\n             * @private\n             */\n            cleanup() {\n              this.subs.forEach((subDestroy) => subDestroy());\n              this.subs.length = 0;\n              this.decoder.destroy();\n            }\n            /**\n             * Close the current socket.\n             *\n             * @private\n             */\n            _close() {\n              this.skipReconnect = true;\n              this._reconnecting = false;\n              this.onclose(\"forced close\");\n              if (this.engine)\n                this.engine.close();\n            }\n            /**\n             * Alias for close()\n             *\n             * @private\n             */\n            disconnect() {\n              return this._close();\n            }\n            /**\n             * Called upon engine close.\n             *\n             * @private\n             */\n            onclose(reason, description) {\n              this.cleanup();\n              this.backoff.reset();\n              this._readyState = \"closed\";\n              this.emitReserved(\"close\", reason, description);\n              if (this._reconnection && !this.skipReconnect) {\n                this.reconnect();\n              }\n            }\n            /**\n             * Attempt a reconnection.\n             *\n             * @private\n             */\n            reconnect() {\n              if (this._reconnecting || this.skipReconnect)\n                return this;\n              const self2 = this;\n              if (this.backoff.attempts >= this._reconnectionAttempts) {\n                this.backoff.reset();\n                this.emitReserved(\"reconnect_failed\");\n                this._reconnecting = false;\n              } else {\n                const delay = this.backoff.duration();\n                this._reconnecting = true;\n                const timer = this.setTimeoutFn(() => {\n                  if (self2.skipReconnect)\n                    return;\n                  this.emitReserved(\"reconnect_attempt\", self2.backoff.attempts);\n                  if (self2.skipReconnect)\n                    return;\n                  self2.open((err) => {\n                    if (err) {\n                      self2._reconnecting = false;\n                      self2.reconnect();\n                      this.emitReserved(\"reconnect_error\", err);\n                    } else {\n                      self2.onreconnect();\n                    }\n                  });\n                }, delay);\n                if (this.opts.autoUnref) {\n                  timer.unref();\n                }\n                this.subs.push(function subDestroy() {\n                  clearTimeout(timer);\n                });\n              }\n            }\n            /**\n             * Called upon successful reconnect.\n             *\n             * @private\n             */\n            onreconnect() {\n              const attempt = this.backoff.attempts;\n              this._reconnecting = false;\n              this.backoff.reset();\n              this.emitReserved(\"reconnect\", attempt);\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/on.js\": (\n        /*!*******************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/on.js ***!\n          \\*******************************************************/\n        /*! exports provided: on */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"on\", function() {\n            return on;\n          });\n          function on(obj, ev, fn) {\n            obj.on(ev, fn);\n            return function subDestroy() {\n              obj.off(ev, fn);\n            };\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/socket.js\": (\n        /*!***********************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/socket.js ***!\n          \\***********************************************************/\n        /*! exports provided: Socket */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Socket\", function() {\n            return Socket;\n          });\n          var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! socket.io-parser */\n            \"./node_modules/socket.io-parser/build/esm/index.js\"\n          );\n          var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./on.js */\n            \"./node_modules/socket.io-client/build/esm/on.js\"\n          );\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          const RESERVED_EVENTS = Object.freeze({\n            connect: 1,\n            connect_error: 1,\n            disconnect: 1,\n            disconnecting: 1,\n            // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n            newListener: 1,\n            removeListener: 1\n          });\n          class Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__[\"Emitter\"] {\n            /**\n             * `Socket` constructor.\n             */\n            constructor(io, nsp, opts) {\n              super();\n              this.connected = false;\n              this.recovered = false;\n              this.receiveBuffer = [];\n              this.sendBuffer = [];\n              this._queue = [];\n              this._queueSeq = 0;\n              this.ids = 0;\n              this.acks = {};\n              this.flags = {};\n              this.io = io;\n              this.nsp = nsp;\n              if (opts && opts.auth) {\n                this.auth = opts.auth;\n              }\n              this._opts = Object.assign({}, opts);\n              if (this.io._autoConnect)\n                this.open();\n            }\n            /**\n             * Whether the socket is currently disconnected\n             *\n             * @example\n             * const socket = io();\n             *\n             * socket.on(\"connect\", () => {\n             *   console.log(socket.disconnected); // false\n             * });\n             *\n             * socket.on(\"disconnect\", () => {\n             *   console.log(socket.disconnected); // true\n             * });\n             */\n            get disconnected() {\n              return !this.connected;\n            }\n            /**\n             * Subscribe to open, close and packet events\n             *\n             * @private\n             */\n            subEvents() {\n              if (this.subs)\n                return;\n              const io = this.io;\n              this.subs = [\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"open\", this.onopen.bind(this)),\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"packet\", this.onpacket.bind(this)),\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"error\", this.onerror.bind(this)),\n                Object(_on_js__WEBPACK_IMPORTED_MODULE_1__[\"on\"])(io, \"close\", this.onclose.bind(this))\n              ];\n            }\n            /**\n             * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n             *\n             * @example\n             * const socket = io();\n             *\n             * console.log(socket.active); // true\n             *\n             * socket.on(\"disconnect\", (reason) => {\n             *   if (reason === \"io server disconnect\") {\n             *     // the disconnection was initiated by the server, you need to manually reconnect\n             *     console.log(socket.active); // false\n             *   }\n             *   // else the socket will automatically try to reconnect\n             *   console.log(socket.active); // true\n             * });\n             */\n            get active() {\n              return !!this.subs;\n            }\n            /**\n             * \"Opens\" the socket.\n             *\n             * @example\n             * const socket = io({\n             *   autoConnect: false\n             * });\n             *\n             * socket.connect();\n             */\n            connect() {\n              if (this.connected)\n                return this;\n              this.subEvents();\n              if (!this.io[\"_reconnecting\"])\n                this.io.open();\n              if (\"open\" === this.io._readyState)\n                this.onopen();\n              return this;\n            }\n            /**\n             * Alias for {@link connect()}.\n             */\n            open() {\n              return this.connect();\n            }\n            /**\n             * Sends a `message` event.\n             *\n             * This method mimics the WebSocket.send() method.\n             *\n             * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n             *\n             * @example\n             * socket.send(\"hello\");\n             *\n             * // this is equivalent to\n             * socket.emit(\"message\", \"hello\");\n             *\n             * @return self\n             */\n            send(...args) {\n              args.unshift(\"message\");\n              this.emit.apply(this, args);\n              return this;\n            }\n            /**\n             * Override `emit`.\n             * If the event is in `events`, it's emitted normally.\n             *\n             * @example\n             * socket.emit(\"hello\", \"world\");\n             *\n             * // all serializable datastructures are supported (no need to call JSON.stringify)\n             * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n             *\n             * // with an acknowledgement from the server\n             * socket.emit(\"hello\", \"world\", (val) => {\n             *   // ...\n             * });\n             *\n             * @return self\n             */\n            emit(ev, ...args) {\n              if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n                throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n              }\n              args.unshift(ev);\n              if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n                this._addToQueue(args);\n                return this;\n              }\n              const packet = {\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].EVENT,\n                data: args\n              };\n              packet.options = {};\n              packet.options.compress = this.flags.compress !== false;\n              if (\"function\" === typeof args[args.length - 1]) {\n                const id = this.ids++;\n                const ack = args.pop();\n                this._registerAckCallback(id, ack);\n                packet.id = id;\n              }\n              const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n              const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n              if (discardPacket) {\n              } else if (this.connected) {\n                this.notifyOutgoingListeners(packet);\n                this.packet(packet);\n              } else {\n                this.sendBuffer.push(packet);\n              }\n              this.flags = {};\n              return this;\n            }\n            /**\n             * @private\n             */\n            _registerAckCallback(id, ack) {\n              var _a;\n              const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n              if (timeout === void 0) {\n                this.acks[id] = ack;\n                return;\n              }\n              const timer = this.io.setTimeoutFn(() => {\n                delete this.acks[id];\n                for (let i = 0; i < this.sendBuffer.length; i++) {\n                  if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                  }\n                }\n                ack.call(this, new Error(\"operation has timed out\"));\n              }, timeout);\n              this.acks[id] = (...args) => {\n                this.io.clearTimeoutFn(timer);\n                ack.apply(this, [null, ...args]);\n              };\n            }\n            /**\n             * Emits an event and waits for an acknowledgement\n             *\n             * @example\n             * // without timeout\n             * const response = await socket.emitWithAck(\"hello\", \"world\");\n             *\n             * // with a specific timeout\n             * try {\n             *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n             * } catch (err) {\n             *   // the server did not acknowledge the event in the given delay\n             * }\n             *\n             * @return a Promise that will be fulfilled when the server acknowledges the event\n             */\n            emitWithAck(ev, ...args) {\n              const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;\n              return new Promise((resolve, reject) => {\n                args.push((arg1, arg2) => {\n                  if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                  } else {\n                    return resolve(arg1);\n                  }\n                });\n                this.emit(ev, ...args);\n              });\n            }\n            /**\n             * Add the packet to the queue.\n             * @param args\n             * @private\n             */\n            _addToQueue(args) {\n              let ack;\n              if (typeof args[args.length - 1] === \"function\") {\n                ack = args.pop();\n              }\n              const packet = {\n                id: this._queueSeq++,\n                tryCount: 0,\n                pending: false,\n                args,\n                flags: Object.assign({ fromQueue: true }, this.flags)\n              };\n              args.push((err, ...responseArgs) => {\n                if (packet !== this._queue[0]) {\n                  return;\n                }\n                const hasError = err !== null;\n                if (hasError) {\n                  if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                      ack(err);\n                    }\n                  }\n                } else {\n                  this._queue.shift();\n                  if (ack) {\n                    ack(null, ...responseArgs);\n                  }\n                }\n                packet.pending = false;\n                return this._drainQueue();\n              });\n              this._queue.push(packet);\n              this._drainQueue();\n            }\n            /**\n             * Send the first packet of the queue, and wait for an acknowledgement from the server.\n             * @param force - whether to resend a packet that has not been acknowledged yet\n             *\n             * @private\n             */\n            _drainQueue(force = false) {\n              if (!this.connected || this._queue.length === 0) {\n                return;\n              }\n              const packet = this._queue[0];\n              if (packet.pending && !force) {\n                return;\n              }\n              packet.pending = true;\n              packet.tryCount++;\n              this.flags = packet.flags;\n              this.emit.apply(this, packet.args);\n            }\n            /**\n             * Sends a packet.\n             *\n             * @param packet\n             * @private\n             */\n            packet(packet) {\n              packet.nsp = this.nsp;\n              this.io._packet(packet);\n            }\n            /**\n             * Called upon engine `open`.\n             *\n             * @private\n             */\n            onopen() {\n              if (typeof this.auth == \"function\") {\n                this.auth((data) => {\n                  this._sendConnectPacket(data);\n                });\n              } else {\n                this._sendConnectPacket(this.auth);\n              }\n            }\n            /**\n             * Sends a CONNECT packet to initiate the Socket.IO session.\n             *\n             * @param data\n             * @private\n             */\n            _sendConnectPacket(data) {\n              this.packet({\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT,\n                data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data\n              });\n            }\n            /**\n             * Called upon engine or manager `error`.\n             *\n             * @param err\n             * @private\n             */\n            onerror(err) {\n              if (!this.connected) {\n                this.emitReserved(\"connect_error\", err);\n              }\n            }\n            /**\n             * Called upon engine `close`.\n             *\n             * @param reason\n             * @param description\n             * @private\n             */\n            onclose(reason, description) {\n              this.connected = false;\n              delete this.id;\n              this.emitReserved(\"disconnect\", reason, description);\n            }\n            /**\n             * Called with socket packet.\n             *\n             * @param packet\n             * @private\n             */\n            onpacket(packet) {\n              const sameNamespace = packet.nsp === this.nsp;\n              if (!sameNamespace)\n                return;\n              switch (packet.type) {\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT:\n                  if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                  } else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                  }\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].EVENT:\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].BINARY_EVENT:\n                  this.onevent(packet);\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].ACK:\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].BINARY_ACK:\n                  this.onack(packet);\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].DISCONNECT:\n                  this.ondisconnect();\n                  break;\n                case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].CONNECT_ERROR:\n                  this.destroy();\n                  const err = new Error(packet.data.message);\n                  err.data = packet.data.data;\n                  this.emitReserved(\"connect_error\", err);\n                  break;\n              }\n            }\n            /**\n             * Called upon a server event.\n             *\n             * @param packet\n             * @private\n             */\n            onevent(packet) {\n              const args = packet.data || [];\n              if (null != packet.id) {\n                args.push(this.ack(packet.id));\n              }\n              if (this.connected) {\n                this.emitEvent(args);\n              } else {\n                this.receiveBuffer.push(Object.freeze(args));\n              }\n            }\n            emitEvent(args) {\n              if (this._anyListeners && this._anyListeners.length) {\n                const listeners = this._anyListeners.slice();\n                for (const listener of listeners) {\n                  listener.apply(this, args);\n                }\n              }\n              super.emit.apply(this, args);\n              if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n                this._lastOffset = args[args.length - 1];\n              }\n            }\n            /**\n             * Produces an ack callback to emit with an event.\n             *\n             * @private\n             */\n            ack(id) {\n              const self2 = this;\n              let sent = false;\n              return function(...args) {\n                if (sent)\n                  return;\n                sent = true;\n                self2.packet({\n                  type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].ACK,\n                  id,\n                  data: args\n                });\n              };\n            }\n            /**\n             * Called upon a server acknowlegement.\n             *\n             * @param packet\n             * @private\n             */\n            onack(packet) {\n              const ack = this.acks[packet.id];\n              if (\"function\" === typeof ack) {\n                ack.apply(this, packet.data);\n                delete this.acks[packet.id];\n              } else {\n              }\n            }\n            /**\n             * Called upon server connect.\n             *\n             * @private\n             */\n            onconnect(id, pid) {\n              this.id = id;\n              this.recovered = pid && this._pid === pid;\n              this._pid = pid;\n              this.connected = true;\n              this.emitBuffered();\n              this.emitReserved(\"connect\");\n              this._drainQueue(true);\n            }\n            /**\n             * Emit buffered events (received and emitted).\n             *\n             * @private\n             */\n            emitBuffered() {\n              this.receiveBuffer.forEach((args) => this.emitEvent(args));\n              this.receiveBuffer = [];\n              this.sendBuffer.forEach((packet) => {\n                this.notifyOutgoingListeners(packet);\n                this.packet(packet);\n              });\n              this.sendBuffer = [];\n            }\n            /**\n             * Called upon server disconnect.\n             *\n             * @private\n             */\n            ondisconnect() {\n              this.destroy();\n              this.onclose(\"io server disconnect\");\n            }\n            /**\n             * Called upon forced client/server side disconnections,\n             * this method ensures the manager stops tracking us and\n             * that reconnections don't get triggered for this.\n             *\n             * @private\n             */\n            destroy() {\n              if (this.subs) {\n                this.subs.forEach((subDestroy) => subDestroy());\n                this.subs = void 0;\n              }\n              this.io[\"_destroy\"](this);\n            }\n            /**\n             * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n             *\n             * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n             *\n             * @example\n             * const socket = io();\n             *\n             * socket.on(\"disconnect\", (reason) => {\n             *   // console.log(reason); prints \"io client disconnect\"\n             * });\n             *\n             * socket.disconnect();\n             *\n             * @return self\n             */\n            disconnect() {\n              if (this.connected) {\n                this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__[\"PacketType\"].DISCONNECT });\n              }\n              this.destroy();\n              if (this.connected) {\n                this.onclose(\"io client disconnect\");\n              }\n              return this;\n            }\n            /**\n             * Alias for {@link disconnect()}.\n             *\n             * @return self\n             */\n            close() {\n              return this.disconnect();\n            }\n            /**\n             * Sets the compress flag.\n             *\n             * @example\n             * socket.compress(false).emit(\"hello\");\n             *\n             * @param compress - if `true`, compresses the sending data\n             * @return self\n             */\n            compress(compress) {\n              this.flags.compress = compress;\n              return this;\n            }\n            /**\n             * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n             * ready to send messages.\n             *\n             * @example\n             * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n             *\n             * @returns self\n             */\n            get volatile() {\n              this.flags.volatile = true;\n              return this;\n            }\n            /**\n             * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n             * given number of milliseconds have elapsed without an acknowledgement from the server:\n             *\n             * @example\n             * socket.timeout(5000).emit(\"my-event\", (err) => {\n             *   if (err) {\n             *     // the server did not acknowledge the event in the given delay\n             *   }\n             * });\n             *\n             * @returns self\n             */\n            timeout(timeout) {\n              this.flags.timeout = timeout;\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback.\n             *\n             * @example\n             * socket.onAny((event, ...args) => {\n             *   console.log(`got ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            onAny(listener) {\n              this._anyListeners = this._anyListeners || [];\n              this._anyListeners.push(listener);\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback. The listener is added to the beginning of the listeners array.\n             *\n             * @example\n             * socket.prependAny((event, ...args) => {\n             *   console.log(`got event ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            prependAny(listener) {\n              this._anyListeners = this._anyListeners || [];\n              this._anyListeners.unshift(listener);\n              return this;\n            }\n            /**\n             * Removes the listener that will be fired when any event is emitted.\n             *\n             * @example\n             * const catchAllListener = (event, ...args) => {\n             *   console.log(`got event ${event}`);\n             * }\n             *\n             * socket.onAny(catchAllListener);\n             *\n             * // remove a specific listener\n             * socket.offAny(catchAllListener);\n             *\n             * // or remove all listeners\n             * socket.offAny();\n             *\n             * @param listener\n             */\n            offAny(listener) {\n              if (!this._anyListeners) {\n                return this;\n              }\n              if (listener) {\n                const listeners = this._anyListeners;\n                for (let i = 0; i < listeners.length; i++) {\n                  if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                  }\n                }\n              } else {\n                this._anyListeners = [];\n              }\n              return this;\n            }\n            /**\n             * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n             * e.g. to remove listeners.\n             */\n            listenersAny() {\n              return this._anyListeners || [];\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback.\n             *\n             * Note: acknowledgements sent to the server are not included.\n             *\n             * @example\n             * socket.onAnyOutgoing((event, ...args) => {\n             *   console.log(`sent event ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            onAnyOutgoing(listener) {\n              this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n              this._anyOutgoingListeners.push(listener);\n              return this;\n            }\n            /**\n             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n             * callback. The listener is added to the beginning of the listeners array.\n             *\n             * Note: acknowledgements sent to the server are not included.\n             *\n             * @example\n             * socket.prependAnyOutgoing((event, ...args) => {\n             *   console.log(`sent event ${event}`);\n             * });\n             *\n             * @param listener\n             */\n            prependAnyOutgoing(listener) {\n              this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n              this._anyOutgoingListeners.unshift(listener);\n              return this;\n            }\n            /**\n             * Removes the listener that will be fired when any event is emitted.\n             *\n             * @example\n             * const catchAllListener = (event, ...args) => {\n             *   console.log(`sent event ${event}`);\n             * }\n             *\n             * socket.onAnyOutgoing(catchAllListener);\n             *\n             * // remove a specific listener\n             * socket.offAnyOutgoing(catchAllListener);\n             *\n             * // or remove all listeners\n             * socket.offAnyOutgoing();\n             *\n             * @param [listener] - the catch-all listener (optional)\n             */\n            offAnyOutgoing(listener) {\n              if (!this._anyOutgoingListeners) {\n                return this;\n              }\n              if (listener) {\n                const listeners = this._anyOutgoingListeners;\n                for (let i = 0; i < listeners.length; i++) {\n                  if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                  }\n                }\n              } else {\n                this._anyOutgoingListeners = [];\n              }\n              return this;\n            }\n            /**\n             * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n             * e.g. to remove listeners.\n             */\n            listenersAnyOutgoing() {\n              return this._anyOutgoingListeners || [];\n            }\n            /**\n             * Notify the listeners for each packet sent\n             *\n             * @param packet\n             *\n             * @private\n             */\n            notifyOutgoingListeners(packet) {\n              if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n                const listeners = this._anyOutgoingListeners.slice();\n                for (const listener of listeners) {\n                  listener.apply(this, packet.data);\n                }\n              }\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-client/build/esm/url.js\": (\n        /*!********************************************************!*\\\n          !*** ./node_modules/socket.io-client/build/esm/url.js ***!\n          \\********************************************************/\n        /*! exports provided: url */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"url\", function() {\n            return url;\n          });\n          var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! engine.io-client */\n            \"./node_modules/engine.io-client/build/esm/index.js\"\n          );\n          function url(uri, path = \"\", loc) {\n            let obj = uri;\n            loc = loc || typeof location !== \"undefined\" && location;\n            if (null == uri)\n              uri = loc.protocol + \"//\" + loc.host;\n            if (typeof uri === \"string\") {\n              if (\"/\" === uri.charAt(0)) {\n                if (\"/\" === uri.charAt(1)) {\n                  uri = loc.protocol + uri;\n                } else {\n                  uri = loc.host + uri;\n                }\n              }\n              if (!/^(https?|wss?):\\/\\//.test(uri)) {\n                if (\"undefined\" !== typeof loc) {\n                  uri = loc.protocol + \"//\" + uri;\n                } else {\n                  uri = \"https://\" + uri;\n                }\n              }\n              obj = Object(engine_io_client__WEBPACK_IMPORTED_MODULE_0__[\"parse\"])(uri);\n            }\n            if (!obj.port) {\n              if (/^(http|ws)$/.test(obj.protocol)) {\n                obj.port = \"80\";\n              } else if (/^(http|ws)s$/.test(obj.protocol)) {\n                obj.port = \"443\";\n              }\n            }\n            obj.path = obj.path || \"/\";\n            const ipv6 = obj.host.indexOf(\":\") !== -1;\n            const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n            obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n            obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n            return obj;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-parser/build/esm/binary.js\": (\n        /*!***********************************************************!*\\\n          !*** ./node_modules/socket.io-parser/build/esm/binary.js ***!\n          \\***********************************************************/\n        /*! exports provided: deconstructPacket, reconstructPacket */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"deconstructPacket\", function() {\n            return deconstructPacket;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"reconstructPacket\", function() {\n            return reconstructPacket;\n          });\n          var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./is-binary.js */\n            \"./node_modules/socket.io-parser/build/esm/is-binary.js\"\n          );\n          function deconstructPacket(packet) {\n            const buffers = [];\n            const packetData = packet.data;\n            const pack = packet;\n            pack.data = _deconstructPacket(packetData, buffers);\n            pack.attachments = buffers.length;\n            return { packet: pack, buffers };\n          }\n          function _deconstructPacket(data, buffers) {\n            if (!data)\n              return data;\n            if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_0__[\"isBinary\"])(data)) {\n              const placeholder = { _placeholder: true, num: buffers.length };\n              buffers.push(data);\n              return placeholder;\n            } else if (Array.isArray(data)) {\n              const newData = new Array(data.length);\n              for (let i = 0; i < data.length; i++) {\n                newData[i] = _deconstructPacket(data[i], buffers);\n              }\n              return newData;\n            } else if (typeof data === \"object\" && !(data instanceof Date)) {\n              const newData = {};\n              for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                  newData[key] = _deconstructPacket(data[key], buffers);\n                }\n              }\n              return newData;\n            }\n            return data;\n          }\n          function reconstructPacket(packet, buffers) {\n            packet.data = _reconstructPacket(packet.data, buffers);\n            delete packet.attachments;\n            return packet;\n          }\n          function _reconstructPacket(data, buffers) {\n            if (!data)\n              return data;\n            if (data && data._placeholder === true) {\n              const isIndexValid = typeof data.num === \"number\" && data.num >= 0 && data.num < buffers.length;\n              if (isIndexValid) {\n                return buffers[data.num];\n              } else {\n                throw new Error(\"illegal attachments\");\n              }\n            } else if (Array.isArray(data)) {\n              for (let i = 0; i < data.length; i++) {\n                data[i] = _reconstructPacket(data[i], buffers);\n              }\n            } else if (typeof data === \"object\") {\n              for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                  data[key] = _reconstructPacket(data[key], buffers);\n                }\n              }\n            }\n            return data;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-parser/build/esm/index.js\": (\n        /*!**********************************************************!*\\\n          !*** ./node_modules/socket.io-parser/build/esm/index.js ***!\n          \\**********************************************************/\n        /*! exports provided: protocol, PacketType, Encoder, Decoder */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"protocol\", function() {\n            return protocol;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"PacketType\", function() {\n            return PacketType;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Encoder\", function() {\n            return Encoder;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"Decoder\", function() {\n            return Decoder;\n          });\n          var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! @socket.io/component-emitter */\n            \"./node_modules/@socket.io/component-emitter/index.mjs\"\n          );\n          var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./binary.js */\n            \"./node_modules/socket.io-parser/build/esm/binary.js\"\n          );\n          var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(\n            /*! ./is-binary.js */\n            \"./node_modules/socket.io-parser/build/esm/is-binary.js\"\n          );\n          const RESERVED_EVENTS = [\n            \"connect\",\n            \"connect_error\",\n            \"disconnect\",\n            \"disconnecting\",\n            \"newListener\",\n            \"removeListener\"\n            // used by the Node.js EventEmitter\n          ];\n          const protocol = 5;\n          var PacketType;\n          (function(PacketType2) {\n            PacketType2[PacketType2[\"CONNECT\"] = 0] = \"CONNECT\";\n            PacketType2[PacketType2[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n            PacketType2[PacketType2[\"EVENT\"] = 2] = \"EVENT\";\n            PacketType2[PacketType2[\"ACK\"] = 3] = \"ACK\";\n            PacketType2[PacketType2[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n            PacketType2[PacketType2[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n            PacketType2[PacketType2[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n          })(PacketType || (PacketType = {}));\n          class Encoder {\n            /**\n             * Encoder constructor\n             *\n             * @param {function} replacer - custom replacer to pass down to JSON.parse\n             */\n            constructor(replacer) {\n              this.replacer = replacer;\n            }\n            /**\n             * Encode a packet as a single string if non-binary, or as a\n             * buffer sequence, depending on packet type.\n             *\n             * @param {Object} obj - packet object\n             */\n            encode(obj) {\n              if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n                if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__[\"hasBinary\"])(obj)) {\n                  return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id\n                  });\n                }\n              }\n              return [this.encodeAsString(obj)];\n            }\n            /**\n             * Encode packet as string.\n             */\n            encodeAsString(obj) {\n              let str = \"\" + obj.type;\n              if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {\n                str += obj.attachments + \"-\";\n              }\n              if (obj.nsp && \"/\" !== obj.nsp) {\n                str += obj.nsp + \",\";\n              }\n              if (null != obj.id) {\n                str += obj.id;\n              }\n              if (null != obj.data) {\n                str += JSON.stringify(obj.data, this.replacer);\n              }\n              return str;\n            }\n            /**\n             * Encode packet as 'buffer sequence' by removing blobs, and\n             * deconstructing packet into object with placeholders and\n             * a list of buffers.\n             */\n            encodeAsBinary(obj) {\n              const deconstruction = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__[\"deconstructPacket\"])(obj);\n              const pack = this.encodeAsString(deconstruction.packet);\n              const buffers = deconstruction.buffers;\n              buffers.unshift(pack);\n              return buffers;\n            }\n          }\n          function isObject(value) {\n            return Object.prototype.toString.call(value) === \"[object Object]\";\n          }\n          class Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__[\"Emitter\"] {\n            /**\n             * Decoder constructor\n             *\n             * @param {function} reviver - custom reviver to pass down to JSON.stringify\n             */\n            constructor(reviver) {\n              super();\n              this.reviver = reviver;\n            }\n            /**\n             * Decodes an encoded packet string into packet JSON.\n             *\n             * @param {String} obj - encoded packet\n             */\n            add(obj) {\n              let packet;\n              if (typeof obj === \"string\") {\n                if (this.reconstructor) {\n                  throw new Error(\"got plaintext data when reconstructing a packet\");\n                }\n                packet = this.decodeString(obj);\n                const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n                if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                  packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                  this.reconstructor = new BinaryReconstructor(packet);\n                  if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                  }\n                } else {\n                  super.emitReserved(\"decoded\", packet);\n                }\n              } else if (Object(_is_binary_js__WEBPACK_IMPORTED_MODULE_2__[\"isBinary\"])(obj) || obj.base64) {\n                if (!this.reconstructor) {\n                  throw new Error(\"got binary data when not reconstructing a packet\");\n                } else {\n                  packet = this.reconstructor.takeBinaryData(obj);\n                  if (packet) {\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                  }\n                }\n              } else {\n                throw new Error(\"Unknown type: \" + obj);\n              }\n            }\n            /**\n             * Decode a packet String (JSON data)\n             *\n             * @param {String} str\n             * @return {Object} packet\n             */\n            decodeString(str) {\n              let i = 0;\n              const p = {\n                type: Number(str.charAt(0))\n              };\n              if (PacketType[p.type] === void 0) {\n                throw new Error(\"unknown packet type \" + p.type);\n              }\n              if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {\n                const start = i + 1;\n                while (str.charAt(++i) !== \"-\" && i != str.length) {\n                }\n                const buf = str.substring(start, i);\n                if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                  throw new Error(\"Illegal attachments\");\n                }\n                p.attachments = Number(buf);\n              }\n              if (\"/\" === str.charAt(i + 1)) {\n                const start = i + 1;\n                while (++i) {\n                  const c = str.charAt(i);\n                  if (\",\" === c)\n                    break;\n                  if (i === str.length)\n                    break;\n                }\n                p.nsp = str.substring(start, i);\n              } else {\n                p.nsp = \"/\";\n              }\n              const next = str.charAt(i + 1);\n              if (\"\" !== next && Number(next) == next) {\n                const start = i + 1;\n                while (++i) {\n                  const c = str.charAt(i);\n                  if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                  }\n                  if (i === str.length)\n                    break;\n                }\n                p.id = Number(str.substring(start, i + 1));\n              }\n              if (str.charAt(++i)) {\n                const payload = this.tryParse(str.substr(i));\n                if (Decoder.isPayloadValid(p.type, payload)) {\n                  p.data = payload;\n                } else {\n                  throw new Error(\"invalid payload\");\n                }\n              }\n              return p;\n            }\n            tryParse(str) {\n              try {\n                return JSON.parse(str, this.reviver);\n              } catch (e) {\n                return false;\n              }\n            }\n            static isPayloadValid(type, payload) {\n              switch (type) {\n                case PacketType.CONNECT:\n                  return isObject(payload);\n                case PacketType.DISCONNECT:\n                  return payload === void 0;\n                case PacketType.CONNECT_ERROR:\n                  return typeof payload === \"string\" || isObject(payload);\n                case PacketType.EVENT:\n                case PacketType.BINARY_EVENT:\n                  return Array.isArray(payload) && (typeof payload[0] === \"number\" || typeof payload[0] === \"string\" && RESERVED_EVENTS.indexOf(payload[0]) === -1);\n                case PacketType.ACK:\n                case PacketType.BINARY_ACK:\n                  return Array.isArray(payload);\n              }\n            }\n            /**\n             * Deallocates a parser's resources\n             */\n            destroy() {\n              if (this.reconstructor) {\n                this.reconstructor.finishedReconstruction();\n                this.reconstructor = null;\n              }\n            }\n          }\n          class BinaryReconstructor {\n            constructor(packet) {\n              this.packet = packet;\n              this.buffers = [];\n              this.reconPack = packet;\n            }\n            /**\n             * Method to be called when binary data received from connection\n             * after a BINARY_EVENT packet.\n             *\n             * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n             * @return {null | Object} returns null if more binary data is expected or\n             *   a reconstructed packet object if all buffers have been received.\n             */\n            takeBinaryData(binData) {\n              this.buffers.push(binData);\n              if (this.buffers.length === this.reconPack.attachments) {\n                const packet = Object(_binary_js__WEBPACK_IMPORTED_MODULE_1__[\"reconstructPacket\"])(this.reconPack, this.buffers);\n                this.finishedReconstruction();\n                return packet;\n              }\n              return null;\n            }\n            /**\n             * Cleans up binary packet reconstruction variables.\n             */\n            finishedReconstruction() {\n              this.reconPack = null;\n              this.buffers = [];\n            }\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/socket.io-parser/build/esm/is-binary.js\": (\n        /*!**************************************************************!*\\\n          !*** ./node_modules/socket.io-parser/build/esm/is-binary.js ***!\n          \\**************************************************************/\n        /*! exports provided: isBinary, hasBinary */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"isBinary\", function() {\n            return isBinary;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"hasBinary\", function() {\n            return hasBinary;\n          });\n          const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n          const isView = (obj) => {\n            return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n          };\n          const toString = Object.prototype.toString;\n          const withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\n          const withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\n          function isBinary(obj) {\n            return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n          }\n          function hasBinary(obj, toJSON) {\n            if (!obj || typeof obj !== \"object\") {\n              return false;\n            }\n            if (Array.isArray(obj)) {\n              for (let i = 0, l = obj.length; i < l; i++) {\n                if (hasBinary(obj[i])) {\n                  return true;\n                }\n              }\n              return false;\n            }\n            if (isBinary(obj)) {\n              return true;\n            }\n            if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) {\n              return hasBinary(obj.toJSON(), true);\n            }\n            for (const key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n                return true;\n              }\n            }\n            return false;\n          }\n        }\n      ),\n      /***/\n      \"./node_modules/webpack/buildin/global.js\": (\n        /*!***********************************!*\\\n          !*** (webpack)/buildin/global.js ***!\n          \\***********************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2) {\n          var g;\n          g = function() {\n            return this;\n          }();\n          try {\n            g = g || new Function(\"return this\")();\n          } catch (e) {\n            if (typeof window === \"object\")\n              g = window;\n          }\n          module2.exports = g;\n        }\n      ),\n      /***/\n      \"./node_modules/worker-loader/dist/workers/InlineWorker.js\": (\n        /*!*****************************************************************!*\\\n          !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!\n          \\*****************************************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          var URL2 = window.URL || window.webkitURL;\n          module2.exports = function(content, url) {\n            try {\n              try {\n                var blob;\n                try {\n                  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n                  blob = new BlobBuilder();\n                  blob.append(content);\n                  blob = blob.getBlob();\n                } catch (e) {\n                  blob = new Blob([content]);\n                }\n                return new Worker(URL2.createObjectURL(blob));\n              } catch (e) {\n                return new Worker(\"data:application/javascript,\" + encodeURIComponent(content));\n              }\n            } catch (e) {\n              if (!url) {\n                throw Error(\"Inline worker is not supported\");\n              }\n              return new Worker(url);\n            }\n          };\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/main.js\": (\n        /*!*********************!*\\\n          !*** ./src/main.js ***!\n          \\*********************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"waitForInitialization\", function() {\n            return waitForInitialization;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setupRPC\", function() {\n            return setupRPC;\n          });\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./plugin.webworker.js */\n            \"./src/plugin.webworker.js\"\n          );\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n          var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./pluginIframe.js */\n            \"./src/pluginIframe.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"loadRequirements\"];\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"API_VERSION\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_4__[\"version\"];\n          });\n          function _inIframe() {\n            try {\n              return window.self !== window.top;\n            } catch (e) {\n              return true;\n            }\n          }\n          function _inWebWorker2() {\n            return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          }\n          function setupWebWorker(config) {\n            if (!config.allow_execution)\n              throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n            let broadcastChannel = null;\n            if (config.broadcastChannel) {\n              broadcastChannel = new BroadcastChannel(config.broadcastChannel);\n            }\n            const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a();\n            const fallbackTimeout = setTimeout(function() {\n              worker.terminate();\n              console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n              Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n            }, 2e3);\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            worker.addEventListener(\"message\", function(e) {\n              let transferables = void 0;\n              const m = e.data;\n              if (m.type === \"worker-ready\") {\n                worker.postMessage({\n                  type: \"connectRPC\",\n                  config\n                });\n                clearTimeout(fallbackTimeout);\n                return;\n              } else if (m.type === \"initialized\") {\n                m.config = Object.assign({}, config, m.config);\n                m.origin = globalThis.location.origin;\n                m.peer_id = peer_id;\n              } else if (m.type === \"imjoy_remote_api_ready\") {\n                globalThis.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: null\n                }));\n              } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n                cache_requirements(m.requirements);\n              } else if (m.type === \"disconnect\") {\n                worker.terminate();\n              } else {\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n              }\n              if (broadcastChannel)\n                broadcastChannel.postMessage(m);\n              else\n                parent.postMessage(m, config.target_origin || \"*\", transferables);\n            });\n            (broadcastChannel || window).addEventListener(\"message\", function(e) {\n              if (e.type === \"message\" && (broadcastChannel || config.target_origin === \"*\" || e.origin === config.target_origin)) {\n                let transferables = void 0;\n                const m = e.data;\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n                if (m.peer_id === peer_id) {\n                  worker.postMessage(m, transferables);\n                } else if (config.debug) {\n                  console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n                }\n              }\n            });\n          }\n          function waitForInitialization(config) {\n            if (_inWebWorker2()) {\n              globalThis.parent = self;\n            }\n            config = config || {};\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n              config.enable_service_worker = false;\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            const targetOrigin = config.target_origin || \"*\";\n            if (config.credential_required && typeof config.verify_credential !== \"function\") {\n              throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n            }\n            if (config.credential_required && targetOrigin === \"*\") {\n              throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n            }\n            const done = () => {\n              globalThis.removeEventListener(\"message\", handleEvent);\n            };\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            const handleEvent = (e) => {\n              if (e.type === \"message\" && (!e.origin || targetOrigin === \"*\" || e.origin === targetOrigin)) {\n                if (e.data.type === \"initialize\") {\n                  done();\n                  if (e.data.peer_id !== peer_id) {\n                    console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n                  }\n                  const cfg = e.data.config;\n                  if (targetOrigin !== \"*\") {\n                    cfg.target_origin = targetOrigin;\n                  }\n                  if (config.credential_required) {\n                    config.verify_credential(cfg.credential).then((result) => {\n                      if (result && result.auth && !result.error) {\n                        cfg.auth = result.auth;\n                        setupRPC(cfg).then(() => {\n                          console.log(\"ImJoy RPC loaded successfully!\");\n                        });\n                      } else {\n                        throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n                      }\n                    });\n                  } else {\n                    setupRPC(cfg).then(() => {\n                      console.log(\"ImJoy RPC loaded successfully!\");\n                    });\n                  }\n                } else {\n                  throw new Error(`unrecognized message: ${e.data}`);\n                }\n              }\n            };\n            globalThis.addEventListener(\"message\", handleEvent);\n            if (_inWebWorker2()) {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              });\n            } else {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              }, \"*\");\n            }\n          }\n          function setupRPC(config) {\n            config = config || {};\n            config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"normalizeConfig\"])(config);\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            return new Promise((resolve, reject) => {\n              const handleEvent = (e) => {\n                const api = e.detail;\n                if (config.expose_api_globally) {\n                  globalThis.api = api;\n                }\n                resolve(api);\n                globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              };\n              if (_inIframe()) {\n                if (config.type === \"web-worker\") {\n                  try {\n                    setupWebWorker(config);\n                  } catch (e) {\n                    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                  }\n                } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n                  Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                } else {\n                  console.error(\"Unsupported plugin type: \" + config.type);\n                  reject(\"Unsupported plugin type: \" + config.type);\n                  return;\n                }\n                globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              } else if (_inWebWorker2()) {\n                Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n              } else {\n                reject(new Error(\"imjoy-rpc should only run inside an iframe or a webworker.\"));\n              }\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/plugin.webworker.js\": (\n        /*!*********************************!*\\\n          !*** ./src/plugin.webworker.js ***!\n          \\*********************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          module2.exports = function() {\n            return __webpack_require__2(\n              /*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */\n              \"./node_modules/worker-loader/dist/workers/InlineWorker.js\"\n            )('/******/ (function(modules) { // webpackBootstrap\\n/******/ \t// The module cache\\n/******/ \tvar installedModules = {};\\n/******/\\n/******/ \t// The require function\\n/******/ \tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \t\t// Check if module is in cache\\n/******/ \t\tif(installedModules[moduleId]) {\\n/******/ \t\t\treturn installedModules[moduleId].exports;\\n/******/ \t\t}\\n/******/ \t\t// Create a new module (and put it into the cache)\\n/******/ \t\tvar module = installedModules[moduleId] = {\\n/******/ \t\t\ti: moduleId,\\n/******/ \t\t\tl: false,\\n/******/ \t\t\texports: {}\\n/******/ \t\t};\\n/******/\\n/******/ \t\t// Execute the module function\\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \t\t// Flag the module as loaded\\n/******/ \t\tmodule.l = true;\\n/******/\\n/******/ \t\t// Return the exports of the module\\n/******/ \t\treturn module.exports;\\n/******/ \t}\\n/******/\\n/******/\\n/******/ \t// expose the modules object (__webpack_modules__)\\n/******/ \t__webpack_require__.m = modules;\\n/******/\\n/******/ \t// expose the module cache\\n/******/ \t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \t// define getter function for harmony exports\\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \t\t}\\n/******/ \t};\\n/******/\\n/******/ \t// define __esModule on exports\\n/******/ \t__webpack_require__.r = function(exports) {\\n/******/ \t\tif(typeof Symbol !== \\'undefined\\' && Symbol.toStringTag) {\\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \\'Module\\' });\\n/******/ \t\t}\\n/******/ \t\tObject.defineProperty(exports, \\'__esModule\\', { value: true });\\n/******/ \t};\\n/******/\\n/******/ \t// create a fake namespace object\\n/******/ \t// mode & 1: value is a module id, require it\\n/******/ \t// mode & 2: merge all properties of value into the ns\\n/******/ \t// mode & 4: return value when already ns object\\n/******/ \t// mode & 8|1: behave like require\\n/******/ \t__webpack_require__.t = function(value, mode) {\\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \t\tif(mode & 8) return value;\\n/******/ \t\tif((mode & 4) && typeof value === \\'object\\' && value && value.__esModule) return value;\\n/******/ \t\tvar ns = Object.create(null);\\n/******/ \t\t__webpack_require__.r(ns);\\n/******/ \t\tObject.defineProperty(ns, \\'default\\', { enumerable: true, value: value });\\n/******/ \t\tif(mode & 2 && typeof value != \\'string\\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \t\treturn ns;\\n/******/ \t};\\n/******/\\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \t__webpack_require__.n = function(module) {\\n/******/ \t\tvar getter = module && module.__esModule ?\\n/******/ \t\t\tfunction getDefault() { return module[\\'default\\']; } :\\n/******/ \t\t\tfunction getModuleExports() { return module; };\\n/******/ \t\t__webpack_require__.d(getter, \\'a\\', getter);\\n/******/ \t\treturn getter;\\n/******/ \t};\\n/******/\\n/******/ \t// Object.prototype.hasOwnProperty.call\\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \t// __webpack_public_path__\\n/******/ \t__webpack_require__.p = \"\";\\n/******/\\n/******/\\n/******/ \t// Load entry module and return exports\\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/plugin.webworker.js\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \"./src/plugin.webworker.js\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \"undefined\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\"This script can only loaded in a webworker\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\"message\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \"initialized\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\"beforeDisconnect\");\\n    self.close();\\n    this._fire(\"disconnected\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \"requirements\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWebworker\"])(code.requirements);\\n    } else if (code.type === \"script\") {\\n      try {\\n        if (code.attrs.type === \"module\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \"unsupported code type.\";\\n    }\\n    if (code.type === \"requirements\") {\\n      self.postMessage({\\n        type: \"cacheRequirements\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \"web-worker\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \"javascript\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\"connectRPC\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \"worker-ready\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \"./src/pluginCore.js\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\\n  rpc.on(\"getInterface\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\"remoteReady\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\"Remove duplicated codec: \" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\"name\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \"imjoy_remote_api_ready\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \"function\") {\\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/rpc.js\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \"0.2.3\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\"undefined index\");\\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\"remoteIdle\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\"remoteBusy\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \"initialized\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\"interfaceAvailable\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\"interfaceSetAsRemote\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\"interface is not set.\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \"setInterface\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(`Object (id=${objectId}) not found.`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\"disposed\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \"disposeObject\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\"Invalid object\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\"init\", this.init);\\n\\n    this._connection.on(\"execute\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \"executed\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"executed\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\"method\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\".\")) {\\n          const tmp = data.name.split(\".\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"callback\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"disposeObject\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \"disposed\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"disposed\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"setInterface\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\"getInterface\", () => {\\n      this._fire(\"getInterface\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\"interfaceAvailable\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"interfaceSetAsRemote\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\"interfaceSetAsRemote\");\\n    });\\n\\n    this._connection.on(\"disconnect\", () => {\\n      this._fire(\"beforeDisconnect\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\"disconnected\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \"getInterface\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \"dtype doesn\\'t match the type of the array: \" + _dtype + \" != \" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \"ndarray\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\"remoteReady\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \"method\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \"interfaceSetAsRemote\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \"function\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\"objectId is not specified.\");\\n        bObject = {\\n          _rtype: \"interface\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \"callback\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \"error\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \"blob\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\\n      bObject = {\\n        _rtype: \"typedarray\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"memoryview\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \"set\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \"orderedmap\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\"Please instantiate the class before exportting it.\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\"Unsupported interface type\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \"constructor\") continue;\\n\\n          if (k.startsWith(\"_\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \"function\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \"function\") {\\n          aObject.on(\"close\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \"object\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n\\n      for (let k of keys) {\\n        if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \"imjoy-rpc: Unsupported data type:\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\"Failed to encode object\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\"_rtype\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \"callback\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \"interface\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \"ndarray\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \"undefined\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \"error\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \"file\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \"typedarray\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \"memoryview\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \"blob\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \"orderedmap\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \"set\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\"Failed to decode object\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \"callback\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \"callback\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \"disconnect\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/utils.js\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\"script\");\\n      scriptTag.src = url;\\n      scriptTag.type = \"text/javascript\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n            if (requirements[i].startsWith(\"css:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\"link\");\\n            link_node.rel = \"stylesheet\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\"mjs:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n            if (requirements[i].startsWith(\"js:\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"http\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n          } else {\\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \"unsupported requirements definition\";\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n          throw \"unable to import css in a webworker\";\\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n          if (requirements[i].startsWith(\"js:\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"http\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n        } else {\\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \"0.1.0\";\\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\\n  config.type = config.type || \"rpc-window\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \"*\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \"function\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \"int8\",\\n  Int16Array: \"int16\",\\n  Int32Array: \"int32\",\\n  Uint8Array: \"uint8\",\\n  Uint16Array: \"uint16\",\\n  Uint32Array: \"uint32\",\\n  Float32Array: \"float32\",\\n  Float64Array: \"float64\",\\n  Array: \"array\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \"add\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\"Service worker is not supported.\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\"Service worker controller is not available\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\"js:\")) req = req.slice(3);\\n    if (req.startsWith(\"css:\")) req = req.slice(4);\\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\\n    if (!req.startsWith(\"http\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\"serviceWorker\" in navigator) {\\n    baseUrl = baseUrl || \"/\";\\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\"ServiceWorker registration failed: \", err);\\n    });\\n    targetOrigin = targetOrigin || \"*\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\\n      throw new Error(\"config.cache_requirements must be a function\");\\n    }\\n\\n    window.addEventListener(\"message\", function (e) {\\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \"cacheRequirements\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\"/\").replace(/[\\\\/]+/g, \"/\").replace(/^(.+):\\\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\\\/(\\\\?|&|#[^!])/g, \"$1\").replace(/\\\\?/g, \"&\").replace(\"&\", \"?\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\"emit is not implemented\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\"unhandled event\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map', null);\n          };\n        }\n      ),\n      /***/\n      \"./src/pluginCore.js\": (\n        /*!***************************!*\\\n          !*** ./src/pluginCore.js ***!\n          \\***************************/\n        /*! exports provided: connectRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"connectRPC\", function() {\n            return connectRPC;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          function connectRPC(connection, config) {\n            config = config || {};\n            const codecs = {};\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n            rpc.on(\"getInterface\", function() {\n              launchConnected();\n            });\n            rpc.on(\"remoteReady\", function() {\n              const api = rpc.getRemote() || {};\n              api.registerCodec = function(config2) {\n                if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                  throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n                } else {\n                  if (config2.type) {\n                    for (let k of Object.keys(codecs)) {\n                      if (codecs[k].type === config2.type || k === config2.name) {\n                        delete codecs[k];\n                        console.warn(\"Remove duplicated codec: \" + k);\n                      }\n                    }\n                  }\n                  codecs[config2[\"name\"]] = config2;\n                }\n              };\n              api.init = function(config2) {\n                rpc.setInterface({\n                  setup() {\n                  }\n                }, config2);\n              };\n              api.disposeObject = function(obj) {\n                rpc.disposeObject(obj);\n              };\n              api.export = function(_interface, config2) {\n                rpc.setInterface(_interface, config2);\n              };\n              api.onLoad = function(handler) {\n                handler = checkHandler(handler);\n                if (connected) {\n                  handler();\n                } else {\n                  connectedHandlers.push(handler);\n                }\n              };\n              api.dispose = function(_interface) {\n                rpc.disconnect();\n              };\n              api._rpc = rpc;\n              if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n                self.api = api;\n                self.postMessage({\n                  type: \"imjoy_remote_api_ready\"\n                });\n                self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              } else if (typeof window) {\n                window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              }\n            });\n            let connected = false;\n            const connectedHandlers = [];\n            const launchConnected = function() {\n              if (!connected) {\n                connected = true;\n                let handler;\n                while (handler = connectedHandlers.pop()) {\n                  handler();\n                }\n              }\n            };\n            const checkHandler = function(handler) {\n              const type = typeof handler;\n              if (type !== \"function\") {\n                const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n                throw new Error(msg);\n              }\n              return handler;\n            };\n            return rpc;\n          }\n        }\n      ),\n      /***/\n      \"./src/pluginIframe.js\": (\n        /*!*****************************!*\\\n          !*** ./src/pluginIframe.js ***!\n          \\*****************************/\n        /*! exports provided: Connection, default */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_305242__) {\n          \"use strict\";\n          __nested_webpack_require_305242__.r(__nested_webpack_exports__);\n          __nested_webpack_require_305242__.d(__nested_webpack_exports__, \"Connection\", function() {\n            return Connection;\n          });\n          __nested_webpack_require_305242__.d(__nested_webpack_exports__, \"default\", function() {\n            return setupIframe;\n          });\n          var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_305242__(\n            /*! ./pluginCore.js */\n            \"./src/pluginCore.js\"\n          );\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_305242__(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_305242__(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          function _htmlToElement(html) {\n            var template = document.createElement(\"template\");\n            html = html.trim();\n            template.innerHTML = html;\n            return template.content.firstChild;\n          }\n          const _inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          async function executeEsModule(content) {\n            const dataUri = \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\n            await import(\n              /* webpackIgnore: true */\n              dataUri\n            );\n          }\n          class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n            constructor(config) {\n              super(config && config.debug);\n              this.config = config || {};\n              this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n            }\n            connect() {\n              this.config.target_origin = this.config.target_origin || \"*\";\n              if (this.config.broadcastChannel) {\n                this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);\n              } else {\n                this.broadcastChannel = null;\n              }\n              if (this.broadcastChannel)\n                this.broadcastChannel.addEventListener(\"message\", this);\n              else\n                globalThis.addEventListener(\"message\", this);\n              this.emit({\n                type: \"initialized\",\n                config: this.config,\n                origin: globalThis.location.origin,\n                peer_id: this.peer_id\n              });\n              this._fire(\"connected\");\n            }\n            handleEvent(e) {\n              if (e.type === \"message\" && (this.broadcastChannel || this.config.target_origin === \"*\" || !e.origin || e.origin === this.config.target_origin)) {\n                if (e.data.peer_id === this.peer_id) {\n                  this._fire(e.data.type, e.data);\n                } else if (this.config.debug) {\n                  console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n                }\n              }\n            }\n            disconnect() {\n              this._fire(\"beforeDisconnect\");\n              globalThis.removeEventListener(\"message\", this);\n              this._fire(\"disconnected\");\n            }\n            emit(data) {\n              let transferables;\n              if (this.broadcastChannel)\n                this.broadcastChannel.postMessage(data);\n              else {\n                if (data.__transferables__) {\n                  transferables = data.__transferables__;\n                  delete data.__transferables__;\n                } else if (_inWebWorker)\n                  self.postMessage(data, transferables);\n                else\n                  parent.postMessage(data, this.config.target_origin, transferables);\n              }\n            }\n            async execute(code) {\n              try {\n                if (code.type === \"requirements\") {\n                  await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWindow\"])(code.requirements);\n                } else if (code.type === \"script\") {\n                  if (code.src) {\n                    var script_node = document.createElement(\"script\");\n                    script_node.setAttribute(\"type\", code.attrs.type);\n                    script_node.setAttribute(\"src\", code.src);\n                    document.head.appendChild(script_node);\n                  } else {\n                    if (code.content && code.attrs.lang === \"javascript\") {\n                      if (code.attrs.type === \"module\") {\n                        await executeEsModule(code.content);\n                      } else {\n                        eval(code.content);\n                      }\n                    } else {\n                      var node = document.createElement(\"script\");\n                      for (let k in code.attrs) {\n                        node.setAttribute(k, code.attrs[k]);\n                      }\n                      node.appendChild(document.createTextNode(code.content));\n                      document.body.appendChild(node);\n                    }\n                  }\n                } else if (code.type === \"style\") {\n                  const style_node = document.createElement(\"style\");\n                  if (code.src) {\n                    style_node.src = code.src;\n                  }\n                  style_node.innerHTML = code.content;\n                  document.head.appendChild(style_node);\n                } else if (code.type === \"link\") {\n                  const link_node_ = document.createElement(\"link\");\n                  if (code.rel) {\n                    link_node_.rel = code.rel;\n                  }\n                  if (code.href) {\n                    link_node_.href = code.href;\n                  }\n                  if (code.attrs && code.attrs.type) {\n                    link_node_.type = code.attrs.type;\n                  }\n                  document.head.appendChild(link_node_);\n                } else if (code.type === \"html\") {\n                  document.body.appendChild(_htmlToElement(code.content));\n                } else {\n                  throw \"unsupported code type.\";\n                }\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\"\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\"\n                  }, this.config.target_origin);\n              } catch (e) {\n                console.error(\"failed to execute scripts: \", code, e);\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  }, this.config.target_origin);\n              }\n            }\n          }\n          function setupIframe(config) {\n            config = config || {};\n            config.dedicated_thread = false;\n            config.lang = \"javascript\";\n            config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n            const conn = new Connection(config);\n            Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n            conn.connect();\n          }\n        }\n      ),\n      /***/\n      \"./src/rpc.js\": (\n        /*!********************!*\\\n          !*** ./src/rpc.js ***!\n          \\********************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          const API_VERSION = \"0.2.3\";\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, config, codecs) {\n              super(config && config.debug);\n              this._connection = connection;\n              this.config = config || {};\n              this._codecs = codecs || {};\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._remote_set = false;\n              const name = this.config.name;\n              this._connection.execute = this._connection.execute || function() {\n                throw new Error(`connection.execute not implemented (in \"${name}\")`);\n              };\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n              this._method_refs.onReady(() => {\n                this._fire(\"remoteIdle\");\n              });\n              this._method_refs.onBusy(() => {\n                this._fire(\"remoteBusy\");\n              });\n              this._setupMessageHanlders();\n            }\n            init() {\n              this._connection.emit({\n                type: \"initialized\",\n                config: this.config,\n                peer_id: this._connection.peer_id\n              });\n            }\n            setConfig(config) {\n              if (config)\n                for (const k of Object.keys(config)) {\n                  this.config[k] = config[k];\n                }\n            }\n            /**\n             * Set a handler to be called when received a responce from the\n             * remote site reporting that the previously provided interface\n             * has been successfully set as remote for that site\n             *\n             * @param {Function} handler\n             */\n            getRemoteCallStack() {\n              return this._method_refs.getStack();\n            }\n            /**\n             * @returns {Object} set of remote interface methods\n             */\n            getRemote() {\n              return this._remote_interface;\n            }\n            /**\n             * Sets the interface of this site making it available to the\n             * remote site by sending a message with a set of methods names\n             *\n             * @param {Object} _interface to set\n             */\n            setInterface(_interface, config) {\n              config = config || {};\n              this.config.name = config.name || this.config.name;\n              this.config.description = config.description || this.config.description;\n              if (this.config.forwarding_functions) {\n                for (let func_name of this.config.forwarding_functions) {\n                  const _remote = this._remote_interface;\n                  if (_remote[func_name]) {\n                    if (_interface.constructor === Object) {\n                      if (!_interface[func_name]) {\n                        _interface[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    } else if (_interface.constructor.constructor === Function) {\n                      if (!_interface.constructor.prototype[func_name]) {\n                        _interface.constructor.prototype[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    }\n                  }\n                }\n              }\n              this._local_api = _interface;\n              if (!this._remote_set)\n                this._fire(\"interfaceAvailable\");\n              else\n                this.sendInterface();\n              return new Promise((resolve) => {\n                this.once(\"interfaceSetAsRemote\", resolve);\n              });\n            }\n            /**\n             * Sends the actual interface to the remote site upon it was\n             * updated or by a special request of the remote site\n             */\n            sendInterface() {\n              if (!this._local_api) {\n                throw new Error(\"interface is not set.\");\n              }\n              this._encode(this._local_api, true).then((api) => {\n                this._connection.emit({\n                  type: \"setInterface\",\n                  api\n                });\n              });\n            }\n            _disposeObject(objectId) {\n              if (this._object_store[objectId]) {\n                delete this._object_store[objectId];\n              } else {\n                throw new Error(`Object (id=${objectId}) not found.`);\n              }\n            }\n            disposeObject(obj) {\n              return new Promise((resolve, reject) => {\n                if (this._object_weakmap.has(obj)) {\n                  const objectId = this._object_weakmap.get(obj);\n                  this._connection.once(\"disposed\", (data) => {\n                    if (data.error)\n                      reject(new Error(data.error));\n                    else\n                      resolve();\n                  });\n                  this._connection.emit({\n                    type: \"disposeObject\",\n                    object_id: objectId\n                  });\n                } else {\n                  throw new Error(\"Invalid object\");\n                }\n              });\n            }\n            /**\n             * Handles a message from the remote site\n             */\n            _setupMessageHanlders() {\n              this._connection.on(\"init\", this.init);\n              this._connection.on(\"execute\", (data) => {\n                Promise.resolve(this._connection.execute(data.code)).then(() => {\n                  this._connection.emit({\n                    type: \"executed\"\n                  });\n                }).catch((e) => {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"executed\",\n                    error: String(e)\n                  });\n                });\n              });\n              this._connection.on(\"method\", async (data) => {\n                let resolve, reject, method, method_this, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  const _interface = this._object_store[data.object_id];\n                  method = indexObject(_interface, data.name);\n                  if (data.name.includes(\".\")) {\n                    const tmp = data.name.split(\".\");\n                    const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\n                    method_this = indexObject(_interface, intf_index);\n                  } else {\n                    method_this = _interface;\n                  }\n                  args = await this._unwrap(data.args, true);\n                  if (data.promise) {\n                    result = method.apply(method_this, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method.apply(method_this, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"callback\", async (data) => {\n                let resolve, reject, method, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  if (data.promise) {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    result = method.apply(null, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    method.apply(null, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"disposeObject\", (data) => {\n                try {\n                  this._disposeObject(data.object_id);\n                  this._connection.emit({\n                    type: \"disposed\"\n                  });\n                } catch (e) {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"disposed\",\n                    error: String(e)\n                  });\n                }\n              });\n              this._connection.on(\"setInterface\", (data) => {\n                this._setRemoteInterface(data.api);\n              });\n              this._connection.on(\"getInterface\", () => {\n                this._fire(\"getInterface\");\n                if (this._local_api) {\n                  this.sendInterface();\n                } else {\n                  this.once(\"interfaceAvailable\", () => {\n                    this.sendInterface();\n                  });\n                }\n              });\n              this._connection.on(\"interfaceSetAsRemote\", () => {\n                this._remote_set = true;\n                this._fire(\"interfaceSetAsRemote\");\n              });\n              this._connection.on(\"disconnect\", () => {\n                this._fire(\"beforeDisconnect\");\n                this._connection.disconnect();\n                this._fire(\"disconnected\");\n              });\n            }\n            /**\n             * Sends a requests to the remote site asking it to provide its\n             * current interface\n             */\n            requestRemote() {\n              this._connection.emit({\n                type: \"getInterface\"\n              });\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            /**\n             * Sets the new remote interface provided by the other site\n             *\n             * @param {Array} names list of function names\n             */\n            _setRemoteInterface(api) {\n              this._decode(api).then((intf) => {\n                if (this._remote_interface) {\n                  for (let k in this._remote_interface)\n                    delete this._remote_interface[k];\n                  Object.assign(this._remote_interface, intf);\n                } else\n                  this._remote_interface = intf;\n                this._fire(\"remoteReady\");\n                this._reportRemoteSet();\n              });\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * method. When the generated function is called, it will send the\n             * corresponding message to the remote site asking it to execute\n             * the particular method of its interface\n             *\n             * @param {String} name of the remote method\n             *\n             * @returns {Function} wrapped remote method\n             */\n            _genRemoteMethod(targetId, name, objectId) {\n              const me = this;\n              const remoteMethod = function() {\n                return new Promise(async (resolve, reject) => {\n                  let id = null;\n                  try {\n                    id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n                    const wrapped_resolve = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return resolve.apply(this, arguments);\n                    };\n                    const wrapped_reject = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return reject.apply(this, arguments);\n                    };\n                    const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]);\n                    wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n                    let args = Array.prototype.slice.call(arguments);\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\n                      args = await me._wrap(args, true);\n                    } else {\n                      args = await me._wrap(args);\n                    }\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    me._connection.emit({\n                      type: \"method\",\n                      target_id: targetId,\n                      name,\n                      object_id: objectId,\n                      args,\n                      promise: encodedPromise,\n                      with_kwargs: withKwargs\n                    }, transferables);\n                  } catch (e) {\n                    if (id)\n                      me._method_refs.fetch(id);\n                    reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n                  }\n                });\n              };\n              remoteMethod.__remote_method = true;\n              return remoteMethod;\n            }\n            /**\n             * Sends a responce reporting that interface just provided by the\n             * remote site was successfully set by this site as remote\n             */\n            _reportRemoteSet() {\n              this._connection.emit({\n                type: \"interfaceSetAsRemote\"\n              });\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, asInterface, objectId) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof ArrayBuffer) {\n                return aObject;\n              }\n              let bObject;\n              if (typeof aObject === \"function\") {\n                if (asInterface) {\n                  if (!objectId)\n                    throw new Error(\"objectId is not specified.\");\n                  bObject = {\n                    _rtype: \"interface\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rintf: objectId,\n                    _rvalue: asInterface\n                  };\n                  this._method_weakmap.set(aObject, bObject);\n                } else if (this._method_weakmap.has(aObject)) {\n                  bObject = this._method_weakmap.get(aObject);\n                } else {\n                  const cid = this._store.put(aObject);\n                  bObject = {\n                    _rtype: \"callback\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rname: aObject.constructor && aObject.constructor.name || cid,\n                    _rvalue: cid\n                  };\n                }\n                return bObject;\n              }\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                if (aObject._rintf) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._encode(aObject, asInterface, objectId);\n                  bObject._rtype = temp;\n                } else {\n                  bObject = aObject;\n                }\n                return bObject;\n              }\n              const transferables = [];\n              const _transfer = aObject._transfer;\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (encodedObj && encodedObj._rintf) {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, asInterface, objectId);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                if (aObject._transfer || _transfer) {\n                  transferables.push(v_buffer.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: v_buffer.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.selection.data.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: aObject.selection.data.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString()\n                };\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rname: aObject.name,\n                  _rmime: aObject.type,\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject instanceof Blob) {\n                bObject = {\n                  _rtype: \"blob\",\n                  _rvalue: aObject\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: aObject.buffer,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: aObject.buffer\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                let keys;\n                if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  keys = Object.keys(aObject);\n                } else if (aObject.constructor === Function) {\n                  throw new Error(\"Please instantiate the class before exportting it.\");\n                } else if (aObject.constructor.constructor === Function) {\n                  keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                  asInterface = true;\n                } else {\n                  throw Error(\"Unsupported interface type\");\n                }\n                let hasFunction = false;\n                if (aObject._rintf || asInterface) {\n                  if (!objectId) {\n                    if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\n                      objectId = aObject._rintf;\n                    } else {\n                      objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                    }\n                    if (this._object_store[objectId])\n                      console.warn(`Overwritting interface object with the same id: ${objectId}`);\n                    this._object_store[objectId] = aObject;\n                  }\n                  for (let k of keys) {\n                    if (k === \"constructor\")\n                      continue;\n                    if (k.startsWith(\"_\")) {\n                      continue;\n                    }\n                    bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n                    if (typeof aObject[k] === \"function\") {\n                      hasFunction = true;\n                    }\n                  }\n                  if (hasFunction)\n                    bObject._rintf = objectId;\n                  if (aObject.on && typeof aObject.on === \"function\") {\n                    aObject.on(\"close\", () => {\n                      delete this._object_store[objectId];\n                    });\n                  }\n                } else {\n                  for (let k of keys) {\n                    if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                      continue;\n                    bObject[k] = await this._encode(aObject[k]);\n                  }\n                }\n              } else if (typeof aObject === \"object\") {\n                const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                const objectId2 = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                for (let k of keys) {\n                  if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                    continue;\n                  bObject[k] = await this._encode(aObject[k], k, bObject);\n                }\n                bObject._rintf = objectId2;\n              } else {\n                throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n              }\n              if (transferables.length > 0) {\n                bObject.__transferables__ = transferables;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async _decode(aObject, withPromise) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject[\"_rtype\"]) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    aObject = await this._decode(aObject, withPromise);\n                    aObject._rtype = temp;\n                  }\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"callback\") {\n                  bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n                } else if (aObject._rtype === \"interface\") {\n                  bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(aObject._rvalue);\n                } else if (aObject._rtype === \"file\") {\n                  if (aObject._rvalue instanceof File) {\n                    bObject = aObject._rvalue;\n                    bObject._path = aObject._rpath;\n                  } else {\n                    bObject = new File([aObject._rvalue], aObject._rname, {\n                      type: aObject._rmime\n                    });\n                    bObject._path = aObject._rpath;\n                  }\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  bObject = new arraytype(aObject._rvalue);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = new DataView(aObject._rvalue);\n                } else if (aObject._rtype === \"blob\") {\n                  if (aObject._rvalue instanceof Blob) {\n                    bObject = aObject._rvalue;\n                  } else {\n                    bObject = new Blob([aObject._rvalue], {\n                      type: aObject._rmime\n                    });\n                  }\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, withPromise));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, withPromise));\n                } else {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    bObject = await this._decode(aObject, withPromise);\n                    bObject._rtype = temp;\n                  } else\n                    bObject = aObject;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, withPromise);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              if (aObject._rintf) {\n                this._object_weakmap.set(bObject, aObject._rintf);\n              }\n              return bObject;\n            }\n            async _wrap(args, asInterface) {\n              return await this._encode(args, asInterface);\n            }\n            /**\n             * Unwraps the set of arguments delivered from the remote site,\n             * replaces all callback identifiers with a function which will\n             * initiate sending that callback identifier back to other site\n             *\n             * @param {Object} args to unwrap\n             *\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Array} unwrapped args\n             */\n            async _unwrap(args, withPromise) {\n              return await this._decode(args, withPromise);\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * callback. When the generated function is called, it will send\n             * the corresponding message to the remote site asking it to\n             * execute the particular callback previously saved during a call\n             * by the remote site a method from the interface of this site\n             *\n             * @param {Number} id of the remote callback to execute\n             * @param {Number} argNum argument index of the callback\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Function} wrapped remote callback\n             */\n            _genRemoteCallback(targetId, cid, withPromise) {\n              const me = this;\n              let remoteCallback;\n              if (withPromise) {\n                remoteCallback = function() {\n                  return new Promise(async (resolve, reject) => {\n                    const args = await me._wrap(Array.prototype.slice.call(arguments));\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    const encodedPromise = await me._wrap([resolve, reject]);\n                    resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    reject.__promise_pair = encodedPromise[0]._rvalue;\n                    try {\n                      me._connection.emit({\n                        type: \"callback\",\n                        target_id: targetId,\n                        id: cid,\n                        args,\n                        promise: encodedPromise,\n                        with_kwargs: withKwargs\n                      }, transferables);\n                    } catch (e) {\n                      reject(`Failed to exectue remote callback ( id: ${cid}).`);\n                    }\n                  });\n                };\n                return remoteCallback;\n              } else {\n                remoteCallback = async function() {\n                  const args = await me._wrap(Array.prototype.slice.call(arguments));\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  const transferables = args.__transferables__;\n                  if (transferables)\n                    delete args.__transferables__;\n                  return me._connection.emit({\n                    type: \"callback\",\n                    target_id: targetId,\n                    id: cid,\n                    args,\n                    with_kwargs: withKwargs\n                  }, transferables);\n                };\n                return remoteCallback;\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._remote_interface = null;\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n            }\n            /**\n             * Sends the notification message and breaks the connection\n             */\n            disconnect() {\n              this._connection.emit({\n                type: \"disconnect\"\n              });\n              this.reset();\n              setTimeout(() => {\n                this._connection.disconnect();\n              }, 2e3);\n            }\n          }\n          class ReferenceStore {\n            constructor() {\n              this._store = {};\n              this._indices = [0];\n              this._readyHandler = function() {\n              };\n              this._busyHandler = function() {\n              };\n              this._readyHandler();\n            }\n            /**\n             * call handler when the store is empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onReady(readyHandler) {\n              this._readyHandler = readyHandler || function() {\n              };\n            }\n            /**\n             * call handler when the store is not empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onBusy(busyHandler) {\n              this._busyHandler = busyHandler || function() {\n              };\n            }\n            /**\n             * get the length of the store\n             *\n             */\n            getStack() {\n              return Object.keys(this._store).length;\n            }\n            /**\n             * @function _genId() generates the new reference id\n             *\n             * @returns {Number} smallest available id and reserves it\n             */\n            _genId() {\n              let id;\n              if (this._indices.length === 1) {\n                id = this._indices[0]++;\n              } else {\n                id = this._indices.shift();\n              }\n              return id;\n            }\n            /**\n             * Releases the given reference id so that it will be available by\n             * another object stored\n             *\n             * @param {Number} id to release\n             */\n            _releaseId(id) {\n              for (let i = 0; i < this._indices.length; i++) {\n                if (id < this._indices[i]) {\n                  this._indices.splice(i, 0, id);\n                  break;\n                }\n              }\n              for (let i = this._indices.length - 1; i >= 0; i--) {\n                if (this._indices[i] - 1 === this._indices[i - 1]) {\n                  this._indices.pop();\n                } else {\n                  break;\n                }\n              }\n            }\n            /**\n             * Stores the given object and returns the refernce id instead\n             *\n             * @param {Object} obj to store\n             *\n             * @returns {Number} reference id of the stored object\n             */\n            put(obj) {\n              if (this._busyHandler && Object.keys(this._store).length === 0) {\n                this._busyHandler();\n              }\n              const id = this._genId();\n              this._store[id] = obj;\n              return id;\n            }\n            /**\n             * Retrieves previously stored object and releases its reference\n             *\n             * @param {Number} id of an object to retrieve\n             */\n            fetch(id) {\n              const obj = this._store[id];\n              if (obj && !obj.__remote_method) {\n                delete this._store[id];\n                this._releaseId(id);\n                if (this._readyHandler && Object.keys(this._store).length === 0) {\n                  this._readyHandler();\n                }\n              }\n              if (obj && obj.__promise_pair) {\n                this.fetch(obj.__promise_pair);\n              }\n              return obj;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/socketIOMain.js\": (\n        /*!*****************************!*\\\n          !*** ./src/socketIOMain.js ***!\n          \\*****************************/\n        /*! exports provided: setupRPC, waitForInitialization, VERSION, RPC, API_VERSION, loadRequirements, Connection, connectToServer */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"Connection\", function() {\n            return Connection2;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"connectToServer\", function() {\n            return connectToServer;\n          });\n          var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__2 = __webpack_require__2(\n            /*! ./pluginCore.js */\n            \"./src/pluginCore.js\"\n          );\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_1__2 = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_1__2[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_1__2[\"API_VERSION\"];\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"loadRequirements\"];\n          });\n          var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! socket.io-client */\n            \"./node_modules/socket.io-client/build/esm/index.js\"\n          );\n          var _main_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ./main.js */\n            \"./src/main.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"setupRPC\", function() {\n            return _main_js__WEBPACK_IMPORTED_MODULE_4__[\"setupRPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"waitForInitialization\", function() {\n            return _main_js__WEBPACK_IMPORTED_MODULE_4__[\"waitForInitialization\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(\n            /*! ../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_5___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_5__[\"version\"];\n          });\n          class Connection2 extends _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"MessageEmitter\"] {\n            constructor(config) {\n              super(config && config.debug);\n              this.config = config || {};\n              this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            }\n            init() {\n              return new Promise((resolve, reject) => {\n                const config = this.config;\n                const url = config.server_url;\n                const extraHeaders = {};\n                if (config.token) {\n                  extraHeaders.Authorization = \"Bearer \" + config.token;\n                }\n                const basePath = new URL(url).pathname;\n                const socket = Object(socket_io_client__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(url, {\n                  withCredentials: true,\n                  extraHeaders,\n                  path: (basePath.endsWith(\"/\") ? basePath.slice(0, -1) : basePath) + \"/socket.io\"\n                });\n                let connected = false;\n                socket.on(\"connect\", () => {\n                  if (connected) {\n                    console.warn(\"Skipping reconnect to the server\");\n                    return;\n                  }\n                  socket.emit(\"register_plugin\", config, (result) => {\n                    if (!result.success) {\n                      console.error(result.detail);\n                      reject(result.detail);\n                      return;\n                    }\n                    connected = true;\n                    this.plugin_id = result.plugin_id;\n                    socket.on(\"plugin_message\", (data) => {\n                      if (data.peer_id === this.peer_id) {\n                        this._fire(data.type, data);\n                      } else if (this.config.debug) {\n                        console.log(`connection peer id mismatch ${data.peer_id} !== ${this.peer_id}`);\n                      }\n                    });\n                    this.once(\"initialize\", () => {\n                      if (!this.rpc) {\n                        this.rpc = Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__2[\"connectRPC\"])(this, config);\n                      } else {\n                        this.rpc.once(\"remoteReady\", () => {\n                          this.rpc.sendInterface();\n                        });\n                      }\n                      this.connect();\n                      resolve();\n                    });\n                    this.emit({\n                      type: \"imjoyRPCReady\",\n                      config,\n                      peer_id: this.peer_id\n                    });\n                  });\n                  this._disconnected = false;\n                });\n                socket.on(\"connect_error\", () => {\n                  reject(\"connection error\");\n                  this._fire(\"connectFailure\");\n                });\n                socket.on(\"disconnect\", () => {\n                  reject(\"disconnected\");\n                  this.disconnect();\n                  this._fire(\"disconnected\");\n                });\n                this.socket = socket;\n              });\n            }\n            connect() {\n              this.emit({\n                type: \"initialized\",\n                config: this.config,\n                origin: globalThis.location.origin,\n                peer_id: this.peer_id\n              });\n              this._fire(\"connected\");\n            }\n            reset() {\n              this._event_handlers = {};\n              this._once_handlers = {};\n            }\n            execute() {\n              throw new Error(\"Execution is not allowed for socketio connection\");\n            }\n            disconnect() {\n              this._fire(\"beforeDisconnect\");\n              this.socket.disconnect();\n              this.init();\n              this._fire(\"disconnected\");\n            }\n            emit(data) {\n              data.plugin_id = this.plugin_id;\n              this.socket.emit(\"plugin_message\", data, (result) => {\n                if (!result.success)\n                  this._fire(\"error\", data.detail);\n              });\n            }\n          }\n          function connectToServer(config) {\n            config = config || {};\n            if (!config.server_url)\n              throw new Error(\"Server URL is not specified.\");\n            config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"normalizeConfig\"])(config);\n            return new Promise((resolve, reject) => {\n              const handleEvent = (e) => {\n                const api = e.detail;\n                if (config.expose_api_globally) {\n                  globalThis.api = api;\n                }\n                resolve(api);\n                globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              };\n              globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              config = config || {};\n              config.dedicated_thread = false;\n              config.lang = \"javascript\";\n              config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__2[\"API_VERSION\"];\n              const conn = new Connection2(config);\n              conn.init().catch(reject);\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/utils.js\": (\n        /*!**********************!*\\\n          !*** ./src/utils.js ***!\n          \\**********************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_362459__) {\n          \"use strict\";\n          __nested_webpack_require_362459__.r(__nested_webpack_exports__);\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_362459__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/dist/imjoy-rpc.js":
/*!**************************************************!*\
  !*** ./node_modules/imjoy-rpc/dist/imjoy-rpc.js ***!
  \**************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true)\n    module.exports = factory();\n  else {}\n})(this, function() {\n  return (\n    /******/\n    function(modules) {\n      var installedModules = {};\n      function __webpack_require__2(moduleId) {\n        if (installedModules[moduleId]) {\n          return installedModules[moduleId].exports;\n        }\n        var module2 = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n          /******/\n          l: false,\n          /******/\n          exports: {}\n          /******/\n        };\n        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);\n        module2.l = true;\n        return module2.exports;\n      }\n      __webpack_require__2.m = modules;\n      __webpack_require__2.c = installedModules;\n      __webpack_require__2.d = function(exports2, name, getter) {\n        if (!__webpack_require__2.o(exports2, name)) {\n          Object.defineProperty(exports2, name, { enumerable: true, get: getter });\n        }\n      };\n      __webpack_require__2.r = function(exports2) {\n        if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n          Object.defineProperty(exports2, Symbol.toStringTag, { value: \"Module\" });\n        }\n        Object.defineProperty(exports2, \"__esModule\", { value: true });\n      };\n      __webpack_require__2.t = function(value, mode) {\n        if (mode & 1)\n          value = __webpack_require__2(value);\n        if (mode & 8)\n          return value;\n        if (mode & 4 && typeof value === \"object\" && value && value.__esModule)\n          return value;\n        var ns = /* @__PURE__ */ Object.create(null);\n        __webpack_require__2.r(ns);\n        Object.defineProperty(ns, \"default\", { enumerable: true, value });\n        if (mode & 2 && typeof value != \"string\")\n          for (var key in value)\n            __webpack_require__2.d(ns, key, function(key2) {\n              return value[key2];\n            }.bind(null, key));\n        return ns;\n      };\n      __webpack_require__2.n = function(module2) {\n        var getter = module2 && module2.__esModule ? (\n          /******/\n          function getDefault() {\n            return module2[\"default\"];\n          }\n        ) : (\n          /******/\n          function getModuleExports() {\n            return module2;\n          }\n        );\n        __webpack_require__2.d(getter, \"a\", getter);\n        return getter;\n      };\n      __webpack_require__2.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      __webpack_require__2.p = \"\";\n      return __webpack_require__2(__webpack_require__2.s = \"./src/main.js\");\n    }({\n      /***/\n      \"./node_modules/worker-loader/dist/workers/InlineWorker.js\": (\n        /*!*****************************************************************!*\\\n          !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!\n          \\*****************************************************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          \"use strict\";\n          var URL = window.URL || window.webkitURL;\n          module2.exports = function(content, url) {\n            try {\n              try {\n                var blob;\n                try {\n                  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n                  blob = new BlobBuilder();\n                  blob.append(content);\n                  blob = blob.getBlob();\n                } catch (e) {\n                  blob = new Blob([content]);\n                }\n                return new Worker(URL.createObjectURL(blob));\n              } catch (e) {\n                return new Worker(\"data:application/javascript,\" + encodeURIComponent(content));\n              }\n            } catch (e) {\n              if (!url) {\n                throw Error(\"Inline worker is not supported\");\n              }\n              return new Worker(url);\n            }\n          };\n        }\n      ),\n      /***/\n      \"./package.json\": (\n        /*!**********************!*\\\n          !*** ./package.json ***!\n          \\**********************/\n        /*! exports provided: name, version, description, module, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, eslintConfig, default */\n        /***/\n        function(module2) {\n          module2.exports = JSON.parse('{\"name\":\"imjoy-rpc\",\"version\":\"0.5.59\",\"description\":\"Remote procedure calls for ImJoy.\",\"module\":\"index.js\",\"types\":\"index.d.ts\",\"scripts\":{\"build\":\"rm -rf dist && npm run build-umd\",\"build-umd\":\"webpack --config webpack.config.js --mode development && NODE_ENV=production webpack --config webpack.config.js --mode production --devtool source-map \",\"watch\":\"NODE_ENV=production webpack --watch --progress --config webpack.config.js --mode production --devtool source-map\",\"publish-npm\":\"npm install && npm run build && npm publish\",\"serve\":\"webpack-dev-server\",\"stats\":\"webpack --profile --json > stats.json\",\"stats-prod\":\"webpack --profile --json --mode production > stats-prod.json\",\"analyze\":\"webpack-bundle-analyzer -p 9999 stats.json\",\"analyze-prod\":\"webpack-bundle-analyzer -p 9999 stats-prod.json\",\"clean\":\"rimraf dist/*\",\"deploy\":\"npm run build && node deploy-site.js\",\"format\":\"prettier --write \\\\\"{src,tests}/**/**\\\\\"\",\"check-format\":\"prettier --check \\\\\"{src,tests}/**/**\\\\\"\",\"test\":\"karma start --single-run --browsers ChromeHeadless,FirefoxHeadless karma.conf.js\",\"test-watch\":\"karma start --auto-watch --browsers ChromeDebugging karma.conf.js --debug\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/imjoy-team/imjoy-rpc.git\"},\"keywords\":[\"imjoy\",\"rpc\"],\"author\":\"imjoy-team <imjoy.team@gmail.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/imjoy-team/imjoy-rpc/issues\"},\"homepage\":\"https://github.com/imjoy-team/imjoy-rpc\",\"dependencies\":{\"@msgpack/msgpack\":\"^2.7.1\",\"socket.io-client\":\"^4.6.2\"},\"devDependencies\":{\"@babel/core\":\"^7.16.12\",\"@babel/plugin-syntax-dynamic-import\":\"^7.8.3\",\"@babel/polyfill\":\"^7.12.1\",\"@babel/preset-env\":\"^7.16.11\",\"@types/requirejs\":\"^2.1.34\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^10.1.0\",\"babel-loader\":\"^8.2.3\",\"babel-runtime\":\"^6.26.0\",\"chai\":\"^4.3.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^5.1.2\",\"eslint\":\"^6.8.0\",\"eslint-config-prettier\":\"^4.2.0\",\"eslint-loader\":\"^4.0.2\",\"file-loader\":\"^0.11.2\",\"fs-extra\":\"^0.30.0\",\"gh-pages\":\"^2.0.1\",\"html-loader\":\"^0.5.5\",\"html-webpack-plugin\":\"^3.2.0\",\"json-loader\":\"^0.5.4\",\"karma\":\"^6.3.12\",\"karma-chrome-launcher\":\"^3.1.0\",\"karma-firefox-launcher\":\"^1.3.0\",\"karma-mocha\":\"^2.0.1\",\"karma-sourcemap-loader\":\"^0.3.8\",\"karma-spec-reporter\":\"0.0.32\",\"karma-webpack\":\"^4.0.2\",\"lerna\":\"^6.0.3\",\"lodash.debounce\":\"^4.0.8\",\"mocha\":\"^10.1.0\",\"postcss\":\"^7.0.36\",\"prettier\":\"^1.6.1\",\"rimraf\":\"^2.6.2\",\"schema-utils\":\"^0.4.3\",\"style-loader\":\"^0.18.1\",\"ts-loader\":\"^9.4.3\",\"url-loader\":\"^0.5.9\",\"webpack\":\"^4.46.0\",\"webpack-bundle-analyzer\":\"^4.7.0\",\"webpack-cli\":\"^3.3.12\",\"webpack-dev-server\":\"^3.11.3\",\"webpack-merge\":\"^4.1.1\",\"workbox-webpack-plugin\":\"^4.3.1\",\"worker-loader\":\"^2.0.0\",\"write-file-webpack-plugin\":\"^4.5.1\"},\"eslintConfig\":{\"globals\":{\"document\":true,\"window\":true}}}');\n        }\n      ),\n      /***/\n      \"./src/main.js\": (\n        /*!*********************!*\\\n          !*** ./src/main.js ***!\n          \\*********************/\n        /*! exports provided: RPC, API_VERSION, VERSION, loadRequirements, waitForInitialization, setupRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"waitForInitialization\", function() {\n            return waitForInitialization;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"setupRPC\", function() {\n            return setupRPC;\n          });\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./plugin.webworker.js */\n            \"./src/plugin.webworker.js\"\n          );\n          var _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0__);\n          var _pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(\n            /*! ./pluginIframe.js */\n            \"./src/pluginIframe.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__2 = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"loadRequirements\", function() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"loadRequirements\"];\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"RPC\"];\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return _rpc_js__WEBPACK_IMPORTED_MODULE_3__[\"API_VERSION\"];\n          });\n          var _package_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(\n            /*! ../package.json */\n            \"./package.json\"\n          );\n          var _package_json__WEBPACK_IMPORTED_MODULE_4___namespace = /* @__PURE__ */ __webpack_require__2.t(\n            /*! ../package.json */\n            \"./package.json\",\n            1\n          );\n          __webpack_require__2.d(__webpack_exports__2, \"VERSION\", function() {\n            return _package_json__WEBPACK_IMPORTED_MODULE_4__[\"version\"];\n          });\n          function _inIframe() {\n            try {\n              return window.self !== window.top;\n            } catch (e) {\n              return true;\n            }\n          }\n          function _inWebWorker2() {\n            return typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          }\n          function setupWebWorker(config) {\n            if (!config.allow_execution)\n              throw new Error(\"web-worker plugin can only work with allow_execution=true\");\n            let broadcastChannel = null;\n            if (config.broadcastChannel) {\n              broadcastChannel = new BroadcastChannel(config.broadcastChannel);\n            }\n            const worker = new _plugin_webworker_js__WEBPACK_IMPORTED_MODULE_0___default.a();\n            const fallbackTimeout = setTimeout(function() {\n              worker.terminate();\n              console.warn(`Plugin failed to start as a web-worker, running in an iframe instead.`);\n              Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n            }, 2e3);\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            worker.addEventListener(\"message\", function(e) {\n              let transferables = void 0;\n              const m = e.data;\n              if (m.type === \"worker-ready\") {\n                worker.postMessage({\n                  type: \"connectRPC\",\n                  config\n                });\n                clearTimeout(fallbackTimeout);\n                return;\n              } else if (m.type === \"initialized\") {\n                m.config = Object.assign({}, config, m.config);\n                m.origin = globalThis.location.origin;\n                m.peer_id = peer_id;\n              } else if (m.type === \"imjoy_remote_api_ready\") {\n                globalThis.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: null\n                }));\n              } else if (m.type === \"cacheRequirements\" && typeof cache_requirements === \"function\") {\n                cache_requirements(m.requirements);\n              } else if (m.type === \"disconnect\") {\n                worker.terminate();\n              } else {\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n              }\n              if (broadcastChannel)\n                broadcastChannel.postMessage(m);\n              else\n                parent.postMessage(m, config.target_origin || \"*\", transferables);\n            });\n            (broadcastChannel || window).addEventListener(\"message\", function(e) {\n              if (e.type === \"message\" && (broadcastChannel || config.target_origin === \"*\" || e.origin === config.target_origin)) {\n                let transferables = void 0;\n                const m = e.data;\n                if (m.__transferables__) {\n                  transferables = m.__transferables__;\n                  delete m.__transferables__;\n                }\n                if (m.peer_id === peer_id) {\n                  worker.postMessage(m, transferables);\n                } else if (config.debug) {\n                  console.log(`connection peer id mismatch ${m.peer_id} !== ${peer_id}`);\n                }\n              }\n            });\n          }\n          function waitForInitialization(config) {\n            if (_inWebWorker2()) {\n              globalThis.parent = self;\n            }\n            config = config || {};\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n              config.enable_service_worker = false;\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            const targetOrigin = config.target_origin || \"*\";\n            if (config.credential_required && typeof config.verify_credential !== \"function\") {\n              throw new Error(\"Please also provide the `verify_credential` function with `credential_required`.\");\n            }\n            if (config.credential_required && targetOrigin === \"*\") {\n              throw new Error(\"`target_origin` was set to `*` with `credential_required=true`, there is a security risk that you may leak the credential to website from other origin. Please specify the `target_origin` explicitly.\");\n            }\n            const done = () => {\n              globalThis.removeEventListener(\"message\", handleEvent);\n            };\n            const peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            const handleEvent = (e) => {\n              if (e.type === \"message\" && (!e.origin || targetOrigin === \"*\" || e.origin === targetOrigin)) {\n                if (e.data.type === \"initialize\") {\n                  done();\n                  if (e.data.peer_id !== peer_id) {\n                    console.warn(`${e.data.config && e.data.config.name}: connection peer id mismatch ${e.data.peer_id} !== ${peer_id}`);\n                  }\n                  const cfg = e.data.config;\n                  if (targetOrigin !== \"*\") {\n                    cfg.target_origin = targetOrigin;\n                  }\n                  if (config.credential_required) {\n                    config.verify_credential(cfg.credential).then((result) => {\n                      if (result && result.auth && !result.error) {\n                        cfg.auth = result.auth;\n                        setupRPC(cfg).then(() => {\n                          console.log(\"ImJoy RPC loaded successfully!\");\n                        });\n                      } else {\n                        throw new Error(\"Failed to verify the credentail:\" + (result && result.error));\n                      }\n                    });\n                  } else {\n                    setupRPC(cfg).then(() => {\n                      console.log(\"ImJoy RPC loaded successfully!\");\n                    });\n                  }\n                } else {\n                  throw new Error(`unrecognized message: ${e.data}`);\n                }\n              }\n            };\n            globalThis.addEventListener(\"message\", handleEvent);\n            if (_inWebWorker2()) {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              });\n            } else {\n              parent.postMessage({\n                type: \"imjoyRPCReady\",\n                config,\n                peer_id\n              }, \"*\");\n            }\n          }\n          function setupRPC(config) {\n            config = config || {};\n            config.name = config.name || Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"randId\"])();\n            config = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"normalizeConfig\"])(config);\n            if (config.enable_service_worker) {\n              Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__2[\"setupServiceWorker\"])(config.base_url, config.target_origin, config.cache_requirements);\n            }\n            if (config.cache_requirements) {\n              delete config.cache_requirements;\n            }\n            return new Promise((resolve, reject) => {\n              const handleEvent = (e) => {\n                const api = e.detail;\n                if (config.expose_api_globally) {\n                  globalThis.api = api;\n                }\n                resolve(api);\n                globalThis.removeEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              };\n              if (_inIframe()) {\n                if (config.type === \"web-worker\") {\n                  try {\n                    setupWebWorker(config);\n                  } catch (e) {\n                    Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                  }\n                } else if ([\"rpc-window\", \"rpc-worker\", \"iframe\", \"window\"].includes(config.type)) {\n                  Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n                } else {\n                  console.error(\"Unsupported plugin type: \" + config.type);\n                  reject(\"Unsupported plugin type: \" + config.type);\n                  return;\n                }\n                globalThis.addEventListener(\"imjoy_remote_api_ready\", handleEvent);\n              } else if (_inWebWorker2()) {\n                Object(_pluginIframe_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(config);\n              } else {\n                reject(new Error(\"imjoy-rpc should only run inside an iframe or a webworker.\"));\n              }\n            });\n          }\n        }\n      ),\n      /***/\n      \"./src/plugin.webworker.js\": (\n        /*!*********************************!*\\\n          !*** ./src/plugin.webworker.js ***!\n          \\*********************************/\n        /*! no static exports found */\n        /***/\n        function(module2, exports2, __webpack_require__2) {\n          module2.exports = function() {\n            return __webpack_require__2(\n              /*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */\n              \"./node_modules/worker-loader/dist/workers/InlineWorker.js\"\n            )('/******/ (function(modules) { // webpackBootstrap\\n/******/ \t// The module cache\\n/******/ \tvar installedModules = {};\\n/******/\\n/******/ \t// The require function\\n/******/ \tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \t\t// Check if module is in cache\\n/******/ \t\tif(installedModules[moduleId]) {\\n/******/ \t\t\treturn installedModules[moduleId].exports;\\n/******/ \t\t}\\n/******/ \t\t// Create a new module (and put it into the cache)\\n/******/ \t\tvar module = installedModules[moduleId] = {\\n/******/ \t\t\ti: moduleId,\\n/******/ \t\t\tl: false,\\n/******/ \t\t\texports: {}\\n/******/ \t\t};\\n/******/\\n/******/ \t\t// Execute the module function\\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \t\t// Flag the module as loaded\\n/******/ \t\tmodule.l = true;\\n/******/\\n/******/ \t\t// Return the exports of the module\\n/******/ \t\treturn module.exports;\\n/******/ \t}\\n/******/\\n/******/\\n/******/ \t// expose the modules object (__webpack_modules__)\\n/******/ \t__webpack_require__.m = modules;\\n/******/\\n/******/ \t// expose the module cache\\n/******/ \t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \t// define getter function for harmony exports\\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \t\t}\\n/******/ \t};\\n/******/\\n/******/ \t// define __esModule on exports\\n/******/ \t__webpack_require__.r = function(exports) {\\n/******/ \t\tif(typeof Symbol !== \\'undefined\\' && Symbol.toStringTag) {\\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \\'Module\\' });\\n/******/ \t\t}\\n/******/ \t\tObject.defineProperty(exports, \\'__esModule\\', { value: true });\\n/******/ \t};\\n/******/\\n/******/ \t// create a fake namespace object\\n/******/ \t// mode & 1: value is a module id, require it\\n/******/ \t// mode & 2: merge all properties of value into the ns\\n/******/ \t// mode & 4: return value when already ns object\\n/******/ \t// mode & 8|1: behave like require\\n/******/ \t__webpack_require__.t = function(value, mode) {\\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \t\tif(mode & 8) return value;\\n/******/ \t\tif((mode & 4) && typeof value === \\'object\\' && value && value.__esModule) return value;\\n/******/ \t\tvar ns = Object.create(null);\\n/******/ \t\t__webpack_require__.r(ns);\\n/******/ \t\tObject.defineProperty(ns, \\'default\\', { enumerable: true, value: value });\\n/******/ \t\tif(mode & 2 && typeof value != \\'string\\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \t\treturn ns;\\n/******/ \t};\\n/******/\\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \t__webpack_require__.n = function(module) {\\n/******/ \t\tvar getter = module && module.__esModule ?\\n/******/ \t\t\tfunction getDefault() { return module[\\'default\\']; } :\\n/******/ \t\t\tfunction getModuleExports() { return module; };\\n/******/ \t\t__webpack_require__.d(getter, \\'a\\', getter);\\n/******/ \t\treturn getter;\\n/******/ \t};\\n/******/\\n/******/ \t// Object.prototype.hasOwnProperty.call\\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \t// __webpack_public_path__\\n/******/ \t__webpack_require__.p = \"\";\\n/******/\\n/******/\\n/******/ \t// Load entry module and return exports\\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/plugin.webworker.js\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \"./src/plugin.webworker.js\":\\n/*!*********************************!*\\\\\\n  !*** ./src/plugin.webworker.js ***!\\n  \\\\*********************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginCore.js */ \"./src/pluginCore.js\");\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the routines loaded by the plugin Worker under web-browser.\\n *\\n * Initializes the web environment version of the platform-dependent\\n * connection object for the plugin site\\n */\\n\\n\\n\\n\\n// make sure this runs inside a webworker\\nif (\\n  typeof WorkerGlobalScope === \"undefined\" ||\\n  !self ||\\n  !(self instanceof WorkerGlobalScope)\\n) {\\n  throw new Error(\"This script can only loaded in a webworker\");\\n}\\n\\nasync function executeEsModule(content) {\\n  const dataUri =\\n    \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\\n  await import(/* webpackIgnore: true */ dataUri);\\n}\\n\\n/**\\n * Connection object provided to the RPC constructor,\\n * plugin site implementation for the web-based environment.\\n * Global will be then cleared to prevent exposure into the\\n * Worker, so we put this local connection object into a closure\\n */\\nclass Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\\n  constructor(config) {\\n    super(config && config.debug);\\n    this.config = config || {};\\n  }\\n  connect() {\\n    self.addEventListener(\"message\", e => {\\n      this._fire(e.data.type, e.data);\\n    });\\n    this.emit({\\n      type: \"initialized\",\\n      config: this.config\\n    });\\n  }\\n  disconnect() {\\n    this._fire(\"beforeDisconnect\");\\n    self.close();\\n    this._fire(\"disconnected\");\\n  }\\n  emit(data) {\\n    let transferables = undefined;\\n    if (data.__transferables__) {\\n      transferables = data.__transferables__;\\n      delete data.__transferables__;\\n    }\\n    self.postMessage(data, transferables);\\n  }\\n  async execute(code) {\\n    if (code.type === \"requirements\") {\\n      await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWebworker\"])(code.requirements);\\n    } else if (code.type === \"script\") {\\n      try {\\n        if (code.attrs.type === \"module\") {\\n          await executeEsModule(code.content);\\n        } else {\\n          eval(code.content);\\n        }\\n      } catch (e) {\\n        console.error(e.message, e.stack);\\n        throw e;\\n      }\\n    } else {\\n      throw \"unsupported code type.\";\\n    }\\n    if (code.type === \"requirements\") {\\n      self.postMessage({\\n        type: \"cacheRequirements\",\\n        requirements: code.requirements\\n      });\\n    }\\n  }\\n}\\nconst config = {\\n  type: \"web-worker\",\\n  dedicated_thread: true,\\n  allow_execution: true,\\n  lang: \"javascript\",\\n  api_version: _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"]\\n};\\nconst conn = new Connection(config);\\nconn.on(\"connectRPC\", data => {\\n  Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, Object.assign(data.config, config));\\n});\\nconn.connect();\\nself.postMessage({\\n  type: \"worker-ready\"\\n});\\n\\n\\n/***/ }),\\n\\n/***/ \"./src/pluginCore.js\":\\n/*!***************************!*\\\\\\n  !*** ./src/pluginCore.js ***!\\n  \\\\***************************/\\n/*! exports provided: connectRPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"connectRPC\", function() { return connectRPC; });\\n/* harmony import */ var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpc.js */ \"./src/rpc.js\");\\n/**\\n * Core plugin script loaded into the plugin process/thread.\\n *\\n * Initializes the plugin-site API global methods.\\n */\\n\\nfunction connectRPC(connection, config) {\\n  config = config || {};\\n  const codecs = {};\\n  const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\\n  rpc.on(\"getInterface\", function () {\\n    launchConnected();\\n  });\\n  rpc.on(\"remoteReady\", function () {\\n    const api = rpc.getRemote() || {};\\n\\n    api.registerCodec = function (config) {\\n      if (!config[\"name\"] || !config[\"encoder\"] && !config[\"decoder\"]) {\\n        throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\\n      } else {\\n        if (config.type) {\\n          for (let k of Object.keys(codecs)) {\\n            if (codecs[k].type === config.type || k === config.name) {\\n              delete codecs[k];\\n              console.warn(\"Remove duplicated codec: \" + k);\\n            }\\n          }\\n        }\\n\\n        codecs[config[\"name\"]] = config;\\n      }\\n    };\\n\\n    api.init = function (config) {\\n      // register a minimal plugin api\\n      rpc.setInterface({\\n        setup() {}\\n\\n      }, config);\\n    };\\n\\n    api.disposeObject = function (obj) {\\n      rpc.disposeObject(obj);\\n    };\\n\\n    api.export = function (_interface, config) {\\n      rpc.setInterface(_interface, config);\\n    };\\n\\n    api.onLoad = function (handler) {\\n      handler = checkHandler(handler);\\n\\n      if (connected) {\\n        handler();\\n      } else {\\n        connectedHandlers.push(handler);\\n      }\\n    };\\n\\n    api.dispose = function (_interface) {\\n      rpc.disconnect();\\n    };\\n\\n    api._rpc = rpc;\\n\\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n      self.api = api;\\n      self.postMessage({\\n        type: \"imjoy_remote_api_ready\"\\n      });\\n      self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    } else if (typeof window) {\\n      window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\\n        detail: api\\n      }));\\n    }\\n  });\\n  let connected = false;\\n  const connectedHandlers = [];\\n\\n  const launchConnected = function () {\\n    if (!connected) {\\n      connected = true;\\n      let handler;\\n\\n      while (handler = connectedHandlers.pop()) {\\n        handler();\\n      }\\n    }\\n  };\\n\\n  const checkHandler = function (handler) {\\n    const type = typeof handler;\\n\\n    if (type !== \"function\") {\\n      const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\\n      throw new Error(msg);\\n    }\\n\\n    return handler;\\n  };\\n\\n  return rpc;\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/rpc.js\":\\n/*!********************!*\\\\\\n  !*** ./src/rpc.js ***!\\n  \\\\********************/\\n/*! exports provided: API_VERSION, RPC */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"API_VERSION\", function() { return API_VERSION; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RPC\", function() { return RPC; });\\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\\n/**\\n * Contains the RPC object used both by the application\\n * site, and by each plugin\\n */\\n\\nconst API_VERSION = \"0.2.3\";\\nconst ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\\n\\nfunction _appendBuffer(buffer1, buffer2) {\\n  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\\n  tmp.set(new Uint8Array(buffer1), 0);\\n  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\\n  return tmp.buffer;\\n}\\n\\nfunction indexObject(obj, is) {\\n  if (!is) throw new Error(\"undefined index\");\\n  if (typeof is === \"string\") return indexObject(obj, is.split(\".\"));else if (is.length === 0) return obj;else return indexObject(obj[is[0]], is.slice(1));\\n}\\n/**\\n * RPC object represents a single site in the\\n * communication protocol between the application and the plugin\\n *\\n * @param {Object} connection a special object allowing to send\\n * and receive messages from the opposite site (basically it\\n * should only provide send() and onMessage() methods)\\n */\\n\\n\\nclass RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\\n  constructor(connection, config, codecs) {\\n    super(config && config.debug);\\n    this._connection = connection;\\n    this.config = config || {};\\n    this._codecs = codecs || {};\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._remote_set = false; // make sure there is an execute function\\n\\n    const name = this.config.name;\\n\\n    this._connection.execute = this._connection.execute || function () {\\n      throw new Error(`connection.execute not implemented (in \"${name}\")`);\\n    };\\n\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n\\n    this._method_refs.onReady(() => {\\n      this._fire(\"remoteIdle\");\\n    });\\n\\n    this._method_refs.onBusy(() => {\\n      this._fire(\"remoteBusy\");\\n    });\\n\\n    this._setupMessageHanlders();\\n  }\\n\\n  init() {\\n    this._connection.emit({\\n      type: \"initialized\",\\n      config: this.config,\\n      peer_id: this._connection.peer_id\\n    });\\n  }\\n\\n  setConfig(config) {\\n    if (config) for (const k of Object.keys(config)) {\\n      this.config[k] = config[k];\\n    }\\n  }\\n  /**\\n   * Set a handler to be called when received a responce from the\\n   * remote site reporting that the previously provided interface\\n   * has been successfully set as remote for that site\\n   *\\n   * @param {Function} handler\\n   */\\n\\n\\n  getRemoteCallStack() {\\n    return this._method_refs.getStack();\\n  }\\n  /**\\n   * @returns {Object} set of remote interface methods\\n   */\\n\\n\\n  getRemote() {\\n    return this._remote_interface;\\n  }\\n  /**\\n   * Sets the interface of this site making it available to the\\n   * remote site by sending a message with a set of methods names\\n   *\\n   * @param {Object} _interface to set\\n   */\\n\\n\\n  setInterface(_interface, config) {\\n    config = config || {};\\n    this.config.name = config.name || this.config.name;\\n    this.config.description = config.description || this.config.description;\\n\\n    if (this.config.forwarding_functions) {\\n      for (let func_name of this.config.forwarding_functions) {\\n        const _remote = this._remote_interface;\\n\\n        if (_remote[func_name]) {\\n          if (_interface.constructor === Object) {\\n            if (!_interface[func_name]) {\\n              _interface[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          } else if (_interface.constructor.constructor === Function) {\\n            if (!_interface.constructor.prototype[func_name]) {\\n              _interface.constructor.prototype[func_name] = (...args) => {\\n                _remote[func_name](...args);\\n              };\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    this._local_api = _interface;\\n    if (!this._remote_set) this._fire(\"interfaceAvailable\");else this.sendInterface();\\n    return new Promise(resolve => {\\n      this.once(\"interfaceSetAsRemote\", resolve);\\n    });\\n  }\\n  /**\\n   * Sends the actual interface to the remote site upon it was\\n   * updated or by a special request of the remote site\\n   */\\n\\n\\n  sendInterface() {\\n    if (!this._local_api) {\\n      throw new Error(\"interface is not set.\");\\n    }\\n\\n    this._encode(this._local_api, true).then(api => {\\n      this._connection.emit({\\n        type: \"setInterface\",\\n        api: api\\n      });\\n    });\\n  }\\n\\n  _disposeObject(objectId) {\\n    if (this._object_store[objectId]) {\\n      delete this._object_store[objectId];\\n    } else {\\n      throw new Error(`Object (id=${objectId}) not found.`);\\n    }\\n  }\\n\\n  disposeObject(obj) {\\n    return new Promise((resolve, reject) => {\\n      if (this._object_weakmap.has(obj)) {\\n        const objectId = this._object_weakmap.get(obj);\\n\\n        this._connection.once(\"disposed\", data => {\\n          if (data.error) reject(new Error(data.error));else resolve();\\n        });\\n\\n        this._connection.emit({\\n          type: \"disposeObject\",\\n          object_id: objectId\\n        });\\n      } else {\\n        throw new Error(\"Invalid object\");\\n      }\\n    });\\n  }\\n  /**\\n   * Handles a message from the remote site\\n   */\\n\\n\\n  _setupMessageHanlders() {\\n    this._connection.on(\"init\", this.init);\\n\\n    this._connection.on(\"execute\", data => {\\n      Promise.resolve(this._connection.execute(data.code)).then(() => {\\n        this._connection.emit({\\n          type: \"executed\"\\n        });\\n      }).catch(e => {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"executed\",\\n          error: String(e)\\n        });\\n      });\\n    });\\n\\n    this._connection.on(\"method\", async data => {\\n      let resolve, reject, method, method_this, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        const _interface = this._object_store[data.object_id];\\n        method = indexObject(_interface, data.name);\\n\\n        if (data.name.includes(\".\")) {\\n          const tmp = data.name.split(\".\");\\n          const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\\n          method_this = indexObject(_interface, intf_index);\\n        } else {\\n          method_this = _interface;\\n        }\\n\\n        args = await this._unwrap(data.args, true);\\n\\n        if (data.promise) {\\n          result = method.apply(method_this, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method.apply(method_this, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"callback\", async data => {\\n      let resolve, reject, method, args, result;\\n\\n      try {\\n        if (data.promise) {\\n          [resolve, reject] = await this._unwrap(data.promise, false);\\n        }\\n\\n        if (data.promise) {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          result = method.apply(null, args);\\n\\n          if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\\n            result.then(resolve).catch(reject);\\n          } else {\\n            resolve(result);\\n          }\\n        } else {\\n          method = this._store.fetch(data.id);\\n          args = await this._unwrap(data.args, true);\\n\\n          if (!method) {\\n            throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\\n          }\\n\\n          method.apply(null, args);\\n        }\\n      } catch (err) {\\n        console.error(this.config.name, err);\\n\\n        if (reject) {\\n          reject(err);\\n        }\\n      }\\n    });\\n\\n    this._connection.on(\"disposeObject\", data => {\\n      try {\\n        this._disposeObject(data.object_id);\\n\\n        this._connection.emit({\\n          type: \"disposed\"\\n        });\\n      } catch (e) {\\n        console.error(e);\\n\\n        this._connection.emit({\\n          type: \"disposed\",\\n          error: String(e)\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"setInterface\", data => {\\n      this._setRemoteInterface(data.api);\\n    });\\n\\n    this._connection.on(\"getInterface\", () => {\\n      this._fire(\"getInterface\");\\n\\n      if (this._local_api) {\\n        this.sendInterface();\\n      } else {\\n        this.once(\"interfaceAvailable\", () => {\\n          this.sendInterface();\\n        });\\n      }\\n    });\\n\\n    this._connection.on(\"interfaceSetAsRemote\", () => {\\n      this._remote_set = true;\\n\\n      this._fire(\"interfaceSetAsRemote\");\\n    });\\n\\n    this._connection.on(\"disconnect\", () => {\\n      this._fire(\"beforeDisconnect\");\\n\\n      this._connection.disconnect();\\n\\n      this._fire(\"disconnected\");\\n    });\\n  }\\n  /**\\n   * Sends a requests to the remote site asking it to provide its\\n   * current interface\\n   */\\n\\n\\n  requestRemote() {\\n    this._connection.emit({\\n      type: \"getInterface\"\\n    });\\n  }\\n\\n  _ndarray(typedArray, shape, dtype) {\\n    const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\\n\\n    if (dtype && dtype !== _dtype) {\\n      throw \"dtype doesn\\'t match the type of the array: \" + _dtype + \" != \" + dtype;\\n    }\\n\\n    shape = shape || [typedArray.length];\\n    return {\\n      _rtype: \"ndarray\",\\n      _rvalue: typedArray.buffer,\\n      _rshape: shape,\\n      _rdtype: _dtype\\n    };\\n  }\\n  /**\\n   * Sets the new remote interface provided by the other site\\n   *\\n   * @param {Array} names list of function names\\n   */\\n\\n\\n  _setRemoteInterface(api) {\\n    this._decode(api).then(intf => {\\n      // update existing interface instead of recreating it\\n      // this will preserve the object reference\\n      if (this._remote_interface) {\\n        // clear the interface\\n        for (let k in this._remote_interface) delete this._remote_interface[k]; // then assign the new interfaces\\n\\n\\n        Object.assign(this._remote_interface, intf);\\n      } else this._remote_interface = intf;\\n\\n      this._fire(\"remoteReady\");\\n\\n      this._reportRemoteSet();\\n    });\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * method. When the generated function is called, it will send the\\n   * corresponding message to the remote site asking it to execute\\n   * the particular method of its interface\\n   *\\n   * @param {String} name of the remote method\\n   *\\n   * @returns {Function} wrapped remote method\\n   */\\n\\n\\n  _genRemoteMethod(targetId, name, objectId) {\\n    const me = this;\\n\\n    const remoteMethod = function () {\\n      return new Promise(async (resolve, reject) => {\\n        let id = null;\\n\\n        try {\\n          id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\\n\\n          const wrapped_resolve = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return resolve.apply(this, arguments);\\n          };\\n\\n          const wrapped_reject = function () {\\n            if (id !== null) me._method_refs.fetch(id);\\n            return reject.apply(this, arguments);\\n          };\\n\\n          const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]); // store the key id for removing them from the reference store together\\n\\n          wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\\n          let args = Array.prototype.slice.call(arguments);\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n\\n          if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\\n            args = await me._wrap(args, true);\\n          } else {\\n            args = await me._wrap(args);\\n          }\\n\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n\\n          me._connection.emit({\\n            type: \"method\",\\n            target_id: targetId,\\n            name: name,\\n            object_id: objectId,\\n            args: args,\\n            promise: encodedPromise,\\n            with_kwargs: withKwargs\\n          }, transferables);\\n        } catch (e) {\\n          if (id) me._method_refs.fetch(id);\\n          reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\\n        }\\n      });\\n    };\\n\\n    remoteMethod.__remote_method = true;\\n    return remoteMethod;\\n  }\\n  /**\\n   * Sends a responce reporting that interface just provided by the\\n   * remote site was successfully set by this site as remote\\n   */\\n\\n\\n  _reportRemoteSet() {\\n    this._connection.emit({\\n      type: \"interfaceSetAsRemote\"\\n    });\\n  }\\n  /**\\n   * Prepares the provided set of remote method arguments for\\n   * sending to the remote site, replaces all the callbacks with\\n   * identifiers\\n   *\\n   * @param {Array} args to wrap\\n   *\\n   * @returns {Array} wrapped arguments\\n   */\\n\\n\\n  async _encode(aObject, asInterface, objectId) {\\n    const aType = typeof aObject;\\n\\n    if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === undefined || aObject instanceof ArrayBuffer) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (typeof aObject === \"function\") {\\n      if (asInterface) {\\n        if (!objectId) throw new Error(\"objectId is not specified.\");\\n        bObject = {\\n          _rtype: \"interface\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rintf: objectId,\\n          _rvalue: asInterface\\n        };\\n\\n        this._method_weakmap.set(aObject, bObject);\\n      } else if (this._method_weakmap.has(aObject)) {\\n        bObject = this._method_weakmap.get(aObject);\\n      } else {\\n        const cid = this._store.put(aObject);\\n\\n        bObject = {\\n          _rtype: \"callback\",\\n          _rtarget_id: this._connection.peer_id,\\n          _rname: aObject.constructor && aObject.constructor.name || cid,\\n          _rvalue: cid\\n        };\\n      }\\n\\n      return bObject;\\n    } // skip if already encoded\\n\\n\\n    if (aObject.constructor instanceof Object && aObject._rtype) {\\n      // make sure the interface functions are encoded\\n      if (aObject._rintf) {\\n        const temp = aObject._rtype;\\n        delete aObject._rtype;\\n        bObject = await this._encode(aObject, asInterface, objectId);\\n        bObject._rtype = temp;\\n      } else {\\n        bObject = aObject;\\n      }\\n\\n      return bObject;\\n    }\\n\\n    const transferables = [];\\n    const _transfer = aObject._transfer;\\n    const isarray = Array.isArray(aObject);\\n\\n    for (let tp of Object.keys(this._codecs)) {\\n      const codec = this._codecs[tp];\\n\\n      if (codec.encoder && aObject instanceof codec.type) {\\n        // TODO: what if multiple encoders found\\n        let encodedObj = await Promise.resolve(codec.encoder(aObject));\\n        if (encodedObj && !encodedObj._rtype) encodedObj._rtype = codec.name; // encode the functions in the interface object\\n\\n        if (encodedObj && encodedObj._rintf) {\\n          const temp = encodedObj._rtype;\\n          delete encodedObj._rtype;\\n          encodedObj = await this._encode(encodedObj, asInterface, objectId);\\n          encodedObj._rtype = temp;\\n        }\\n\\n        bObject = encodedObj;\\n        return bObject;\\n      }\\n    }\\n\\n    if (\\n    /*global tf*/\\n    typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor) {\\n      const v_buffer = aObject.dataSync();\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(v_buffer.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: v_buffer.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: aObject.dtype\\n      };\\n    } else if (\\n    /*global nj*/\\n    typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray) {\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\\n\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.selection.data.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"ndarray\",\\n        _rvalue: aObject.selection.data.buffer,\\n        _rshape: aObject.shape,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof Error) {\\n      console.error(aObject);\\n      bObject = {\\n        _rtype: \"error\",\\n        _rvalue: aObject.toString()\\n      };\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } // send objects supported by structure clone algorithm\\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\\n    else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\\n      bObject = aObject; // TODO: avoid object such as DynamicPlugin instance.\\n    } else if (typeof File !== \"undefined\" && aObject instanceof File) {\\n      bObject = {\\n        _rtype: \"file\",\\n        _rname: aObject.name,\\n        _rmime: aObject.type,\\n        _rvalue: aObject,\\n        _rpath: aObject._path || aObject.webkitRelativePath\\n      };\\n    } else if (aObject instanceof Blob) {\\n      bObject = {\\n        _rtype: \"blob\",\\n        _rvalue: aObject\\n      };\\n    } else if (aObject instanceof ArrayBufferView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\\n      bObject = {\\n        _rtype: \"typedarray\",\\n        _rvalue: aObject.buffer,\\n        _rdtype: dtype\\n      };\\n    } else if (aObject instanceof DataView) {\\n      if (aObject._transfer || _transfer) {\\n        transferables.push(aObject.buffer);\\n        delete aObject._transfer;\\n      }\\n\\n      bObject = {\\n        _rtype: \"memoryview\",\\n        _rvalue: aObject.buffer\\n      };\\n    } else if (aObject instanceof Set) {\\n      bObject = {\\n        _rtype: \"set\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject instanceof Map) {\\n      bObject = {\\n        _rtype: \"orderedmap\",\\n        _rvalue: await this._encode(Array.from(aObject), asInterface)\\n      };\\n    } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\\n      bObject = isarray ? [] : {};\\n      let keys; // an object/array\\n\\n      if (aObject.constructor === Object || Array.isArray(aObject)) {\\n        keys = Object.keys(aObject);\\n      } // a class\\n      else if (aObject.constructor === Function) {\\n        throw new Error(\"Please instantiate the class before exportting it.\");\\n      } // instance of a class\\n      else if (aObject.constructor.constructor === Function) {\\n        keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject)); // TODO: use a proxy object to represent the actual object\\n        // always encode class instance as interface\\n\\n        asInterface = true;\\n      } else {\\n        throw Error(\"Unsupported interface type\");\\n      }\\n\\n      let hasFunction = false; // encode interfaces\\n\\n      if (aObject._rintf || asInterface) {\\n        if (!objectId) {\\n          if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\\n            objectId = aObject._rintf; // enable custom object id\\n          } else {\\n            objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n          } // Note: object with the same id will be overwritten\\n\\n\\n          if (this._object_store[objectId]) console.warn(`Overwritting interface object with the same id: ${objectId}`);\\n          this._object_store[objectId] = aObject;\\n        }\\n\\n        for (let k of keys) {\\n          if (k === \"constructor\") continue;\\n\\n          if (k.startsWith(\"_\")) {\\n            continue;\\n          }\\n\\n          bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\\n\\n          if (typeof aObject[k] === \"function\") {\\n            hasFunction = true;\\n          }\\n        } // object id for dispose the object remotely\\n\\n\\n        if (hasFunction) bObject._rintf = objectId; // remove interface when closed\\n\\n        if (aObject.on && typeof aObject.on === \"function\") {\\n          aObject.on(\"close\", () => {\\n            delete this._object_store[objectId];\\n          });\\n        }\\n      } else {\\n        for (let k of keys) {\\n          if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue;\\n          bObject[k] = await this._encode(aObject[k]);\\n        }\\n      } // for example, browserFS object\\n\\n    } else if (typeof aObject === \"object\") {\\n      const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\\n      const objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\\n\\n      for (let k of keys) {\\n        if ([\"hasOwnProperty\", \"constructor\"].includes(k)) continue; // encode as interface\\n\\n        bObject[k] = await this._encode(aObject[k], k, bObject);\\n      } // object id, used for dispose the object\\n\\n\\n      bObject._rintf = objectId;\\n    } else {\\n      throw \"imjoy-rpc: Unsupported data type:\" + aObject;\\n    }\\n\\n    if (transferables.length > 0) {\\n      bObject.__transferables__ = transferables;\\n    }\\n\\n    if (!bObject) {\\n      throw new Error(\"Failed to encode object\");\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _decode(aObject, withPromise) {\\n    if (!aObject) {\\n      return aObject;\\n    }\\n\\n    let bObject;\\n\\n    if (aObject[\"_rtype\"]) {\\n      if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          aObject = await this._decode(aObject, withPromise);\\n          aObject._rtype = temp;\\n        }\\n\\n        bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\\n      } else if (aObject._rtype === \"callback\") {\\n        bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\\n      } else if (aObject._rtype === \"interface\") {\\n        bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\\n      } else if (aObject._rtype === \"ndarray\") {\\n        /*global nj tf*/\\n        //create build array/tensor if used in the plugin\\n        if (typeof nj !== \"undefined\" && nj.array) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\\n        } else if (typeof tf !== \"undefined\" && tf.Tensor) {\\n          if (Array.isArray(aObject._rvalue)) {\\n            aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\\n          }\\n\\n          const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n          bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\\n        } else {\\n          //keep it as regular if transfered to the main app\\n          bObject = aObject;\\n        }\\n      } else if (aObject._rtype === \"error\") {\\n        bObject = new Error(aObject._rvalue);\\n      } else if (aObject._rtype === \"file\") {\\n        if (aObject._rvalue instanceof File) {\\n          bObject = aObject._rvalue; //patch _path\\n\\n          bObject._path = aObject._rpath;\\n        } else {\\n          bObject = new File([aObject._rvalue], aObject._rname, {\\n            type: aObject._rmime\\n          });\\n          bObject._path = aObject._rpath;\\n        }\\n      } else if (aObject._rtype === \"typedarray\") {\\n        const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\\n        if (!arraytype) throw new Error(\"unsupported dtype: \" + aObject._rdtype);\\n        bObject = new arraytype(aObject._rvalue);\\n      } else if (aObject._rtype === \"memoryview\") {\\n        bObject = new DataView(aObject._rvalue);\\n      } else if (aObject._rtype === \"blob\") {\\n        if (aObject._rvalue instanceof Blob) {\\n          bObject = aObject._rvalue;\\n        } else {\\n          bObject = new Blob([aObject._rvalue], {\\n            type: aObject._rmime\\n          });\\n        }\\n      } else if (aObject._rtype === \"orderedmap\") {\\n        bObject = new Map(await this._decode(aObject._rvalue, withPromise));\\n      } else if (aObject._rtype === \"set\") {\\n        bObject = new Set(await this._decode(aObject._rvalue, withPromise));\\n      } else {\\n        // make sure all the interface functions are decoded\\n        if (aObject._rintf) {\\n          const temp = aObject._rtype;\\n          delete aObject._rtype;\\n          bObject = await this._decode(aObject, withPromise);\\n          bObject._rtype = temp;\\n        } else bObject = aObject;\\n      }\\n    } else if (aObject.constructor === Object || Array.isArray(aObject)) {\\n      const isarray = Array.isArray(aObject);\\n      bObject = isarray ? [] : {};\\n\\n      for (let k of Object.keys(aObject)) {\\n        if (isarray || aObject.hasOwnProperty(k)) {\\n          const v = aObject[k];\\n          bObject[k] = await this._decode(v, withPromise);\\n        }\\n      }\\n    } else {\\n      bObject = aObject;\\n    }\\n\\n    if (bObject === undefined) {\\n      throw new Error(\"Failed to decode object\");\\n    } // store the object id for dispose\\n\\n\\n    if (aObject._rintf) {\\n      this._object_weakmap.set(bObject, aObject._rintf);\\n    }\\n\\n    return bObject;\\n  }\\n\\n  async _wrap(args, asInterface) {\\n    return await this._encode(args, asInterface);\\n  }\\n  /**\\n   * Unwraps the set of arguments delivered from the remote site,\\n   * replaces all callback identifiers with a function which will\\n   * initiate sending that callback identifier back to other site\\n   *\\n   * @param {Object} args to unwrap\\n   *\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Array} unwrapped args\\n   */\\n\\n\\n  async _unwrap(args, withPromise) {\\n    return await this._decode(args, withPromise);\\n  }\\n  /**\\n   * Generates the wrapped function corresponding to a single remote\\n   * callback. When the generated function is called, it will send\\n   * the corresponding message to the remote site asking it to\\n   * execute the particular callback previously saved during a call\\n   * by the remote site a method from the interface of this site\\n   *\\n   * @param {Number} id of the remote callback to execute\\n   * @param {Number} argNum argument index of the callback\\n   * @param {Boolean} withPromise is true means this the callback should contain a promise\\n   *\\n   * @returns {Function} wrapped remote callback\\n   */\\n\\n\\n  _genRemoteCallback(targetId, cid, withPromise) {\\n    const me = this;\\n    let remoteCallback;\\n\\n    if (withPromise) {\\n      remoteCallback = function () {\\n        return new Promise(async (resolve, reject) => {\\n          const args = await me._wrap(Array.prototype.slice.call(arguments));\\n          const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n          const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n          if (withKwargs) delete args[argLength - 1]._rkwargs;\\n          const transferables = args.__transferables__;\\n          if (transferables) delete args.__transferables__;\\n          const encodedPromise = await me._wrap([resolve, reject]); // store the key id for removing them from the reference store together\\n\\n          resolve.__promise_pair = encodedPromise[1]._rvalue;\\n          reject.__promise_pair = encodedPromise[0]._rvalue;\\n\\n          try {\\n            me._connection.emit({\\n              type: \"callback\",\\n              target_id: targetId,\\n              id: cid,\\n              args: args,\\n              promise: encodedPromise,\\n              with_kwargs: withKwargs\\n            }, transferables);\\n          } catch (e) {\\n            reject(`Failed to exectue remote callback ( id: ${cid}).`);\\n          }\\n        });\\n      };\\n\\n      return remoteCallback;\\n    } else {\\n      remoteCallback = async function () {\\n        const args = await me._wrap(Array.prototype.slice.call(arguments));\\n        const argLength = args.length; // if the last argument is an object, mark it as kwargs\\n\\n        const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\\n        if (withKwargs) delete args[argLength - 1]._rkwargs;\\n        const transferables = args.__transferables__;\\n        if (transferables) delete args.__transferables__;\\n        return me._connection.emit({\\n          type: \"callback\",\\n          target_id: targetId,\\n          id: cid,\\n          args: args,\\n          with_kwargs: withKwargs\\n        }, transferables);\\n      };\\n\\n      return remoteCallback;\\n    }\\n  }\\n\\n  reset() {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._remote_interface = null;\\n    this._object_store = {};\\n    this._method_weakmap = new WeakMap();\\n    this._object_weakmap = new WeakMap();\\n    this._local_api = null;\\n    this._store = new ReferenceStore();\\n    this._method_refs = new ReferenceStore();\\n  }\\n  /**\\n   * Sends the notification message and breaks the connection\\n   */\\n\\n\\n  disconnect() {\\n    this._connection.emit({\\n      type: \"disconnect\"\\n    });\\n\\n    this.reset();\\n    setTimeout(() => {\\n      this._connection.disconnect();\\n    }, 2000);\\n  }\\n\\n}\\n/**\\n * ReferenceStore is a special object which stores other objects\\n * and provides the references (number) instead. This reference\\n * may then be sent over a json-based communication channel (IPC\\n * to another Node.js process or a message to the Worker). Other\\n * site may then provide the reference in the responce message\\n * implying the given object should be activated.\\n *\\n * Primary usage for the ReferenceStore is a storage for the\\n * callbacks, which therefore makes it possible to initiate a\\n * callback execution by the opposite site (which normally cannot\\n * directly execute functions over the communication channel).\\n *\\n * Each stored object can only be fetched once and is not\\n * available for the second time. Each stored object must be\\n * fetched, since otherwise it will remain stored forever and\\n * consume memory.\\n *\\n * Stored object indeces are simply the numbers, which are however\\n * released along with the objects, and are later reused again (in\\n * order to postpone the overflow, which should not likely happen,\\n * but anyway).\\n */\\n\\nclass ReferenceStore {\\n  constructor() {\\n    this._store = {}; // stored object\\n\\n    this._indices = [0]; // smallest available indices\\n\\n    this._readyHandler = function () {};\\n\\n    this._busyHandler = function () {};\\n\\n    this._readyHandler();\\n  }\\n  /**\\n   * call handler when the store is empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onReady(readyHandler) {\\n    this._readyHandler = readyHandler || function () {};\\n  }\\n  /**\\n   * call handler when the store is not empty\\n   *\\n   * @param {FUNCTION} id of a handler\\n   */\\n\\n\\n  onBusy(busyHandler) {\\n    this._busyHandler = busyHandler || function () {};\\n  }\\n  /**\\n   * get the length of the store\\n   *\\n   */\\n\\n\\n  getStack() {\\n    return Object.keys(this._store).length;\\n  }\\n  /**\\n   * @function _genId() generates the new reference id\\n   *\\n   * @returns {Number} smallest available id and reserves it\\n   */\\n\\n\\n  _genId() {\\n    let id;\\n\\n    if (this._indices.length === 1) {\\n      id = this._indices[0]++;\\n    } else {\\n      id = this._indices.shift();\\n    }\\n\\n    return id;\\n  }\\n  /**\\n   * Releases the given reference id so that it will be available by\\n   * another object stored\\n   *\\n   * @param {Number} id to release\\n   */\\n\\n\\n  _releaseId(id) {\\n    for (let i = 0; i < this._indices.length; i++) {\\n      if (id < this._indices[i]) {\\n        this._indices.splice(i, 0, id);\\n\\n        break;\\n      }\\n    } // cleaning-up the sequence tail\\n\\n\\n    for (let i = this._indices.length - 1; i >= 0; i--) {\\n      if (this._indices[i] - 1 === this._indices[i - 1]) {\\n        this._indices.pop();\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n  /**\\n   * Stores the given object and returns the refernce id instead\\n   *\\n   * @param {Object} obj to store\\n   *\\n   * @returns {Number} reference id of the stored object\\n   */\\n\\n\\n  put(obj) {\\n    if (this._busyHandler && Object.keys(this._store).length === 0) {\\n      this._busyHandler();\\n    }\\n\\n    const id = this._genId();\\n\\n    this._store[id] = obj;\\n    return id;\\n  }\\n  /**\\n   * Retrieves previously stored object and releases its reference\\n   *\\n   * @param {Number} id of an object to retrieve\\n   */\\n\\n\\n  fetch(id) {\\n    const obj = this._store[id];\\n\\n    if (obj && !obj.__remote_method) {\\n      delete this._store[id];\\n\\n      this._releaseId(id);\\n\\n      if (this._readyHandler && Object.keys(this._store).length === 0) {\\n        this._readyHandler();\\n      }\\n    }\\n\\n    if (obj && obj.__promise_pair) {\\n      this.fetch(obj.__promise_pair);\\n    }\\n\\n    return obj;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ \"./src/utils.js\":\\n/*!**********************!*\\\\\\n  !*** ./src/utils.js ***!\\n  \\\\**********************/\\n/*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\"use strict\";\\n__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randId\", function() { return randId; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dtypeToTypedArray\", function() { return dtypeToTypedArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWindow\", function() { return loadRequirementsInWindow; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirementsInWebworker\", function() { return loadRequirementsInWebworker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadRequirements\", function() { return loadRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeConfig\", function() { return normalizeConfig; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtypeMapping\", function() { return typedArrayToDtypeMapping; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typedArrayToDtype\", function() { return typedArrayToDtype; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cacheRequirements\", function() { return cacheRequirements; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupServiceWorker\", function() { return setupServiceWorker; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"urlJoin\", function() { return urlJoin; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageEmitter\", function() { return MessageEmitter; });\\nfunction randId() {\\n  return Math.random().toString(36).substr(2, 10) + new Date().getTime();\\n}\\nconst dtypeToTypedArray = {\\n  int8: Int8Array,\\n  int16: Int16Array,\\n  int32: Int32Array,\\n  uint8: Uint8Array,\\n  uint16: Uint16Array,\\n  uint32: Uint32Array,\\n  float32: Float32Array,\\n  float64: Float64Array,\\n  array: Array\\n};\\nasync function loadRequirementsInWindow(requirements) {\\n  function _importScript(url) {\\n    //url is URL of external file, implementationCode is the code\\n    //to be called from the file, location is the location to\\n    //insert the <script> element\\n    return new Promise((resolve, reject) => {\\n      var scriptTag = document.createElement(\"script\");\\n      scriptTag.src = url;\\n      scriptTag.type = \"text/javascript\";\\n      scriptTag.onload = resolve;\\n\\n      scriptTag.onreadystatechange = function () {\\n        if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\\n          resolve();\\n        }\\n      };\\n\\n      scriptTag.onerror = reject;\\n      document.head.appendChild(scriptTag);\\n    });\\n  } // support importScripts outside web worker\\n\\n\\n  async function importScripts() {\\n    var args = Array.prototype.slice.call(arguments),\\n        len = args.length,\\n        i = 0;\\n\\n    for (; i < len; i++) {\\n      await _importScript(args[i]);\\n    }\\n  }\\n\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      var link_node;\\n      requirements = typeof requirements === \"string\" ? [requirements] : requirements;\\n\\n      if (Array.isArray(requirements)) {\\n        for (var i = 0; i < requirements.length; i++) {\\n          if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n            if (requirements[i].startsWith(\"css:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            link_node = document.createElement(\"link\");\\n            link_node.rel = \"stylesheet\";\\n            link_node.href = requirements[i];\\n            document.head.appendChild(link_node);\\n          } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\\n            // import esmodule\\n            if (requirements[i].startsWith(\"mjs:\")) {\\n              requirements[i] = requirements[i].slice(4);\\n            }\\n\\n            await import(\\n            /* webpackIgnore: true */\\n            requirements[i]);\\n          } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n            if (requirements[i].startsWith(\"js:\")) {\\n              requirements[i] = requirements[i].slice(3);\\n            }\\n\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"http\")) {\\n            await importScripts(requirements[i]);\\n          } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n          } else {\\n            console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n          }\\n        }\\n      } else {\\n        throw \"unsupported requirements definition\";\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nasync function loadRequirementsInWebworker(requirements) {\\n  if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\\n    try {\\n      if (!Array.isArray(requirements)) {\\n        requirements = [requirements];\\n      }\\n\\n      for (var i = 0; i < requirements.length; i++) {\\n        if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\\n          throw \"unable to import css in a webworker\";\\n        } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\\n          if (requirements[i].startsWith(\"js:\")) {\\n            requirements[i] = requirements[i].slice(3);\\n          }\\n\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"http\")) {\\n          importScripts(requirements[i]);\\n        } else if (requirements[i].startsWith(\"cache:\")) {//ignore cache\\n        } else {\\n          console.log(\"Unprocessed requirements url: \" + requirements[i]);\\n        }\\n      }\\n    } catch (e) {\\n      throw \"failed to import required scripts: \" + requirements.toString();\\n    }\\n  }\\n}\\nfunction loadRequirements(requirements) {\\n  if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\\n    return loadRequirementsInWebworker(requirements);\\n  } else {\\n    return loadRequirementsInWindow(requirements);\\n  }\\n}\\nfunction normalizeConfig(config) {\\n  config.version = config.version || \"0.1.0\";\\n  config.description = config.description || `[TODO: add description for ${config.name} ]`;\\n  config.type = config.type || \"rpc-window\";\\n  config.id = config.id || randId();\\n  config.target_origin = config.target_origin || \"*\";\\n  config.allow_execution = config.allow_execution || false; // remove functions\\n\\n  config = Object.keys(config).reduce((p, c) => {\\n    if (typeof config[c] !== \"function\") p[c] = config[c];\\n    return p;\\n  }, {});\\n  return config;\\n}\\nconst typedArrayToDtypeMapping = {\\n  Int8Array: \"int8\",\\n  Int16Array: \"int16\",\\n  Int32Array: \"int32\",\\n  Uint8Array: \"uint8\",\\n  Uint16Array: \"uint16\",\\n  Uint32Array: \"uint32\",\\n  Float32Array: \"float32\",\\n  Float64Array: \"float64\",\\n  Array: \"array\"\\n};\\nconst typedArrayToDtypeKeys = [];\\n\\nfor (const arrType of Object.keys(typedArrayToDtypeMapping)) {\\n  typedArrayToDtypeKeys.push(eval(arrType));\\n}\\n\\nfunction typedArrayToDtype(obj) {\\n  let dtype = typedArrayToDtypeMapping[obj.constructor.name];\\n\\n  if (!dtype) {\\n    const pt = Object.getPrototypeOf(obj);\\n\\n    for (const arrType of typedArrayToDtypeKeys) {\\n      if (pt instanceof arrType) {\\n        dtype = typedArrayToDtypeMapping[arrType.name];\\n        break;\\n      }\\n    }\\n  }\\n\\n  return dtype;\\n}\\n\\nfunction cacheUrlInServiceWorker(url) {\\n  return new Promise(function (resolve, reject) {\\n    const message = {\\n      command: \"add\",\\n      url: url\\n    };\\n\\n    if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\\n      reject(\"Service worker is not supported.\");\\n      return;\\n    }\\n\\n    const messageChannel = new MessageChannel();\\n\\n    messageChannel.port1.onmessage = function (event) {\\n      if (event.data && event.data.error) {\\n        reject(event.data.error);\\n      } else {\\n        resolve(event.data && event.data.result);\\n      }\\n    };\\n\\n    if (navigator.serviceWorker && navigator.serviceWorker.controller) {\\n      navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\\n    } else {\\n      reject(\"Service worker controller is not available\");\\n    }\\n  });\\n}\\n\\nasync function cacheRequirements(requirements) {\\n  requirements = requirements || [];\\n\\n  if (!Array.isArray(requirements)) {\\n    requirements = [requirements];\\n  }\\n\\n  for (let req of requirements) {\\n    //remove prefix\\n    if (req.startsWith(\"js:\")) req = req.slice(3);\\n    if (req.startsWith(\"css:\")) req = req.slice(4);\\n    if (req.startsWith(\"cache:\")) req = req.slice(6);\\n    if (!req.startsWith(\"http\")) continue;\\n    await cacheUrlInServiceWorker(req).catch(e => {\\n      console.error(e);\\n    });\\n  }\\n}\\nfunction setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\\n  // register service worker for offline access\\n  if (\"serviceWorker\" in navigator) {\\n    baseUrl = baseUrl || \"/\";\\n    navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function (registration) {\\n      // Registration was successful\\n      console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\\n    }, function (err) {\\n      // registration failed :(\\n      console.log(\"ServiceWorker registration failed: \", err);\\n    });\\n    targetOrigin = targetOrigin || \"*\";\\n    cacheCallback = cacheCallback || cacheRequirements;\\n\\n    if (cacheCallback && typeof cacheCallback !== \"function\") {\\n      throw new Error(\"config.cache_requirements must be a function\");\\n    }\\n\\n    window.addEventListener(\"message\", function (e) {\\n      if (targetOrigin === \"*\" || e.origin === targetOrigin) {\\n        const m = e.data;\\n\\n        if (m.type === \"cacheRequirements\") {\\n          cacheCallback(m.requirements);\\n        }\\n      }\\n    });\\n  }\\n} //#Source https://bit.ly/2neWfJ2\\n\\nfunction urlJoin(...args) {\\n  return args.join(\"/\").replace(/[\\\\/]+/g, \"/\").replace(/^(.+):\\\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\\\/(\\\\?|&|#[^!])/g, \"$1\").replace(/\\\\?/g, \"&\").replace(\"&\", \"?\");\\n}\\nclass MessageEmitter {\\n  constructor(debug) {\\n    this._event_handlers = {};\\n    this._once_handlers = {};\\n    this._debug = debug;\\n  }\\n\\n  emit() {\\n    throw new Error(\"emit is not implemented\");\\n  }\\n\\n  on(event, handler) {\\n    if (!this._event_handlers[event]) {\\n      this._event_handlers[event] = [];\\n    }\\n\\n    this._event_handlers[event].push(handler);\\n  }\\n\\n  once(event, handler) {\\n    handler.___event_run_once = true;\\n    this.on(event, handler);\\n  }\\n\\n  off(event, handler) {\\n    if (!event && !handler) {\\n      // remove all events handlers\\n      this._event_handlers = {};\\n    } else if (event && !handler) {\\n      // remove all hanlders for the event\\n      if (this._event_handlers[event]) this._event_handlers[event] = [];\\n    } else {\\n      // remove a specific handler\\n      if (this._event_handlers[event]) {\\n        const idx = this._event_handlers[event].indexOf(handler);\\n\\n        if (idx >= 0) {\\n          this._event_handlers[event].splice(idx, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  _fire(event, data) {\\n    if (this._event_handlers[event]) {\\n      var i = this._event_handlers[event].length;\\n\\n      while (i--) {\\n        const handler = this._event_handlers[event][i];\\n\\n        try {\\n          handler(data);\\n        } catch (e) {\\n          console.error(e);\\n        } finally {\\n          if (handler.___event_run_once) {\\n            this._event_handlers[event].splice(i, 1);\\n          }\\n        }\\n      }\\n    } else {\\n      if (this._debug) {\\n        console.warn(\"unhandled event\", event, data);\\n      }\\n    }\\n  }\\n\\n}\\n\\n/***/ })\\n\\n/******/ });\\n//# sourceMappingURL=plugin.webworker.js.map', null);\n          };\n        }\n      ),\n      /***/\n      \"./src/pluginCore.js\": (\n        /*!***************************!*\\\n          !*** ./src/pluginCore.js ***!\n          \\***************************/\n        /*! exports provided: connectRPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"connectRPC\", function() {\n            return connectRPC;\n          });\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          function connectRPC(connection, config) {\n            config = config || {};\n            const codecs = {};\n            const rpc = new _rpc_js__WEBPACK_IMPORTED_MODULE_0__[\"RPC\"](connection, config, codecs);\n            rpc.on(\"getInterface\", function() {\n              launchConnected();\n            });\n            rpc.on(\"remoteReady\", function() {\n              const api = rpc.getRemote() || {};\n              api.registerCodec = function(config2) {\n                if (!config2[\"name\"] || !config2[\"encoder\"] && !config2[\"decoder\"]) {\n                  throw new Error(\"Invalid codec format, please make sure you provide a name, type, encoder and decoder.\");\n                } else {\n                  if (config2.type) {\n                    for (let k of Object.keys(codecs)) {\n                      if (codecs[k].type === config2.type || k === config2.name) {\n                        delete codecs[k];\n                        console.warn(\"Remove duplicated codec: \" + k);\n                      }\n                    }\n                  }\n                  codecs[config2[\"name\"]] = config2;\n                }\n              };\n              api.init = function(config2) {\n                rpc.setInterface({\n                  setup() {\n                  }\n                }, config2);\n              };\n              api.disposeObject = function(obj) {\n                rpc.disposeObject(obj);\n              };\n              api.export = function(_interface, config2) {\n                rpc.setInterface(_interface, config2);\n              };\n              api.onLoad = function(handler) {\n                handler = checkHandler(handler);\n                if (connected) {\n                  handler();\n                } else {\n                  connectedHandlers.push(handler);\n                }\n              };\n              api.dispose = function(_interface) {\n                rpc.disconnect();\n              };\n              api._rpc = rpc;\n              if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n                self.api = api;\n                self.postMessage({\n                  type: \"imjoy_remote_api_ready\"\n                });\n                self.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              } else if (typeof window) {\n                window.dispatchEvent(new CustomEvent(\"imjoy_remote_api_ready\", {\n                  detail: api\n                }));\n              }\n            });\n            let connected = false;\n            const connectedHandlers = [];\n            const launchConnected = function() {\n              if (!connected) {\n                connected = true;\n                let handler;\n                while (handler = connectedHandlers.pop()) {\n                  handler();\n                }\n              }\n            };\n            const checkHandler = function(handler) {\n              const type = typeof handler;\n              if (type !== \"function\") {\n                const msg = \"A function may only be subsribed to the event, \" + type + \" was provided instead\";\n                throw new Error(msg);\n              }\n              return handler;\n            };\n            return rpc;\n          }\n        }\n      ),\n      /***/\n      \"./src/pluginIframe.js\": (\n        /*!*****************************!*\\\n          !*** ./src/pluginIframe.js ***!\n          \\*****************************/\n        /*! exports provided: Connection, default */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_82604__) {\n          \"use strict\";\n          __nested_webpack_require_82604__.r(__nested_webpack_exports__);\n          __nested_webpack_require_82604__.d(__nested_webpack_exports__, \"Connection\", function() {\n            return Connection;\n          });\n          __nested_webpack_require_82604__.d(__nested_webpack_exports__, \"default\", function() {\n            return setupIframe;\n          });\n          var _pluginCore_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_82604__(\n            /*! ./pluginCore.js */\n            \"./src/pluginCore.js\"\n          );\n          var _rpc_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_82604__(\n            /*! ./rpc.js */\n            \"./src/rpc.js\"\n          );\n          var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_82604__(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          function _htmlToElement(html) {\n            var template = document.createElement(\"template\");\n            html = html.trim();\n            template.innerHTML = html;\n            return template.content.firstChild;\n          }\n          const _inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n          async function executeEsModule(content) {\n            const dataUri = \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(content);\n            await import(\n              /* webpackIgnore: true */\n              dataUri\n            );\n          }\n          class Connection extends _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"MessageEmitter\"] {\n            constructor(config) {\n              super(config && config.debug);\n              this.config = config || {};\n              this.peer_id = Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"randId\"])();\n            }\n            connect() {\n              this.config.target_origin = this.config.target_origin || \"*\";\n              if (this.config.broadcastChannel) {\n                this.broadcastChannel = new BroadcastChannel(this.config.broadcastChannel);\n              } else {\n                this.broadcastChannel = null;\n              }\n              if (this.broadcastChannel)\n                this.broadcastChannel.addEventListener(\"message\", this);\n              else\n                globalThis.addEventListener(\"message\", this);\n              this.emit({\n                type: \"initialized\",\n                config: this.config,\n                origin: globalThis.location.origin,\n                peer_id: this.peer_id\n              });\n              this._fire(\"connected\");\n            }\n            handleEvent(e) {\n              if (e.type === \"message\" && (this.broadcastChannel || this.config.target_origin === \"*\" || !e.origin || e.origin === this.config.target_origin)) {\n                if (e.data.peer_id === this.peer_id) {\n                  this._fire(e.data.type, e.data);\n                } else if (this.config.debug) {\n                  console.log(`connection peer id mismatch ${e.data.peer_id} !== ${this.peer_id}`);\n                }\n              }\n            }\n            disconnect() {\n              this._fire(\"beforeDisconnect\");\n              globalThis.removeEventListener(\"message\", this);\n              this._fire(\"disconnected\");\n            }\n            emit(data) {\n              let transferables;\n              if (this.broadcastChannel)\n                this.broadcastChannel.postMessage(data);\n              else {\n                if (data.__transferables__) {\n                  transferables = data.__transferables__;\n                  delete data.__transferables__;\n                } else if (_inWebWorker)\n                  self.postMessage(data, transferables);\n                else\n                  parent.postMessage(data, this.config.target_origin, transferables);\n              }\n            }\n            async execute(code) {\n              try {\n                if (code.type === \"requirements\") {\n                  await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"loadRequirementsInWindow\"])(code.requirements);\n                } else if (code.type === \"script\") {\n                  if (code.src) {\n                    var script_node = document.createElement(\"script\");\n                    script_node.setAttribute(\"type\", code.attrs.type);\n                    script_node.setAttribute(\"src\", code.src);\n                    document.head.appendChild(script_node);\n                  } else {\n                    if (code.content && code.attrs.lang === \"javascript\") {\n                      if (code.attrs.type === \"module\") {\n                        await executeEsModule(code.content);\n                      } else {\n                        eval(code.content);\n                      }\n                    } else {\n                      var node = document.createElement(\"script\");\n                      for (let k in code.attrs) {\n                        node.setAttribute(k, code.attrs[k]);\n                      }\n                      node.appendChild(document.createTextNode(code.content));\n                      document.body.appendChild(node);\n                    }\n                  }\n                } else if (code.type === \"style\") {\n                  const style_node = document.createElement(\"style\");\n                  if (code.src) {\n                    style_node.src = code.src;\n                  }\n                  style_node.innerHTML = code.content;\n                  document.head.appendChild(style_node);\n                } else if (code.type === \"link\") {\n                  const link_node_ = document.createElement(\"link\");\n                  if (code.rel) {\n                    link_node_.rel = code.rel;\n                  }\n                  if (code.href) {\n                    link_node_.href = code.href;\n                  }\n                  if (code.attrs && code.attrs.type) {\n                    link_node_.type = code.attrs.type;\n                  }\n                  document.head.appendChild(link_node_);\n                } else if (code.type === \"html\") {\n                  document.body.appendChild(_htmlToElement(code.content));\n                } else {\n                  throw \"unsupported code type.\";\n                }\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\"\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\"\n                  }, this.config.target_origin);\n              } catch (e) {\n                console.error(\"failed to execute scripts: \", code, e);\n                if (_inWebWorker)\n                  self.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  });\n                else\n                  parent.postMessage({\n                    type: \"executed\",\n                    error: e.stack || String(e)\n                  }, this.config.target_origin);\n              }\n            }\n          }\n          function setupIframe(config) {\n            config = config || {};\n            config.dedicated_thread = false;\n            config.lang = \"javascript\";\n            config.api_version = _rpc_js__WEBPACK_IMPORTED_MODULE_1__[\"API_VERSION\"];\n            const conn = new Connection(config);\n            Object(_pluginCore_js__WEBPACK_IMPORTED_MODULE_0__[\"connectRPC\"])(conn, config);\n            conn.connect();\n          }\n        }\n      ),\n      /***/\n      \"./src/rpc.js\": (\n        /*!********************!*\\\n          !*** ./src/rpc.js ***!\n          \\********************/\n        /*! exports provided: API_VERSION, RPC */\n        /***/\n        function(module2, __webpack_exports__2, __webpack_require__2) {\n          \"use strict\";\n          __webpack_require__2.r(__webpack_exports__2);\n          __webpack_require__2.d(__webpack_exports__2, \"API_VERSION\", function() {\n            return API_VERSION;\n          });\n          __webpack_require__2.d(__webpack_exports__2, \"RPC\", function() {\n            return RPC;\n          });\n          var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(\n            /*! ./utils.js */\n            \"./src/utils.js\"\n          );\n          const API_VERSION = \"0.2.3\";\n          const ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n          function _appendBuffer(buffer1, buffer2) {\n            const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp.buffer;\n          }\n          function indexObject(obj, is) {\n            if (!is)\n              throw new Error(\"undefined index\");\n            if (typeof is === \"string\")\n              return indexObject(obj, is.split(\".\"));\n            else if (is.length === 0)\n              return obj;\n            else\n              return indexObject(obj[is[0]], is.slice(1));\n          }\n          class RPC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"MessageEmitter\"] {\n            constructor(connection, config, codecs) {\n              super(config && config.debug);\n              this._connection = connection;\n              this.config = config || {};\n              this._codecs = codecs || {};\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._remote_set = false;\n              const name = this.config.name;\n              this._connection.execute = this._connection.execute || function() {\n                throw new Error(`connection.execute not implemented (in \"${name}\")`);\n              };\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n              this._method_refs.onReady(() => {\n                this._fire(\"remoteIdle\");\n              });\n              this._method_refs.onBusy(() => {\n                this._fire(\"remoteBusy\");\n              });\n              this._setupMessageHanlders();\n            }\n            init() {\n              this._connection.emit({\n                type: \"initialized\",\n                config: this.config,\n                peer_id: this._connection.peer_id\n              });\n            }\n            setConfig(config) {\n              if (config)\n                for (const k of Object.keys(config)) {\n                  this.config[k] = config[k];\n                }\n            }\n            /**\n             * Set a handler to be called when received a responce from the\n             * remote site reporting that the previously provided interface\n             * has been successfully set as remote for that site\n             *\n             * @param {Function} handler\n             */\n            getRemoteCallStack() {\n              return this._method_refs.getStack();\n            }\n            /**\n             * @returns {Object} set of remote interface methods\n             */\n            getRemote() {\n              return this._remote_interface;\n            }\n            /**\n             * Sets the interface of this site making it available to the\n             * remote site by sending a message with a set of methods names\n             *\n             * @param {Object} _interface to set\n             */\n            setInterface(_interface, config) {\n              config = config || {};\n              this.config.name = config.name || this.config.name;\n              this.config.description = config.description || this.config.description;\n              if (this.config.forwarding_functions) {\n                for (let func_name of this.config.forwarding_functions) {\n                  const _remote = this._remote_interface;\n                  if (_remote[func_name]) {\n                    if (_interface.constructor === Object) {\n                      if (!_interface[func_name]) {\n                        _interface[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    } else if (_interface.constructor.constructor === Function) {\n                      if (!_interface.constructor.prototype[func_name]) {\n                        _interface.constructor.prototype[func_name] = (...args) => {\n                          _remote[func_name](...args);\n                        };\n                      }\n                    }\n                  }\n                }\n              }\n              this._local_api = _interface;\n              if (!this._remote_set)\n                this._fire(\"interfaceAvailable\");\n              else\n                this.sendInterface();\n              return new Promise((resolve) => {\n                this.once(\"interfaceSetAsRemote\", resolve);\n              });\n            }\n            /**\n             * Sends the actual interface to the remote site upon it was\n             * updated or by a special request of the remote site\n             */\n            sendInterface() {\n              if (!this._local_api) {\n                throw new Error(\"interface is not set.\");\n              }\n              this._encode(this._local_api, true).then((api) => {\n                this._connection.emit({\n                  type: \"setInterface\",\n                  api\n                });\n              });\n            }\n            _disposeObject(objectId) {\n              if (this._object_store[objectId]) {\n                delete this._object_store[objectId];\n              } else {\n                throw new Error(`Object (id=${objectId}) not found.`);\n              }\n            }\n            disposeObject(obj) {\n              return new Promise((resolve, reject) => {\n                if (this._object_weakmap.has(obj)) {\n                  const objectId = this._object_weakmap.get(obj);\n                  this._connection.once(\"disposed\", (data) => {\n                    if (data.error)\n                      reject(new Error(data.error));\n                    else\n                      resolve();\n                  });\n                  this._connection.emit({\n                    type: \"disposeObject\",\n                    object_id: objectId\n                  });\n                } else {\n                  throw new Error(\"Invalid object\");\n                }\n              });\n            }\n            /**\n             * Handles a message from the remote site\n             */\n            _setupMessageHanlders() {\n              this._connection.on(\"init\", this.init);\n              this._connection.on(\"execute\", (data) => {\n                Promise.resolve(this._connection.execute(data.code)).then(() => {\n                  this._connection.emit({\n                    type: \"executed\"\n                  });\n                }).catch((e) => {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"executed\",\n                    error: String(e)\n                  });\n                });\n              });\n              this._connection.on(\"method\", async (data) => {\n                let resolve, reject, method, method_this, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  const _interface = this._object_store[data.object_id];\n                  method = indexObject(_interface, data.name);\n                  if (data.name.includes(\".\")) {\n                    const tmp = data.name.split(\".\");\n                    const intf_index = tmp.slice(0, tmp.length - 1).join(\".\");\n                    method_this = indexObject(_interface, intf_index);\n                  } else {\n                    method_this = _interface;\n                  }\n                  args = await this._unwrap(data.args, true);\n                  if (data.promise) {\n                    result = method.apply(method_this, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method.apply(method_this, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"callback\", async (data) => {\n                let resolve, reject, method, args, result;\n                try {\n                  if (data.promise) {\n                    [resolve, reject] = await this._unwrap(data.promise, false);\n                  }\n                  if (data.promise) {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    result = method.apply(null, args);\n                    if (result instanceof Promise || method.constructor && method.constructor.name === \"AsyncFunction\") {\n                      result.then(resolve).catch(reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } else {\n                    method = this._store.fetch(data.id);\n                    args = await this._unwrap(data.args, true);\n                    if (!method) {\n                      throw new Error(\"Please notice that callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function. See https://imjoy.io/docs for more details.\");\n                    }\n                    method.apply(null, args);\n                  }\n                } catch (err) {\n                  console.error(this.config.name, err);\n                  if (reject) {\n                    reject(err);\n                  }\n                }\n              });\n              this._connection.on(\"disposeObject\", (data) => {\n                try {\n                  this._disposeObject(data.object_id);\n                  this._connection.emit({\n                    type: \"disposed\"\n                  });\n                } catch (e) {\n                  console.error(e);\n                  this._connection.emit({\n                    type: \"disposed\",\n                    error: String(e)\n                  });\n                }\n              });\n              this._connection.on(\"setInterface\", (data) => {\n                this._setRemoteInterface(data.api);\n              });\n              this._connection.on(\"getInterface\", () => {\n                this._fire(\"getInterface\");\n                if (this._local_api) {\n                  this.sendInterface();\n                } else {\n                  this.once(\"interfaceAvailable\", () => {\n                    this.sendInterface();\n                  });\n                }\n              });\n              this._connection.on(\"interfaceSetAsRemote\", () => {\n                this._remote_set = true;\n                this._fire(\"interfaceSetAsRemote\");\n              });\n              this._connection.on(\"disconnect\", () => {\n                this._fire(\"beforeDisconnect\");\n                this._connection.disconnect();\n                this._fire(\"disconnected\");\n              });\n            }\n            /**\n             * Sends a requests to the remote site asking it to provide its\n             * current interface\n             */\n            requestRemote() {\n              this._connection.emit({\n                type: \"getInterface\"\n              });\n            }\n            _ndarray(typedArray, shape, dtype) {\n              const _dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(typedArray);\n              if (dtype && dtype !== _dtype) {\n                throw \"dtype doesn't match the type of the array: \" + _dtype + \" != \" + dtype;\n              }\n              shape = shape || [typedArray.length];\n              return {\n                _rtype: \"ndarray\",\n                _rvalue: typedArray.buffer,\n                _rshape: shape,\n                _rdtype: _dtype\n              };\n            }\n            /**\n             * Sets the new remote interface provided by the other site\n             *\n             * @param {Array} names list of function names\n             */\n            _setRemoteInterface(api) {\n              this._decode(api).then((intf) => {\n                if (this._remote_interface) {\n                  for (let k in this._remote_interface)\n                    delete this._remote_interface[k];\n                  Object.assign(this._remote_interface, intf);\n                } else\n                  this._remote_interface = intf;\n                this._fire(\"remoteReady\");\n                this._reportRemoteSet();\n              });\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * method. When the generated function is called, it will send the\n             * corresponding message to the remote site asking it to execute\n             * the particular method of its interface\n             *\n             * @param {String} name of the remote method\n             *\n             * @returns {Function} wrapped remote method\n             */\n            _genRemoteMethod(targetId, name, objectId) {\n              const me = this;\n              const remoteMethod = function() {\n                return new Promise(async (resolve, reject) => {\n                  let id = null;\n                  try {\n                    id = me._method_refs.put(objectId ? objectId + \"/\" + name : name);\n                    const wrapped_resolve = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return resolve.apply(this, arguments);\n                    };\n                    const wrapped_reject = function() {\n                      if (id !== null)\n                        me._method_refs.fetch(id);\n                      return reject.apply(this, arguments);\n                    };\n                    const encodedPromise = await me._wrap([wrapped_resolve, wrapped_reject]);\n                    wrapped_resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    wrapped_reject.__promise_pair = encodedPromise[0]._rvalue;\n                    let args = Array.prototype.slice.call(arguments);\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    if (name === \"register\" || name === \"registerService\" || name === \"register_service\" || name === \"export\" || name === \"on\") {\n                      args = await me._wrap(args, true);\n                    } else {\n                      args = await me._wrap(args);\n                    }\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    me._connection.emit({\n                      type: \"method\",\n                      target_id: targetId,\n                      name,\n                      object_id: objectId,\n                      args,\n                      promise: encodedPromise,\n                      with_kwargs: withKwargs\n                    }, transferables);\n                  } catch (e) {\n                    if (id)\n                      me._method_refs.fetch(id);\n                    reject(`Failed to exectue remote method (interface: ${objectId || me.id}, method: ${name}), error: ${e}`);\n                  }\n                });\n              };\n              remoteMethod.__remote_method = true;\n              return remoteMethod;\n            }\n            /**\n             * Sends a responce reporting that interface just provided by the\n             * remote site was successfully set by this site as remote\n             */\n            _reportRemoteSet() {\n              this._connection.emit({\n                type: \"interfaceSetAsRemote\"\n              });\n            }\n            /**\n             * Prepares the provided set of remote method arguments for\n             * sending to the remote site, replaces all the callbacks with\n             * identifiers\n             *\n             * @param {Array} args to wrap\n             *\n             * @returns {Array} wrapped arguments\n             */\n            async _encode(aObject, asInterface, objectId) {\n              const aType = typeof aObject;\n              if (aType === \"number\" || aType === \"string\" || aType === \"boolean\" || aObject === null || aObject === void 0 || aObject instanceof ArrayBuffer) {\n                return aObject;\n              }\n              let bObject;\n              if (typeof aObject === \"function\") {\n                if (asInterface) {\n                  if (!objectId)\n                    throw new Error(\"objectId is not specified.\");\n                  bObject = {\n                    _rtype: \"interface\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rintf: objectId,\n                    _rvalue: asInterface\n                  };\n                  this._method_weakmap.set(aObject, bObject);\n                } else if (this._method_weakmap.has(aObject)) {\n                  bObject = this._method_weakmap.get(aObject);\n                } else {\n                  const cid = this._store.put(aObject);\n                  bObject = {\n                    _rtype: \"callback\",\n                    _rtarget_id: this._connection.peer_id,\n                    _rname: aObject.constructor && aObject.constructor.name || cid,\n                    _rvalue: cid\n                  };\n                }\n                return bObject;\n              }\n              if (aObject.constructor instanceof Object && aObject._rtype) {\n                if (aObject._rintf) {\n                  const temp = aObject._rtype;\n                  delete aObject._rtype;\n                  bObject = await this._encode(aObject, asInterface, objectId);\n                  bObject._rtype = temp;\n                } else {\n                  bObject = aObject;\n                }\n                return bObject;\n              }\n              const transferables = [];\n              const _transfer = aObject._transfer;\n              const isarray = Array.isArray(aObject);\n              for (let tp of Object.keys(this._codecs)) {\n                const codec = this._codecs[tp];\n                if (codec.encoder && aObject instanceof codec.type) {\n                  let encodedObj = await Promise.resolve(codec.encoder(aObject));\n                  if (encodedObj && !encodedObj._rtype)\n                    encodedObj._rtype = codec.name;\n                  if (encodedObj && encodedObj._rintf) {\n                    const temp = encodedObj._rtype;\n                    delete encodedObj._rtype;\n                    encodedObj = await this._encode(encodedObj, asInterface, objectId);\n                    encodedObj._rtype = temp;\n                  }\n                  bObject = encodedObj;\n                  return bObject;\n                }\n              }\n              if (\n                /*global tf*/\n                typeof tf !== \"undefined\" && tf.Tensor && aObject instanceof tf.Tensor\n              ) {\n                const v_buffer = aObject.dataSync();\n                if (aObject._transfer || _transfer) {\n                  transferables.push(v_buffer.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: v_buffer.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: aObject.dtype\n                };\n              } else if (\n                /*global nj*/\n                typeof nj !== \"undefined\" && nj.NdArray && aObject instanceof nj.NdArray\n              ) {\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject.selection.data);\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.selection.data.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"ndarray\",\n                  _rvalue: aObject.selection.data.buffer,\n                  _rshape: aObject.shape,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof Error) {\n                console.error(aObject);\n                bObject = {\n                  _rtype: \"error\",\n                  _rvalue: aObject.toString()\n                };\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject !== Object(aObject) || aObject instanceof Boolean || aObject instanceof String || aObject instanceof Date || aObject instanceof RegExp || aObject instanceof ImageData || typeof FileList !== \"undefined\" && aObject instanceof FileList || typeof FileSystemDirectoryHandle !== \"undefined\" && aObject instanceof FileSystemDirectoryHandle || typeof FileSystemFileHandle !== \"undefined\" && aObject instanceof FileSystemFileHandle || typeof FileSystemHandle !== \"undefined\" && aObject instanceof FileSystemHandle || typeof FileSystemWritableFileStream !== \"undefined\" && aObject instanceof FileSystemWritableFileStream) {\n                bObject = aObject;\n              } else if (typeof File !== \"undefined\" && aObject instanceof File) {\n                bObject = {\n                  _rtype: \"file\",\n                  _rname: aObject.name,\n                  _rmime: aObject.type,\n                  _rvalue: aObject,\n                  _rpath: aObject._path || aObject.webkitRelativePath\n                };\n              } else if (aObject instanceof Blob) {\n                bObject = {\n                  _rtype: \"blob\",\n                  _rvalue: aObject\n                };\n              } else if (aObject instanceof ArrayBufferView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                const dtype = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"typedArrayToDtype\"])(aObject);\n                bObject = {\n                  _rtype: \"typedarray\",\n                  _rvalue: aObject.buffer,\n                  _rdtype: dtype\n                };\n              } else if (aObject instanceof DataView) {\n                if (aObject._transfer || _transfer) {\n                  transferables.push(aObject.buffer);\n                  delete aObject._transfer;\n                }\n                bObject = {\n                  _rtype: \"memoryview\",\n                  _rvalue: aObject.buffer\n                };\n              } else if (aObject instanceof Set) {\n                bObject = {\n                  _rtype: \"set\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject instanceof Map) {\n                bObject = {\n                  _rtype: \"orderedmap\",\n                  _rvalue: await this._encode(Array.from(aObject), asInterface)\n                };\n              } else if (aObject.constructor instanceof Object || Array.isArray(aObject)) {\n                bObject = isarray ? [] : {};\n                let keys;\n                if (aObject.constructor === Object || Array.isArray(aObject)) {\n                  keys = Object.keys(aObject);\n                } else if (aObject.constructor === Function) {\n                  throw new Error(\"Please instantiate the class before exportting it.\");\n                } else if (aObject.constructor.constructor === Function) {\n                  keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                  asInterface = true;\n                } else {\n                  throw Error(\"Unsupported interface type\");\n                }\n                let hasFunction = false;\n                if (aObject._rintf || asInterface) {\n                  if (!objectId) {\n                    if (typeof aObject._rintf === \"string\" && aObject._rintf.length > 0) {\n                      objectId = aObject._rintf;\n                    } else {\n                      objectId = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                    }\n                    if (this._object_store[objectId])\n                      console.warn(`Overwritting interface object with the same id: ${objectId}`);\n                    this._object_store[objectId] = aObject;\n                  }\n                  for (let k of keys) {\n                    if (k === \"constructor\")\n                      continue;\n                    if (k.startsWith(\"_\")) {\n                      continue;\n                    }\n                    bObject[k] = await this._encode(aObject[k], typeof asInterface === \"string\" ? asInterface + \".\" + k : k, objectId);\n                    if (typeof aObject[k] === \"function\") {\n                      hasFunction = true;\n                    }\n                  }\n                  if (hasFunction)\n                    bObject._rintf = objectId;\n                  if (aObject.on && typeof aObject.on === \"function\") {\n                    aObject.on(\"close\", () => {\n                      delete this._object_store[objectId];\n                    });\n                  }\n                } else {\n                  for (let k of keys) {\n                    if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                      continue;\n                    bObject[k] = await this._encode(aObject[k]);\n                  }\n                }\n              } else if (typeof aObject === \"object\") {\n                const keys = Object.getOwnPropertyNames(Object.getPrototypeOf(aObject)).concat(Object.keys(aObject));\n                const objectId2 = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__[\"randId\"])();\n                for (let k of keys) {\n                  if ([\"hasOwnProperty\", \"constructor\"].includes(k))\n                    continue;\n                  bObject[k] = await this._encode(aObject[k], k, bObject);\n                }\n                bObject._rintf = objectId2;\n              } else {\n                throw \"imjoy-rpc: Unsupported data type:\" + aObject;\n              }\n              if (transferables.length > 0) {\n                bObject.__transferables__ = transferables;\n              }\n              if (!bObject) {\n                throw new Error(\"Failed to encode object\");\n              }\n              return bObject;\n            }\n            async _decode(aObject, withPromise) {\n              if (!aObject) {\n                return aObject;\n              }\n              let bObject;\n              if (aObject[\"_rtype\"]) {\n                if (this._codecs[aObject._rtype] && this._codecs[aObject._rtype].decoder) {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    aObject = await this._decode(aObject, withPromise);\n                    aObject._rtype = temp;\n                  }\n                  bObject = await Promise.resolve(this._codecs[aObject._rtype].decoder(aObject));\n                } else if (aObject._rtype === \"callback\") {\n                  bObject = this._genRemoteCallback(aObject._rtarget_id, aObject._rvalue, withPromise);\n                } else if (aObject._rtype === \"interface\") {\n                  bObject = this._genRemoteMethod(aObject._rtarget_id, aObject._rvalue, aObject._rintf);\n                } else if (aObject._rtype === \"ndarray\") {\n                  if (typeof nj !== \"undefined\" && nj.array) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    bObject = nj.array(new Uint8(aObject._rvalue), aObject._rdtype).reshape(aObject._rshape);\n                  } else if (typeof tf !== \"undefined\" && tf.Tensor) {\n                    if (Array.isArray(aObject._rvalue)) {\n                      aObject._rvalue = aObject._rvalue.reduce(_appendBuffer);\n                    }\n                    const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                    bObject = tf.tensor(new arraytype(aObject._rvalue), aObject._rshape, aObject._rdtype);\n                  } else {\n                    bObject = aObject;\n                  }\n                } else if (aObject._rtype === \"error\") {\n                  bObject = new Error(aObject._rvalue);\n                } else if (aObject._rtype === \"file\") {\n                  if (aObject._rvalue instanceof File) {\n                    bObject = aObject._rvalue;\n                    bObject._path = aObject._rpath;\n                  } else {\n                    bObject = new File([aObject._rvalue], aObject._rname, {\n                      type: aObject._rmime\n                    });\n                    bObject._path = aObject._rpath;\n                  }\n                } else if (aObject._rtype === \"typedarray\") {\n                  const arraytype = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"dtypeToTypedArray\"][aObject._rdtype];\n                  if (!arraytype)\n                    throw new Error(\"unsupported dtype: \" + aObject._rdtype);\n                  bObject = new arraytype(aObject._rvalue);\n                } else if (aObject._rtype === \"memoryview\") {\n                  bObject = new DataView(aObject._rvalue);\n                } else if (aObject._rtype === \"blob\") {\n                  if (aObject._rvalue instanceof Blob) {\n                    bObject = aObject._rvalue;\n                  } else {\n                    bObject = new Blob([aObject._rvalue], {\n                      type: aObject._rmime\n                    });\n                  }\n                } else if (aObject._rtype === \"orderedmap\") {\n                  bObject = new Map(await this._decode(aObject._rvalue, withPromise));\n                } else if (aObject._rtype === \"set\") {\n                  bObject = new Set(await this._decode(aObject._rvalue, withPromise));\n                } else {\n                  if (aObject._rintf) {\n                    const temp = aObject._rtype;\n                    delete aObject._rtype;\n                    bObject = await this._decode(aObject, withPromise);\n                    bObject._rtype = temp;\n                  } else\n                    bObject = aObject;\n                }\n              } else if (aObject.constructor === Object || Array.isArray(aObject)) {\n                const isarray = Array.isArray(aObject);\n                bObject = isarray ? [] : {};\n                for (let k of Object.keys(aObject)) {\n                  if (isarray || aObject.hasOwnProperty(k)) {\n                    const v = aObject[k];\n                    bObject[k] = await this._decode(v, withPromise);\n                  }\n                }\n              } else {\n                bObject = aObject;\n              }\n              if (bObject === void 0) {\n                throw new Error(\"Failed to decode object\");\n              }\n              if (aObject._rintf) {\n                this._object_weakmap.set(bObject, aObject._rintf);\n              }\n              return bObject;\n            }\n            async _wrap(args, asInterface) {\n              return await this._encode(args, asInterface);\n            }\n            /**\n             * Unwraps the set of arguments delivered from the remote site,\n             * replaces all callback identifiers with a function which will\n             * initiate sending that callback identifier back to other site\n             *\n             * @param {Object} args to unwrap\n             *\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Array} unwrapped args\n             */\n            async _unwrap(args, withPromise) {\n              return await this._decode(args, withPromise);\n            }\n            /**\n             * Generates the wrapped function corresponding to a single remote\n             * callback. When the generated function is called, it will send\n             * the corresponding message to the remote site asking it to\n             * execute the particular callback previously saved during a call\n             * by the remote site a method from the interface of this site\n             *\n             * @param {Number} id of the remote callback to execute\n             * @param {Number} argNum argument index of the callback\n             * @param {Boolean} withPromise is true means this the callback should contain a promise\n             *\n             * @returns {Function} wrapped remote callback\n             */\n            _genRemoteCallback(targetId, cid, withPromise) {\n              const me = this;\n              let remoteCallback;\n              if (withPromise) {\n                remoteCallback = function() {\n                  return new Promise(async (resolve, reject) => {\n                    const args = await me._wrap(Array.prototype.slice.call(arguments));\n                    const argLength = args.length;\n                    const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                    if (withKwargs)\n                      delete args[argLength - 1]._rkwargs;\n                    const transferables = args.__transferables__;\n                    if (transferables)\n                      delete args.__transferables__;\n                    const encodedPromise = await me._wrap([resolve, reject]);\n                    resolve.__promise_pair = encodedPromise[1]._rvalue;\n                    reject.__promise_pair = encodedPromise[0]._rvalue;\n                    try {\n                      me._connection.emit({\n                        type: \"callback\",\n                        target_id: targetId,\n                        id: cid,\n                        args,\n                        promise: encodedPromise,\n                        with_kwargs: withKwargs\n                      }, transferables);\n                    } catch (e) {\n                      reject(`Failed to exectue remote callback ( id: ${cid}).`);\n                    }\n                  });\n                };\n                return remoteCallback;\n              } else {\n                remoteCallback = async function() {\n                  const args = await me._wrap(Array.prototype.slice.call(arguments));\n                  const argLength = args.length;\n                  const withKwargs = argLength > 0 && typeof args[argLength - 1] === \"object\" && args[argLength - 1] !== null && args[argLength - 1]._rkwargs;\n                  if (withKwargs)\n                    delete args[argLength - 1]._rkwargs;\n                  const transferables = args.__transferables__;\n                  if (transferables)\n                    delete args.__transferables__;\n                  return me._connection.emit({\n                    type: \"callback\",\n                    target_id: targetId,\n                    id: cid,\n                    args,\n                    with_kwargs: withKwargs\n                  }, transferables);\n                };\n                return remoteCallback;\n              }\n            }\n            reset() {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._remote_interface = null;\n              this._object_store = {};\n              this._method_weakmap = /* @__PURE__ */ new WeakMap();\n              this._object_weakmap = /* @__PURE__ */ new WeakMap();\n              this._local_api = null;\n              this._store = new ReferenceStore();\n              this._method_refs = new ReferenceStore();\n            }\n            /**\n             * Sends the notification message and breaks the connection\n             */\n            disconnect() {\n              this._connection.emit({\n                type: \"disconnect\"\n              });\n              this.reset();\n              setTimeout(() => {\n                this._connection.disconnect();\n              }, 2e3);\n            }\n          }\n          class ReferenceStore {\n            constructor() {\n              this._store = {};\n              this._indices = [0];\n              this._readyHandler = function() {\n              };\n              this._busyHandler = function() {\n              };\n              this._readyHandler();\n            }\n            /**\n             * call handler when the store is empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onReady(readyHandler) {\n              this._readyHandler = readyHandler || function() {\n              };\n            }\n            /**\n             * call handler when the store is not empty\n             *\n             * @param {FUNCTION} id of a handler\n             */\n            onBusy(busyHandler) {\n              this._busyHandler = busyHandler || function() {\n              };\n            }\n            /**\n             * get the length of the store\n             *\n             */\n            getStack() {\n              return Object.keys(this._store).length;\n            }\n            /**\n             * @function _genId() generates the new reference id\n             *\n             * @returns {Number} smallest available id and reserves it\n             */\n            _genId() {\n              let id;\n              if (this._indices.length === 1) {\n                id = this._indices[0]++;\n              } else {\n                id = this._indices.shift();\n              }\n              return id;\n            }\n            /**\n             * Releases the given reference id so that it will be available by\n             * another object stored\n             *\n             * @param {Number} id to release\n             */\n            _releaseId(id) {\n              for (let i = 0; i < this._indices.length; i++) {\n                if (id < this._indices[i]) {\n                  this._indices.splice(i, 0, id);\n                  break;\n                }\n              }\n              for (let i = this._indices.length - 1; i >= 0; i--) {\n                if (this._indices[i] - 1 === this._indices[i - 1]) {\n                  this._indices.pop();\n                } else {\n                  break;\n                }\n              }\n            }\n            /**\n             * Stores the given object and returns the refernce id instead\n             *\n             * @param {Object} obj to store\n             *\n             * @returns {Number} reference id of the stored object\n             */\n            put(obj) {\n              if (this._busyHandler && Object.keys(this._store).length === 0) {\n                this._busyHandler();\n              }\n              const id = this._genId();\n              this._store[id] = obj;\n              return id;\n            }\n            /**\n             * Retrieves previously stored object and releases its reference\n             *\n             * @param {Number} id of an object to retrieve\n             */\n            fetch(id) {\n              const obj = this._store[id];\n              if (obj && !obj.__remote_method) {\n                delete this._store[id];\n                this._releaseId(id);\n                if (this._readyHandler && Object.keys(this._store).length === 0) {\n                  this._readyHandler();\n                }\n              }\n              if (obj && obj.__promise_pair) {\n                this.fetch(obj.__promise_pair);\n              }\n              return obj;\n            }\n          }\n        }\n      ),\n      /***/\n      \"./src/utils.js\": (\n        /*!**********************!*\\\n          !*** ./src/utils.js ***!\n          \\**********************/\n        /*! exports provided: randId, dtypeToTypedArray, loadRequirementsInWindow, loadRequirementsInWebworker, loadRequirements, normalizeConfig, typedArrayToDtypeMapping, typedArrayToDtype, cacheRequirements, setupServiceWorker, urlJoin, MessageEmitter */\n        /***/\n        function(module, __nested_webpack_exports__, __nested_webpack_require_131535__) {\n          \"use strict\";\n          __nested_webpack_require_131535__.r(__nested_webpack_exports__);\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"randId\", function() {\n            return randId;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"dtypeToTypedArray\", function() {\n            return dtypeToTypedArray;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"loadRequirementsInWindow\", function() {\n            return loadRequirementsInWindow;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"loadRequirementsInWebworker\", function() {\n            return loadRequirementsInWebworker;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"loadRequirements\", function() {\n            return loadRequirements;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"normalizeConfig\", function() {\n            return normalizeConfig;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"typedArrayToDtypeMapping\", function() {\n            return typedArrayToDtypeMapping;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"typedArrayToDtype\", function() {\n            return typedArrayToDtype;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"cacheRequirements\", function() {\n            return cacheRequirements;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"setupServiceWorker\", function() {\n            return setupServiceWorker;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"urlJoin\", function() {\n            return urlJoin;\n          });\n          __nested_webpack_require_131535__.d(__nested_webpack_exports__, \"MessageEmitter\", function() {\n            return MessageEmitter;\n          });\n          function randId() {\n            return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n          }\n          const dtypeToTypedArray = {\n            int8: Int8Array,\n            int16: Int16Array,\n            int32: Int32Array,\n            uint8: Uint8Array,\n            uint16: Uint16Array,\n            uint32: Uint32Array,\n            float32: Float32Array,\n            float64: Float64Array,\n            array: Array\n          };\n          async function loadRequirementsInWindow(requirements) {\n            function _importScript(url) {\n              return new Promise((resolve, reject) => {\n                var scriptTag = document.createElement(\"script\");\n                scriptTag.src = url;\n                scriptTag.type = \"text/javascript\";\n                scriptTag.onload = resolve;\n                scriptTag.onreadystatechange = function() {\n                  if (this.readyState === \"loaded\" || this.readyState === \"complete\") {\n                    resolve();\n                  }\n                };\n                scriptTag.onerror = reject;\n                document.head.appendChild(scriptTag);\n              });\n            }\n            async function importScripts2() {\n              var args = Array.prototype.slice.call(arguments), len = args.length, i2 = 0;\n              for (; i2 < len; i2++) {\n                await _importScript(args[i2]);\n              }\n            }\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                var link_node;\n                requirements = typeof requirements === \"string\" ? [requirements] : requirements;\n                if (Array.isArray(requirements)) {\n                  for (var i = 0; i < requirements.length; i++) {\n                    if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                      if (requirements[i].startsWith(\"css:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      link_node = document.createElement(\"link\");\n                      link_node.rel = \"stylesheet\";\n                      link_node.href = requirements[i];\n                      document.head.appendChild(link_node);\n                    } else if (requirements[i].toLowerCase().endsWith(\".mjs\") || requirements[i].startsWith(\"mjs:\")) {\n                      if (requirements[i].startsWith(\"mjs:\")) {\n                        requirements[i] = requirements[i].slice(4);\n                      }\n                      await import(\n                        /* webpackIgnore: true */\n                        requirements[i]\n                      );\n                    } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                      if (requirements[i].startsWith(\"js:\")) {\n                        requirements[i] = requirements[i].slice(3);\n                      }\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"http\")) {\n                      await importScripts2(requirements[i]);\n                    } else if (requirements[i].startsWith(\"cache:\")) {\n                    } else {\n                      console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                    }\n                  }\n                } else {\n                  throw \"unsupported requirements definition\";\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          async function loadRequirementsInWebworker(requirements) {\n            if (requirements && (Array.isArray(requirements) || typeof requirements === \"string\")) {\n              try {\n                if (!Array.isArray(requirements)) {\n                  requirements = [requirements];\n                }\n                for (var i = 0; i < requirements.length; i++) {\n                  if (requirements[i].toLowerCase().endsWith(\".css\") || requirements[i].startsWith(\"css:\")) {\n                    throw \"unable to import css in a webworker\";\n                  } else if (requirements[i].toLowerCase().endsWith(\".js\") || requirements[i].startsWith(\"js:\")) {\n                    if (requirements[i].startsWith(\"js:\")) {\n                      requirements[i] = requirements[i].slice(3);\n                    }\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"http\")) {\n                    importScripts(requirements[i]);\n                  } else if (requirements[i].startsWith(\"cache:\")) {\n                  } else {\n                    console.log(\"Unprocessed requirements url: \" + requirements[i]);\n                  }\n                }\n              } catch (e) {\n                throw \"failed to import required scripts: \" + requirements.toString();\n              }\n            }\n          }\n          function loadRequirements(requirements) {\n            if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n              return loadRequirementsInWebworker(requirements);\n            } else {\n              return loadRequirementsInWindow(requirements);\n            }\n          }\n          function normalizeConfig(config) {\n            config.version = config.version || \"0.1.0\";\n            config.description = config.description || `[TODO: add description for ${config.name} ]`;\n            config.type = config.type || \"rpc-window\";\n            config.id = config.id || randId();\n            config.target_origin = config.target_origin || \"*\";\n            config.allow_execution = config.allow_execution || false;\n            config = Object.keys(config).reduce((p, c) => {\n              if (typeof config[c] !== \"function\")\n                p[c] = config[c];\n              return p;\n            }, {});\n            return config;\n          }\n          const typedArrayToDtypeMapping = {\n            Int8Array: \"int8\",\n            Int16Array: \"int16\",\n            Int32Array: \"int32\",\n            Uint8Array: \"uint8\",\n            Uint16Array: \"uint16\",\n            Uint32Array: \"uint32\",\n            Float32Array: \"float32\",\n            Float64Array: \"float64\",\n            Array: \"array\"\n          };\n          const typedArrayToDtypeKeys = [];\n          for (const arrType of Object.keys(typedArrayToDtypeMapping)) {\n            typedArrayToDtypeKeys.push(eval(arrType));\n          }\n          function typedArrayToDtype(obj) {\n            let dtype = typedArrayToDtypeMapping[obj.constructor.name];\n            if (!dtype) {\n              const pt = Object.getPrototypeOf(obj);\n              for (const arrType2 of typedArrayToDtypeKeys) {\n                if (pt instanceof arrType2) {\n                  dtype = typedArrayToDtypeMapping[arrType2.name];\n                  break;\n                }\n              }\n            }\n            return dtype;\n          }\n          function cacheUrlInServiceWorker(url) {\n            return new Promise(function(resolve, reject) {\n              const message = {\n                command: \"add\",\n                url\n              };\n              if (!navigator.serviceWorker || !navigator.serviceWorker.register) {\n                reject(\"Service worker is not supported.\");\n                return;\n              }\n              const messageChannel = new MessageChannel();\n              messageChannel.port1.onmessage = function(event) {\n                if (event.data && event.data.error) {\n                  reject(event.data.error);\n                } else {\n                  resolve(event.data && event.data.result);\n                }\n              };\n              if (navigator.serviceWorker && navigator.serviceWorker.controller) {\n                navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n              } else {\n                reject(\"Service worker controller is not available\");\n              }\n            });\n          }\n          async function cacheRequirements(requirements) {\n            requirements = requirements || [];\n            if (!Array.isArray(requirements)) {\n              requirements = [requirements];\n            }\n            for (let req of requirements) {\n              if (req.startsWith(\"js:\"))\n                req = req.slice(3);\n              if (req.startsWith(\"css:\"))\n                req = req.slice(4);\n              if (req.startsWith(\"cache:\"))\n                req = req.slice(6);\n              if (!req.startsWith(\"http\"))\n                continue;\n              await cacheUrlInServiceWorker(req).catch((e) => {\n                console.error(e);\n              });\n            }\n          }\n          function setupServiceWorker(baseUrl, targetOrigin, cacheCallback) {\n            if (\"serviceWorker\" in navigator) {\n              baseUrl = baseUrl || \"/\";\n              navigator.serviceWorker.register(baseUrl + \"plugin-service-worker.js\").then(function(registration) {\n                console.log(\"ServiceWorker registration successful with scope: \", registration.scope);\n              }, function(err) {\n                console.log(\"ServiceWorker registration failed: \", err);\n              });\n              targetOrigin = targetOrigin || \"*\";\n              cacheCallback = cacheCallback || cacheRequirements;\n              if (cacheCallback && typeof cacheCallback !== \"function\") {\n                throw new Error(\"config.cache_requirements must be a function\");\n              }\n              window.addEventListener(\"message\", function(e) {\n                if (targetOrigin === \"*\" || e.origin === targetOrigin) {\n                  const m = e.data;\n                  if (m.type === \"cacheRequirements\") {\n                    cacheCallback(m.requirements);\n                  }\n                }\n              });\n            }\n          }\n          function urlJoin(...args) {\n            return args.join(\"/\").replace(/[\\/]+/g, \"/\").replace(/^(.+):\\//, \"$1://\").replace(/^file:/, \"file:/\").replace(/\\/(\\?|&|#[^!])/g, \"$1\").replace(/\\?/g, \"&\").replace(\"&\", \"?\");\n          }\n          class MessageEmitter {\n            constructor(debug) {\n              this._event_handlers = {};\n              this._once_handlers = {};\n              this._debug = debug;\n            }\n            emit() {\n              throw new Error(\"emit is not implemented\");\n            }\n            on(event, handler) {\n              if (!this._event_handlers[event]) {\n                this._event_handlers[event] = [];\n              }\n              this._event_handlers[event].push(handler);\n            }\n            once(event, handler) {\n              handler.___event_run_once = true;\n              this.on(event, handler);\n            }\n            off(event, handler) {\n              if (!event && !handler) {\n                this._event_handlers = {};\n              } else if (event && !handler) {\n                if (this._event_handlers[event])\n                  this._event_handlers[event] = [];\n              } else {\n                if (this._event_handlers[event]) {\n                  const idx = this._event_handlers[event].indexOf(handler);\n                  if (idx >= 0) {\n                    this._event_handlers[event].splice(idx, 1);\n                  }\n                }\n              }\n            }\n            _fire(event, data) {\n              if (this._event_handlers[event]) {\n                var i = this._event_handlers[event].length;\n                while (i--) {\n                  const handler = this._event_handlers[event][i];\n                  try {\n                    handler(data);\n                  } catch (e) {\n                    console.error(e);\n                  } finally {\n                    if (handler.___event_run_once) {\n                      this._event_handlers[event].splice(i, 1);\n                    }\n                  }\n                }\n              } else {\n                if (this._debug) {\n                  console.warn(\"unhandled event\", event, data);\n                }\n              }\n            }\n          }\n        }\n      )\n      /******/\n    })\n  );\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/dist/imjoy-rpc.js?");

/***/ }),

/***/ "./node_modules/imjoy-rpc/index.js":
/*!*****************************************!*\
  !*** ./node_modules/imjoy-rpc/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = { imjoyRPC: __webpack_require__(/*! ./dist/imjoy-rpc.js */ \"./node_modules/imjoy-rpc/dist/imjoy-rpc.js\"), imjoyRPCSocketIO: __webpack_require__(/*! ./dist/imjoy-rpc-socketio.js */ \"./node_modules/imjoy-rpc/dist/imjoy-rpc-socketio.js\"), hyphaRPC: __webpack_require__(/*! ./dist/hypha-rpc.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc.js\"), hyphaWebsocketClient: __webpack_require__(/*! ./dist/hypha-rpc-websocket.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc-websocket.js\"), hyphaSSEClient: __webpack_require__(/*! ./dist/hypha-rpc-sse.js */ \"./node_modules/imjoy-rpc/dist/hypha-rpc-sse.js\") };\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/imjoy-rpc/index.js?");

/***/ }),

/***/ "./node_modules/mock-socket/dist/mock-socket.js":
/*!******************************************************!*\
  !*** ./node_modules/mock-socket/dist/mock-socket.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function(global2, factory) {\n   true ? factory(exports) : 0;\n})(this, function(exports2) {\n  \"use strict\";\n  var commonjsGlobal = typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : {};\n  var requiresPort = function required(port, protocol) {\n    protocol = protocol.split(\":\")[0];\n    port = +port;\n    if (!port) {\n      return false;\n    }\n    switch (protocol) {\n      case \"http\":\n      case \"ws\":\n        return port !== 80;\n      case \"https\":\n      case \"wss\":\n        return port !== 443;\n      case \"ftp\":\n        return port !== 21;\n      case \"gopher\":\n        return port !== 70;\n      case \"file\":\n        return false;\n    }\n    return port !== 0;\n  };\n  var has = Object.prototype.hasOwnProperty;\n  var undef;\n  function decode(input) {\n    try {\n      return decodeURIComponent(input.replace(/\\+/g, \" \"));\n    } catch (e) {\n      return null;\n    }\n  }\n  function encode(input) {\n    try {\n      return encodeURIComponent(input);\n    } catch (e) {\n      return null;\n    }\n  }\n  function querystring(query) {\n    var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;\n    while (part = parser.exec(query)) {\n      var key = decode(part[1]), value = decode(part[2]);\n      if (key === null || value === null || key in result) {\n        continue;\n      }\n      result[key] = value;\n    }\n    return result;\n  }\n  function querystringify(obj, prefix) {\n    prefix = prefix || \"\";\n    var pairs = [], value, key;\n    if (\"string\" !== typeof prefix) {\n      prefix = \"?\";\n    }\n    for (key in obj) {\n      if (has.call(obj, key)) {\n        value = obj[key];\n        if (!value && (value === null || value === undef || isNaN(value))) {\n          value = \"\";\n        }\n        key = encode(key);\n        value = encode(value);\n        if (key === null || value === null) {\n          continue;\n        }\n        pairs.push(key + \"=\" + value);\n      }\n    }\n    return pairs.length ? prefix + pairs.join(\"&\") : \"\";\n  }\n  var stringify = querystringify;\n  var parse = querystring;\n  var querystringify_1 = {\n    stringify,\n    parse\n  };\n  var CRHTLF = /[\\n\\r\\t]/g;\n  var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n  var protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i;\n  var windowsDriveLetter = /^[a-zA-Z]:/;\n  var whitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\n  function trimLeft(str) {\n    return (str ? str : \"\").toString().replace(whitespace, \"\");\n  }\n  var rules = [\n    [\"#\", \"hash\"],\n    // Extract from the back.\n    [\"?\", \"query\"],\n    // Extract from the back.\n    function sanitize(address, url) {\n      return isSpecial(url.protocol) ? address.replace(/\\\\/g, \"/\") : address;\n    },\n    [\"/\", \"pathname\"],\n    // Extract from the back.\n    [\"@\", \"auth\", 1],\n    // Extract from the front.\n    [NaN, \"host\", void 0, 1, 1],\n    // Set left over value.\n    [/:(\\d*)$/, \"port\", void 0, 1],\n    // RegExp the back.\n    [NaN, \"hostname\", void 0, 1, 1]\n    // Set left over.\n  ];\n  var ignore = { hash: 1, query: 1 };\n  function lolcation(loc) {\n    var globalVar;\n    if (typeof window !== \"undefined\") {\n      globalVar = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n      globalVar = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n      globalVar = self;\n    } else {\n      globalVar = {};\n    }\n    var location = globalVar.location || {};\n    loc = loc || location;\n    var finaldestination = {}, type = typeof loc, key;\n    if (\"blob:\" === loc.protocol) {\n      finaldestination = new Url(unescape(loc.pathname), {});\n    } else if (\"string\" === type) {\n      finaldestination = new Url(loc, {});\n      for (key in ignore) {\n        delete finaldestination[key];\n      }\n    } else if (\"object\" === type) {\n      for (key in loc) {\n        if (key in ignore) {\n          continue;\n        }\n        finaldestination[key] = loc[key];\n      }\n      if (finaldestination.slashes === void 0) {\n        finaldestination.slashes = slashes.test(loc.href);\n      }\n    }\n    return finaldestination;\n  }\n  function isSpecial(scheme) {\n    return scheme === \"file:\" || scheme === \"ftp:\" || scheme === \"http:\" || scheme === \"https:\" || scheme === \"ws:\" || scheme === \"wss:\";\n  }\n  function extractProtocol(address, location) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, \"\");\n    location = location || {};\n    var match = protocolre.exec(address);\n    var protocol = match[1] ? match[1].toLowerCase() : \"\";\n    var forwardSlashes = !!match[2];\n    var otherSlashes = !!match[3];\n    var slashesCount = 0;\n    var rest;\n    if (forwardSlashes) {\n      if (otherSlashes) {\n        rest = match[2] + match[3] + match[4];\n        slashesCount = match[2].length + match[3].length;\n      } else {\n        rest = match[2] + match[4];\n        slashesCount = match[2].length;\n      }\n    } else {\n      if (otherSlashes) {\n        rest = match[3] + match[4];\n        slashesCount = match[3].length;\n      } else {\n        rest = match[4];\n      }\n    }\n    if (protocol === \"file:\") {\n      if (slashesCount >= 2) {\n        rest = rest.slice(2);\n      }\n    } else if (isSpecial(protocol)) {\n      rest = match[4];\n    } else if (protocol) {\n      if (forwardSlashes) {\n        rest = rest.slice(2);\n      }\n    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n      rest = match[4];\n    }\n    return {\n      protocol,\n      slashes: forwardSlashes || isSpecial(protocol),\n      slashesCount,\n      rest\n    };\n  }\n  function resolve(relative, base) {\n    if (relative === \"\") {\n      return base;\n    }\n    var path = (base || \"/\").split(\"/\").slice(0, -1).concat(relative.split(\"/\")), i = path.length, last = path[i - 1], unshift = false, up = 0;\n    while (i--) {\n      if (path[i] === \".\") {\n        path.splice(i, 1);\n      } else if (path[i] === \"..\") {\n        path.splice(i, 1);\n        up++;\n      } else if (up) {\n        if (i === 0) {\n          unshift = true;\n        }\n        path.splice(i, 1);\n        up--;\n      }\n    }\n    if (unshift) {\n      path.unshift(\"\");\n    }\n    if (last === \".\" || last === \"..\") {\n      path.push(\"\");\n    }\n    return path.join(\"/\");\n  }\n  function Url(address, location, parser) {\n    address = trimLeft(address);\n    address = address.replace(CRHTLF, \"\");\n    if (!(this instanceof Url)) {\n      return new Url(address, location, parser);\n    }\n    var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;\n    if (\"object\" !== type && \"string\" !== type) {\n      parser = location;\n      location = null;\n    }\n    if (parser && \"function\" !== typeof parser) {\n      parser = querystringify_1.parse;\n    }\n    location = lolcation(location);\n    extracted = extractProtocol(address || \"\", location);\n    relative = !extracted.protocol && !extracted.slashes;\n    url.slashes = extracted.slashes || relative && location.slashes;\n    url.protocol = extracted.protocol || location.protocol || \"\";\n    address = extracted.rest;\n    if (extracted.protocol === \"file:\" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {\n      instructions[3] = [/(.*)/, \"pathname\"];\n    }\n    for (; i < instructions.length; i++) {\n      instruction = instructions[i];\n      if (typeof instruction === \"function\") {\n        address = instruction(address, url);\n        continue;\n      }\n      parse2 = instruction[0];\n      key = instruction[1];\n      if (parse2 !== parse2) {\n        url[key] = address;\n      } else if (\"string\" === typeof parse2) {\n        index = parse2 === \"@\" ? address.lastIndexOf(parse2) : address.indexOf(parse2);\n        if (~index) {\n          if (\"number\" === typeof instruction[2]) {\n            url[key] = address.slice(0, index);\n            address = address.slice(index + instruction[2]);\n          } else {\n            url[key] = address.slice(index);\n            address = address.slice(0, index);\n          }\n        }\n      } else if (index = parse2.exec(address)) {\n        url[key] = index[1];\n        address = address.slice(0, index.index);\n      }\n      url[key] = url[key] || (relative && instruction[3] ? location[key] || \"\" : \"\");\n      if (instruction[4]) {\n        url[key] = url[key].toLowerCase();\n      }\n    }\n    if (parser) {\n      url.query = parser(url.query);\n    }\n    if (relative && location.slashes && url.pathname.charAt(0) !== \"/\" && (url.pathname !== \"\" || location.pathname !== \"\")) {\n      url.pathname = resolve(url.pathname, location.pathname);\n    }\n    if (url.pathname.charAt(0) !== \"/\" && isSpecial(url.protocol)) {\n      url.pathname = \"/\" + url.pathname;\n    }\n    if (!requiresPort(url.port, url.protocol)) {\n      url.host = url.hostname;\n      url.port = \"\";\n    }\n    url.username = url.password = \"\";\n    if (url.auth) {\n      index = url.auth.indexOf(\":\");\n      if (~index) {\n        url.username = url.auth.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n        url.password = url.auth.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(url.auth));\n      }\n      url.auth = url.password ? url.username + \":\" + url.password : url.username;\n    }\n    url.origin = url.protocol !== \"file:\" && isSpecial(url.protocol) && url.host ? url.protocol + \"//\" + url.host : \"null\";\n    url.href = url.toString();\n  }\n  function set(part, value, fn) {\n    var url = this;\n    switch (part) {\n      case \"query\":\n        if (\"string\" === typeof value && value.length) {\n          value = (fn || querystringify_1.parse)(value);\n        }\n        url[part] = value;\n        break;\n      case \"port\":\n        url[part] = value;\n        if (!requiresPort(value, url.protocol)) {\n          url.host = url.hostname;\n          url[part] = \"\";\n        } else if (value) {\n          url.host = url.hostname + \":\" + value;\n        }\n        break;\n      case \"hostname\":\n        url[part] = value;\n        if (url.port) {\n          value += \":\" + url.port;\n        }\n        url.host = value;\n        break;\n      case \"host\":\n        url[part] = value;\n        if (/:\\d+$/.test(value)) {\n          value = value.split(\":\");\n          url.port = value.pop();\n          url.hostname = value.join(\":\");\n        } else {\n          url.hostname = value;\n          url.port = \"\";\n        }\n        break;\n      case \"protocol\":\n        url.protocol = value.toLowerCase();\n        url.slashes = !fn;\n        break;\n      case \"pathname\":\n      case \"hash\":\n        if (value) {\n          var char = part === \"pathname\" ? \"/\" : \"#\";\n          url[part] = value.charAt(0) !== char ? char + value : value;\n        } else {\n          url[part] = value;\n        }\n        break;\n      case \"username\":\n      case \"password\":\n        url[part] = encodeURIComponent(value);\n        break;\n      case \"auth\":\n        var index = value.indexOf(\":\");\n        if (~index) {\n          url.username = value.slice(0, index);\n          url.username = encodeURIComponent(decodeURIComponent(url.username));\n          url.password = value.slice(index + 1);\n          url.password = encodeURIComponent(decodeURIComponent(url.password));\n        } else {\n          url.username = encodeURIComponent(decodeURIComponent(value));\n        }\n    }\n    for (var i = 0; i < rules.length; i++) {\n      var ins = rules[i];\n      if (ins[4]) {\n        url[ins[1]] = url[ins[1]].toLowerCase();\n      }\n    }\n    url.auth = url.password ? url.username + \":\" + url.password : url.username;\n    url.origin = url.protocol !== \"file:\" && isSpecial(url.protocol) && url.host ? url.protocol + \"//\" + url.host : \"null\";\n    url.href = url.toString();\n    return url;\n  }\n  function toString(stringify2) {\n    if (!stringify2 || \"function\" !== typeof stringify2) {\n      stringify2 = querystringify_1.stringify;\n    }\n    var query, url = this, host = url.host, protocol = url.protocol;\n    if (protocol && protocol.charAt(protocol.length - 1) !== \":\") {\n      protocol += \":\";\n    }\n    var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? \"//\" : \"\");\n    if (url.username) {\n      result += url.username;\n      if (url.password) {\n        result += \":\" + url.password;\n      }\n      result += \"@\";\n    } else if (url.password) {\n      result += \":\" + url.password;\n      result += \"@\";\n    } else if (url.protocol !== \"file:\" && isSpecial(url.protocol) && !host && url.pathname !== \"/\") {\n      result += \"@\";\n    }\n    if (host[host.length - 1] === \":\") {\n      host += \":\";\n    }\n    result += host + url.pathname;\n    query = \"object\" === typeof url.query ? stringify2(url.query) : url.query;\n    if (query) {\n      result += \"?\" !== query.charAt(0) ? \"?\" + query : query;\n    }\n    if (url.hash) {\n      result += url.hash;\n    }\n    return result;\n  }\n  Url.prototype = { set, toString };\n  Url.extractProtocol = extractProtocol;\n  Url.location = lolcation;\n  Url.trimLeft = trimLeft;\n  Url.qs = querystringify_1;\n  var urlParse = Url;\n  function delay(callback, context) {\n    setTimeout(function(timeoutContext) {\n      return callback.call(timeoutContext);\n    }, 4, context);\n  }\n  function log(method, message) {\n    if (typeof process !== \"undefined\" && \"development\" !== \"test\") {\n      console[method].call(null, message);\n    }\n  }\n  function reject(array, callback) {\n    if (array === void 0)\n      array = [];\n    var results = [];\n    array.forEach(function(itemInArray) {\n      if (!callback(itemInArray)) {\n        results.push(itemInArray);\n      }\n    });\n    return results;\n  }\n  function filter(array, callback) {\n    if (array === void 0)\n      array = [];\n    var results = [];\n    array.forEach(function(itemInArray) {\n      if (callback(itemInArray)) {\n        results.push(itemInArray);\n      }\n    });\n    return results;\n  }\n  var EventTarget = function EventTarget2() {\n    this.listeners = {};\n  };\n  EventTarget.prototype.addEventListener = function addEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n      if (!Array.isArray(this.listeners[type])) {\n        this.listeners[type] = [];\n      }\n      if (filter(this.listeners[type], function(item) {\n        return item === listener;\n      }).length === 0) {\n        this.listeners[type].push(listener);\n      }\n    }\n  };\n  EventTarget.prototype.removeEventListener = function removeEventListener(type, removingListener) {\n    var arrayOfListeners = this.listeners[type];\n    this.listeners[type] = reject(arrayOfListeners, function(listener) {\n      return listener === removingListener;\n    });\n  };\n  EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n    var this$1 = this;\n    var customArguments = [], len = arguments.length - 1;\n    while (len-- > 0)\n      customArguments[len] = arguments[len + 1];\n    var eventName = event.type;\n    var listeners = this.listeners[eventName];\n    if (!Array.isArray(listeners)) {\n      return false;\n    }\n    listeners.forEach(function(listener) {\n      if (customArguments.length > 0) {\n        listener.apply(this$1, customArguments);\n      } else {\n        listener.call(this$1, event);\n      }\n    });\n    return true;\n  };\n  function trimQueryPartFromURL(url) {\n    var queryIndex = url.indexOf(\"?\");\n    return queryIndex >= 0 ? url.slice(0, queryIndex) : url;\n  }\n  var NetworkBridge = function NetworkBridge2() {\n    this.urlMap = {};\n  };\n  NetworkBridge.prototype.attachWebSocket = function attachWebSocket(websocket, url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) === -1) {\n      connectionLookup.websockets.push(websocket);\n      return connectionLookup.server;\n    }\n  };\n  NetworkBridge.prototype.addMembershipToRoom = function addMembershipToRoom(websocket, room) {\n    var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n    if (connectionLookup && connectionLookup.server && connectionLookup.websockets.indexOf(websocket) !== -1) {\n      if (!connectionLookup.roomMemberships[room]) {\n        connectionLookup.roomMemberships[room] = [];\n      }\n      connectionLookup.roomMemberships[room].push(websocket);\n    }\n  };\n  NetworkBridge.prototype.attachServer = function attachServer(server, url) {\n    var serverUrl = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverUrl];\n    if (!connectionLookup) {\n      this.urlMap[serverUrl] = {\n        server,\n        websockets: [],\n        roomMemberships: {}\n      };\n      return server;\n    }\n  };\n  NetworkBridge.prototype.serverLookup = function serverLookup(url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup) {\n      return connectionLookup.server;\n    }\n  };\n  NetworkBridge.prototype.websocketsLookup = function websocketsLookup(url, room, broadcaster) {\n    var serverURL = trimQueryPartFromURL(url);\n    var websockets;\n    var connectionLookup = this.urlMap[serverURL];\n    websockets = connectionLookup ? connectionLookup.websockets : [];\n    if (room) {\n      var members = connectionLookup.roomMemberships[room];\n      websockets = members || [];\n    }\n    return broadcaster ? websockets.filter(function(websocket) {\n      return websocket !== broadcaster;\n    }) : websockets;\n  };\n  NetworkBridge.prototype.removeServer = function removeServer(url) {\n    delete this.urlMap[trimQueryPartFromURL(url)];\n  };\n  NetworkBridge.prototype.removeWebSocket = function removeWebSocket(websocket, url) {\n    var serverURL = trimQueryPartFromURL(url);\n    var connectionLookup = this.urlMap[serverURL];\n    if (connectionLookup) {\n      connectionLookup.websockets = reject(connectionLookup.websockets, function(socket) {\n        return socket === websocket;\n      });\n    }\n  };\n  NetworkBridge.prototype.removeMembershipFromRoom = function removeMembershipFromRoom(websocket, room) {\n    var connectionLookup = this.urlMap[trimQueryPartFromURL(websocket.url)];\n    var memberships = connectionLookup.roomMemberships[room];\n    if (connectionLookup && memberships !== null) {\n      connectionLookup.roomMemberships[room] = reject(memberships, function(socket) {\n        return socket === websocket;\n      });\n    }\n  };\n  var networkBridge = new NetworkBridge();\n  var CLOSE_CODES = {\n    CLOSE_NORMAL: 1e3,\n    CLOSE_GOING_AWAY: 1001,\n    CLOSE_PROTOCOL_ERROR: 1002,\n    CLOSE_UNSUPPORTED: 1003,\n    CLOSE_NO_STATUS: 1005,\n    CLOSE_ABNORMAL: 1006,\n    UNSUPPORTED_DATA: 1007,\n    POLICY_VIOLATION: 1008,\n    CLOSE_TOO_LARGE: 1009,\n    MISSING_EXTENSION: 1010,\n    INTERNAL_ERROR: 1011,\n    SERVICE_RESTART: 1012,\n    TRY_AGAIN_LATER: 1013,\n    TLS_HANDSHAKE: 1015\n  };\n  var ERROR_PREFIX = {\n    CONSTRUCTOR_ERROR: \"Failed to construct 'WebSocket':\",\n    CLOSE_ERROR: \"Failed to execute 'close' on 'WebSocket':\",\n    EVENT: {\n      CONSTRUCT: \"Failed to construct 'Event':\",\n      MESSAGE: \"Failed to construct 'MessageEvent':\",\n      CLOSE: \"Failed to construct 'CloseEvent':\"\n    }\n  };\n  var EventPrototype = function EventPrototype2() {\n  };\n  EventPrototype.prototype.stopPropagation = function stopPropagation() {\n  };\n  EventPrototype.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n  };\n  EventPrototype.prototype.initEvent = function initEvent(type, bubbles, cancelable) {\n    if (type === void 0)\n      type = \"undefined\";\n    if (bubbles === void 0)\n      bubbles = false;\n    if (cancelable === void 0)\n      cancelable = false;\n    this.type = \"\" + type;\n    this.bubbles = Boolean(bubbles);\n    this.cancelable = Boolean(cancelable);\n  };\n  var Event = function(EventPrototype$$1) {\n    function Event2(type, eventInitConfig) {\n      if (eventInitConfig === void 0)\n        eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT_ERROR + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== \"object\") {\n        throw new TypeError(ERROR_PREFIX.EVENT_ERROR + \" parameter 2 ('eventInitDict') is not an object.\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.cancelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n    }\n    if (EventPrototype$$1)\n      Event2.__proto__ = EventPrototype$$1;\n    Event2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    Event2.prototype.constructor = Event2;\n    return Event2;\n  }(EventPrototype);\n  var MessageEvent = function(EventPrototype$$1) {\n    function MessageEvent2(type, eventInitConfig) {\n      if (eventInitConfig === void 0)\n        eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== \"object\") {\n        throw new TypeError(ERROR_PREFIX.EVENT.MESSAGE + \" parameter 2 ('eventInitDict') is not an object\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      var data = eventInitConfig.data;\n      var origin = eventInitConfig.origin;\n      var lastEventId = eventInitConfig.lastEventId;\n      var ports = eventInitConfig.ports;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.canncelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n      this.origin = \"\" + origin;\n      this.ports = typeof ports === \"undefined\" ? null : ports;\n      this.data = typeof data === \"undefined\" ? null : data;\n      this.lastEventId = \"\" + (lastEventId || \"\");\n    }\n    if (EventPrototype$$1)\n      MessageEvent2.__proto__ = EventPrototype$$1;\n    MessageEvent2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    MessageEvent2.prototype.constructor = MessageEvent2;\n    return MessageEvent2;\n  }(EventPrototype);\n  var CloseEvent = function(EventPrototype$$1) {\n    function CloseEvent2(type, eventInitConfig) {\n      if (eventInitConfig === void 0)\n        eventInitConfig = {};\n      EventPrototype$$1.call(this);\n      if (!type) {\n        throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + \" 1 argument required, but only 0 present.\");\n      }\n      if (typeof eventInitConfig !== \"object\") {\n        throw new TypeError(ERROR_PREFIX.EVENT.CLOSE + \" parameter 2 ('eventInitDict') is not an object\");\n      }\n      var bubbles = eventInitConfig.bubbles;\n      var cancelable = eventInitConfig.cancelable;\n      var code = eventInitConfig.code;\n      var reason = eventInitConfig.reason;\n      var wasClean = eventInitConfig.wasClean;\n      this.type = \"\" + type;\n      this.timeStamp = Date.now();\n      this.target = null;\n      this.srcElement = null;\n      this.returnValue = true;\n      this.isTrusted = false;\n      this.eventPhase = 0;\n      this.defaultPrevented = false;\n      this.currentTarget = null;\n      this.cancelable = cancelable ? Boolean(cancelable) : false;\n      this.cancelBubble = false;\n      this.bubbles = bubbles ? Boolean(bubbles) : false;\n      this.code = typeof code === \"number\" ? parseInt(code, 10) : 0;\n      this.reason = \"\" + (reason || \"\");\n      this.wasClean = wasClean ? Boolean(wasClean) : false;\n    }\n    if (EventPrototype$$1)\n      CloseEvent2.__proto__ = EventPrototype$$1;\n    CloseEvent2.prototype = Object.create(EventPrototype$$1 && EventPrototype$$1.prototype);\n    CloseEvent2.prototype.constructor = CloseEvent2;\n    return CloseEvent2;\n  }(EventPrototype);\n  function createEvent(config) {\n    var type = config.type;\n    var target = config.target;\n    var eventObject = new Event(type);\n    if (target) {\n      eventObject.target = target;\n      eventObject.srcElement = target;\n      eventObject.currentTarget = target;\n    }\n    return eventObject;\n  }\n  function createMessageEvent(config) {\n    var type = config.type;\n    var origin = config.origin;\n    var data = config.data;\n    var target = config.target;\n    var messageEvent = new MessageEvent(type, {\n      data,\n      origin\n    });\n    if (target) {\n      messageEvent.target = target;\n      messageEvent.srcElement = target;\n      messageEvent.currentTarget = target;\n    }\n    return messageEvent;\n  }\n  function createCloseEvent(config) {\n    var code = config.code;\n    var reason = config.reason;\n    var type = config.type;\n    var target = config.target;\n    var wasClean = config.wasClean;\n    if (!wasClean) {\n      wasClean = code === CLOSE_CODES.CLOSE_NORMAL || code === CLOSE_CODES.CLOSE_NO_STATUS;\n    }\n    var closeEvent = new CloseEvent(type, {\n      code,\n      reason,\n      wasClean\n    });\n    if (target) {\n      closeEvent.target = target;\n      closeEvent.srcElement = target;\n      closeEvent.currentTarget = target;\n    }\n    return closeEvent;\n  }\n  function closeWebSocketConnection(context, code, reason) {\n    context.readyState = WebSocket$1.CLOSING;\n    var server = networkBridge.serverLookup(context.url);\n    var closeEvent = createCloseEvent({\n      type: \"close\",\n      target: context.target,\n      code,\n      reason\n    });\n    delay(function() {\n      networkBridge.removeWebSocket(context, context.url);\n      context.readyState = WebSocket$1.CLOSED;\n      context.dispatchEvent(closeEvent);\n      if (server) {\n        server.dispatchEvent(closeEvent, server);\n      }\n    }, context);\n  }\n  function failWebSocketConnection(context, code, reason) {\n    context.readyState = WebSocket$1.CLOSING;\n    var server = networkBridge.serverLookup(context.url);\n    var closeEvent = createCloseEvent({\n      type: \"close\",\n      target: context.target,\n      code,\n      reason,\n      wasClean: false\n    });\n    var errorEvent = createEvent({\n      type: \"error\",\n      target: context.target\n    });\n    delay(function() {\n      networkBridge.removeWebSocket(context, context.url);\n      context.readyState = WebSocket$1.CLOSED;\n      context.dispatchEvent(errorEvent);\n      context.dispatchEvent(closeEvent);\n      if (server) {\n        server.dispatchEvent(closeEvent, server);\n      }\n    }, context);\n  }\n  function normalizeSendData(data) {\n    if (Object.prototype.toString.call(data) !== \"[object Blob]\" && !(data instanceof ArrayBuffer)) {\n      data = String(data);\n    }\n    return data;\n  }\n  var proxies = /* @__PURE__ */ new WeakMap();\n  function proxyFactory(target) {\n    if (proxies.has(target)) {\n      return proxies.get(target);\n    }\n    var proxy = new Proxy(target, {\n      get: function get(obj, prop) {\n        if (prop === \"close\") {\n          return function close(options) {\n            if (options === void 0)\n              options = {};\n            var code = options.code || CLOSE_CODES.CLOSE_NORMAL;\n            var reason = options.reason || \"\";\n            closeWebSocketConnection(proxy, code, reason);\n          };\n        }\n        if (prop === \"send\") {\n          return function send(data) {\n            data = normalizeSendData(data);\n            target.dispatchEvent(\n              createMessageEvent({\n                type: \"message\",\n                data,\n                origin: this.url,\n                target\n              })\n            );\n          };\n        }\n        var toSocketName = function(type) {\n          return type === \"message\" ? \"server::\" + type : type;\n        };\n        if (prop === \"on\") {\n          return function onWrapper(type, cb) {\n            target.addEventListener(toSocketName(type), cb);\n          };\n        }\n        if (prop === \"off\") {\n          return function offWrapper(type, cb) {\n            target.removeEventListener(toSocketName(type), cb);\n          };\n        }\n        if (prop === \"target\") {\n          return target;\n        }\n        return obj[prop];\n      }\n    });\n    proxies.set(target, proxy);\n    return proxy;\n  }\n  function lengthInUtf8Bytes(str) {\n    var m = encodeURIComponent(str).match(/%[89ABab]/g);\n    return str.length + (m ? m.length : 0);\n  }\n  function urlVerification(url) {\n    var urlRecord = new urlParse(url);\n    var pathname = urlRecord.pathname;\n    var protocol = urlRecord.protocol;\n    var hash = urlRecord.hash;\n    if (!url) {\n      throw new TypeError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" 1 argument required, but only 0 present.\");\n    }\n    if (!pathname) {\n      urlRecord.pathname = \"/\";\n    }\n    if (protocol === \"\") {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL '\" + urlRecord.toString() + \"' is invalid.\");\n    }\n    if (protocol !== \"ws:\" && protocol !== \"wss:\") {\n      throw new SyntaxError(\n        ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL's scheme must be either 'ws' or 'wss'. '\" + protocol + \"' is not allowed.\"\n      );\n    }\n    if (hash !== \"\") {\n      throw new SyntaxError(\n        ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The URL contains a fragment identifier ('\" + hash + \"'). Fragment identifiers are not allowed in WebSocket URLs.\"\n      );\n    }\n    return urlRecord.toString();\n  }\n  function protocolVerification(protocols) {\n    if (protocols === void 0)\n      protocols = [];\n    if (!Array.isArray(protocols) && typeof protocols !== \"string\") {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The subprotocol '\" + protocols.toString() + \"' is invalid.\");\n    }\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n    var uniq = protocols.map(function(p) {\n      return { count: 1, protocol: p };\n    }).reduce(function(a, b) {\n      a[b.protocol] = (a[b.protocol] || 0) + b.count;\n      return a;\n    }, {});\n    var duplicates = Object.keys(uniq).filter(function(a) {\n      return uniq[a] > 1;\n    });\n    if (duplicates.length > 0) {\n      throw new SyntaxError(ERROR_PREFIX.CONSTRUCTOR_ERROR + \" The subprotocol '\" + duplicates[0] + \"' is duplicated.\");\n    }\n    return protocols;\n  }\n  var WebSocket$1 = function(EventTarget$$1) {\n    function WebSocket2(url, protocols) {\n      EventTarget$$1.call(this);\n      this._onopen = null;\n      this._onmessage = null;\n      this._onerror = null;\n      this._onclose = null;\n      this.url = urlVerification(url);\n      protocols = protocolVerification(protocols);\n      this.protocol = protocols[0] || \"\";\n      this.binaryType = \"blob\";\n      this.readyState = WebSocket2.CONNECTING;\n      var client = proxyFactory(this);\n      var server = networkBridge.attachWebSocket(client, this.url);\n      delay(function delayCallback() {\n        if (this.readyState !== WebSocket2.CONNECTING) {\n          return;\n        }\n        if (server) {\n          if (server.options.verifyClient && typeof server.options.verifyClient === \"function\" && !server.options.verifyClient()) {\n            this.readyState = WebSocket2.CLOSED;\n            log(\n              \"error\",\n              \"WebSocket connection to '\" + this.url + \"' failed: HTTP Authentication failed; no valid credentials available\"\n            );\n            networkBridge.removeWebSocket(client, this.url);\n            this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n            this.dispatchEvent(createCloseEvent({ type: \"close\", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n          } else {\n            if (server.options.selectProtocol && typeof server.options.selectProtocol === \"function\") {\n              var selectedProtocol = server.options.selectProtocol(protocols);\n              var isFilled = selectedProtocol !== \"\";\n              var isRequested = protocols.indexOf(selectedProtocol) !== -1;\n              if (isFilled && !isRequested) {\n                this.readyState = WebSocket2.CLOSED;\n                log(\"error\", \"WebSocket connection to '\" + this.url + \"' failed: Invalid Sub-Protocol\");\n                networkBridge.removeWebSocket(client, this.url);\n                this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n                this.dispatchEvent(createCloseEvent({ type: \"close\", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n                return;\n              }\n              this.protocol = selectedProtocol;\n            }\n            this.readyState = WebSocket2.OPEN;\n            this.dispatchEvent(createEvent({ type: \"open\", target: this }));\n            server.dispatchEvent(createEvent({ type: \"connection\" }), client);\n          }\n        } else {\n          this.readyState = WebSocket2.CLOSED;\n          this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n          this.dispatchEvent(createCloseEvent({ type: \"close\", target: this, code: CLOSE_CODES.CLOSE_NORMAL }));\n          log(\"error\", \"WebSocket connection to '\" + this.url + \"' failed\");\n        }\n      }, this);\n    }\n    if (EventTarget$$1)\n      WebSocket2.__proto__ = EventTarget$$1;\n    WebSocket2.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    WebSocket2.prototype.constructor = WebSocket2;\n    var prototypeAccessors = { onopen: {}, onmessage: {}, onclose: {}, onerror: {} };\n    prototypeAccessors.onopen.get = function() {\n      return this._onopen;\n    };\n    prototypeAccessors.onmessage.get = function() {\n      return this._onmessage;\n    };\n    prototypeAccessors.onclose.get = function() {\n      return this._onclose;\n    };\n    prototypeAccessors.onerror.get = function() {\n      return this._onerror;\n    };\n    prototypeAccessors.onopen.set = function(listener) {\n      this.removeEventListener(\"open\", this._onopen);\n      this._onopen = listener;\n      this.addEventListener(\"open\", listener);\n    };\n    prototypeAccessors.onmessage.set = function(listener) {\n      this.removeEventListener(\"message\", this._onmessage);\n      this._onmessage = listener;\n      this.addEventListener(\"message\", listener);\n    };\n    prototypeAccessors.onclose.set = function(listener) {\n      this.removeEventListener(\"close\", this._onclose);\n      this._onclose = listener;\n      this.addEventListener(\"close\", listener);\n    };\n    prototypeAccessors.onerror.set = function(listener) {\n      this.removeEventListener(\"error\", this._onerror);\n      this._onerror = listener;\n      this.addEventListener(\"error\", listener);\n    };\n    WebSocket2.prototype.send = function send(data) {\n      var this$1 = this;\n      if (this.readyState === WebSocket2.CONNECTING) {\n        throw new Error(\"Failed to execute 'send' on 'WebSocket': Still in CONNECTING state\");\n      }\n      var messageEvent = createMessageEvent({\n        type: \"server::message\",\n        origin: this.url,\n        data: normalizeSendData(data)\n      });\n      var server = networkBridge.serverLookup(this.url);\n      if (server) {\n        delay(function() {\n          this$1.dispatchEvent(messageEvent, data);\n        }, server);\n      }\n    };\n    WebSocket2.prototype.close = function close(code, reason) {\n      if (code !== void 0) {\n        if (typeof code !== \"number\" || code !== 1e3 && (code < 3e3 || code > 4999)) {\n          throw new TypeError(\n            ERROR_PREFIX.CLOSE_ERROR + \" The code must be either 1000, or between 3000 and 4999. \" + code + \" is neither.\"\n          );\n        }\n      }\n      if (reason !== void 0) {\n        var length = lengthInUtf8Bytes(reason);\n        if (length > 123) {\n          throw new SyntaxError(ERROR_PREFIX.CLOSE_ERROR + \" The message must not be greater than 123 bytes.\");\n        }\n      }\n      if (this.readyState === WebSocket2.CLOSING || this.readyState === WebSocket2.CLOSED) {\n        return;\n      }\n      var client = proxyFactory(this);\n      if (this.readyState === WebSocket2.CONNECTING) {\n        failWebSocketConnection(client, code || CLOSE_CODES.CLOSE_ABNORMAL, reason);\n      } else {\n        closeWebSocketConnection(client, code || CLOSE_CODES.CLOSE_NO_STATUS, reason);\n      }\n    };\n    Object.defineProperties(WebSocket2.prototype, prototypeAccessors);\n    return WebSocket2;\n  }(EventTarget);\n  WebSocket$1.CONNECTING = 0;\n  WebSocket$1.prototype.CONNECTING = WebSocket$1.CONNECTING;\n  WebSocket$1.OPEN = 1;\n  WebSocket$1.prototype.OPEN = WebSocket$1.OPEN;\n  WebSocket$1.CLOSING = 2;\n  WebSocket$1.prototype.CLOSING = WebSocket$1.CLOSING;\n  WebSocket$1.CLOSED = 3;\n  WebSocket$1.prototype.CLOSED = WebSocket$1.CLOSED;\n  var SocketIO$1 = function(EventTarget$$1) {\n    function SocketIO(url, protocol) {\n      var this$1 = this;\n      if (url === void 0)\n        url = \"socket.io\";\n      if (protocol === void 0)\n        protocol = \"\";\n      EventTarget$$1.call(this);\n      this.binaryType = \"blob\";\n      var urlRecord = new urlParse(url);\n      if (!urlRecord.pathname) {\n        urlRecord.pathname = \"/\";\n      }\n      this.url = urlRecord.toString();\n      this.readyState = SocketIO.CONNECTING;\n      this.protocol = \"\";\n      this.target = this;\n      if (typeof protocol === \"string\" || typeof protocol === \"object\" && protocol !== null) {\n        this.protocol = protocol;\n      } else if (Array.isArray(protocol) && protocol.length > 0) {\n        this.protocol = protocol[0];\n      }\n      var server = networkBridge.attachWebSocket(this, this.url);\n      delay(function delayCallback() {\n        if (server) {\n          this.readyState = SocketIO.OPEN;\n          server.dispatchEvent(createEvent({ type: \"connection\" }), server, this);\n          server.dispatchEvent(createEvent({ type: \"connect\" }), server, this);\n          this.dispatchEvent(createEvent({ type: \"connect\", target: this }));\n        } else {\n          this.readyState = SocketIO.CLOSED;\n          this.dispatchEvent(createEvent({ type: \"error\", target: this }));\n          this.dispatchEvent(\n            createCloseEvent({\n              type: \"close\",\n              target: this,\n              code: CLOSE_CODES.CLOSE_NORMAL\n            })\n          );\n          log(\"error\", \"Socket.io connection to '\" + this.url + \"' failed\");\n        }\n      }, this);\n      this.addEventListener(\"close\", function(event) {\n        this$1.dispatchEvent(\n          createCloseEvent({\n            type: \"disconnect\",\n            target: event.target,\n            code: event.code\n          })\n        );\n      });\n    }\n    if (EventTarget$$1)\n      SocketIO.__proto__ = EventTarget$$1;\n    SocketIO.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    SocketIO.prototype.constructor = SocketIO;\n    var prototypeAccessors = { broadcast: {} };\n    SocketIO.prototype.close = function close() {\n      if (this.readyState !== SocketIO.OPEN) {\n        return void 0;\n      }\n      var server = networkBridge.serverLookup(this.url);\n      networkBridge.removeWebSocket(this, this.url);\n      this.readyState = SocketIO.CLOSED;\n      this.dispatchEvent(\n        createCloseEvent({\n          type: \"close\",\n          target: this,\n          code: CLOSE_CODES.CLOSE_NORMAL\n        })\n      );\n      if (server) {\n        server.dispatchEvent(\n          createCloseEvent({\n            type: \"disconnect\",\n            target: this,\n            code: CLOSE_CODES.CLOSE_NORMAL\n          }),\n          server\n        );\n      }\n      return this;\n    };\n    SocketIO.prototype.disconnect = function disconnect() {\n      return this.close();\n    };\n    SocketIO.prototype.emit = function emit(event) {\n      var data = [], len = arguments.length - 1;\n      while (len-- > 0)\n        data[len] = arguments[len + 1];\n      if (this.readyState !== SocketIO.OPEN) {\n        throw new Error(\"SocketIO is already in CLOSING or CLOSED state\");\n      }\n      var messageEvent = createMessageEvent({\n        type: event,\n        origin: this.url,\n        data\n      });\n      var server = networkBridge.serverLookup(this.url);\n      if (server) {\n        server.dispatchEvent.apply(server, [messageEvent].concat(data));\n      }\n      return this;\n    };\n    SocketIO.prototype.send = function send(data) {\n      this.emit(\"message\", data);\n      return this;\n    };\n    prototypeAccessors.broadcast.get = function() {\n      if (this.readyState !== SocketIO.OPEN) {\n        throw new Error(\"SocketIO is already in CLOSING or CLOSED state\");\n      }\n      var self2 = this;\n      var server = networkBridge.serverLookup(this.url);\n      if (!server) {\n        throw new Error(\"SocketIO can not find a server at the specified URL (\" + this.url + \")\");\n      }\n      return {\n        emit: function emit(event, data) {\n          server.emit(event, data, { websockets: networkBridge.websocketsLookup(self2.url, null, self2) });\n          return self2;\n        },\n        to: function to(room) {\n          return server.to(room, self2);\n        },\n        in: function in$1(room) {\n          return server.in(room, self2);\n        }\n      };\n    };\n    SocketIO.prototype.on = function on(type, callback) {\n      this.addEventListener(type, callback);\n      return this;\n    };\n    SocketIO.prototype.off = function off(type, callback) {\n      this.removeEventListener(type, callback);\n    };\n    SocketIO.prototype.hasListeners = function hasListeners(type) {\n      var listeners = this.listeners[type];\n      if (!Array.isArray(listeners)) {\n        return false;\n      }\n      return !!listeners.length;\n    };\n    SocketIO.prototype.join = function join(room) {\n      networkBridge.addMembershipToRoom(this, room);\n    };\n    SocketIO.prototype.leave = function leave(room) {\n      networkBridge.removeMembershipFromRoom(this, room);\n    };\n    SocketIO.prototype.to = function to(room) {\n      return this.broadcast.to(room);\n    };\n    SocketIO.prototype.in = function in$1() {\n      return this.to.apply(null, arguments);\n    };\n    SocketIO.prototype.dispatchEvent = function dispatchEvent(event) {\n      var this$1 = this;\n      var customArguments = [], len = arguments.length - 1;\n      while (len-- > 0)\n        customArguments[len] = arguments[len + 1];\n      var eventName = event.type;\n      var listeners = this.listeners[eventName];\n      if (!Array.isArray(listeners)) {\n        return false;\n      }\n      listeners.forEach(function(listener) {\n        if (customArguments.length > 0) {\n          listener.apply(this$1, customArguments);\n        } else {\n          listener.call(this$1, event.data ? event.data : event);\n        }\n      });\n    };\n    Object.defineProperties(SocketIO.prototype, prototypeAccessors);\n    return SocketIO;\n  }(EventTarget);\n  SocketIO$1.CONNECTING = 0;\n  SocketIO$1.OPEN = 1;\n  SocketIO$1.CLOSING = 2;\n  SocketIO$1.CLOSED = 3;\n  var IO = function ioConstructor(url, protocol) {\n    return new SocketIO$1(url, protocol);\n  };\n  IO.connect = function ioConnect(url, protocol) {\n    return IO(url, protocol);\n  };\n  var dedupe = function(arr) {\n    return arr.reduce(function(deduped, b) {\n      if (deduped.indexOf(b) > -1) {\n        return deduped;\n      }\n      return deduped.concat(b);\n    }, []);\n  };\n  function retrieveGlobalObject() {\n    if (typeof window !== \"undefined\") {\n      return window;\n    }\n    return typeof process === \"object\" && \"function\" === \"function\" && typeof __webpack_require__.g === \"object\" ? __webpack_require__.g : this;\n  }\n  var defaultOptions = {\n    mock: true,\n    verifyClient: null,\n    selectProtocol: null\n  };\n  var Server$1 = function(EventTarget$$1) {\n    function Server2(url, options) {\n      if (options === void 0)\n        options = defaultOptions;\n      EventTarget$$1.call(this);\n      var urlRecord = new urlParse(url);\n      if (!urlRecord.pathname) {\n        urlRecord.pathname = \"/\";\n      }\n      this.url = urlRecord.toString();\n      this.originalWebSocket = null;\n      var server = networkBridge.attachServer(this, this.url);\n      if (!server) {\n        this.dispatchEvent(createEvent({ type: \"error\" }));\n        throw new Error(\"A mock server is already listening on this url\");\n      }\n      this.options = Object.assign({}, defaultOptions, options);\n      if (this.options.mock) {\n        this.mockWebsocket();\n      }\n    }\n    if (EventTarget$$1)\n      Server2.__proto__ = EventTarget$$1;\n    Server2.prototype = Object.create(EventTarget$$1 && EventTarget$$1.prototype);\n    Server2.prototype.constructor = Server2;\n    Server2.prototype.mockWebsocket = function mockWebsocket() {\n      var globalObj = retrieveGlobalObject();\n      this.originalWebSocket = globalObj.WebSocket;\n      globalObj.WebSocket = WebSocket$1;\n    };\n    Server2.prototype.restoreWebsocket = function restoreWebsocket() {\n      var globalObj = retrieveGlobalObject();\n      if (this.originalWebSocket !== null) {\n        globalObj.WebSocket = this.originalWebSocket;\n      }\n      this.originalWebSocket = null;\n    };\n    Server2.prototype.stop = function stop(callback) {\n      if (callback === void 0)\n        callback = function() {\n        };\n      if (this.options.mock) {\n        this.restoreWebsocket();\n      }\n      networkBridge.removeServer(this.url);\n      if (typeof callback === \"function\") {\n        callback();\n      }\n    };\n    Server2.prototype.on = function on(type, callback) {\n      this.addEventListener(type, callback);\n    };\n    Server2.prototype.off = function off(type, callback) {\n      this.removeEventListener(type, callback);\n    };\n    Server2.prototype.close = function close(options) {\n      if (options === void 0)\n        options = {};\n      var code = options.code;\n      var reason = options.reason;\n      var wasClean = options.wasClean;\n      var listeners = networkBridge.websocketsLookup(this.url);\n      networkBridge.removeServer(this.url);\n      listeners.forEach(function(socket) {\n        socket.readyState = WebSocket$1.CLOSED;\n        socket.dispatchEvent(\n          createCloseEvent({\n            type: \"close\",\n            target: socket.target,\n            code: code || CLOSE_CODES.CLOSE_NORMAL,\n            reason: reason || \"\",\n            wasClean\n          })\n        );\n      });\n      this.dispatchEvent(createCloseEvent({ type: \"close\" }), this);\n    };\n    Server2.prototype.emit = function emit(event, data, options) {\n      var this$1 = this;\n      if (options === void 0)\n        options = {};\n      var websockets = options.websockets;\n      if (!websockets) {\n        websockets = networkBridge.websocketsLookup(this.url);\n      }\n      var normalizedData;\n      if (typeof options !== \"object\" || arguments.length > 3) {\n        data = Array.prototype.slice.call(arguments, 1, arguments.length);\n        normalizedData = data.map(function(item) {\n          return normalizeSendData(item);\n        });\n      } else {\n        normalizedData = normalizeSendData(data);\n      }\n      websockets.forEach(function(socket) {\n        var messageData = socket instanceof SocketIO$1 ? data : normalizedData;\n        if (Array.isArray(messageData)) {\n          socket.dispatchEvent.apply(\n            socket,\n            [createMessageEvent({\n              type: event,\n              data: messageData,\n              origin: this$1.url,\n              target: socket.target\n            })].concat(messageData)\n          );\n        } else {\n          socket.dispatchEvent(\n            createMessageEvent({\n              type: event,\n              data: messageData,\n              origin: this$1.url,\n              target: socket.target\n            })\n          );\n        }\n      });\n    };\n    Server2.prototype.clients = function clients() {\n      return networkBridge.websocketsLookup(this.url);\n    };\n    Server2.prototype.to = function to(room, broadcaster, broadcastList) {\n      var this$1 = this;\n      if (broadcastList === void 0)\n        broadcastList = [];\n      var self2 = this;\n      var websockets = dedupe(broadcastList.concat(networkBridge.websocketsLookup(this.url, room, broadcaster)));\n      return {\n        to: function(chainedRoom, chainedBroadcaster) {\n          return this$1.to.call(this$1, chainedRoom, chainedBroadcaster, websockets);\n        },\n        emit: function emit(event, data) {\n          self2.emit(event, data, { websockets });\n        }\n      };\n    };\n    Server2.prototype.in = function in$1() {\n      var args = [], len = arguments.length;\n      while (len--)\n        args[len] = arguments[len];\n      return this.to.apply(null, args);\n    };\n    Server2.prototype.simulate = function simulate(event) {\n      var listeners = networkBridge.websocketsLookup(this.url);\n      if (event === \"error\") {\n        listeners.forEach(function(socket) {\n          socket.readyState = WebSocket$1.CLOSED;\n          socket.dispatchEvent(createEvent({ type: \"error\", target: socket.target }));\n        });\n      }\n    };\n    return Server2;\n  }(EventTarget);\n  Server$1.of = function of(url) {\n    return new Server$1(url);\n  };\n  var Server = Server$1;\n  var WebSocket = WebSocket$1;\n  var SocketIO$$1 = IO;\n  exports2.Server = Server;\n  exports2.WebSocket = WebSocket;\n  exports2.SocketIO = SocketIO$$1;\n  Object.defineProperty(exports2, \"__esModule\", { value: true });\n});\n\n\n//# sourceURL=webpack://hypha-core/./node_modules/mock-socket/dist/mock-socket.js?");

/***/ }),

/***/ "./src/hypha-core.js":
/*!***************************!*\
  !*** ./src/hypha-core.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HyphaCore: () => (/* binding */ HyphaCore),\n/* harmony export */   WebSocket: () => (/* reexport safe */ mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket),\n/* harmony export */   WebsocketRPCConnection: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.WebsocketRPCConnection),\n/* harmony export */   Workspace: () => (/* reexport safe */ _workspace_js__WEBPACK_IMPORTED_MODULE_4__.Workspace),\n/* harmony export */   connectToServer: () => (/* binding */ connectToServer),\n/* harmony export */   hyphaWebsocketClient: () => (/* reexport safe */ hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient),\n/* harmony export */   imjoyRPC: () => (/* reexport safe */ imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__.imjoyRPC)\n/* harmony export */ });\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mock-socket */ \"./node_modules/mock-socket/dist/mock-socket.js\");\n/* harmony import */ var mock_socket__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mock_socket__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! imjoy-rpc */ \"./node_modules/imjoy-rpc/index.js\");\n/* harmony import */ var imjoy_rpc__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/index.js */ \"./src/utils/index.js\");\n/* harmony import */ var _workspace_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./workspace.js */ \"./src/workspace.js\");\n/* harmony import */ var _utils_redis_mock_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/redis-mock.js */ \"./src/utils/redis-mock.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\n\n\n\n\n\nconst connectToServer = hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.connectToServer;\nconst AUTH0_NAMESPACE = \"https://api.imjoy.io/\";\nfunction base64UrlEncode(data) {\n  if (typeof btoa !== \"undefined\") {\n    const base64 = btoa(\n      typeof data === \"string\" ? data : String.fromCharCode(...new Uint8Array(data))\n    );\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  } else if (typeof Buffer !== \"undefined\") {\n    const buffer = typeof data === \"string\" ? Buffer.from(data) : Buffer.from(data);\n    const base64 = buffer.toString(\"base64\");\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  } else {\n    throw new Error(\"Base64 encoding not available in current environment\");\n  }\n}\nfunction base64UrlDecode(base64Url) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  if (typeof atob !== \"undefined\") {\n    return atob(base64);\n  } else if (typeof Buffer !== \"undefined\") {\n    return Buffer.from(base64, \"base64\").toString(\"binary\");\n  } else {\n    throw new Error(\"Base64 decoding not available in current environment\");\n  }\n}\nasync function hmacSha256(key, data) {\n  if (typeof crypto !== \"undefined\" && crypto.subtle) {\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(key);\n    const msgData = encoder.encode(data);\n    const cryptoKey = await crypto.subtle.importKey(\n      \"raw\",\n      keyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\"]\n    );\n    const signature = await crypto.subtle.sign(\"HMAC\", cryptoKey, msgData);\n    return new Uint8Array(signature);\n  } else {\n    throw new Error(\"JWT HS256 signing requires Web Crypto API (browser) or crypto module (Node.js/Deno)\");\n  }\n}\nasync function verifyJWT(token, secret) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  const [encodedHeader, encodedPayload, encodedSignature] = parts;\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  try {\n    const header = JSON.parse(base64UrlDecode(encodedHeader));\n    if (header.alg !== \"HS256\") {\n      throw new Error(\"Unsupported algorithm\");\n    }\n    const expectedSignature = await hmacSha256(secret, unsigned);\n    const actualSignature = new Uint8Array(\n      Array.from(base64UrlDecode(encodedSignature)).map((c) => c.charCodeAt(0))\n    );\n    if (expectedSignature.length !== actualSignature.length) {\n      throw new Error(\"Invalid signature\");\n    }\n    for (let i = 0; i < expectedSignature.length; i++) {\n      if (expectedSignature[i] !== actualSignature[i]) {\n        throw new Error(\"Invalid signature\");\n      }\n    }\n    const payload = JSON.parse(base64UrlDecode(encodedPayload));\n    if (payload.exp && Date.now() / 1e3 > payload.exp) {\n      throw new Error(\"Token expired\");\n    }\n    return payload;\n  } catch (error) {\n    throw new Error(`JWT verification failed: ${error.message}`);\n  }\n}\nasync function generateJWT(payload, secret) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await hmacSha256(secret, unsigned);\n  const encodedSignature = base64UrlEncode(signature);\n  return `${unsigned}.${encodedSignature}`;\n}\nconst _HyphaCore = class extends _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.MessageEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.redis = _utils_redis_mock_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n    this.port = config.port || 8080;\n    this.baseUrl = config.base_url || _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.getSafeBaseUrl();\n    if (!this.baseUrl.endsWith(\"/\")) {\n      this.baseUrl += \"/\";\n    }\n    if (config.url && config.port) {\n      throw new Error(\"Please provide either url or port, not both.\");\n    }\n    this.ServerClass = config.ServerClass || mock_socket__WEBPACK_IMPORTED_MODULE_0__.Server;\n    this.WebSocketClass = config.WebSocketClass || mock_socket__WEBPACK_IMPORTED_MODULE_0__.WebSocket;\n    if (config.url && (config.url.startsWith(\"wss://\") || config.url.startsWith(\"ws://\"))) {\n      if (!config.url.endsWith(\"/ws\")) {\n        throw new Error(\"Please provide a valid wss url ending with /ws\");\n      }\n      this.url = config.url.replace(\"wss://\", \"https://\").replace(\"ws://\", \"http://\").slice(0, -3);\n      this.wsUrl = config.url;\n    } else {\n      this.url = config.url || \"https://local-hypha-server:\" + this.port;\n      this.wsUrl = this.url.replace(\"https://\", \"wss://\").replace(\"http://\", \"ws://\") + \"/ws\";\n    }\n    this.api = null;\n    this.server = null;\n    this.workspaceManagerId = \"workspace-manager\";\n    this.connections = {};\n    this.defaultServices = config.default_service || {};\n    this.imjoyPluginWindows = /* @__PURE__ */ new Map();\n    this.jwtSecret = config.jwtSecret || \"hypha-core-default-secret-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.randId)();\n    this.environment = _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.getEnvironment();\n    this.on(\"add_window\", (config2) => {\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.isBrowser()) {\n        console.log(\"Creating window: \", config2);\n      } else {\n        console.warn(`Window creation requested but not supported in ${this.environment} environment:`, config2);\n      }\n    });\n  }\n  async emit(event, data) {\n    this._fire(event, data);\n  }\n  _handleImJoyPlugin(event) {\n    const contentWindow = event.source;\n    const data = event.data;\n    let cid = null;\n    for (const [key, value] of Object.entries(this.connections)) {\n      if (value.source === contentWindow) {\n        cid = key;\n        break;\n      }\n    }\n    if (!cid) {\n      console.error(\"Client id not found for the plugin: \", data);\n      return;\n    }\n    const defaultService = this.workspaceManager.getDefaultService();\n    const coreInterface = {};\n    for (const key in defaultService) {\n      const camelKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toCamelCase)(key);\n      if (typeof defaultService[key] === \"function\") {\n        coreInterface[camelKey] = async (...args) => {\n          const context = {\n            ws: this.connections[cid].workspace,\n            from: `${cid}`,\n            to: `${this.connections[cid].workspace}/${this.workspaceManagerId}`,\n            user: this.connections[cid].user || {\n              id: \"anonymous\",\n              is_anonymous: true,\n              email: \"anonymous@imjoy.io\",\n              roles: [],\n              scopes: []\n            }\n          };\n          return await defaultService[key](...args, context);\n        };\n      } else {\n        coreInterface[camelKey] = defaultService[key];\n      }\n    }\n    const coreConnection = {\n      peer_id: data.peer_id,\n      fire(m) {\n        if (coreConnection._messageHandler[m.type]) {\n          coreConnection._messageHandler[m.type](m);\n        }\n      },\n      disconnect: function() {\n      },\n      emit: (msg) => {\n        msg.peer_id = coreConnection.peer_id;\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.safePostMessage(contentWindow, msg, \"*\");\n      },\n      on: function(event2, handler) {\n        coreConnection._messageHandler[event2] = handler;\n      },\n      _messageHandler: {},\n      async execute(code) {\n        coreConnection.emit({ type: \"execute\", code });\n      }\n    };\n    const pluginConfig = data.config;\n    if (data.error) {\n      console.error(\"Failed to initialize the plugin\", data.error);\n      return;\n    }\n    if (!data.peer_id) {\n      throw \"Please provide a peer_id for the connection.\";\n    }\n    this.imjoyPluginWindows.set(\n      event.source,\n      {\n        coreConnection,\n        cid\n      }\n    );\n    console.log(\"plugin initialized:\", pluginConfig);\n    const core = new imjoy_rpc__WEBPACK_IMPORTED_MODULE_2__.imjoyRPC.RPC(coreConnection, { name: \"core\" });\n    core.setInterface(coreInterface);\n    core.on(\"interfaceSetAsRemote\", () => {\n      core.on(\"remoteReady\", async () => {\n        const api = core.getRemote();\n        api.id = `${cid}:default`;\n        api.type = \"imjoy\";\n        await this.workspaceManager.eventBus.emit(\"service_added\", api);\n      });\n      core.requestRemote();\n    });\n    core.sendInterface();\n  }\n  _handleClientMessage(event) {\n    if (event.data && event.data.type === \"hyphaClientReady\") {\n      for (const key in this.connections) {\n        if (this.connections[key].source === event.currentTarget) {\n          const conn = this.connections[key];\n          this.emit(\"connection_ready\", conn);\n          break;\n        }\n      }\n    }\n    const workspace = event.data.workspace;\n    if (!workspace) {\n      if (event.data.type === \"initialized\") {\n        this._handleImJoyPlugin(event);\n      } else if (this.imjoyPluginWindows.has(event.source)) {\n        const coreConnection = this.imjoyPluginWindows.get(event.source).coreConnection;\n        coreConnection.fire(event.data);\n      }\n      return;\n    }\n    const clientId = event.data.from;\n    if (!clientId || !this.connections[workspace + \"/\" + clientId]) {\n      console.warn(\"Connection not found for client: \", clientId);\n      return;\n    }\n    const connection = this.connections[workspace + \"/\" + clientId];\n    const ws = connection.websocket;\n    if (event.data.type === \"message\") {\n      ws.send(event.data.data);\n    } else if (event.data.type === \"close\") {\n      ws.close();\n    } else if (event.data.type === \"connect\") {\n      const ws2 = new this.WebSocketClass(event.data.url);\n      ws2.onmessage = (evt) => {\n        connection.postMessage({ type: \"message\", data: evt.data, to: clientId });\n      };\n      ws2.onopen = () => {\n        connection.postMessage({ type: \"connected\", to: clientId });\n      };\n      ws2.onclose = () => {\n        connection.postMessage({ type: \"closed\", to: clientId });\n      };\n      connection.websocket = ws2;\n    }\n  }\n  async start(config) {\n    if (_HyphaCore.servers[this.url]) {\n      throw new Error(`Server already running at ${this.url}`);\n    } else {\n      const serverOptions = {\n        mock: false,\n        hyphaCore: this\n        // Enable HTTP service proxy functionality\n      };\n      this.server = new this.ServerClass(this.wsUrl, serverOptions);\n      _HyphaCore.servers[this.url] = this.server;\n      this.messageHandler = this._handleClientMessage.bind(this);\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.isBrowser()) {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.safeAddEventListener(window, \"message\", this.messageHandler);\n      } else {\n        console.log(`Running in ${this.environment} environment - window message handling disabled`);\n      }\n    }\n    this.server.on(\"connection\", async (websocket) => {\n      await this._handleWebsocketConnection(websocket);\n    });\n    config = config || {};\n    config.server = this;\n    config.WebSocketClass = this.WebSocketClass;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(config.workspace === void 0, \"workspace is not allowed to be set in the config\");\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(config.client_id === void 0, \"client_id is not allowed to be set in the config\");\n    this.workspaceManager = new _workspace_js__WEBPACK_IMPORTED_MODULE_4__.Workspace(this);\n    await this.workspaceManager.setup({\n      client_id: this.workspaceManagerId,\n      method_timeout: 60,\n      default_service: this.defaultServices\n    });\n    const api = this._createDirectAPIWrapper();\n    this.api = api;\n    return api;\n  }\n  async _handleWebsocketConnection(websocket) {\n    let authConfig = {};\n    let userInfo;\n    let workspace;\n    let clientId;\n    try {\n      const authData = await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error(\"Authentication timeout\"));\n        }, 3e4);\n        websocket.on(\"message\", (data) => {\n          clearTimeout(timeout);\n          resolve(data);\n        });\n        websocket.on(\"error\", (error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n        websocket.on(\"close\", () => {\n          clearTimeout(timeout);\n          reject(new Error(\"Connection closed during authentication\"));\n        });\n      });\n      try {\n        authConfig = JSON.parse(authData);\n      } catch (parseError) {\n        await this._disconnectWebsocket(websocket, \"Failed to decode authentication information\", 1003);\n        return;\n      }\n      if (authConfig.workspace === void 0 && authConfig.client_id === void 0 && authConfig.token === void 0) {\n        throw new Error(\"Authentication required: workspace, client_id, or token must be provided\");\n      }\n      const authResult = await this._authenticateUser(authConfig);\n      userInfo = authResult.userInfo;\n      workspace = authResult.workspace;\n      clientId = authConfig.client_id;\n      if (!workspace) {\n        workspace = \"workspace-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.randId)();\n      }\n      if (!clientId) {\n        clientId = \"client-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.randId)();\n      }\n      await this._checkClientPermissions(clientId, workspace, userInfo);\n      await this._establishWebsocketCommunication(websocket, workspace, clientId, userInfo);\n    } catch (error) {\n      console.error(\"WebSocket connection failed:\", error.message);\n      await this._disconnectWebsocket(websocket, `Failed to establish connection: ${error.message}`, 1001);\n    }\n  }\n  async _authenticateUser(authConfig) {\n    let userInfo;\n    let workspace = authConfig.workspace;\n    if (authConfig.token) {\n      try {\n        const payload = await verifyJWT(authConfig.token, this.jwtSecret);\n        userInfo = {\n          id: payload.sub || payload.user_id || \"anonymous\",\n          is_anonymous: !payload.email,\n          email: payload.email || \"\",\n          roles: payload.roles || [],\n          scopes: payload.scope ? payload.scope.split(\" \") : [],\n          expires_at: payload.exp\n        };\n        workspace = payload.workspace || authConfig.workspace || \"default\";\n      } catch (jwtError) {\n        try {\n          const info = parseJwt(authConfig.token);\n          const expiresAt = info[\"exp\"];\n          userInfo = {\n            id: info[\"sub\"],\n            is_anonymous: !info[AUTH0_NAMESPACE + \"email\"],\n            email: info[AUTH0_NAMESPACE + \"email\"],\n            roles: info[AUTH0_NAMESPACE + \"roles\"],\n            scopes: info[\"scope\"],\n            expires_at: expiresAt\n          };\n          workspace = info.workspace || authConfig.workspace || userInfo.id;\n        } catch (parseError) {\n          throw new Error(`Token verification failed: ${jwtError.message}`);\n        }\n      }\n    } else if (authConfig.reconnection_token) {\n      try {\n        const payload = await verifyJWT(authConfig.reconnection_token, this.jwtSecret);\n        userInfo = {\n          id: payload.sub || \"anonymous\",\n          is_anonymous: !payload.email,\n          email: payload.email || \"\",\n          roles: payload.roles || [],\n          scopes: payload.scope ? payload.scope.split(\" \") : [],\n          expires_at: payload.exp\n        };\n        workspace = payload.workspace || authConfig.workspace;\n        if (payload.client_id && authConfig.client_id && payload.client_id !== authConfig.client_id) {\n          throw new Error(\"Client ID mismatch during reconnection\");\n        }\n      } catch (error) {\n        throw new Error(`Reconnection token verification failed: ${error.message}`);\n      }\n    } else {\n      const anonymousUserId = \"anonymous-\" + (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.randId)();\n      userInfo = {\n        id: anonymousUserId,\n        is_anonymous: true,\n        email: \"anonymous@imjoy.io\",\n        roles: [],\n        scopes: []\n      };\n      const requestedWorkspace = authConfig.workspace;\n      if (!requestedWorkspace) {\n        workspace = anonymousUserId;\n      } else {\n        if (requestedWorkspace !== \"public\" && requestedWorkspace !== anonymousUserId) {\n          throw new Error(`Anonymous client attempted to access protected workspace: ${requestedWorkspace}`);\n        }\n        workspace = requestedWorkspace;\n      }\n    }\n    return { userInfo, workspace };\n  }\n  async _checkClientPermissions(clientId, workspace, userInfo) {\n    if (workspace === \"public\") {\n      return;\n    }\n    if (userInfo.is_anonymous && !workspace.startsWith(\"anonymous-\")) {\n      throw new Error(`Permission denied for workspace: ${workspace}`);\n    }\n  }\n  async _establishWebsocketCommunication(websocket, workspace, clientId, userInfo) {\n    const connectionKey = `${workspace}/${clientId}`;\n    if (!this._websockets) {\n      this._websockets = {};\n    }\n    this._websockets[connectionKey] = websocket;\n    try {\n      const conn = new _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.RedisRPCConnection(this, workspace, clientId, userInfo, this.workspaceManagerId);\n      conn.on_message((data) => {\n        if (websocket.readyState === websocket.OPEN) {\n          websocket.send(data);\n        }\n      });\n      const reconnectionToken = await this._generateReconnectionToken(userInfo, workspace, clientId);\n      const baseUrl = this.url.endsWith(\"/\") ? this.url.slice(0, -1) : this.url;\n      const connectionInfo = {\n        \"type\": \"connection_info\",\n        \"hypha_version\": \"0.1.0\",\n        \"public_base_url\": baseUrl,\n        \"local_base_url\": baseUrl,\n        \"manager_id\": this.workspaceManagerId,\n        \"workspace\": workspace,\n        \"client_id\": clientId,\n        \"user\": userInfo,\n        \"reconnection_token\": reconnectionToken,\n        \"reconnection_token_life_time\": 3600\n        // 1 hour\n      };\n      websocket.send(JSON.stringify(connectionInfo));\n      websocket.on(\"message\", async (data) => {\n        try {\n          if (typeof data === \"string\") {\n            if (data.length > 1e3) {\n              console.warn(`Ignoring long text message: ${data.substring(0, 1e3)}...`);\n              return;\n            }\n            const message = JSON.parse(data);\n            if (message.type === \"ping\") {\n              websocket.send(JSON.stringify({ type: \"pong\" }));\n            } else if (message.type === \"refresh_token\") {\n              const newReconnectionToken = await this._generateReconnectionToken(userInfo, workspace, clientId);\n              websocket.send(JSON.stringify({\n                type: \"reconnection_token\",\n                reconnection_token: newReconnectionToken\n              }));\n            } else {\n              console.info(\"Unknown message type:\", message.type);\n            }\n          } else {\n            await conn.emit_message(data);\n          }\n        } catch (error) {\n          console.error(\"Error processing websocket message:\", error);\n        }\n      });\n      websocket.on(\"close\", async () => {\n        await this._handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn);\n      });\n      websocket.on(\"error\", async (error) => {\n        console.error(`WebSocket error for ${connectionKey}:`, error);\n        await this._handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn);\n      });\n    } catch (error) {\n      if (this._websockets && this._websockets[connectionKey]) {\n        delete this._websockets[connectionKey];\n      }\n      throw error;\n    }\n  }\n  async _generateReconnectionToken(userInfo, workspace, clientId) {\n    const payload = {\n      sub: userInfo.id,\n      workspace,\n      client_id: clientId,\n      email: userInfo.email,\n      roles: userInfo.roles || [],\n      scope: Array.isArray(userInfo.scopes) ? userInfo.scopes.join(\" \") : \"\",\n      iat: Math.floor(Date.now() / 1e3),\n      exp: Math.floor(Date.now() / 1e3) + 3600,\n      // 1 hour\n      iss: \"hypha-core\",\n      aud: \"hypha-reconnection\"\n    };\n    return await generateJWT(payload, this.jwtSecret);\n  }\n  async _handleWebsocketDisconnection(websocket, workspace, clientId, userInfo, conn) {\n    const connectionKey = `${workspace}/${clientId}`;\n    try {\n      if (conn) {\n        await conn.disconnect(\"disconnected\");\n      }\n      console.info(`Client disconnected: ${connectionKey}`);\n    } catch (error) {\n      console.error(`Error handling disconnection for ${connectionKey}:`, error);\n    } finally {\n      if (this._websockets && this._websockets[connectionKey]) {\n        delete this._websockets[connectionKey];\n      }\n    }\n  }\n  async _disconnectWebsocket(websocket, reason, code = 1e3) {\n    console.error(\"Disconnecting websocket, reason:\", reason, \"code:\", code);\n    try {\n      if (websocket.readyState === websocket.OPEN) {\n        websocket.send(JSON.stringify({ type: \"error\", message: reason }));\n      }\n    } catch (error) {\n      console.error(\"Error sending disconnect message:\", error);\n    }\n    try {\n      if (websocket.readyState === websocket.OPEN || websocket.readyState === websocket.CONNECTING) {\n        websocket.close(code, reason);\n      }\n    } catch (error) {\n      console.error(\"Error closing websocket:\", error);\n    }\n  }\n  getWebsockets() {\n    return this._websockets || {};\n  }\n  async forceDisconnect(workspace, clientId, code, reason) {\n    const connectionKey = `${workspace}/${clientId}`;\n    const websocket = this._websockets && this._websockets[connectionKey];\n    if (!websocket) {\n      throw new Error(`Client not connected: ${connectionKey}`);\n    }\n    await this._disconnectWebsocket(websocket, reason, code);\n  }\n  async connect(config) {\n    config = config || {};\n    config.server = this;\n    config.WebSocketClass = this.WebSocketClass;\n    (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.assert)(config.client_id !== \"root\", \"client_id cannot be 'root'\");\n    config.client_id = config.client_id || (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.randId)();\n    const rawApi = await connectToServer(config);\n    return this._createCamelCaseWrapper(rawApi);\n  }\n  _createCamelCaseWrapper(rawApi) {\n    const wrappedApi = {};\n    for (const key in rawApi) {\n      const camelKey = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.toCamelCase)(key);\n      if (typeof rawApi[key] === \"function\") {\n        wrappedApi[camelKey] = rawApi[key].bind(rawApi);\n      } else {\n        wrappedApi[camelKey] = rawApi[key];\n      }\n    }\n    return wrappedApi;\n  }\n  async reset() {\n    this.close();\n    await this.start();\n  }\n  close() {\n    if (this.messageHandler) {\n      if (_utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.isBrowser()) {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_3__.Environment.safeRemoveEventListener(window, \"message\", this.messageHandler);\n      }\n    }\n    if (this.server) {\n      this.server.close();\n      delete _HyphaCore.servers[this.url];\n    }\n  }\n  _createDirectAPIWrapper() {\n    const context = {\n      ws: \"default\",\n      from: \"default/root\",\n      user: {\n        id: \"root\",\n        is_anonymous: false,\n        email: \"root@localhost\",\n        roles: [\"admin\"],\n        scopes: []\n      }\n    };\n    const api = {\n      // API properties that tests expect\n      id: context.from.split(\"/\")[1],\n      // Extract client ID from \"workspace/clientId\"\n      config: {\n        workspace: context.ws,\n        server_url: this.url\n      },\n      // Workspace management functions\n      registerService: async (service) => {\n        return await this.workspaceManager.registerService(service, context);\n      },\n      unregisterService: async (serviceId) => {\n        return await this.workspaceManager.unregisterService(serviceId, context);\n      },\n      listServices: async (query = {}) => {\n        return await this.workspaceManager.listServices(query, context);\n      },\n      getService: async (serviceId, options = {}) => {\n        return await this.workspaceManager.getService(serviceId, options, context);\n      },\n      close: () => {\n        this.close();\n      },\n      // Event methods\n      emit: async (type, data) => {\n        await this.workspaceManager.eventBus.emit(type, data);\n      },\n      on: (event, handler) => {\n        this.workspaceManager.eventBus.on(event, handler);\n      },\n      off: (event, handler) => {\n        this.workspaceManager.eventBus.off(event, handler);\n      },\n      // Utility methods\n      echo: (msg) => {\n        return msg;\n      },\n      alert: (msg) => {\n        alert(msg);\n      },\n      confirm: (msg) => {\n        return confirm(msg);\n      },\n      prompt: (msg, default_value) => {\n        return prompt(msg, default_value);\n      },\n      showProgress: (progress) => {\n        console.log(\"showProgress\", progress);\n      },\n      showMessage: (msg) => {\n        console.log(msg);\n      },\n      log: (msg) => {\n        console.log(msg);\n      },\n      info: (msg) => {\n        console.info(msg);\n      },\n      error: (msg) => {\n        console.error(msg);\n      },\n      warning: (msg) => {\n        console.warn(msg);\n      },\n      critical: (msg) => {\n        console.error(msg);\n      },\n      // Token generation\n      generateToken: async (tokenConfig) => {\n        if (!tokenConfig) {\n          tokenConfig = {};\n        }\n        const currentWorkspace = context.ws;\n        const currentClientId = context.from?.split(\"/\")[1];\n        let targetWorkspace = tokenConfig.workspace || currentWorkspace;\n        if (targetWorkspace !== currentWorkspace) {\n          if (currentWorkspace !== \"default\" || currentClientId !== \"root\") {\n            throw new Error(`Access denied: Cannot generate token for workspace '${targetWorkspace}' from workspace '${currentWorkspace}' with client '${currentClientId}'. Only root client in default workspace can generate cross-workspace tokens.`);\n          }\n        }\n        const payload = {\n          sub: tokenConfig.user_id || context.user?.id || \"anonymous\",\n          workspace: targetWorkspace,\n          client_id: tokenConfig.client_id || context.from?.split(\"/\")[1] || \"anonymous-\" + Date.now().toString(),\n          email: tokenConfig.email || context.user?.email || \"\",\n          roles: tokenConfig.roles || context.user?.roles || [],\n          scope: Array.isArray(tokenConfig.scopes) ? tokenConfig.scopes.join(\" \") : tokenConfig.scope || \"\",\n          iat: Math.floor(Date.now() / 1e3),\n          exp: tokenConfig.expires_in ? Math.floor(Date.now() / 1e3) + tokenConfig.expires_in : Math.floor(Date.now() / 1e3) + 24 * 60 * 60,\n          // Default 24 hours\n          iss: \"hypha-core\",\n          aud: \"hypha-api\"\n        };\n        const jwtSecret = this.jwtSecret;\n        if (!jwtSecret) {\n          throw new Error(\"JWT secret not configured on server\");\n        }\n        return await generateJWT(payload, jwtSecret);\n      },\n      // App and window management methods\n      loadApp: async (config, extra_config) => {\n        return await this.workspaceManager.loadApp(config, extra_config, context);\n      },\n      createWindow: async (config, extra_config) => {\n        return await this.workspaceManager.createWindow(config, extra_config, context);\n      },\n      getWindow: async (config) => {\n        return await this.workspaceManager.getWindow(config, context);\n      },\n      getApp: async (config, extra_config) => {\n        return await this.workspaceManager.getApp(config, extra_config, context);\n      }\n    };\n    api.getPlugin = api.getApp;\n    api.loadPlugin = api.loadApp;\n    this.workspaceManager.registerService({\n      id: \"default\",\n      name: \"Default workspace management service\",\n      description: \"Services for managing workspace.\",\n      config: {\n        visibility: \"public\"\n      },\n      ...this.workspaceManager.getDefaultService()\n    }, context).catch((err) => {\n      console.warn(\"Could not register default service:\", err.message);\n    });\n    return this._createCamelCaseWrapper(api);\n  }\n};\nlet HyphaCore = _HyphaCore;\n__publicField(HyphaCore, \"servers\", {});\nfunction parseJwt(token) {\n  var base64Url = token.split(\".\")[1];\n  var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  var jsonPayload = decodeURIComponent(atob(base64).split(\"\").map(function(c) {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"));\n  return JSON.parse(jsonPayload);\n}\n\n\n\n//# sourceURL=webpack://hypha-core/./src/hypha-core.js?");

/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   MessageEmitter: () => (/* binding */ MessageEmitter),\n/* harmony export */   RedisRPCConnection: () => (/* binding */ RedisRPCConnection),\n/* harmony export */   WebsocketRPCConnection: () => (/* binding */ WebsocketRPCConnection),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   parsePluginCode: () => (/* binding */ parsePluginCode),\n/* harmony export */   randId: () => (/* binding */ randId),\n/* harmony export */   toCamelCase: () => (/* binding */ toCamelCase)\n/* harmony export */ });\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs\");\n/* harmony import */ var _pluginParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginParser.js */ \"./src/utils/pluginParser.js\");\n\n\nfunction toCamelCase(str) {\n  if (!str.includes(\"_\")) {\n    return str;\n  }\n  return str.replace(/_./g, (match) => match[1].toUpperCase());\n}\nclass MessageEmitter {\n  constructor(debug) {\n    this._event_handlers = {};\n    this._once_handlers = {};\n    this._debug = debug;\n  }\n  emit() {\n    throw new Error(\"emit is not implemented\");\n  }\n  on(event, handler) {\n    if (!this._event_handlers[event]) {\n      this._event_handlers[event] = [];\n    }\n    this._event_handlers[event].push(handler);\n  }\n  once(event, handler) {\n    handler.___event_run_once = true;\n    this.on(event, handler);\n  }\n  off(event, handler) {\n    if (!event && !handler) {\n      this._event_handlers = {};\n    } else if (event && !handler) {\n      if (this._event_handlers[event])\n        this._event_handlers[event] = [];\n    } else {\n      if (this._event_handlers[event]) {\n        const idx = this._event_handlers[event].indexOf(handler);\n        if (idx >= 0) {\n          this._event_handlers[event].splice(idx, 1);\n        }\n      }\n    }\n  }\n  _fire(event, data) {\n    if (this._event_handlers[event]) {\n      var i = this._event_handlers[event].length;\n      while (i--) {\n        const handler = this._event_handlers[event][i];\n        try {\n          handler(data);\n        } catch (e) {\n          console.error(e);\n        } finally {\n          if (handler.___event_run_once) {\n            this._event_handlers[event].splice(i, 1);\n          }\n        }\n      }\n    } else {\n      if (this._debug) {\n        console.warn(\"unhandled event\", event, data);\n      }\n    }\n  }\n  waitFor(event, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (data) => {\n        clearTimeout(timer);\n        resolve(data);\n      };\n      this.once(event, handler);\n      const timer = setTimeout(() => {\n        this.off(event, handler);\n        reject(new Error(\"Timeout\"));\n      }, timeout);\n    });\n  }\n}\nfunction randId() {\n  return Math.random().toString(36).substr(2, 10) + (/* @__PURE__ */ new Date()).getTime();\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nclass WebsocketRPCConnection {\n  constructor(eventBus, clients, clientId, workspace, managerId, timeout = 60) {\n    this._clients = clients;\n    this._clientId = clientId;\n    this._handle_message = null;\n    this._handle_connected = null;\n    this._handle_disconnected = null;\n    this._reconnection_token = null;\n    this._timeout = timeout * 1e3;\n    this.workspace = workspace;\n    this.connection_info = null;\n    this.manager_id = managerId;\n    this.eventBus = eventBus;\n  }\n  mount(config) {\n    assert(config.id && config.workspace && config.websocket && config.user_info, \"Invalid client config\");\n    config.websocket.on(\"message\", (data) => {\n      const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n      const unpacker = decoder.decodeMulti(data);\n      const { value: message } = unpacker.next();\n      const targetId = message.to.includes(\"/\") ? message.to.split(\"/\")[1] : message.to;\n      if (targetId === this._clientId) {\n        this._handle_message(data.buffer);\n      } else {\n        this.emit_message(data);\n      }\n    });\n  }\n  on_connected(handler) {\n    this._handle_connected = handler;\n  }\n  on_disconnected(handler) {\n    this._handle_disconnected = handler;\n  }\n  on_message(handler) {\n    assert(handler, \"handler is required\");\n    this._handle_message = handler;\n  }\n  async emit_message(data) {\n    assert(this._handle_message, \"No handler for message\");\n    const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n    const unpacker = decoder.decodeMulti(data);\n    const { value: message } = unpacker.next();\n    let targetId = message.to;\n    if (!targetId.includes(\"/\")) {\n      targetId = `${this.workspace}/${targetId}`;\n    }\n    if (!this._clients[targetId]) {\n      console.error(\"No client found for targetId:\", targetId);\n      return;\n    }\n    const client = this._clients[targetId];\n    const websocket = client.websocket;\n    if (!message.from.includes(\"/\")) {\n      message.from = `${this.workspace}/${message.from}`;\n    }\n    const updatedMessage = {\n      ...message,\n      ws: this.workspace,\n      to: targetId,\n      from: message.from,\n      user: client.userInfo\n    };\n    const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(updatedMessage);\n    const pos = decoder.pos;\n    const remainingData = data.slice(pos);\n    const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n    finalData.set(encodedUpdatedMessage, 0);\n    finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n    if (!websocket || !websocket.send) {\n      console.error(\"No websocket found for targetId:\", targetId);\n      return;\n    }\n    websocket.send(finalData.buffer);\n  }\n  disconnect(reason) {\n    console.info(`Websocket connection disconnected (${reason})`);\n  }\n}\nclass RedisRPCConnection {\n  /**\n   * Represent a Redis connection for handling RPC-like messaging.\n   * @param {EventBus} eventBus - Event bus for messaging.\n   * @param {string} workspace - Workspace identifier.\n   * @param {string} clientId - Client identifier.\n   * @param {UserInfo} userInfo - User information.\n   * @param {string} managerId - Manager identifier.\n   */\n  constructor(eventBus, workspace, clientId, userInfo, managerId) {\n    if (!workspace || clientId.includes(\"/\")) {\n      throw new Error(\"Invalid workspace or client ID\");\n    }\n    this._workspace = workspace;\n    this._clientId = clientId;\n    this._userInfo = userInfo;\n    this._stop = false;\n    this._eventBus = eventBus;\n    this._handleConnected = null;\n    this._handleDisconnected = null;\n    this._handleMessage = null;\n    this.manager_id = managerId;\n  }\n  /**\n   * Register a disconnection event handler.\n   * @param {function} handler - Disconnection handler.\n   */\n  on_disconnected(handler) {\n    this._handleDisconnected = handler;\n  }\n  /**\n   * Register a connection open event handler.\n   * @param {function} handler - Connection handler.\n   */\n  on_connected(handler) {\n    this._handleConnected = handler;\n  }\n  /**\n   * Set message handler.\n   * @param {function} handler - Message handler.\n   */\n  on_message(handler) {\n    this._handleMessage = handler;\n    this._eventBus.on(`${this._workspace}/${this._clientId}:msg`, handler);\n    this._eventBus.on(`${this._workspace}/*:msg`, handler);\n    if (this._handleConnected) {\n      this._handleConnected(this);\n    }\n  }\n  /**\n   * Send message after packing additional info.\n   * @param {Object|Uint8Array} data - Data to send.\n   */\n  async emit_message(data) {\n    if (this._stop) {\n      throw new Error(`Connection has already been closed (client: ${this._workspace}/${this._clientId})`);\n    }\n    if (!(data instanceof Uint8Array)) {\n      console.log(\"Skipping text message\", data);\n      return;\n    }\n    const decoder = new _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_1__.Decoder();\n    const unpacker = decoder.decodeMulti(data);\n    const { value: message } = unpacker.next();\n    const pos = decoder.pos;\n    let targetId = message.to;\n    if (!targetId.includes(\"/\")) {\n      if (targetId.includes(\"/workspace-manager-\")) {\n        throw new Error(`Invalid target ID: ${targetId}, it appears that the target is a workspace manager (target_id should starts with */)`);\n      }\n      targetId = `${this._workspace}/${targetId}`;\n    }\n    const sourceId = `${this._workspace}/${this._clientId}`;\n    message.ws = this._workspace === \"*\" ? targetId.split(\"/\")[0] : this._workspace;\n    message.to = targetId;\n    message.from = sourceId;\n    message.user = this._userInfo;\n    const encodedUpdatedMessage = (0,_msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.encode)(message);\n    const remainingData = data.slice(pos);\n    const finalData = new Uint8Array(encodedUpdatedMessage.length + remainingData.length);\n    finalData.set(encodedUpdatedMessage, 0);\n    finalData.set(new Uint8Array(remainingData), encodedUpdatedMessage.length);\n    this._eventBus.emit(`${targetId}:msg`, finalData.buffer);\n  }\n  /**\n   * Handle disconnection.\n   * @param {string} [reason] - Reason for disconnection.\n   */\n  async disconnect(reason) {\n    this._stop = true;\n    if (this._handleMessage) {\n      this._eventBus.off(`${this._workspace}/${this._clientId}:msg`, this._handleMessage);\n      this._eventBus.off(`${this._workspace}/*:msg`, this._handleMessage);\n    }\n    this._handleMessage = null;\n    console.info(`Redis Connection Disconnected: ${reason}`);\n    if (this._handleDisconnected) {\n      await this._handleDisconnected(reason);\n    }\n  }\n}\nconst CONFIGURABLE_FIELDS = [\n  \"env\",\n  \"requirements\",\n  \"dependencies\",\n  \"icon\",\n  \"ui\",\n  \"type\",\n  \"flags\",\n  \"labels\",\n  \"cover\",\n  \"base_frame\",\n  \"base_worker\",\n  \"passive\"\n];\nfunction parsePluginCode(code, overwrite_config) {\n  overwrite_config = overwrite_config || {};\n  try {\n    const pluginComp = (0,_pluginParser_js__WEBPACK_IMPORTED_MODULE_0__.parseComponent)(code);\n    let config;\n    if (pluginComp.config[0].attrs.lang === \"yaml\") {\n      throw new Error(\"YAML not supported\");\n    } else if (pluginComp.config[0].attrs.lang === \"json\") {\n      config = JSON.parse(pluginComp.config[0].content);\n    } else {\n      config = JSON.parse(pluginComp.config[0].content);\n      if (compareVersions(config.api_version, \">\", \"0.1.5\")) {\n        throw `Unsupported config language ${pluginComp.config[0].attrs.lang}, please set lang=\"json\" or lang=\"yaml\"`;\n      }\n    }\n    config.tag = overwrite_config.tag || config.tags && config.tags[0];\n    config.hot_reloading = overwrite_config.hot_reloading, config.scripts = [];\n    for (let i = 0; i < pluginComp.script.length; i++) {\n      if (pluginComp.script[i].attrs.tag === config.tag) {\n        config.script = pluginComp.script[i].content;\n      }\n      if (!pluginComp.script[i].attrs.tag || pluginComp.script[i].attrs.tag === config.tag) {\n        config.scripts.push(pluginComp.script[i]);\n      }\n    }\n    if (!config.script && pluginComp.script.length > 0) {\n      config.script = pluginComp.script[0].content;\n      config.lang = pluginComp.script[0].attrs.lang;\n    }\n    config.links = pluginComp.link || null;\n    config.windows = pluginComp.window || null;\n    config.styles = pluginComp.style || null;\n    config.docs = pluginComp.docs && pluginComp.docs[0] || config.docs;\n    config.attachments = pluginComp.attachment || null;\n    config._id = overwrite_config._id || config.name.replace(/ /g, \"_\");\n    config.uri = overwrite_config.uri;\n    config.origin = overwrite_config.origin;\n    config.namespace = overwrite_config.namespace;\n    config.code = code;\n    config.id = config.name.trim().replace(/ /g, \"_\") + \"_\" + randId();\n    config.runnable = config.runnable === false ? false : true;\n    config.requirements = config.requirements || [];\n    for (let i = 0; i < CONFIGURABLE_FIELDS.length; i++) {\n      const obj = config[CONFIGURABLE_FIELDS[i]];\n      if (obj && typeof obj === \"object\" && !(obj instanceof Array)) {\n        if (config.tag) {\n          config[CONFIGURABLE_FIELDS[i]] = obj[config.tag];\n          if (!Object.prototype.hasOwnProperty.call(obj, config.tag)) {\n            console.log(\n              \"WARNING: \" + CONFIGURABLE_FIELDS[i] + \" do not contain a tag named: \" + config.tag\n            );\n          }\n        } else {\n          throw \"You must use 'tags' with configurable fields.\";\n        }\n      }\n    }\n    config.lang = config.lang || \"javascript\";\n    return config;\n  } catch (e) {\n    console.error(e);\n    throw `Failed to parse the plugin file, error: ${e}`;\n  }\n}\nconst Environment = {\n  /**\n   * Check if we're running in a browser environment\n   */\n  isBrowser() {\n    return typeof window !== \"undefined\" && typeof document !== \"undefined\" && typeof navigator !== \"undefined\";\n  },\n  /**\n   * Check if we're running in Node.js\n   */\n  isNode() {\n    return typeof process !== \"undefined\" && process.versions && process.versions.node;\n  },\n  /**\n   * Check if we're running in Deno\n   */\n  isDeno() {\n    return typeof Deno !== \"undefined\";\n  },\n  /**\n   * Check if we're running in a server environment (Node.js or Deno)\n   */\n  isServer() {\n    return this.isNode() || this.isDeno();\n  },\n  /**\n   * Get environment name for debugging\n   */\n  getEnvironment() {\n    if (this.isBrowser())\n      return \"browser\";\n    if (this.isDeno())\n      return \"deno\";\n    if (this.isNode())\n      return \"node\";\n    return \"unknown\";\n  },\n  /**\n   * Require browser environment or throw error\n   */\n  requireBrowser(feature) {\n    if (!this.isBrowser()) {\n      throw new Error(`${feature} requires browser environment. Currently running in: ${this.getEnvironment()}`);\n    }\n  },\n  /**\n   * Get safe base URL for different environments\n   */\n  getSafeBaseUrl() {\n    if (this.isBrowser() && typeof document !== \"undefined\" && document.location) {\n      return new URL(\"./\", document.location.href).href;\n    }\n    return \"http://localhost:8080/\";\n  },\n  /**\n   * Safe postMessage wrapper\n   */\n  safePostMessage(target, message, origin = \"*\") {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.postMessage === \"function\") {\n      target.postMessage(message, origin);\n    } else {\n      console.warn(\"postMessage not available in current environment:\", this.getEnvironment());\n    }\n  },\n  /**\n   * Safe event listener management\n   */\n  safeAddEventListener(target, event, handler) {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.addEventListener === \"function\") {\n      target.addEventListener(event, handler);\n      return true;\n    }\n    return false;\n  },\n  safeRemoveEventListener(target, event, handler) {\n    if ((this.isBrowser() || this.isDeno()) && target && typeof target.removeEventListener === \"function\") {\n      target.removeEventListener(event, handler);\n      return true;\n    }\n    return false;\n  }\n};\n\n\n//# sourceURL=webpack://hypha-core/./src/utils/index.js?");

/***/ }),

/***/ "./src/utils/pluginParser.js":
/*!***********************************!*\
  !*** ./src/utils/pluginParser.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseComponent: () => (/* binding */ parseComponent)\n/* harmony export */ });\nvar splitRE = /\\r?\\n/g;\nvar emptyRE = /^\\s*$/;\nvar needFixRE = /^(\\r?\\n)*[\\t\\s]/;\nvar deIndent = function deindent(str) {\n  if (!needFixRE.test(str)) {\n    return str;\n  }\n  var lines = str.split(splitRE);\n  var min = Infinity;\n  var type, cur, c;\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    if (!emptyRE.test(line)) {\n      if (!type) {\n        c = line.charAt(0);\n        if (c === \" \" || c === \"\t\") {\n          type = c;\n          cur = count(line, type);\n          if (cur < min) {\n            min = cur;\n          }\n        } else {\n          return str;\n        }\n      } else {\n        cur = count(line, type);\n        if (cur < min) {\n          min = cur;\n        }\n      }\n    }\n  }\n  return lines.map(function(line2) {\n    return line2.slice(min);\n  }).join(\"\\n\");\n};\nfunction count(line, type) {\n  var i = 0;\n  while (line.charAt(i) === type) {\n    i++;\n  }\n  return i;\n}\nvar emptyObject = Object.freeze({});\nfunction isUndef(v) {\n  return v === void 0 || v === null;\n}\nfunction isPrimitive(value) {\n  return typeof value === \"string\" || typeof value === \"number\" || // $flow-disable-line\n  typeof value === \"symbol\" || typeof value === \"boolean\";\n}\nfunction isObject(obj) {\n  return obj !== null && typeof obj === \"object\";\n}\nvar _toString = Object.prototype.toString;\nfunction toRawType(value) {\n  return _toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === \"[object Object]\";\n}\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\nfunction makeMap(str, expectsLowerCase) {\n  var map = /* @__PURE__ */ Object.create(null);\n  var list = str.split(\",\");\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function(val) {\n    return map[val.toLowerCase()];\n  } : function(val) {\n    return map[val];\n  };\n}\nvar isBuiltInTag = makeMap(\"slot,component\", true);\nvar isReservedAttribute = makeMap(\"key,ref,slot,slot-scope,is\");\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\nfunction cached(fn) {\n  var cache = /* @__PURE__ */ Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function(str) {\n  return str.replace(camelizeRE, function(_, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n});\nfunction polyfillBind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  boundFn._length = fn.length;\n  return boundFn;\n}\nfunction nativeBind(fn, ctx) {\n  return fn.bind(ctx);\n}\nvar bind = Function.prototype.bind ? nativeBind : polyfillBind;\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\nfunction noop(a, b, c) {\n}\nvar no = function(a, b, c) {\n  return false;\n};\nvar identity = function(_) {\n  return _;\n};\nfunction genStaticKeys(modules) {\n  return modules.reduce(function(keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(\",\");\n}\nvar isUnaryTag = makeMap(\n  \"area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr\"\n);\nvar canBeLeftOpenTag = makeMap(\n  \"colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source\"\n);\nvar isNonPhrasingTag = makeMap(\n  \"address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track\"\n);\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\w\\\\-\\\\.]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp(\"^<\" + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\nvar IS_REGEX_CAPTURING_BROKEN = false;\n\"x\".replace(/x(.)?/g, function(m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === \"\";\n});\nvar isPlainTextElement = makeMap(\"script,style,textarea\", true);\nvar reCache = {};\nvar decodingMap = {\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&amp;\": \"&\",\n  \"&#10;\": \"\\n\",\n  \"&#9;\": \"\t\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\nvar isIgnoreNewlineTag = makeMap(\"pre,textarea\", true);\nvar shouldIgnoreFirstNewline = function(tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === \"\\n\";\n};\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function(match) {\n    return decodingMap[match];\n  });\n}\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf(\"<\");\n      if (textEnd === 0) {\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf(\"-->\");\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(\"]>\");\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue;\n        }\n      }\n      var text = void 0, rest = void 0, next = void 0;\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          next = rest.indexOf(\"<\", 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n      if (textEnd < 0) {\n        text = html;\n        html = \"\";\n      }\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(\n        \"([\\\\s\\\\S]*?)(</\" + stackedTag + \"[^>]*>)\",\n        \"i\"\n      ));\n      var rest$1 = html.replace(reStackedTag, function(all, text2, endTag2) {\n        endTagLength = endTag2.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== \"noscript\") {\n          text2 = text2.replace(/<!\\--([\\s\\S]*?)-->/g, \"$1\").replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1\");\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text2)) {\n          text2 = text2.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text2);\n        }\n        return \"\";\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (!stack.length && options.warn) {\n        options.warn('Mal-formatted tag at end of template: \"' + html + '\"');\n      }\n      break;\n    }\n  }\n  parseEndTag();\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n    if (expectHTML) {\n      if (lastTag === \"p\" && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === \"\") {\n          delete args[3];\n        }\n        if (args[4] === \"\") {\n          delete args[4];\n        }\n        if (args[5] === \"\") {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || \"\";\n      var shouldDecodeNewlines = tagName === \"a\" && args[1] === \"href\" ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n    if (!unary) {\n      stack.push({\n        tag: tagName,\n        lowerCasedTag: tagName.toLowerCase(),\n        attrs\n      });\n      lastTag = tagName;\n    }\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      pos = 0;\n    }\n    if (pos >= 0) {\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if ((i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === \"br\") {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === \"p\") {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\nvar splitRE$1 = /\\r?\\n/g;\nvar replaceRE = /./g;\nvar isSpecialTag = makeMap(\"script,style,template\", true);\nfunction parseComponent(content, options) {\n  if (options === void 0)\n    options = {};\n  var sfc = {\n    script: [],\n    style: [],\n    config: [],\n    window: [],\n    docs: [],\n    attachment: [],\n    link: [],\n    others: []\n  };\n  var depth = 0;\n  var currentBlock = null;\n  function start(tag, attrs, unary, start2, end2) {\n    if (depth === 0) {\n      currentBlock = {\n        type: tag,\n        content: \"\",\n        start: end2,\n        attrs: attrs.reduce(function(cumulated, ref) {\n          var name = ref.name;\n          var value = ref.value;\n          cumulated[name] = value || true;\n          return cumulated;\n        }, {})\n      };\n      if (sfc[tag]) {\n        checkAttrs(currentBlock, attrs);\n        sfc[tag].push(currentBlock);\n      } else {\n        sfc.others.push(currentBlock);\n      }\n    }\n    if (!unary) {\n      depth++;\n    }\n  }\n  function checkAttrs(block, attrs) {\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (attr.name === \"lang\") {\n        block.lang = attr.value;\n      }\n      if (attr.name === \"scoped\") {\n        block.scoped = true;\n      }\n      if (attr.name === \"module\") {\n        block.module = attr.value || true;\n      }\n      if (attr.name === \"src\") {\n        block.src = attr.value;\n      }\n    }\n  }\n  function end(tag, start2, end2) {\n    if (depth === 1 && currentBlock) {\n      currentBlock.end = start2;\n      var text = deIndent(content.slice(currentBlock.start, currentBlock.end));\n      if (currentBlock.type !== \"template\" && options.pad) {\n        text = padContent(currentBlock, options.pad) + text;\n      }\n      currentBlock.content = text;\n      currentBlock = null;\n    }\n    depth--;\n  }\n  function padContent(block, pad) {\n    if (pad === \"space\") {\n      return content.slice(0, block.start).replace(replaceRE, \" \");\n    } else {\n      var offset = content.slice(0, block.start).split(splitRE$1).length;\n      var padChar = block.type === \"script\" && !block.lang ? \"//\\n\" : \"\\n\";\n      return Array(offset).join(padChar);\n    }\n  }\n  parseHTML(content, {\n    start,\n    end\n  });\n  return sfc;\n}\n\n\n//# sourceURL=webpack://hypha-core/./src/utils/pluginParser.js?");

/***/ }),

/***/ "./src/utils/redis-mock.js":
/*!*********************************!*\
  !*** ./src/utils/redis-mock.js ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function() {\n  \"use strict\";\n  var root = this || globalThis;\n  var redismock2 = {};\n  function exists(v) {\n    return typeof v !== \"undefined\" && v !== null;\n  }\n  if (typeof exports !== \"undefined\") {\n    if ( true && module.exports) {\n      exports = module.exports = redismock2;\n    }\n    exports.redismock = redismock2;\n  } else {\n    root.redismock = redismock2;\n  }\n  if (typeof setImmediate === \"undefined\" || typeof setImmediate !== \"function\") {\n    var setImmediate = function(f) {\n      setTimeout(f, 0);\n    };\n  }\n  redismock2.Array = Array;\n  function SortedSet() {\n    this.scores = [];\n    this.set = {};\n    this.invset = {};\n    this.indices = {};\n    this.lengths = {};\n    this.card = 0;\n    return this;\n  }\n  SortedSet.prototype.add = function(score, member) {\n    var ret = 1;\n    if (exists(this.invset[member])) {\n      this.rem(member);\n      ret = 0;\n    }\n    if (!exists(this.set[score])) {\n      this.scores.push(score);\n      this.set[score] = [];\n      this.lengths[score] = 0;\n    }\n    this.set[score].push(member);\n    this.invset[member] = score;\n    this.indices[member] = this.set[score].length - 1;\n    this.lengths[score] += 1;\n    this.card += 1;\n    return ret;\n  };\n  SortedSet.prototype.rem = function(member) {\n    var score;\n    if (!exists(this.invset[member])) {\n      return 0;\n    }\n    score = this.invset[member];\n    this.set[score].splice(this.set[score].indexOf(member), 1);\n    this.lengths[score] -= 1;\n    if (this.lengths[score] === 0) {\n      this.set[score] = void 0;\n      this.scores.splice(this.scores.indexOf(score), 1);\n    }\n    this.invset[member] = void 0;\n    this.indices[member] = void 0;\n    this.card -= 1;\n    return 1;\n  };\n  SortedSet.prototype.sortScores = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(a, 10) - parseInt(b, 10);\n    });\n    return this;\n  };\n  SortedSet.prototype.sortScoresRev = function() {\n    this.scores.sort(function(a, b) {\n      return parseInt(b, 10) - parseInt(a, 10);\n    });\n    return this;\n  };\n  redismock2.SortedSet = function() {\n    return new SortedSet();\n  };\n  var cache = {};\n  var timeouts = {};\n  var subscribers = [];\n  var watchers = {};\n  var sets = \"sets-\" + Math.random();\n  var zsets = \"zsets-\" + Math.random();\n  var hashes = \"hashes-\" + Math.random();\n  cache[sets] = {};\n  cache[zsets] = {};\n  cache[hashes] = {};\n  String.prototype.escape = function() {\n    var escapable = /[.\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    var meta;\n    meta = {\n      // table of character substitutions\n      \"\\b\": \"\\\\b\",\n      \"\t\": \"\\\\t\",\n      \"\\n\": \"\\\\n\",\n      \"\\f\": \"\\\\f\",\n      \"\\r\": \"\\\\r\",\n      \".\": \"\\\\.\",\n      '\"': '\\\\\"',\n      \"\\\\\": \"\\\\\\\\\"\n    };\n    function escapechar(a) {\n      var c = meta[a];\n      return typeof c === \"string\" ? c : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n    }\n    return this.replace(escapable, escapechar);\n  };\n  function translate(pat) {\n    var i = 0, j, n = pat.length || 0, res, c, stuff;\n    res = \"^\";\n    while (i < n) {\n      c = pat[i];\n      i = i + 1;\n      if (c === \"*\") {\n        res = res + \".*\";\n      } else if (c === \"?\") {\n        res = res + \".\";\n      } else if (c === \"[\") {\n        j = i;\n        if (j < n && pat[j] === \"!\") {\n          j = j + 1;\n        }\n        if (j < n && pat[j] === \"]\") {\n          j = j + 1;\n        }\n        while (j < n && pat[j] !== \"]\") {\n          j = j + 1;\n        }\n        if (j >= n) {\n          res = res + \"\\\\[\";\n        } else {\n          stuff = pat.slice(i, j).replace(\"\\\\\", \"\\\\\\\\\");\n          i = j + 1;\n          if (stuff[0] === \"!\") {\n            stuff = \"^\" + stuff.slice(1);\n          } else if (stuff[0] === \"^\") {\n            stuff = \"\\\\\" + stuff;\n          }\n          res = res + \"[\" + stuff + \"]\";\n        }\n      } else {\n        res = res + c.escape();\n      }\n    }\n    return res + \"$\";\n  }\n  var cb = function(callback, context) {\n    return function() {\n      var args = arguments;\n      if (callback && typeof callback === \"function\") {\n        setImmediate(function() {\n          callback.apply(context, args);\n        });\n      }\n      if (args[0] instanceof Error) {\n        return args[0];\n      }\n      return args[1];\n    };\n  };\n  var gather = function() {\n    return function() {\n      var idx, len = arguments.length;\n      var callback;\n      var list = [];\n      for (idx = len - 1; idx >= 0; idx -= 1) {\n        if (!callback && typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        } else if (exists(arguments[idx])) {\n          list.unshift(arguments[idx]);\n        }\n      }\n      return {\n        callback,\n        list\n      };\n    };\n  };\n  var wrongType = function(callback) {\n    return cb(callback)(new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"));\n  };\n  redismock2.ifType = function(key2, type, callback) {\n    var that = this;\n    return {\n      thenex: function(f) {\n        this._ifex = f;\n        return this;\n      },\n      thennx: function(f) {\n        this._ifnx = f;\n        return this;\n      },\n      then: function(f) {\n        this._then = f;\n        return this;\n      },\n      end: function() {\n        var ret;\n        if (that.exists(key2)) {\n          if (that.type(key2) !== type) {\n            return wrongType(callback);\n          }\n          if (typeof this._ifex === \"function\") {\n            ret = this._ifex.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        } else {\n          if (typeof this._ifnx === \"function\") {\n            ret = this._ifnx.call(that);\n            if (ret && ret instanceof Error) {\n              return cb(callback)(ret);\n            }\n          }\n        }\n        if (typeof this._then === \"function\") {\n          ret = this._then.call(that);\n          if (ret && ret instanceof Error) {\n            return cb(callback)(ret);\n          }\n        }\n        return cb(callback)(null, ret);\n      }\n    };\n  };\n  redismock2.del = function(key2, callback) {\n    var that = this;\n    var count = 0;\n    var g = gather(this.del).apply(this, arguments);\n    callback = g.callback;\n    var deleter = function(k) {\n      if (that.exists(k)) {\n        if (k in cache) {\n          cache[k] = void 0;\n        } else if (k in cache[sets]) {\n          cache[sets][k] = void 0;\n        } else if (k in cache[zsets]) {\n          cache[zsets][k] = void 0;\n        } else if (k in cache[hashes]) {\n          cache[hashes][k] = void 0;\n        }\n        return 1;\n      }\n      return 0;\n    };\n    var toDelete = g.list;\n    if (typeof g.list[0] === \"object\") {\n      toDelete = g.list[0];\n    }\n    toDelete.forEach(function(k) {\n      count += deleter(k);\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.dump = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.exists = function(key2, callback) {\n    return cb(callback)(null, exists(cache[key2]) || exists(cache[sets][key2]) || exists(cache[zsets][key2]) || exists(cache[hashes][key2]) ? 1 : 0);\n  };\n  redismock2.expire = function(key2, seconds, callback) {\n    return this.pexpire(key2, seconds * 1e3, callback);\n  };\n  redismock2.expireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp * 1e3 - now.getTime(), callback);\n  };\n  redismock2.keys = function(pattern, callback) {\n    var keys = [], key2;\n    var regex = new RegExp(translate(pattern));\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        if (key2.match(regex) !== null) {\n          keys.push(key2);\n        }\n      }\n    }\n    return cb(callback)(null, keys);\n  };\n  redismock2.migrate = function(host, port, key2, destination_db, timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.move = function(key2, db, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.object = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.persist = function(key2, callback) {\n    if (this.exists(key2) && timeouts[key2]) {\n      clearTimeout(timeouts[key2].timeout);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.pexpire = function(key2, milliseconds, callback) {\n    var that = this;\n    if (this.exists(key2)) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n      if (milliseconds <= 0) {\n        this.del(key2);\n      } else {\n        timeouts[key2] = {};\n        timeouts[key2].start = /* @__PURE__ */ new Date();\n        timeouts[key2].end = new Date(timeouts[key2].start.getTime() + milliseconds);\n        timeouts[key2].timeout = setTimeout(function() {\n          timeouts[key2] = void 0;\n          that.del(key2);\n        }, milliseconds);\n      }\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.pexpireat = function(key2, timestamp, callback) {\n    var now = /* @__PURE__ */ new Date();\n    return this.pexpire(key2, timestamp - now.getTime(), callback);\n  };\n  redismock2.pttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, timeouts[key2].end.getTime() - now.getTime());\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock2.randomkey = function(callback) {\n    var rando = null;\n    function loop_through(count, looper) {\n      var key2;\n      for (key2 in looper) {\n        if (key2 === sets) {\n          count = loop_through(count, cache[sets]);\n          continue;\n        } else if (key2 === zsets) {\n          count = loop_through(count, cache[zsets]);\n          continue;\n        } else if (key2 === hashes) {\n          count = loop_through(count, cache[hashes]);\n          continue;\n        } else if (Math.random() < 1 / count) {\n          rando = key2;\n        }\n        count += 1;\n      }\n      return count;\n    }\n    loop_through(1, cache);\n    return cb(callback)(null, rando);\n  };\n  redismock2.rename = function(key2, newkey, callback) {\n    var type;\n    if (!this.exists(key2)) {\n      return cb(callback)(new Error(\"ERR no such key\"));\n    }\n    if (key2 === newkey) {\n      return cb(callback)(null, \"OK\");\n    }\n    type = this.type(key2);\n    if (type === \"string\" || type === \"list\") {\n      cache[newkey] = cache[key2];\n    } else if (type === \"set\") {\n      cache[sets][newkey] = cache[sets][key2];\n    } else if (type === \"zset\") {\n      cache[zsets][newkey] = cache[zsets][key2];\n    } else if (type === \"hash\") {\n      cache[hashes][newkey] = cache[hashes][key2];\n    }\n    this.del(key2);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.renamenx = function(key2, newkey, callback) {\n    var r;\n    if (this.exists(newkey)) {\n      return cb(callback)(null, 0);\n    }\n    r = this.rename(key2, newkey);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, 1);\n  };\n  redismock2.restore = function(key2, ttl, serialized_value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.sort = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.ttl = function(key2, callback) {\n    var now = /* @__PURE__ */ new Date();\n    if (timeouts[key2]) {\n      return cb(callback)(null, (timeouts[key2].end.getTime() - now.getTime()) / 1e3);\n    }\n    return cb(callback)(null, this.exists(key2) ? -1 : -2);\n  };\n  redismock2.type = function(key2, callback) {\n    if (this.exists(key2)) {\n      var type = typeof cache[key2];\n      if (type === \"object\") {\n        if (cache[key2] instanceof Array) {\n          type = \"list\";\n        }\n      } else if (type === \"undefined\") {\n        if (key2 in cache[sets] && cache[sets][key2]) {\n          type = \"set\";\n        } else if (key2 in cache[zsets] && cache[zsets][key2]) {\n          type = \"zset\";\n        } else if (key2 in cache[hashes] && cache[hashes][key2]) {\n          type = \"hash\";\n        }\n      }\n      return cb(callback)(null, type);\n    }\n    return cb(callback)(null, \"none\");\n  };\n  redismock2.scan = function(cursor, callback) {\n    var g = gather(this.scan).apply(null, arguments);\n    var idx = 0;\n    var key2;\n    var reply = [];\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    for (key2 in cache) {\n      if (cache.hasOwnProperty(key2)) {\n        if (key2 === sets || key2 === zsets || key2 === hashes) {\n          continue;\n        }\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        idx += 1;\n        if (idx > cursor) {\n          if (!exists(match) || key2.match(match)) {\n            reply.push(key2);\n            if (reply.length >= count) {\n              return cb(callback)(null, [idx, reply]);\n            }\n          }\n        }\n      }\n    }\n    if (!reply.length) {\n      idx = 0;\n    }\n    return cb(callback)(null, [idx, reply]);\n  };\n  redismock2.append = function(key2, value, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      cache[key2] += value;\n      return null;\n    }).thennx(function() {\n      return this.set(key2, value);\n    }).then(function() {\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.bitcount = function(key2, callback) {\n    var g = gather(this.bitcount).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length === 3) {\n      start = g.list[1];\n      end = g.list[2];\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var idx, n, count;\n      if (!exists(start)) {\n        start = 0;\n      }\n      if (!exists(end)) {\n        end = cache[key2].length - 1;\n      }\n      if (end >= cache[key2].length) {\n        end = cache[key2].length - 1;\n      }\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return 0;\n      }\n      count = 0;\n      for (idx = start; idx <= end; idx += 1) {\n        n = cache[key2].charCodeAt(idx);\n        while (n) {\n          count += n & 1;\n          n >>= 1;\n        }\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.bitop = function(operation, destkey, key2, callback) {\n    var that = this;\n    var g = gather(this.bitop).apply(this, arguments);\n    var longest, strings, string, r;\n    operation = typeof operation === \"string\" ? operation.toLowerCase() : \"\";\n    if (operation !== \"and\" && operation !== \"or\" && operation !== \"xor\" && operation !== \"not\") {\n      return cb(callback)(new Error(\"ERR syntax error\"));\n    }\n    callback = g.callback;\n    strings = g.list.slice(2).map(function(k) {\n      if (that.exists(k) && that.type(k) !== \"string\") {\n        return null;\n      }\n      return that.exists(k) ? cache[k] : \"\";\n    });\n    if (strings.some(function(str) {\n      return str === null;\n    })) {\n      return wrongType(callback);\n    }\n    longest = strings.reduce(function(length, str) {\n      return str.length > length ? str.length : length;\n    }, 0);\n    strings = strings.map(function(str) {\n      while (str.length < longest) {\n        str += \"\\0\";\n      }\n      return str;\n    });\n    string = strings.reduce(function(cur, str, index) {\n      var idx, n, s;\n      s = \"\";\n      for (idx = 0; idx < longest; idx += 1) {\n        if (operation === \"and\") {\n          n = cur.charCodeAt(idx) & str.charCodeAt(idx);\n        } else if (operation === \"or\") {\n          n = cur.charCodeAt(idx) | str.charCodeAt(idx);\n        } else if (operation === \"xor\") {\n          if (index > 0) {\n            n = cur.charCodeAt(idx) ^ str.charCodeAt(idx);\n          } else {\n            n = cur.charCodeAt(idx);\n          }\n        } else if (operation === \"not\") {\n          n = ~cur.charCodeAt(idx);\n        }\n        s += String.fromCharCode(n);\n      }\n      return s;\n    }, strings[0]);\n    r = this.set(destkey, string);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, string.length);\n  };\n  redismock2.bitpos = function(key2, bit, callback) {\n    var g = gather(this.bitpos).apply(this, arguments);\n    var start, end;\n    callback = g.callback;\n    if (g.list.length > 2) {\n      start = g.list[2];\n      end = g.list[3];\n    }\n    if (typeof start === \"undefined\") {\n      start = 0;\n    }\n    if (bit !== 0 && bit !== 1) {\n      return cb(callback)(new Error(\"ERR The bit argument must be 1 or 0.\"));\n    }\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      if (bit === 0) {\n        return 0;\n      }\n      return -1;\n    }).thenex(function() {\n      var idx, ch, cnt, noend = false;\n      if (start < 0) {\n        start = cache[key2].length + start;\n      }\n      if (typeof end === \"undefined\") {\n        noend = true;\n        end = cache[key2].length - 1;\n      }\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start > end) {\n        return -1;\n      }\n      for (idx = start; idx <= end; idx += 1) {\n        ch = cache[key2].charCodeAt(idx);\n        cnt = 0;\n        while (cnt < 8) {\n          if (bit === 0 && (ch & 128) !== 128) {\n            return idx * 8 + cnt;\n          }\n          if (bit === 1 && (ch & 128) === 128) {\n            return idx * 8 + cnt;\n          }\n          ch <<= 1;\n          cnt += 1;\n        }\n      }\n      if (bit === 1) {\n        return -1;\n      }\n      if (bit === 0 && noend) {\n        return idx * 8;\n      }\n      return -1;\n    }).end();\n  };\n  redismock2.decr = function(key2, callback) {\n    return this.decrby(key2, 1, callback);\n  };\n  redismock2.decrby = function(key2, decrement, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt - decrement);\n      return asInt - decrement;\n    }).end();\n  };\n  redismock2.get = function(key2, callback) {\n    if (this.type(key2) === \"string\") {\n      return cb(callback)(null, cache[key2]);\n    }\n    return cb(callback)(null, null);\n  };\n  redismock2.getbit = function(key2, offset, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var n, pos;\n      if (offset >= cache[key2].length * 8) {\n        return 0;\n      }\n      n = cache[key2].charCodeAt(Math.floor(offset / 8));\n      pos = offset % 8;\n      return n >> pos & 1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.getrange = function(key2, start, end, callback) {\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      var len = 0;\n      if (end < 0) {\n        end = cache[key2].length + end;\n      }\n      if (start < 0) {\n        len = end - (cache[key2].length + start) + 1;\n      } else {\n        len = end - start + 1;\n      }\n      return cache[key2].substr(start, len);\n    }).thennx(function() {\n      return \"\";\n    }).end();\n  };\n  redismock2.getset = function(key2, value, callback) {\n    var prev = this.get(key2);\n    this.set(key2, value);\n    return cb(callback)(null, prev);\n  };\n  redismock2.incr = function(key2, callback) {\n    return this.incrby(key2, 1, callback);\n  };\n  redismock2.incrby = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseInt(this.get(key2), 10);\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return asInt + increment;\n    }).end();\n  };\n  redismock2.incrbyfloat = function(key2, increment, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      this.set(key2, \"0\");\n    }).then(function() {\n      var asInt = parseFloat(this.get(key2));\n      if (isNaN(asInt)) {\n        return new Error(\"ERR value is not an integer or out of range\");\n      }\n      this.set(key2, asInt + increment);\n      return this.get(key2);\n    }).end();\n  };\n  redismock2.mget = function(key2, callback) {\n    var g = gather(this.mget).apply(this, arguments);\n    callback = g.callback;\n    var data = typeof g.list[0] === \"object\" ? g.list[0] : g.list;\n    return cb(callback)(null, data.map(function(k) {\n      return cache[k] || null;\n    }));\n  };\n  redismock2.mset = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.mset).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.msetnx = function(key2, value, callback) {\n    var kvs = [];\n    var that = this;\n    var g = gather(this.msetnx).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (index % 2 === 0) {\n        kvs.push([opt, g.list[index + 1]]);\n      }\n    });\n    if (kvs.some(function(kv) {\n      return that.exists(kv[0]);\n    })) {\n      return cb(callback)(null, 0);\n    }\n    kvs.forEach(function(kv) {\n      that.set(kv[0], kv[1]);\n    });\n    return cb(callback)(null, 1);\n  };\n  redismock2.psetex = function(key2, milliseconds, value, callback) {\n    this.set(key2, value);\n    this.pexpire(key2, milliseconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.set = function(key2, value, callback) {\n    var nx = false, xx = false, ex = -1, px = -1;\n    var g = gather(this.set).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(opt, index) {\n      if (opt === \"nx\" || opt === \"NX\") {\n        nx = true;\n      } else if (opt === \"xx\" || opt === \"XX\") {\n        xx = true;\n      } else if (opt === \"ex\" || opt === \"EX\") {\n        ex = g.list[index + 1];\n      } else if (opt === \"px\" || opt === \"PX\") {\n        px = g.list[index + 1];\n      }\n    });\n    if (nx) {\n      if (this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    if (xx) {\n      if (!this.exists(key2)) {\n        return cb(callback)(null, null);\n      }\n    }\n    cache[key2] = exists(value) ? value.toString() : \"\";\n    if (px !== -1) {\n      redismock2.pexpire(key2, px);\n    }\n    if (ex !== -1) {\n      redismock2.expire(key2, ex);\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.setbit = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var byteIdx = Math.floor(offset / 8);\n      var bitIdx = offset % 8;\n      var idx, bit, mask;\n      var code;\n      if (value !== 0 && value !== 1) {\n        return new Error(\"ERR bit is not an integer or out of range\");\n      }\n      while (cache[key2].length < byteIdx + 1) {\n        cache[key2] += \"\\0\";\n      }\n      code = cache[key2].charCodeAt(byteIdx);\n      idx = 0;\n      mask = 128;\n      while (idx < bitIdx) {\n        mask >>= 1;\n        idx += 1;\n      }\n      bit = (code & mask) === 0 ? 0 : 1;\n      if (value === 0) {\n        code = code & ~mask;\n      } else {\n        code = code | mask;\n      }\n      cache[key2] = cache[key2].substr(0, byteIdx) + String.fromCharCode(code) + cache[key2].substr(byteIdx + 1);\n      return bit;\n    }).end();\n  };\n  redismock2.setex = function(key2, seconds, value, callback) {\n    this.set(key2, value);\n    this.expire(key2, seconds);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.setnx = function(key2, value, callback) {\n    if (!this.exists(key2)) {\n      this.set(key2, value);\n      return cb(callback)(null, 1);\n    }\n    return cb(callback)(null, 0);\n  };\n  redismock2.setrange = function(key2, offset, value, callback) {\n    return this.ifType(key2, \"string\", callback).thennx(function() {\n      cache[key2] = \"\";\n    }).then(function() {\n      var idx, newValue;\n      if (cache[key2].length < offset + value.length - 1) {\n        for (idx = cache[key2].length; idx < offset + value.length; idx += 1) {\n          cache[key2] += \"\\0\";\n        }\n      }\n      newValue = cache[key2].substr(0, offset);\n      for (idx = offset; idx < offset + value.length; idx += 1) {\n        newValue += value[idx - offset];\n      }\n      newValue += cache[key2].substr(offset + value.length);\n      cache[key2] = newValue;\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.strlen = function(key2, callback) {\n    if (!this.exists(key2)) {\n      return cb(callback)(null, 0);\n    }\n    return this.ifType(key2, \"string\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.blpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.blpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    var f, timedout = false;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.lpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.brpop = function(key2, timeout, callback) {\n    var that = this;\n    var g = gather(this.brpop).apply(null, arguments);\n    var keys = g.list.slice(0, g.list.length - 1);\n    var f, timedout = false;\n    timeout = g.list[g.list.length - 1];\n    callback = g.callback;\n    f = function() {\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      if (keys.some(function(k) {\n        var len = that.llen(k);\n        if (len instanceof Error) {\n          cb(callback)(len);\n          return true;\n        }\n        if (len > 0) {\n          that.rpop(k, callback);\n          return true;\n        }\n        return false;\n      })) {\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.brpoplpush = function(source, destination, timeout, callback) {\n    var that = this;\n    var f, timedout = false;\n    f = function() {\n      var len;\n      if (timedout) {\n        return cb(callback)(null, null);\n      }\n      len = that.llen(source);\n      if (len instanceof Error) {\n        return cb(callback)(len);\n      }\n      if (len > 0) {\n        that.rpoplpush(source, destination, callback);\n        return;\n      }\n      setImmediate(f);\n    };\n    if (timeout > 0) {\n      setTimeout(function() {\n        timedout = true;\n      }, timeout * 1e3);\n    }\n    setImmediate(f);\n    return this;\n  };\n  redismock2.lindex = function(key2, i, callback) {\n    var elem = null;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (i >= 0 && i < cache[key2].length) {\n        elem = cache[key2][i];\n      } else if (i < 0 && cache[key2].length + 1 >= 0) {\n        elem = cache[key2][cache[key2].length + i];\n      }\n    }).then(function() {\n      return elem;\n    }).end();\n  };\n  redismock2.linsert = function(key2, beforeafter, pivot, value, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx = cache[key2].indexOf(pivot);\n      if (idx !== -1) {\n        if (beforeafter === \"before\") {\n          cache[key2].splice(idx, 0, value);\n        } else if (beforeafter === \"after\") {\n          cache[key2].splice(idx + 1, 0, value);\n        }\n        return cache[key2].length;\n      }\n      return -1;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.llen = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.lpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].shift();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.lpush = function(key2, element, callback) {\n    var g = gather(this.lpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock2.Array();\n    }).then(function() {\n      g.list.slice(1).forEach(function(elem) {\n        cache[key2].unshift(elem);\n      });\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.lpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].unshift(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.lrange = function(key2, start, end, callback) {\n    var l = [];\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (start > cache[key2].length - 1) {\n        l = [];\n      } else {\n        if (start < 0) {\n          start = cache[key2].length + start;\n        }\n        if (end < 0) {\n          end = cache[key2].length + end;\n        }\n        if (start > end) {\n          l = [];\n        } else {\n          l = cache[key2].slice(start, end + 1);\n        }\n      }\n    }).then(function() {\n      return l;\n    }).end();\n  };\n  redismock2.lrem = function(key2, count, element, callback) {\n    var cnt = 0;\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var idx;\n      while (true) {\n        idx = cache[key2].indexOf(element);\n        if (idx === -1) {\n          break;\n        }\n        cache[key2].splice(idx, 1);\n        cnt += 1;\n        if (count > 0 && cnt === count) {\n          break;\n        }\n      }\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return cnt;\n    }).end();\n  };\n  redismock2.lset = function(key2, index, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      if (index >= cache[key2].length) {\n        return new Error(\"ERR index out of range\");\n      }\n      cache[key2][index] = element;\n      return \"OK\";\n    }).thennx(function() {\n      return new Error(\"ERR no such key\");\n    }).end();\n  };\n  redismock2.ltrim = function(key2, start, end, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var tmpS, tmpE;\n      if (start > cache[key2].length - 1 || start > end) {\n        cache[key2] = new redismock2.Array();\n      } else {\n        if (start < 0 && end < 0) {\n          tmpE = cache[key2].length + end;\n          tmpS = cache[key2].length + start;\n          if (tmpS < 0) {\n            tmpS = 0;\n          }\n          start = tmpS;\n          end = tmpE;\n        }\n        if (end > cache[key2].length - 1) {\n          end = cache[key2].length - 1;\n        }\n        cache[key2] = cache[key2].slice(start, end + 1);\n      }\n    }).then(function() {\n      if (this.exists(key2) && !cache[key2].length) {\n        this.del(key2);\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock2.rpop = function(key2, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      var popped = cache[key2].pop();\n      if (!cache[key2].length) {\n        this.del(key2);\n      }\n      return popped;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.rpoplpush = function(source, dest, callback) {\n    var element = null, reply;\n    if (this.exists(source) && this.type(source) !== \"list\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"list\") {\n      return wrongType(callback);\n    }\n    element = this.rpop(source);\n    if (element instanceof Error) {\n      return cb(callback)(element);\n    }\n    if (element) {\n      reply = this.lpush(dest, element);\n      if (reply instanceof Error) {\n        return cb(callback)(reply);\n      }\n    }\n    return cb(callback)(null, element);\n  };\n  redismock2.rpush = function(key2, element, callback) {\n    var g = gather(this.rpush).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"list\", callback).thennx(function() {\n      cache[key2] = new redismock2.Array();\n    }).then(function() {\n      cache[key2] = cache[key2].concat(g.list.slice(1));\n      return cache[key2].length;\n    }).end();\n  };\n  redismock2.rpushx = function(key2, element, callback) {\n    return this.ifType(key2, \"list\", callback).thenex(function() {\n      cache[key2].push(element);\n      return cache[key2].length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.sadd = function(key2, member, callback) {\n    var g = gather(this.sadd).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      cache[sets][key2] = {};\n    }).then(function() {\n      g.list.slice(1).forEach(function(m) {\n        m = m ? m.toString() : \"\";\n        if (m.length === 0) {\n          return;\n        }\n        if (!(m in cache[sets][key2])) {\n          cache[sets][key2][m] = \"\";\n          count += 1;\n        }\n      });\n      return count;\n    }).end();\n  };\n  redismock2.scard = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]).length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.sdiff = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sdiff).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(diff, k) {\n        return diff.filter(function(d) {\n          return !(d in cache[sets][k]);\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock2.sdiffstore = function(destination, key2, callback) {\n    var g = gather(this.sdiffstore).apply(this, arguments);\n    var diff = this.sdiff.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (diff instanceof Error) {\n      return cb(callback)(diff);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    this.sadd.apply(this, [destination].concat(diff));\n    return cb(callback)(null, diff.length);\n  };\n  redismock2.sinter = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sinter).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return g.list.slice(1).reduce(function(inter, k) {\n        return inter.filter(function(i) {\n          return i in cache[sets][k];\n        });\n      }, this.smembers(g.list[0]));\n    }).end();\n  };\n  redismock2.sinterstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sinterstore).apply(this, arguments);\n    var inter = this.sinter.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (inter instanceof Error) {\n      return cb(callback)(inter);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    inter.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, inter.length);\n  };\n  redismock2.sismember = function(key2, member, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return member in cache[sets][key2] ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.smembers = function(key2, callback) {\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      return Object.keys(cache[sets][key2]);\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.smove = function(source, dest, member, callback) {\n    var r, e;\n    if (this.exists(source) && this.type(source) !== \"set\") {\n      return wrongType(callback);\n    }\n    if (this.exists(dest) && this.type(dest) !== \"set\") {\n      return wrongType(callback);\n    }\n    r = redismock2.srem(source, member);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    if (r === 1) {\n      e = redismock2.sadd(dest, member);\n      if (e instanceof Error) {\n        return cb(callback)(e);\n      }\n    }\n    return cb(callback)(null, r);\n  };\n  redismock2.spop = function(key2, callback) {\n    var r;\n    var rando = this.srandmember(key2);\n    if (rando instanceof Error) {\n      return cb(callback)(rando);\n    }\n    r = this.srem(key2, rando);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, rando);\n  };\n  redismock2.srandmember = function(key2, callback) {\n    var that = this;\n    var count;\n    if (arguments.length === 2 && typeof callback !== \"function\") {\n      count = callback;\n      callback = null;\n    }\n    if (arguments.length === 3) {\n      count = callback;\n      callback = arguments[2];\n    }\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      var k = Object.keys(cache[sets][key2]);\n      var randos, rando;\n      var len = that.scard(key2);\n      if (count === 0) {\n        return null;\n      }\n      if (count) {\n        randos = [];\n        while (randos.length < Math.abs(count)) {\n          rando = k[Math.floor(Math.random() * k.length)];\n          if (count < 0) {\n            randos.push(rando);\n          } else {\n            if (randos.indexOf(rando) === -1) {\n              randos.push(rando);\n              if (randos.length === len) {\n                break;\n              }\n            }\n          }\n        }\n        return randos;\n      }\n      return k[Math.floor(Math.random() * k.length)];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.srem = function(key2, member, callback) {\n    var g = gather(this.srem).apply(this, arguments);\n    var count = 0;\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).thenex(function() {\n      g.list.slice(1).forEach(function(m) {\n        var k = m ? m.toString() : \"\";\n        if (k in cache[sets][key2]) {\n          delete cache[sets][key2][k];\n          count += 1;\n        }\n      });\n      if (!Object.keys(cache[sets][key2]).length) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock2.sunion = function(key2, callback) {\n    var that = this;\n    var g = gather(this.sunion).apply(this, arguments);\n    callback = g.callback;\n    if (!g.list.every(function(k) {\n      return that.type(k) === \"set\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    return this.ifType(key2, \"set\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      return Object.keys(g.list.reduce(function(set, k) {\n        Object.keys(cache[sets][k]).filter(function(u) {\n          return !(u in set);\n        }).forEach(function(u) {\n          set[u] = \"\";\n        });\n        return set;\n      }, {}));\n    }).end();\n  };\n  redismock2.sunionstore = function(destination, key2, callback) {\n    var that = this;\n    var g = gather(this.sunionstore).apply(this, arguments);\n    var union = this.sunion.apply(this, g.list.slice(1));\n    callback = g.callback;\n    if (union instanceof Error) {\n      return cb(callback)(union);\n    }\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    union.forEach(function(member) {\n      that.sadd(destination, member);\n    });\n    return cb(callback)(null, union.length);\n  };\n  redismock2.sscan = function(key2, cursor, callback) {\n    var g = gather(this.sscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"set\", callback).then(function() {\n      var arr = [];\n      this.smembers(key2).slice(cursor).some(function(member) {\n        if (typeof match === \"undefined\" || member.match(match)) {\n          arr.push(member);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.zadd = function(key2, score, member, callback) {\n    var g = gather(this.zadd).apply(this, arguments);\n    callback = g.callback;\n    g.list = g.list.slice(1);\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock2.SortedSet();\n    }).then(function() {\n      var count = g.list.map(function(elem, index) {\n        if (index % 2 === 0) {\n          return [parseFloat(g.list[index]), g.list[index + 1]];\n        }\n        return null;\n      }).filter(function(elem) {\n        return elem !== null;\n      }).map(function(sm) {\n        return cache[zsets][key2].add(sm[0], sm[1].toString());\n      }).reduce(function(cnt, ret) {\n        return cnt + ret;\n      }, 0);\n      return count;\n    }).end();\n  };\n  redismock2.zcard = function(key2, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      return cache[zsets][key2].card;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zcount = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = cache[zsets][key2].scores.filter(function(score) {\n        return min <= score && score <= max;\n      }).reduce(function(cnt, score) {\n        return cnt + cache[zsets][key2].lengths[score];\n      }, 0);\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zincrby = function(key2, increment, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      cache[zsets][key2] = redismock2.SortedSet();\n    }).then(function() {\n      var newScore, score;\n      if (!exists(cache[zsets][key2].invset[member])) {\n        this.zadd(key2, increment, member);\n        return increment;\n      }\n      score = cache[zsets][key2].invset[member];\n      newScore = score + increment;\n      this.zadd(key2, newScore, member);\n      return newScore;\n    }).end();\n  };\n  redismock2.zinterstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zinterstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(inter, k) {\n      var arr = [];\n      var idx, len = inter.length;\n      var score, ms;\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        score = cache[zsets][k].invset[inter[idx]];\n        if (!exists(score)) {\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        ms = [inter[idx + 1], inter[idx]];\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, inter) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, inter[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.zlexcount = function(key2, min, max, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock2.zrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = Math.max(this.zcard(key2) + start, 0);\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].lengths[score] > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].lengths[score];\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        while (from < to) {\n          if (exists(cache[zsets][key2].set[score][from])) {\n            arr.push(cache[zsets][key2].set[score][from]);\n          }\n          from += 1;\n        }\n        arr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrangebylex = function(key2, min, max, callback) {\n    function verify(r) {\n      return typeof r === \"string\" && (r.charAt(0) === \"(\" || r.charAt(0) === \"[\" || r.charAt(0) === \"-\" || r.charAt(0) === \"+\");\n    }\n    if (!verify(min) || !verify(max)) {\n      return cb(callback)(new Error(\"ERR min or max not valid string range item\"));\n    }\n    return this.ifType(key2, \"zset\", callback).thennx(function() {\n      return [];\n    }).thenex(function() {\n      var minStr = min.substr(1), maxStr = max.substr(1);\n      var minInclusive = min.charAt(0) === \"[\", maxInclusive = max.charAt(0) === \"[\";\n      var maxAll = max.charAt(0) === \"+\";\n      var range = [];\n      if (min.charAt(0) === \"+\") {\n        return [];\n      }\n      if (max.charAt(0) === \"-\") {\n        return [];\n      }\n      cache[zsets][key2].scores.forEach(function(score) {\n        cache[zsets][key2].set[score].forEach(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if (member > minStr && (member < maxStr || maxAll)) {\n            range.push(member);\n          } else if (member === minStr && minInclusive) {\n            range.push(member);\n          } else if (member === maxStr && maxInclusive) {\n            range.push(member);\n          }\n        });\n      });\n      range.sort(function(a, b) {\n        return a.localeCompare(b);\n      });\n      return range;\n    }).end();\n  };\n  redismock2.zrevrangebylex = function(key2, max, min, callback) {\n    var r = this.zrangebylex(key2, min, max);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.reverse());\n  };\n  redismock2.zrangebyscore = function(key2, min, max, callback) {\n    var withscores = false;\n    var limitOffset = -1, limitCount = -1;\n    var idx, len;\n    var arr = [], offset, count;\n    var minInclusive = true, maxInclusive = true;\n    if (typeof callback !== \"function\") {\n      len = arguments.length;\n      for (idx = 3; idx < len; idx += 1) {\n        if (arguments[idx] === \"withscores\") {\n          withscores = true;\n        }\n        if (typeof arguments[idx] === \"function\") {\n          callback = arguments[idx];\n        }\n        if (arguments[idx] === \"limit\") {\n          limitOffset = arguments[idx + 1];\n          limitCount = arguments[idx + 2];\n        }\n      }\n    }\n    if (min === \"-inf\") {\n      min = Number.NEGATIVE_INFINITY;\n    }\n    if (min === \"+inf\") {\n      min = Number.POSITIVE_INFINITY;\n    }\n    if (max === \"-inf\") {\n      max = Number.NEGATIVE_INFINITY;\n    }\n    if (max === \"+inf\") {\n      max = Number.POSITIVE_INFINITY;\n    }\n    if (min.toString().charAt(0) === \"(\") {\n      minInclusive = false;\n      min = parseFloat(min.toString().substr(1));\n    }\n    if (max.toString().charAt(0) === \"(\") {\n      maxInclusive = false;\n      max = parseFloat(max.toString().substr(1));\n    }\n    offset = 0;\n    count = 0;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        var memberArr = [], scoreArr = [], concatArr = [];\n        cache[zsets][key2].set[score].some(function(member) {\n          if (!exists(member)) {\n            return;\n          }\n          if ((minInclusive && min <= score || !minInclusive && min < score) && (maxInclusive && score <= max || !maxInclusive && score < max)) {\n            if (limitOffset !== -1 && offset >= limitOffset) {\n              if (limitCount !== -1) {\n                if (count + memberArr.length < limitCount) {\n                  memberArr.push(member);\n                  if (withscores) {\n                    scoreArr.push(score);\n                  }\n                } else {\n                  return true;\n                }\n              }\n            } else if (limitOffset === -1) {\n              memberArr.push(member);\n              if (withscores) {\n                scoreArr.push(score);\n              }\n            }\n          }\n          offset += 1;\n          return false;\n        });\n        count += memberArr.length;\n        memberArr.sort(function(a, b) {\n          return a.localeCompare(b);\n        });\n        if (withscores) {\n          memberArr.forEach(function(m, idx2) {\n            concatArr.push(m, scoreArr[idx2]);\n          });\n        } else {\n          concatArr = memberArr;\n        }\n        arr = arr.concat(concatArr);\n        if (limitCount !== -1 && count === limitCount) {\n          return true;\n        }\n        return false;\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx = 0;\n      var found;\n      cache[zsets][key2].sortScores();\n      found = cache[zsets][key2].scores.some(function(score) {\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return true;\n        }\n        idx += 1;\n        return false;\n      });\n      if (!found) {\n        return null;\n      }\n      return idx;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zrem = function(key2, member, callback) {\n    var g = gather(this.zrem).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var count = g.list.reduce(function(cnt, m) {\n        return cnt + cache[zsets][key2].rem(m);\n      }, 0);\n      if (cache[zsets][key2].scores.length === 0) {\n        this.del(key2);\n      }\n      return count;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zremrangebylex = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebylex(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock2.zremrangebyrank = function(key2, min, max, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var that = this;\n      var idx, len = cache[zsets][key2].scores.length, jdx, nel;\n      var cnt;\n      var score;\n      var toRem = [];\n      var card = this.zcard(key2);\n      if (min < 0) {\n        min = card + min;\n      }\n      if (max < 0) {\n        max = card + max;\n      }\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = 0; idx < len; idx += 1) {\n        score = cache[zsets][key2].scores[idx];\n        nel = cache[zsets][key2].set[score].length;\n        for (jdx = 0; jdx < nel; jdx += 1, cnt += 1) {\n          if (min <= cnt && cnt <= max) {\n            toRem.push(cache[zsets][key2].set[score][jdx]);\n          }\n          if (cnt > max) {\n            break;\n          }\n        }\n        if (cnt > max) {\n          break;\n        }\n      }\n      toRem.forEach(function(r) {\n        that.zrem(key2, r);\n      });\n      return toRem.length;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.zremrangebyscore = function(key2, min, max, callback) {\n    var that = this;\n    var range = this.zrangebyscore(key2, min, max);\n    if (range instanceof Error) {\n      return cb(callback)(range);\n    }\n    range.forEach(function(member) {\n      that.zrem(key2, member);\n    });\n    return cb(callback)(null, range.length);\n  };\n  redismock2.zrevrange = function(key2, start, stop, callback) {\n    var withscores = false;\n    if (typeof callback !== \"function\" && callback === \"withscores\") {\n      withscores = true;\n      callback = arguments[4];\n    }\n    if (start < 0) {\n      start = this.zcard(key2) + start;\n    }\n    if (stop < 0) {\n      stop = this.zcard(key2) + stop;\n    }\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var startScoreIdx = 0, idx = 0;\n      var range = [];\n      cache[zsets][key2].sortScoresRev().scores.some(function(score) {\n        if (idx <= start && idx + cache[zsets][key2].set[score].length > start) {\n          return true;\n        }\n        idx += cache[zsets][key2].set[score].length;\n        startScoreIdx += 1;\n        return false;\n      });\n      cache[zsets][key2].scores.slice(startScoreIdx).some(function(score) {\n        var arr = [];\n        var len = cache[zsets][key2].set[score].length;\n        var from = 0, to = 0;\n        if (idx > stop) {\n          return true;\n        }\n        while (idx < start) {\n          idx += 1;\n          from += 1;\n        }\n        to = from + 1;\n        while (idx <= stop && to <= len) {\n          idx += 1;\n          to += 1;\n        }\n        arr = cache[zsets][key2].set[score].slice(from, to);\n        arr.sort(function(a, b) {\n          return b.localeCompare(a);\n        });\n        if (withscores) {\n          arr = arr.map(function(e) {\n            return [e, score];\n          }).reduce(function(flat, es) {\n            return flat.concat(es);\n          }, []);\n        }\n        range = range.concat(arr);\n        return false;\n      });\n      return range;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.zrevrangebyscore = function(key2, max, min, callback) {\n    var g = gather(this.zrevrangebyscore).apply(this, arguments);\n    var r, tmpM;\n    callback = g.callback;\n    tmpM = g.list[1];\n    g.list[1] = g.list[2];\n    g.list[2] = tmpM;\n    r = this.zrangebyscore.apply(this, g.list);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    r.reverse();\n    if (g.list.some(function(arg) {\n      return arg === \"withscores\";\n    })) {\n      r = r.map(function(e, idx) {\n        if (idx % 2 === 0) {\n          return r[idx + 1];\n        }\n        return r[idx - 1];\n      });\n    }\n    return cb(callback)(null, r);\n  };\n  redismock2.zrevrank = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var idx, len = cache[zsets][key2].scores.length, cnt;\n      var score;\n      cnt = 0;\n      cache[zsets][key2].sortScores();\n      for (idx = len - 1; idx >= 0; idx -= 1, cnt += 1) {\n        score = cache[zsets][key2].scores[idx];\n        if (cache[zsets][key2].set[score].indexOf(member) !== -1) {\n          return cnt;\n        }\n      }\n      return null;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zscore = function(key2, member, callback) {\n    return this.ifType(key2, \"zset\", callback).thenex(function() {\n      var score = null;\n      if (exists(cache[zsets][key2].invset[member])) {\n        score = cache[zsets][key2].invset[member];\n      }\n      return score;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.zunionstore = function(destination, numkeys, key2, callback) {\n    var that = this;\n    var g = gather(this.zunionstore).apply(this, arguments);\n    var weights = {};\n    var aggregate = \"sum\";\n    var count;\n    callback = g.callback;\n    if (!g.list.slice(2, 2 + numkeys).every(function(k) {\n      return that.type(k) === \"zset\" || that.type(k) === \"none\";\n    })) {\n      return wrongType(callback);\n    }\n    g.list.forEach(function(option, idx) {\n      var index, weightsArray = [];\n      if (option === \"weights\") {\n        index = idx + 1;\n        while (g.list[index] !== \"aggregate\" && index < g.list.length) {\n          weightsArray.push(g.list[index]);\n          index += 1;\n        }\n        weights = weightsArray.reduce(function(hash, weight, i) {\n          hash[g.list[i + 2]] = weight;\n          return hash;\n        }, {});\n      } else if (option === \"aggregate\") {\n        aggregate = g.list[idx + 1];\n      }\n    });\n    if (this.exists(destination)) {\n      this.del(destination);\n    }\n    count = 0;\n    g.list = g.list.slice(2, 2 + numkeys);\n    g.list.slice(1).reduce(function(union, k) {\n      var arr = [];\n      var idx, len = union.length;\n      var score, ms;\n      var hashk = cache[zsets][k].invset;\n      var hashu = {};\n      for (idx = 0; idx < len; idx += 1) {\n        if (idx % 2 !== 0) {\n          continue;\n        }\n        ms = [union[idx + 1], union[idx]];\n        score = cache[zsets][k].invset[union[idx]];\n        hashu[ms[1]] = ms[0];\n        if (!exists(score)) {\n          arr.push(ms[1], ms[0]);\n          continue;\n        }\n        if (k in weights) {\n          score *= weights[k];\n        }\n        if (aggregate === \"min\") {\n          ms[0] = Math.min(ms[0], score);\n        } else if (aggregate === \"max\") {\n          ms[0] = Math.max(ms[0], score);\n        } else {\n          ms[0] += score;\n        }\n        arr.push(ms[1], ms[0]);\n      }\n      Object.keys(hashk).forEach(function(member) {\n        if (!exists(hashk[member])) {\n          return;\n        }\n        if (!(member in hashu)) {\n          score = hashk[member];\n          if (k in weights) {\n            score *= weights[k];\n          }\n          arr.push(member, score);\n        }\n      });\n      return arr;\n    }, this.zrange(g.list[0], 0, -1, \"withscores\").map(function(mors, index) {\n      if (!(g.list[0] in weights)) {\n        return mors;\n      }\n      if (index % 2 === 0) {\n        return mors;\n      }\n      return mors * weights[g.list[0]];\n    })).forEach(function(mors, index, union) {\n      if (index % 2 !== 0) {\n        return;\n      }\n      that.zadd(destination, union[index + 1], mors);\n      count += 1;\n    });\n    return cb(callback)(null, count);\n  };\n  redismock2.zscan = function(key2, cursor, callback) {\n    var g = gather(this.zscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"zset\", callback).then(function() {\n      var arr = [];\n      var cnt = 0;\n      cache[zsets][key2].sortScores().scores.some(function(score) {\n        cache[zsets][key2].set[score].some(function(member) {\n          if (cursor <= cnt) {\n            if (typeof match === \"undefined\" || member.match(match)) {\n              arr.push([member, score]);\n            }\n            cursor += 1;\n          }\n          if (arr.length >= count) {\n            return true;\n          }\n          cnt += 1;\n          return false;\n        });\n        if (arr.length >= count) {\n          return true;\n        }\n        return false;\n      });\n      arr = arr.reduce(function(unnested, ms) {\n        return unnested.concat(ms);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.hdel = function(key2, field, callback) {\n    var count = 0;\n    var g = gather(this.hdel).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list.forEach(function(field2) {\n        if (field2 in cache[hashes][key2]) {\n          cache[hashes][key2][field2] = void 0;\n          count += 1;\n        }\n      });\n      if (Object.keys(cache[hashes][key2]).length === 0) {\n        this.del(key2);\n      }\n    }).then(function() {\n      return count;\n    }).end();\n  };\n  redismock2.hexists = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field] !== void 0 ? 1 : 0;\n    }).thennx(function() {\n      return 0;\n    }).end();\n  };\n  redismock2.hget = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return cache[hashes][key2][field];\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.hgetall = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var obj = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        prev[fv[0]] = fv[1];\n        return prev;\n      }, {});\n      return obj;\n    }).thennx(function() {\n      return null;\n    }).end();\n  };\n  redismock2.hgetall_array = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      var arr = Object.keys(cache[hashes][key2]).map(function(field) {\n        return [field, cache[hashes][key2][field]];\n      }).reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hincrby = function(key2, field, increment, callback) {\n    increment = parseInt(increment, 10);\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseInt(this.hget(key2, field), 10);\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not an integer\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock2.hincrbyfloat = function(key2, field, increment, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var no;\n      if (this.hexists(key2, field) === 0) {\n        this.hset(key2, field, increment);\n      } else {\n        no = parseFloat(this.hget(key2, field));\n        if (isNaN(no)) {\n          return new Error(\"ERR hash value is not a valid float\");\n        }\n        this.hset(key2, field, no + increment);\n      }\n      return this.hget(key2, field);\n    }).end();\n  };\n  redismock2.hkeys = function(key2, callback) {\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      return Object.keys(cache[hashes][key2]).filter(function(f) {\n        return cache[hashes][key2][f] !== void 0;\n      });\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hlen = function(key2, callback) {\n    var r = this.hkeys(key2);\n    if (r instanceof Error) {\n      return cb(callback)(r);\n    }\n    return cb(callback)(null, r.length);\n  };\n  redismock2.hmget = function(key2, field, callback) {\n    var g = gather(this.hmget).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      g.list = g.list.slice(1);\n      var arr = g.list.map(function(f) {\n        return cache[hashes][key2][f];\n      });\n      return arr;\n    }).thennx(function() {\n      return [];\n    }).end();\n  };\n  redismock2.hmset = function(key2, field, callback) {\n    var g = gather(this.hmset).apply(this, arguments);\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      cache[hashes][key2] = {};\n    }).then(function() {\n      var that = this;\n      var first = g.list[1];\n      if (g.list.length === 2 && typeof first === \"object\" && !(first instanceof Array)) {\n        Object.keys(first).forEach(function(fv) {\n          that.hset(key2, fv, first[fv]);\n        });\n      } else {\n        g.list = g.list.slice(1);\n        g.list.map(function(fv, index) {\n          if (index % 2 === 0) {\n            return [fv, g.list[index + 1]];\n          }\n          return null;\n        }).filter(function(fv) {\n          return fv !== null;\n        }).forEach(function(fv) {\n          that.hset(key2, fv[0], fv[1]);\n        });\n      }\n      return \"OK\";\n    }).end();\n  };\n  redismock2.hset = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n      } else {\n        ret = 1;\n      }\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      cache[hashes][key2][field] = value;\n      return ret;\n    }).end();\n  };\n  redismock2.hsetnx = function(key2, field, value, callback) {\n    var ret;\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      if (field in cache[hashes][key2] && cache[hashes][key2][field] !== void 0) {\n        ret = 0;\n        return;\n      }\n      ret = 1;\n    }).thennx(function() {\n      ret = 1;\n      cache[hashes][key2] = {};\n    }).then(function() {\n      if (ret === 1) {\n        cache[hashes][key2][field] = value;\n      }\n      return ret;\n    }).end();\n  };\n  redismock2.hstrlen = function(key2, field, callback) {\n    return this.ifType(key2, \"hash\", callback).thennx(function() {\n      return 0;\n    }).thenex(function() {\n      if (!exists(cache[hashes][key2][field])) {\n        return 0;\n      }\n      return cache[hashes][key2][field].toString().length;\n    }).end();\n  };\n  redismock2.hvals = function(key2, callback) {\n    var vals = [];\n    return this.ifType(key2, \"hash\", callback).thenex(function() {\n      vals = Object.keys(cache[hashes][key2]).filter(function(field) {\n        return cache[hashes][key2][field] !== void 0;\n      }).map(function(field) {\n        return cache[hashes][key2][field];\n      });\n    }).then(function() {\n      return vals;\n    }).end();\n  };\n  redismock2.hscan = function(key2, cursor, callback) {\n    var g = gather(this.hscan).apply(this, arguments);\n    var count, match;\n    g.list.forEach(function(option, index) {\n      if (option === \"count\") {\n        count = g.list[index + 1];\n      }\n      if (option === \"match\") {\n        match = new RegExp(translate(g.list[index + 1]));\n      }\n    });\n    if (typeof count === \"undefined\" || isNaN(parseInt(count, 10))) {\n      count = 10;\n    }\n    callback = g.callback;\n    return this.ifType(key2, \"hash\", callback).then(function() {\n      var arr = [];\n      this.hgetall_array(key2).slice(cursor * 2).some(function(forv, index, hgetall) {\n        if (index % 2 !== 0) {\n          return false;\n        }\n        if (typeof match === \"undefined\" || forv.match(match)) {\n          arr.push([forv, hgetall[index + 1]]);\n        }\n        cursor += 1;\n        return arr.length >= count;\n      });\n      arr = arr.reduce(function(prev, fv) {\n        return prev.concat(fv);\n      }, []);\n      if (!arr.length) {\n        cursor = 0;\n      }\n      return [cursor, arr];\n    }).end();\n  };\n  redismock2.on = function(event, callback) {\n    if (!exists(this.listeners)) {\n      this.listeners = {};\n    }\n    if (!exists(this.listeners[event])) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n    return this;\n  };\n  function emit(rm, event) {\n    var g = gather(emit).apply(null, arguments);\n    if (exists(rm.listeners[event])) {\n      rm.listeners[event].forEach(function(cb2) {\n        setImmediate(function() {\n          cb2.apply(rm, g.list.slice(2));\n        });\n      });\n    }\n  }\n  function Subscriber(rm) {\n    this.rm = rm;\n    return this;\n  }\n  Subscriber.prototype.subscribe = function(channel) {\n    this.channel = channel;\n    emit(this.rm, \"subscribe\", channel, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.psubscribe = function(pattern) {\n    this.originalPattern = pattern;\n    this.pattern = new RegExp(translate(pattern));\n    emit(this.rm, \"psubscribe\", pattern, subscribers.length);\n    return this;\n  };\n  Subscriber.prototype.matches = function(channel) {\n    if (exists(this.channel) && this.channel === channel) {\n      return true;\n    }\n    if (exists(this.pattern) && channel.match(this.pattern)) {\n      return true;\n    }\n    return false;\n  };\n  Subscriber.prototype.message = function(channel, message) {\n    if (this.matches(channel)) {\n      if (exists(this.channel)) {\n        emit(this.rm, \"message\", channel, message);\n        return true;\n      } else if (exists(this.pattern)) {\n        emit(this.rm, \"pmessage\", this.originalPattern, channel, message);\n        return true;\n      }\n    }\n    return false;\n  };\n  Subscriber.prototype.unsubscribe = function(count) {\n    if (exists(this.channel)) {\n      emit(this.rm, \"unsubscribe\", this.channel, count);\n    }\n    if (exists(this.pattern)) {\n      emit(this.rm, \"punsubscribe\", this.originalPattern, count);\n    }\n    return this;\n  };\n  redismock2.psubscribe = function(pattern, callback) {\n    var that = this;\n    var g = gather(this.psubscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(pat) {\n      subscribers.push(new Subscriber(that).psubscribe(pat));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.pubsub = function(subcommand, callback) {\n    var g = gather(this.pubsub).apply(this, arguments);\n    var ret = null, pat;\n    if (subcommand === \"channels\") {\n      if (g.list[1]) {\n        pat = new RegExp(translate(g.list[1]));\n      }\n      ret = subscribers.map(function(subscriber) {\n        if (exists(subscriber.channel) && (!pat || subscriber.channel.match(pat))) {\n          return subscriber.channel;\n        }\n        return null;\n      }).filter(function(channel) {\n        return channel !== null;\n      });\n    } else if (subcommand === \"numsub\") {\n      ret = g.list.slice(1).map(function(channel) {\n        return subscribers.reduce(function(count, subscriber) {\n          if (subscriber.channel === channel) {\n            return count + 1;\n          }\n          return count;\n        }, 0);\n      }).reduce(function(flattened, cc) {\n        return flattened.concat(cc);\n      }, []);\n    } else if (subcommand === \"numpat\") {\n      ret = subscribers.reduce(function(count, subscriber) {\n        if (exists(subscriber.pattern)) {\n          return count + 1;\n        }\n        return count;\n      }, 0);\n    }\n    callback = g.callback;\n    return cb(callback)(null, ret);\n  };\n  redismock2.publish = function(channel, message, callback) {\n    var count = subscribers.reduce(function(cnt, subscriber) {\n      if (subscriber.message(channel.toString(), message.toString())) {\n        return cnt + 1;\n      }\n      return cnt;\n    }, 0);\n    return cb(callback)(null, count);\n  };\n  redismock2.punsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.punsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.pattern)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.pattern);\n      });\n    } else {\n      g.list.forEach(function(pattern) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.originalPattern === pattern) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.subscribe = function(channel, callback) {\n    var that = this;\n    var g = gather(this.subscribe).apply(this, arguments);\n    callback = g.callback;\n    g.list.forEach(function(chan) {\n      subscribers.push(new Subscriber(that).subscribe(chan));\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.unsubscribe = function(callback) {\n    var that = this;\n    var g = gather(this.unsubscribe).apply(this, arguments);\n    var newCount = subscribers.length;\n    callback = g.callback;\n    if (!g.list.length) {\n      subscribers = subscribers.filter(function(subscriber) {\n        if (subscriber.rm !== that) {\n          return true;\n        }\n        if (exists(subscriber.channel)) {\n          newCount -= 1;\n          subscriber.unsubscribe(newCount);\n        }\n        return !exists(subscriber.channel);\n      });\n    } else {\n      g.list.forEach(function(chan) {\n        subscribers = subscribers.filter(function(subscriber) {\n          if (subscriber.rm !== that) {\n            return true;\n          }\n          if (subscriber.channel === chan) {\n            newCount -= 1;\n            subscriber.unsubscribe(newCount);\n          }\n          return subscriber.channel !== chan;\n        });\n      });\n    }\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.discard = function(callback) {\n    return cb(callback)(new Error(\"ERR DISCARD without MULTI\"));\n  };\n  redismock2.multi = function(commands) {\n    var rc = {};\n    var that = this;\n    var toApply = [], replies = [];\n    if (exists(commands)) {\n      toApply = toApply.concat(commands.map(function(command) {\n        var args = command.slice(1);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        return [command[0], that[command[0]], that, args];\n      }));\n    }\n    Object.keys(this).forEach(function(key2) {\n      rc[key2] = function() {\n        var args = Array.prototype.slice.call(arguments);\n        args.push(function(error, reply) {\n          if (error) {\n            replies.push(error.message);\n          } else {\n            replies.push(reply);\n          }\n        });\n        toApply.push([key2, that[key2], that, args]);\n        return this;\n      };\n    });\n    rc.exec = function(callback) {\n      if (toApply.some(function(apply) {\n        var check = apply[3][0];\n        if (exists(watchers[check]) && watchers[check].modified && watchers[check].watchers.indexOf(that) !== -1) {\n          return true;\n        }\n        return false;\n      })) {\n        that.unwatch();\n        return cb(callback)(null, null);\n      }\n      toApply.forEach(function(apply) {\n        apply[1].apply(apply[2], apply[3]);\n      });\n      that.unwatch();\n      return cb(callback)(null, replies);\n    };\n    rc.discard = function(callback) {\n      toApply = [];\n      that.unwatch();\n      return cb(callback)(null, \"OK\");\n    };\n    return rc;\n  };\n  redismock2.unwatch = function(callback) {\n    var that = this;\n    Object.keys(watchers).forEach(function(k) {\n      if (exists(watchers[k])) {\n        watchers[k].watchers = watchers[k].watchers.filter(function(mock) {\n          return that !== mock;\n        });\n        if (watchers[k].watchers.length === 0) {\n          watchers[k] = void 0;\n        }\n      }\n    });\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.watch = function(key2, callback) {\n    if (!exists(watchers[key2])) {\n      watchers[key2] = {\n        modified: false,\n        watchers: []\n      };\n    }\n    watchers[key2].watchers.push(this);\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.eval = function(script, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.evalsha = function(sha1, numkeys, key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_exists = function(script, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_flush = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.script_load = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.auth = function(password, callback) {\n    if (!redismock2.password) {\n      return cb(callback)(new Error(\"ERR Client sent AUTH, but no password is set\"));\n    }\n    if (password === redismock2.password) {\n      return cb(callback)(null, \"OK\");\n    }\n    return cb(callback)(new Error(\"ERR invalid password\"));\n  };\n  redismock2.echo = function(message, callback) {\n    return cb(callback)(null, message);\n  };\n  redismock2.ping = function(callback) {\n    return cb(callback)(null, \"PONG\");\n  };\n  redismock2.quit = function(callback) {\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.select = function(index, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.createClient = function() {\n    return redismock2.copy();\n  };\n  redismock2.bgrewriteaof = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.bgsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_kill = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_list = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_getname = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_pause = function(timeout, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.client_setname = function(connection_name, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.cluster_slots = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_count = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_getkeys = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.command_info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_get = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_rewrite = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_set = function(parameter, value, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.config_resetstat = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.dbsize = function(callback) {\n    var count = 0, key2;\n    for (key2 in cache) {\n      if (key2 === sets || key2 === zsets || key2 === hashes) {\n        continue;\n      }\n      if (cache.hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[sets]) {\n      if (cache[sets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[zsets]) {\n      if (cache[zsets].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    for (key2 in cache[hashes]) {\n      if (cache[hashes].hasOwnProperty(key2)) {\n        count += 1;\n      }\n    }\n    return cb(callback)(null, count);\n  };\n  redismock2.debug_object = function(key2, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.debug_segfault = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.flushall = function(callback) {\n    return this.flushdb(callback);\n  };\n  redismock2.flushdb = function(callback) {\n    cache = {};\n    cache[sets] = {};\n    cache[zsets] = {};\n    cache[hashes] = {};\n    Object.keys(timeouts).forEach(function(key2) {\n      if (timeouts[key2]) {\n        clearTimeout(timeouts[key2].timeout);\n      }\n    });\n    timeouts = {};\n    return cb(callback)(null, \"OK\");\n  };\n  redismock2.info = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.lastsave = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.monitor = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.role = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.save = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.shutdown = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.slaveof = function(host, port, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.slowlog = function(subcommand, callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.sync = function(callback) {\n    return cb(callback)(new Error(\"UNIMPLEMENTED\"));\n  };\n  redismock2.time = function(callback) {\n    var now = /* @__PURE__ */ new Date();\n    var epoch = now.getTime();\n    var us;\n    if (root.performance) {\n      if (root.performance.now) {\n        now = root.performance.now();\n        us = (now - Math.floor(now)) * 1e5;\n      } else if (root.performance.webkitNow) {\n        now = root.performance.webkitNow();\n        us = (now - Math.floor(now)) * 1e5;\n      } else {\n        us = 0;\n      }\n    } else if (typeof process !== \"undefined\" && process.hrtime) {\n      us = process.hrtime()[1] / 1e3;\n    } else {\n      us = 0;\n    }\n    return cb(callback)(null, [epoch, us]);\n  };\n  var modifiers = [\"del\", \"mset\", \"msetnx\", \"psetex\", \"set\", \"setbit\", \"setex\", \"setrange\", \"incr\", \"decr\", \"incrby\", \"decrby\", \"incrbyfloat\", \"blpop\", \"brpop\", \"brpoplpush\", \"linsert\", \"lpush\", \"lpushx\", \"rpush\", \"rpushx\", \"lpop\", \"rpop\", \"rpoplpush\", \"ltrim\", \"lset\", \"lrem\", \"sadd\", \"smove\", \"spop\", \"sdiffstore\", \"sinterstore\", \"srem\", \"sunionstore\", \"zadd\", \"zrem\", \"zunionstore\", \"zinterstore\", \"zincrby\", \"zremrangebylex\", \"zremrangebyrank\", \"zremrangebyscore\", \"hdel\", \"hincrby\", \"hincrbyfloat\", \"hset\", \"hmset\", \"hsetnx\"];\n  var capture = {};\n  var fkeys = [];\n  for (var key in redismock2) {\n    if (typeof redismock2[key] === \"function\") {\n      fkeys.push(key);\n      capture[key] = redismock2[key];\n    }\n  }\n  fkeys.forEach(function(key2) {\n    redismock2[key2] = function() {\n      if (arguments.length < capture[key2].length - 1) {\n        return cb(arguments[arguments.length - 1])(new Error(\"ERR wrong number of arguments for '\" + key2 + \"' command\"));\n      }\n      return capture[key2].apply(this, arguments);\n    };\n  });\n  modifiers.forEach(function(modifier) {\n    var mod = redismock2[modifier];\n    redismock2[modifier] = function() {\n      var key2 = arguments[0];\n      if (exists(watchers[key2])) {\n        watchers[key2].modified = true;\n      }\n      return mod.apply(this, arguments);\n    };\n  });\n  function toPromise(f, context, deferFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments);\n      var deferred = deferFactory(), promise;\n      var callback;\n      while (args.length < f.length - 1) {\n        args.push(void 0);\n      }\n      if (typeof args[args.length - 1] === \"function\") {\n        callback = args[args.length - 1];\n        args.pop();\n      }\n      args.push(function(err, reply) {\n        if (err) {\n          if (callback && typeof callback === \"function\") {\n            callback(err);\n          }\n          return deferred.reject(err);\n        }\n        if (callback && typeof callback === \"function\") {\n          callback(null, reply);\n        }\n        deferred.resolve(reply);\n      });\n      f.apply(context, args);\n      promise = deferred.promise;\n      if (typeof promise === \"function\") {\n        promise = promise();\n      }\n      return promise;\n    };\n  }\n  redismock2.toPromiseStyle = function(deferFactory) {\n    var that = this;\n    return Object.keys(this).filter(function(key2) {\n      return typeof that[key2] === \"function\" && key2 !== \"multi\";\n    }).map(function(key2) {\n      return [key2, toPromise(that[key2], that, deferFactory)];\n    }).reduce(function(promised, f) {\n      promised[f[0]] = f[1];\n      return promised;\n    }, { multi: this.multi });\n  };\n  redismock2.copy = function() {\n    var copied = {};\n    fkeys.forEach(function(key2) {\n      copied[key2] = function() {\n        return redismock2[key2].apply(copied, arguments);\n      };\n    });\n    copied.toPromiseStyle = redismock2.toPromiseStyle;\n    copied.listeners = {};\n    return copied;\n  };\n  redismock2.unref = function() {\n  };\n  if (typeof process !== \"undefined\" && process.env.REDIS_JS_TO_NODE_REDIS === \"1\") {\n    var asNodeRedis;\n    var node_redis_args = [];\n    if (process.env.REDIS_JS_NODE_REDIS_PORT) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_PORT);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_HOST) {\n      node_redis_args.push(process.env.REDIS_JS_NODE_REDIS_HOST);\n    }\n    if (process.env.REDIS_JS_NODE_REDIS_OPTIONS) {\n      node_redis_args.push(JSON.parse(process.env.REDIS_JS_NODE_REDIS_OPTIONS));\n    }\n  }\n}).call(void 0);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redismock);\n\n\n//# sourceURL=webpack://hypha-core/./src/utils/redis-mock.js?");

/***/ }),

/***/ "./src/workspace.js":
/*!**************************!*\
  !*** ./src/workspace.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Workspace: () => (/* binding */ Workspace)\n/* harmony export */ });\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/index.js */ \"./src/utils/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hypha-rpc */ \"./node_modules/hypha-rpc/index.js\");\n/* harmony import */ var hypha_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hypha_rpc__WEBPACK_IMPORTED_MODULE_1__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\nconst _allowedCharacters = /^[a-zA-Z0-9-_/*]*$/;\nfunction validateKeyPart(keyPart) {\n  if (!_allowedCharacters.test(keyPart)) {\n    throw new Error(`Invalid characters in query part: ${keyPart}`);\n  }\n}\nfunction base64UrlEncode(data) {\n  const base64 = btoa(\n    typeof data === \"string\" ? data : String.fromCharCode(...new Uint8Array(data))\n  );\n  return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlDecode(base64Url) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  return atob(base64);\n}\nasync function hmacSha256(key, data) {\n  const encoder = new TextEncoder();\n  const keyData = encoder.encode(key);\n  const msgData = encoder.encode(data);\n  const cryptoKey = await crypto.subtle.importKey(\n    \"raw\",\n    keyData,\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"]\n  );\n  const signature = await crypto.subtle.sign(\"HMAC\", cryptoKey, msgData);\n  return new Uint8Array(signature);\n}\nasync function generateJWT(payload, secret) {\n  const header = {\n    alg: \"HS256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64UrlEncode(JSON.stringify(header));\n  const encodedPayload = base64UrlEncode(JSON.stringify(payload));\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  const signature = await hmacSha256(secret, unsigned);\n  const encodedSignature = base64UrlEncode(signature);\n  return `${unsigned}.${encodedSignature}`;\n}\nasync function verifyJWT(token, secret) {\n  const parts = token.split(\".\");\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid JWT format\");\n  }\n  const [encodedHeader, encodedPayload, encodedSignature] = parts;\n  const unsigned = `${encodedHeader}.${encodedPayload}`;\n  try {\n    const header = JSON.parse(base64UrlDecode(encodedHeader));\n    if (header.alg !== \"HS256\") {\n      throw new Error(\"Unsupported algorithm\");\n    }\n    const expectedSignature = await hmacSha256(secret, unsigned);\n    const actualSignature = new Uint8Array(\n      Array.from(base64UrlDecode(encodedSignature)).map((c) => c.charCodeAt(0))\n    );\n    if (expectedSignature.length !== actualSignature.length) {\n      throw new Error(\"Invalid signature\");\n    }\n    for (let i = 0; i < expectedSignature.length; i++) {\n      if (expectedSignature[i] !== actualSignature[i]) {\n        throw new Error(\"Invalid signature\");\n      }\n    }\n    const payload = JSON.parse(base64UrlDecode(encodedPayload));\n    if (payload.exp && Date.now() / 1e3 > payload.exp) {\n      throw new Error(\"Token expired\");\n    }\n    return payload;\n  } catch (error) {\n    throw new Error(`JWT verification failed: ${error.message}`);\n  }\n}\nclass Workspace {\n  constructor(hyphaCore) {\n    this._server = hyphaCore;\n    this._redis = hyphaCore.redis;\n    this.connections = hyphaCore.connections;\n    this.eventBus = hyphaCore;\n    this.serverUrl = hyphaCore.url;\n    this.baseUrl = hyphaCore.baseUrl;\n    this._rpc = null;\n    this._localServices = /* @__PURE__ */ new Map();\n  }\n  waitForClient(cid, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        const ccid = info.id.split(\":\")[0];\n        if (ccid !== cid) {\n          return;\n        }\n        this.eventBus.off(\"service_added\", handler);\n        if (info.type === \"imjoy\") {\n          clearTimeout(timeoutId);\n          resolve(info);\n          return;\n        } else {\n          if (!info.id.endsWith(\":default\")) {\n            logger.error(\"Unexpected service added:\", info);\n            return;\n          }\n          const defaultService = info;\n          clearTimeout(timeoutId);\n          this._rpc.get_remote_service(defaultService.id).then(async (svc) => {\n            try {\n              await this.eventBus.emit(\"client_ready\", svc);\n              resolve(svc);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        }\n      };\n      let timeoutId = setTimeout(() => {\n        this.eventBus.off(\"service_added\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"service_added\", handler);\n    });\n  }\n  async setup(config) {\n    if (!config.client_id) {\n      throw new Error(\"client_id is required in the config\");\n    }\n    const workspace = \"*\";\n    const connection = new _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.RedisRPCConnection(\n      this.eventBus,\n      workspace,\n      config.client_id,\n      null,\n      null\n    );\n    this.windows = [];\n    this.services = {};\n    this.plugins = {};\n    this.eventBus.on(\"client_ready\", async (svc) => {\n      this.plugins[svc.id] = svc;\n    });\n    const rpc = new hypha_rpc__WEBPACK_IMPORTED_MODULE_1__.hyphaWebsocketClient.RPC(connection, {\n      client_id: config.client_id,\n      default_context: { connection_type: \"websocket\" },\n      workspace,\n      server_base_url: this.serverUrl,\n      silent: false\n    });\n    this._rpc = rpc;\n    const defaultServices = this.getDefaultService();\n    await rpc.register_service(Object.assign(defaultServices, config.default_service || {}), { notify: false });\n  }\n  async registerService(service, context) {\n    const ws = context.ws;\n    const clientId = context.from;\n    const userInfo = context.user;\n    service.config = service.config || {};\n    service.config.workspace = ws;\n    const originalServiceId = service.id;\n    let simpleServiceId = originalServiceId;\n    let isAlreadyConstructed = false;\n    if (originalServiceId.includes(\"/\") && originalServiceId.includes(\":\")) {\n      const parts = originalServiceId.split(\"/\");\n      if (parts.length === 2 && parts[1].includes(\":\")) {\n        isAlreadyConstructed = true;\n        simpleServiceId = parts[1];\n      }\n    }\n    const isBuiltInService = simpleServiceId.includes(\":built-in\") || simpleServiceId === \"built-in\";\n    const isLegitimateDefaultService = simpleServiceId === \"default\" || simpleServiceId.endsWith(\":default\") && clientId.endsWith(\"/\" + simpleServiceId.split(\":\")[0]);\n    if (ws === \"default\" && !clientId.endsWith(\"/root\") && !isBuiltInService && !isLegitimateDefaultService) {\n      throw new Error(`Access denied: Only root user can register services in '${ws}' workspace. Current client: ${clientId}`);\n    }\n    if (!isAlreadyConstructed) {\n      if (!service.id.includes(\":\")) {\n        service.id = `${clientId.split(\"/\")[1]}:${service.id}`;\n      }\n      if (service.id.includes(\"/\")) {\n        throw new Error(\"Service id must not contain '/'\");\n      }\n      service.id = `${ws}/${service.id}`;\n    }\n    service.app_id = service.app_id || \"*\";\n    service.config.visibility = service.config.visibility || \"protected\";\n    const isLocalService = this._hasServiceFunctions(service);\n    if (isLocalService) {\n      const localServiceKey = `${service.id}@${service.app_id}`;\n      this._localServices.set(localServiceKey, service);\n      console.info(`Storing local service: ${localServiceKey}`);\n    }\n    const serviceExists = this._redis.exists(`services:*:${service.id}@${service.app_id}`);\n    const key = `services:${service.config.visibility}:${service.id}@${service.app_id}`;\n    const serviceMetadata = {};\n    for (const [k, v] of Object.entries(service)) {\n      if (isLocalService && typeof v === \"function\") {\n        serviceMetadata[k] = { type: \"function\", name: v.name || k };\n      } else if (isLocalService && typeof v === \"object\" && v !== null && !Array.isArray(v)) {\n        const objMetadata = {};\n        for (const [subK, subV] of Object.entries(v)) {\n          if (typeof subV === \"function\") {\n            objMetadata[subK] = { type: \"function\", name: subV.name || subK };\n          } else {\n            objMetadata[subK] = subV;\n          }\n        }\n        serviceMetadata[k] = objMetadata;\n      } else {\n        serviceMetadata[k] = v;\n      }\n    }\n    for (const [k, v] of Object.entries(serviceMetadata)) {\n      this._redis.hset(key, k, v);\n    }\n    if (serviceExists) {\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_updated\", { id: clientId, workspace: ws });\n        console.info(`Updating built-in service: ${service.id}`);\n      } else {\n        this.eventBus.emit(\"service_updated\", service);\n        console.info(`Updating service: ${service.id}`);\n      }\n    } else {\n      if (key.includes(\":default@\")) {\n        if (isLocalService && service.setup) {\n          setTimeout(async () => {\n            try {\n              await service.setup();\n              console.debug(`\\u2705 Local setup completed for service \\`${clientId}\\``);\n            } catch (e) {\n              console.error(`Failed to run setup for local default service \\`${clientId}\\`: ${e}`);\n            }\n          }, 10);\n        } else if (!isLocalService && this._shouldAttemptRpcSetup(clientId, service)) {\n          this._setupServiceWithRetry(clientId, 3);\n        }\n      }\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_connected\", { id: clientId, workspace: ws });\n        console.info(`Adding built-in service: ${service.id}, key: ${key}`);\n      } else {\n        this.eventBus.emit(\"service_added\", service);\n        console.info(`Adding service ${service.id}, key: ${key}`);\n      }\n    }\n    return service;\n  }\n  /**\n   * Determine if we should attempt RPC setup for a service\n   */\n  _shouldAttemptRpcSetup(clientId, service) {\n    const clientPart = clientId.includes(\"/\") ? clientId.split(\"/\")[1] : clientId;\n    if (clientPart.startsWith(\"client-\")) {\n      return false;\n    }\n    if (service.config && service.config.no_setup) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Check if a service object contains function properties (indicating it's a local service)\n   */\n  _hasServiceFunctions(service) {\n    for (const [key, value] of Object.entries(service)) {\n      if ([\"id\", \"name\", \"description\", \"config\", \"app_id\"].includes(key)) {\n        continue;\n      }\n      if (typeof value === \"function\") {\n        return true;\n      }\n      if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        if (value._rintf) {\n          continue;\n        }\n        for (const subValue of Object.values(value)) {\n          if (typeof subValue === \"function\") {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Setup service with retry mechanism to handle timing issues\n   */\n  async _setupServiceWithRetry(clientId, maxRetries = 3) {\n    const clientPart = clientId.includes(\"/\") ? clientId.split(\"/\")[1] : clientId;\n    setTimeout(async () => {\n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n          const delay = 100 * Math.pow(4, attempt - 1);\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          if (this._rpc) {\n            const svc = await this._rpc.get_remote_service(`${clientPart}:default`, 5);\n            if (svc && svc.setup) {\n              await svc.setup();\n              console.debug(`\\u2705 Setup completed for default service \\`${clientId}\\``);\n              return;\n            }\n          }\n        } catch (e) {\n          if (attempt === maxRetries) {\n            console.debug(`Setup not available for default service \\`${clientId}\\` (this is normal for local services)`);\n          } else {\n            continue;\n          }\n        }\n      }\n    }, 50);\n  }\n  async unregisterService(serviceId, context) {\n    const ws = context.ws;\n    if (!serviceId.includes(\"/\")) {\n      serviceId = `${ws}/${serviceId}`;\n    }\n    if (!serviceId.includes(\":\")) {\n      throw new Error(\"Service id info must contain ':'\");\n    }\n    if (!serviceId.includes(\"@\")) {\n      serviceId = serviceId + \"@*\";\n    }\n    if (this._localServices.has(serviceId)) {\n      this._localServices.delete(serviceId);\n      console.info(`Removed local service: ${serviceId}`);\n    }\n    const key = `services:*:${serviceId}`;\n    console.info(`Removing service: ${key}`);\n    const serviceExists = this._redis.exists(key);\n    if (serviceExists) {\n      this._redis.delete(key);\n      if (key.includes(\":built-in@\")) {\n        this.eventBus.emit(\"client_disconnected\", { id: context.from, workspace: ws });\n      } else {\n        this.eventBus.emit(\"service_removed\", { id: serviceId });\n      }\n    } else {\n      console.warning(`Service ${key} does not exist and cannot be removed.`);\n    }\n  }\n  async getService(query, { mode = \"default\", skipTimeout = false, timeout = 5 }, context) {\n    const ws = context.ws;\n    const userInfo = context.user;\n    let serviceId;\n    if (typeof query === \"string\") {\n      serviceId = query;\n      query = { id: serviceId };\n    } else {\n      if (!query.id) {\n        serviceId = query.service_id || \"*\";\n      } else {\n        serviceId = query.id;\n      }\n    }\n    if (typeof serviceId !== \"string\") {\n      throw new Error(\"Service ID must be a string\");\n    }\n    if ((serviceId.match(/\\//g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one '/'\");\n    }\n    if ((serviceId.match(/:/g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one ':'\");\n    }\n    if ((serviceId.match(/@/g) || []).length > 1) {\n      throw new Error(\"Service id must contain at most one '@'\");\n    }\n    if (serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n      serviceId += \":default\";\n      query.workspace = serviceId.split(\"/\")[0];\n      if (query.client_id && query.client_id !== serviceId.split(\"/\")[1]) {\n        throw new Error(`client_id (${query.client_id}) does not match service_id (${serviceId})`);\n      }\n      query.client_id = serviceId.split(\"/\")[1];\n    } else if (!serviceId.includes(\"/\") && !serviceId.includes(\":\")) {\n      const workspace = query.workspace || ws;\n      serviceId = `${workspace}/*:${serviceId}`;\n      query.workspace = workspace;\n      query.client_id = \"*\";\n    } else if (!serviceId.includes(\"/\") && serviceId.includes(\":\")) {\n      const workspace = query.workspace || ws;\n      query.client_id = serviceId.split(\":\")[0];\n      serviceId = `${workspace}/${serviceId}`;\n      query.workspace = workspace;\n    } else {\n      const workspace = serviceId.split(\"/\")[0];\n      query.client_id = serviceId.split(\"/\")[1].split(\":\")[0];\n      query.workspace = workspace;\n      if (!serviceId.includes(\"*\")) {\n        const localServiceKey = `${serviceId}@*`;\n        if (this._localServices.has(localServiceKey)) {\n          console.info(`Found local service (direct): ${localServiceKey}`);\n          const localService = this._localServices.get(localServiceKey);\n          return this.patchServiceConfig(workspace, localService);\n        }\n        if (this._rpc) {\n          const serviceApi = await this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        }\n        return null;\n      }\n    }\n    let appId = \"*\";\n    if (serviceId.includes(\"@\")) {\n      [serviceId, appId] = serviceId.split(\"@\");\n      if (query.app_id && query.app_id !== appId) {\n        throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n      }\n    }\n    query.app_id = query.app_id || appId;\n    query.service_id = serviceId.split(\"/\")[1].split(\":\")[1];\n    const originalVisibility = query.visibility || \"*\";\n    let visibility;\n    if (query.workspace === \"*\") {\n      visibility = \"public\";\n    } else {\n      visibility = \"*\";\n    }\n    const pattern = `services:${visibility}:${query.workspace}/${query.client_id}:${query.service_id}@${query.app_id}`;\n    if (!pattern.startsWith(\"services:\")) {\n      throw new Error(\"Query pattern does not start with 'services:'.\");\n    }\n    if (pattern.includes(\"{\") || pattern.includes(\"}\")) {\n      throw new Error(\"Query pattern contains invalid characters.\");\n    }\n    const keys = this._redis.keys(pattern);\n    if (query.workspace === \"*\") {\n      const wsPattern = `services:${originalVisibility}:${ws}/${query.client_id}:${query.service_id}@${query.app_id}`;\n      keys.push(...this._redis.keys(wsPattern));\n    }\n    console.debug(\"Found service keys:\", keys);\n    const withinWorkspaceKeys = [];\n    const outsideWorkspaceKeys = [];\n    keys.forEach((key) => {\n      const keyWorkspace = key.split(\"/\")[1];\n      if (keyWorkspace === ws) {\n        withinWorkspaceKeys.push(key);\n      } else {\n        outsideWorkspaceKeys.push(key);\n      }\n    });\n    if (mode === \"random\") {\n      withinWorkspaceKeys.sort(() => Math.random() - 0.5);\n      outsideWorkspaceKeys.sort(() => Math.random() - 0.5);\n    } else {\n      withinWorkspaceKeys.sort();\n      outsideWorkspaceKeys.sort();\n    }\n    const sortedKeys = [...withinWorkspaceKeys, ...outsideWorkspaceKeys];\n    for (const key of sortedKeys) {\n      try {\n        const parts = key.split(\":\");\n        serviceId = parts[2] + \":\" + parts[3];\n        [serviceId, appId] = serviceId.split(\"@\");\n        const workspace = serviceId.split(\"/\")[0];\n        const localServiceKey = `${serviceId}@${appId}`;\n        if (this._localServices.has(localServiceKey)) {\n          const localService = this._localServices.get(localServiceKey);\n          return this.patchServiceConfig(workspace, localService);\n        }\n        if (this._rpc) {\n          const serviceApi = await this._rpc.get_remote_service(serviceId, timeout);\n          if (serviceApi) {\n            return this.patchServiceConfig(workspace, serviceApi);\n          }\n        }\n      } catch (e) {\n        if (skipTimeout && e instanceof TimeoutError) {\n          console.warning(`Timeout while getting service ${serviceId}, skipping to the next one.`);\n          continue;\n        } else {\n          throw new Error(`Timeout while getting service ${serviceId}`);\n        }\n      }\n    }\n    if (query.app_id && query.app_id !== \"*\") {\n      const serviceApi = await this._launch_application_for_service(query, context);\n      return serviceApi;\n    }\n    return null;\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    return serviceApi;\n  }\n  async listServices(query, context) {\n    if (!context) {\n      throw new Error(\"context is required\");\n    }\n    const cws = context.ws;\n    const userInfo = context.user;\n    if (!query) {\n      query = {\n        visibility: \"*\",\n        workspace: cws,\n        client_id: \"*\",\n        service_id: \"*\"\n      };\n    } else if (typeof query === \"string\") {\n      let visibility2 = \"*\";\n      let workspace2 = \"*\";\n      let clientId2 = \"*\";\n      let serviceId2 = \"*\";\n      if (query.includes(\"/\") && query.includes(\":\")) {\n        const [workspacePart, remaining] = query.split(\"/\");\n        const [clientPart, servicePart] = remaining.split(\":\");\n        workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n        clientId2 = clientPart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else if (query.includes(\":\")) {\n        const [clientPart, servicePart] = query.split(\":\");\n        clientId2 = clientPart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else if (query.includes(\"/\")) {\n        const [workspacePart, servicePart] = query.split(\"/\");\n        workspace2 = workspacePart === \"*\" ? \"public\" : workspacePart;\n        serviceId2 = servicePart || \"*\";\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      } else {\n        workspace2 = query;\n        query = { visibility: visibility2, workspace: workspace2, client_id: clientId2, service_id: serviceId2 };\n      }\n    } else {\n      if (query.id) {\n        if (query.service_id) {\n          throw new Error(\"Cannot specify both 'id' and 'service_id' in the query.\");\n        }\n        query.service_id = query.id;\n        delete query.id;\n      }\n    }\n    const originalVisibility = query.visibility || \"*\";\n    const workspace = query.workspace || \"*\";\n    if (workspace === \"*\") {\n      if (originalVisibility === \"protected\") {\n        throw new Error(\"Cannot list protected services in all workspaces.\");\n      }\n      query.visibility = \"public\";\n    } else if (workspace !== \"public\" && workspace !== cws) {\n    }\n    const visibility = query.visibility || \"*\";\n    const clientId = query.client_id || \"*\";\n    const serviceId = query.service_id || \"*\";\n    const typeFilter = query.type || null;\n    let appId = \"*\";\n    if (serviceId.includes(\"@\")) {\n      [serviceId, appId] = serviceId.split(\"@\");\n      if (query.app_id && query.app_id !== appId) {\n        throw new Error(`App id mismatch: ${query.app_id} != ${appId}`);\n      }\n    }\n    appId = query.app_id || appId;\n    const allowedKeys = [\"visibility\", \"workspace\", \"client_id\", \"service_id\", \"type\", \"app_id\"];\n    if (Object.keys(query).some((key) => !allowedKeys.includes(key))) {\n      console.error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n      throw new Error(`Invalid query keys: ${Object.keys(query).filter((key) => !allowedKeys.includes(key))}`);\n    }\n    validateKeyPart(visibility);\n    validateKeyPart(workspace);\n    validateKeyPart(clientId);\n    validateKeyPart(serviceId);\n    validateKeyPart(appId);\n    const pattern = `services:${visibility}:${workspace}/${clientId}:${serviceId}@${appId}`;\n    if (!pattern.startsWith(\"services:\")) {\n      throw new Error(\"Query pattern does not start with 'services:'.\");\n    }\n    console.log(\"Listing services using pattern:\", pattern);\n    const keys = this._redis.keys(pattern);\n    if (workspace === \"*\") {\n      const wsPattern = `services:${originalVisibility}:${cws}/${clientId}:${serviceId}@${appId}`;\n      keys.push(...this._redis.keys(wsPattern));\n      console.log(\"Listing more services using pattern:\", wsPattern);\n    }\n    const services = [];\n    for (const key of new Set(keys)) {\n      const serviceData = this._redis.hgetall(key);\n      const convertedServiceData = {};\n      for (const [k, v] of Object.entries(serviceData)) {\n        const keyStr = k;\n        let valueStr = v;\n        if (typeof valueStr === \"string\" && (valueStr.startsWith(\"{\") && valueStr.endsWith(\"}\") || valueStr.startsWith(\"[\") && valueStr.endsWith(\"]\"))) {\n          valueStr = JSON.parse(valueStr);\n        }\n        convertedServiceData[keyStr] = valueStr;\n      }\n      if (typeFilter) {\n        if (convertedServiceData.type === typeFilter) {\n          services.push(convertedServiceData);\n        }\n      } else {\n        services.push(convertedServiceData);\n      }\n    }\n    return services;\n  }\n  patchServiceConfig(workspace, serviceApi) {\n    serviceApi.config = serviceApi.config || {};\n    serviceApi.config.workspace = workspace;\n    return serviceApi;\n  }\n  async createWindow(config, extra_config, context) {\n    _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.requireBrowser(\"Window/iframe creation\");\n    let elem;\n    const ws = context.ws;\n    const clientId = \"client-\" + Date.now();\n    this.connections[ws + \"/\" + clientId] = {\n      id: ws + \"/\" + clientId,\n      workspace: ws,\n      user: context.user,\n      // Store user info for nested app creation\n      websocket: null,\n      postMessage: (data) => {\n        _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.safePostMessage(elem.contentWindow, data);\n      }\n    };\n    let authToken = context.token;\n    if (!authToken) {\n      try {\n        authToken = await this.getDefaultService().generate_token({\n          workspace: ws,\n          client_id: clientId,\n          user_id: context.user?.id || \"anonymous\",\n          email: context.user?.email || \"\",\n          roles: context.user?.roles || [],\n          scopes: context.user?.scopes || [],\n          expires_in: 3600\n          // 1 hour\n        }, context);\n      } catch (error) {\n        console.warn(\"Failed to generate auth token for iframe:\", error);\n      }\n    }\n    const authParams = new URLSearchParams();\n    authParams.set(\"client_id\", clientId);\n    authParams.set(\"workspace\", ws);\n    authParams.set(\"server_url\", this.serverUrl);\n    if (authToken) {\n      authParams.set(\"token\", authToken);\n    }\n    if (context.user) {\n      authParams.set(\"user_info\", JSON.stringify(context.user));\n    }\n    const authHash = `#${authParams.toString()}`;\n    if (config.type === \"iframe\") {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"iframe creation requires browser environment with document API\");\n      }\n      elem = document.createElement(\"iframe\");\n      elem.src = config.src + authHash;\n      elem.id = config.window_id || \"window-\" + Date.now();\n      elem.style.width = config.width || \"100%\";\n      elem.style.height = config.height || \"100%\";\n      elem.style.display = \"none\";\n      document.body.appendChild(elem);\n    } else if (config.window_id) {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"Window element access requires browser environment with document API\");\n      }\n      let count = 0;\n      while (!document.getElementById(config.window_id) && count < 9) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        count++;\n      }\n      elem = document.getElementById(config.window_id);\n      if (!elem) {\n        throw new Error(\"Window element not found: \" + config.window_id);\n      }\n    } else {\n      config.window_id = \"window-\" + Date.now();\n      config.workspace = ws;\n      await this.eventBus.emit(\"add_window\", config);\n      await new Promise((resolve) => setTimeout(resolve, 0));\n      let count = 0;\n      while (!document.getElementById(config.window_id) && count < 9) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        count++;\n      }\n      elem = document.getElementById(config.window_id);\n      if (!elem) {\n        throw new Error(`iframe element not found ${config.window_id} in ${9 * 500 / 1e3} s`);\n      }\n    }\n    if (elem.tagName !== \"IFRAME\") {\n      if (typeof document === \"undefined\") {\n        throw new Error(\"iframe creation requires browser environment with document API\");\n      }\n      const iframe = document.createElement(\"iframe\");\n      iframe.style.width = config.width || \"100%\";\n      iframe.style.height = config.height || \"100%\";\n      iframe.src = config.src + authHash;\n      elem.appendChild(iframe);\n      elem = iframe;\n    }\n    this.connections[ws + \"/\" + clientId].source = elem.contentWindow;\n    let waitClientPromise;\n    if (!config.passive) {\n      waitClientPromise = this.waitForClient(ws + \"/\" + clientId, 18e4);\n    }\n    await new Promise((resolve, reject) => {\n      elem.onload = resolve;\n      elem.onerror = reject;\n    });\n    if (config.passive) {\n      delete this.connections[ws + \"/\" + clientId];\n      return;\n    }\n    _utils_index_js__WEBPACK_IMPORTED_MODULE_0__.Environment.safePostMessage(elem.contentWindow, {\n      type: \"initializeHyphaClient\",\n      server_url: this.serverUrl,\n      client_id: clientId,\n      workspace: ws,\n      token: authToken || null,\n      user_info: context.user || null,\n      config\n    });\n    const svc = await waitClientPromise;\n    if (svc.run && config) {\n      await svc.run({ data: config.data, config: config.config });\n    }\n    this.windows.push({ id: config.window_id, name: config.name || config.src, service: svc });\n    return svc;\n  }\n  async getWindow(config, context) {\n    if (typeof config === \"string\") {\n      return this.windows.find((w) => w.name === config);\n    } else if (config.id) {\n      return this.windows.find((w) => w.id === config.id);\n    } else if (config.name) {\n      return this.windows.find((w) => w.name === config.name);\n    }\n    return void 0;\n  }\n  async loadApp(config, extra_config, context) {\n    let code;\n    const ws = context.ws;\n    const src = config.src;\n    if (src.startsWith(\"http\") && !src.split(\"?\")[0].endsWith(\".imjoy.html\")) {\n      return await this.createWindow(config, extra_config, context);\n    }\n    if (src.startsWith(\"http\")) {\n      const resp = await fetch(src);\n      code = await resp.text();\n    } else if (src.includes(\"\\n\")) {\n      code = src;\n    } else {\n      throw new Error(\"Only local plugins are supported in the workspace manager.\");\n    }\n    config = (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.parsePluginCode)(code, {});\n    switch (config.type) {\n      case \"web-worker\":\n        return await this.createWorker(config, ws, this.baseUrl + \"hypha-app-webworker.js\", context);\n      case \"window\":\n      case \"iframe\":\n        config.src = this.baseUrl + \"hypha-app-iframe.html\";\n        return await this.createWindow(config, extra_config, context);\n      case \"web-python\":\n        return await this.createWorker(config, ws, this.baseUrl + \"hypha-app-webpython.js\", context);\n      default:\n        throw new Error(\"Unsupported plugin type: \" + config.type);\n    }\n  }\n  _waitForConnection(conn_id, timeout) {\n    return new Promise((resolve, reject) => {\n      const handler = (info) => {\n        if (info.id === conn_id) {\n          this.eventBus.off(\"connection_ready\", handler);\n          clearTimeout(timeoutId);\n          resolve(info);\n        }\n      };\n      const timeoutId = setTimeout(() => {\n        this.eventBus.off(\"connection_ready\", handler);\n        reject(new Error(`Timeout after ${timeout / 1e3} s`));\n      }, timeout);\n      this.eventBus.on(\"connection_ready\", handler);\n    });\n  }\n  async createWorker(config, workspace, workerUrl, context) {\n    if (typeof Worker === \"undefined\") {\n      throw new Error(\"WebWorker creation requires browser environment with Worker API\");\n    }\n    const clientId = \"client-\" + Date.now();\n    let authToken = context.token;\n    if (!authToken) {\n      try {\n        authToken = await this.getDefaultService().generate_token({\n          workspace,\n          client_id: clientId,\n          user_id: context.user?.id || \"anonymous\",\n          email: context.user?.email || \"\",\n          roles: context.user?.roles || [],\n          scopes: context.user?.scopes || [],\n          expires_in: 3600\n          // 1 hour\n        }, context);\n      } catch (error) {\n        console.warn(\"Failed to generate auth token for worker:\", error);\n      }\n    }\n    const authParams = new URLSearchParams();\n    authParams.set(\"client_id\", clientId);\n    authParams.set(\"workspace\", workspace);\n    authParams.set(\"server_url\", this.serverUrl);\n    if (authToken) {\n      authParams.set(\"token\", authToken);\n    }\n    if (context.user) {\n      authParams.set(\"user_info\", JSON.stringify(context.user));\n    }\n    const authHash = `#${authParams.toString()}`;\n    const worker = new Worker(workerUrl + authHash);\n    this.connections[workspace + \"/\" + clientId] = {\n      id: workspace + \"/\" + clientId,\n      source: worker,\n      workspace,\n      user: context.user,\n      // Store user info for nested app creation\n      websocket: null,\n      postMessage: (data) => {\n        worker.postMessage(data);\n      }\n    };\n    worker.onmessage = this._server.messageHandler;\n    await this._waitForConnection(workspace + \"/\" + clientId, 6e4);\n    worker.postMessage({\n      type: \"initializeHyphaClient\",\n      server_url: this.serverUrl,\n      workspace,\n      client_id: clientId,\n      token: authToken || null,\n      user_info: context?.user || null,\n      config\n    });\n    return await this.waitForClient(workspace + \"/\" + clientId, 6e4);\n  }\n  async getApp(config, extra_config, context) {\n    if (typeof config === \"string\") {\n      return await this.loadApp({ src: config }, {}, context);\n    } else if (config.id) {\n      return this.plugins[config.id];\n    } else if (config.name) {\n      for (const [key, value] of Object.entries(this.plugins)) {\n        if (value.name === config.name) {\n          return value;\n        }\n      }\n    } else {\n      throw new Error(\"Please provide either id or name for the plugin\");\n    }\n  }\n  getDefaultService() {\n    const service = {\n      \"id\": \"default\",\n      \"name\": \"Default workspace management service\",\n      \"description\": \"Services for managing workspace.\",\n      \"config\": {\n        \"require_context\": true,\n        \"visibility\": \"public\"\n      },\n      \"emit\": async (type, data, context) => {\n        const workspaceId = context.ws;\n        await this.eventBus.emit(type, data);\n      },\n      \"on\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.on(event, handler);\n      },\n      \"off\": (event, handler, context) => {\n        const workspaceId = context.ws;\n        this.eventBus.off(event, handler);\n      },\n      \"echo\": (msg, context) => {\n        return msg;\n      },\n      \"alert\": (msg, context) => {\n        alert(msg);\n      },\n      \"confirm\": (msg, context) => {\n        return confirm(msg);\n      },\n      \"prompt\": (msg, default_value, context) => {\n        return prompt(msg, default_value);\n      },\n      \"show_progress\": (progress, context) => {\n        if (progress !== 0 && progress !== 100) {\n          console.debug(\"showProgress\", progress);\n        }\n      },\n      \"show_message\": (msg, context) => {\n        console.log(msg);\n      },\n      \"log\": (msg, context) => {\n        console.log(msg);\n      },\n      \"info\": (msg, context) => {\n        console.info(msg);\n      },\n      \"error\": (msg, context) => {\n        console.error(msg);\n      },\n      \"warning\": (msg, context) => {\n        console.warn(msg);\n      },\n      \"critical\": (msg, context) => {\n        console.error(msg);\n      },\n      \"register_service\": async (service2, context) => {\n        const workspaceId = context.ws;\n        if (service2[\"id\"].includes(\":\")) {\n          throw new Error(\"Service id must not contain ':'\");\n        } else if (service2[\"id\"].includes(\"/\")) {\n          throw new Error(\"Service id must not contain '/'\");\n        }\n        const sv = await this._rpc.get_remote_service(context[\"from\"] + \":built-in\");\n        service2[\"config\"] = service2[\"config\"] || {};\n        service2[\"config\"][\"workspace\"] = workspaceId;\n        service2 = await sv.register_service(service2);\n        (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_0__.assert)(!service2[\"id\"].includes(\"/\"), \"Service id must not contain '/'\");\n        service2[\"id\"] = workspaceId + \"/\" + service2[\"id\"];\n        return service2;\n      },\n      \"get_service\": this.getService.bind(this),\n      \"getService\": this.getService.bind(this),\n      // camelCase alias\n      \"list_services\": this.listServices.bind(this),\n      \"listServices\": this.listServices.bind(this),\n      // camelCase alias\n      \"generate_token\": async (tokenConfig, context) => {\n        if (!tokenConfig) {\n          tokenConfig = {};\n        }\n        const currentWorkspace = context.ws;\n        const currentClientId = context.from?.split(\"/\")[1];\n        let targetWorkspace = tokenConfig.workspace || currentWorkspace;\n        if (targetWorkspace !== currentWorkspace) {\n          if (currentWorkspace !== \"default\" || currentClientId !== \"root\") {\n            throw new Error(`Access denied: Cannot generate token for workspace '${targetWorkspace}' from workspace '${currentWorkspace}' with client '${currentClientId}'. Only root client in default workspace can generate cross-workspace tokens.`);\n          }\n        }\n        const payload = {\n          sub: tokenConfig.user_id || context.user?.id || \"anonymous\",\n          workspace: targetWorkspace,\n          client_id: tokenConfig.client_id || context.from?.split(\"/\")[1] || \"anonymouz-\" + Date.now().toString(),\n          email: tokenConfig.email || context.user?.email || \"\",\n          roles: tokenConfig.roles || context.user?.roles || [],\n          scope: Array.isArray(tokenConfig.scopes) ? tokenConfig.scopes.join(\" \") : tokenConfig.scope || \"\",\n          iat: Math.floor(Date.now() / 1e3),\n          exp: tokenConfig.expires_in ? Math.floor(Date.now() / 1e3) + tokenConfig.expires_in : Math.floor(Date.now() / 1e3) + 24 * 60 * 60,\n          // Default 24 hours\n          iss: \"hypha-core\",\n          aud: \"hypha-api\"\n        };\n        const jwtSecret = this._server.jwtSecret;\n        if (!jwtSecret) {\n          throw new Error(\"JWT secret not configured on server\");\n        }\n        return await generateJWT(payload, jwtSecret);\n      },\n      \"load_app\": async (config, extra_config, context) => {\n        return this.loadApp(config, extra_config, context);\n      },\n      \"create_window\": async (config, extra_config, context) => {\n        return this.createWindow(config, extra_config, context);\n      },\n      \"get_window\": async (config, context) => {\n        return this.getWindow(config, context);\n      },\n      \"get_app\": async (config, extra_config, context) => {\n        return this.getApp(config, extra_config, context);\n      },\n      \"register_service\": async (service2, context) => {\n        return await this.registerService(service2, context);\n      }\n    };\n    service.getPlugin = service.get_app;\n    service.loadPlugin = service.load_app;\n    service.getWindow = service.get_window;\n    return service;\n  }\n}\n__publicField(Workspace, \"workspaces\", {});\n__publicField(Workspace, \"clients\", {});\n\n\n//# sourceURL=webpack://hypha-core/./src/workspace.js?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedKeyDecoder: () => (/* binding */ CachedKeyDecoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n\nvar DEFAULT_MAX_KEY_LENGTH = 16;\nvar DEFAULT_MAX_LENGTH_PER_KEY = 16;\nvar CachedKeyDecoder = /** @class */ (function () {\n    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {\n        if (maxKeyLength === void 0) { maxKeyLength = DEFAULT_MAX_KEY_LENGTH; }\n        if (maxLengthPerKey === void 0) { maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY; }\n        this.maxKeyLength = maxKeyLength;\n        this.maxLengthPerKey = maxLengthPerKey;\n        this.hit = 0;\n        this.miss = 0;\n        // avoid `new Array(N)`, which makes a sparse array,\n        // because a sparse array is typically slower than a non-sparse array.\n        this.caches = [];\n        for (var i = 0; i < this.maxKeyLength; i++) {\n            this.caches.push([]);\n        }\n    }\n    CachedKeyDecoder.prototype.canBeCached = function (byteLength) {\n        return byteLength > 0 && byteLength <= this.maxKeyLength;\n    };\n    CachedKeyDecoder.prototype.find = function (bytes, inputOffset, byteLength) {\n        var records = this.caches[byteLength - 1];\n        FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var recordBytes = record.bytes;\n            for (var j = 0; j < byteLength; j++) {\n                if (recordBytes[j] !== bytes[inputOffset + j]) {\n                    continue FIND_CHUNK;\n                }\n            }\n            return record.str;\n        }\n        return null;\n    };\n    CachedKeyDecoder.prototype.store = function (bytes, value) {\n        var records = this.caches[bytes.length - 1];\n        var record = { bytes: bytes, str: value };\n        if (records.length >= this.maxLengthPerKey) {\n            // `records` are full!\n            // Set `record` to an arbitrary position.\n            records[(Math.random() * records.length) | 0] = record;\n        }\n        else {\n            records.push(record);\n        }\n    };\n    CachedKeyDecoder.prototype.decode = function (bytes, inputOffset, byteLength) {\n        var cachedValue = this.find(bytes, inputOffset, byteLength);\n        if (cachedValue != null) {\n            this.hit++;\n            return cachedValue;\n        }\n        this.miss++;\n        var str = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_0__.utf8DecodeJs)(bytes, inputOffset, byteLength);\n        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n        this.store(slicedCopyOfBytes, str);\n        return str;\n    };\n    return CachedKeyDecoder;\n}());\n\n//# sourceMappingURL=CachedKeyDecoder.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodeError: () => (/* binding */ DecodeError)\n/* harmony export */ });\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar DecodeError = /** @class */ (function (_super) {\n    __extends(DecodeError, _super);\n    function DecodeError(message) {\n        var _this = _super.call(this, message) || this;\n        // fix the prototype chain in a cross-platform way\n        var proto = Object.create(DecodeError.prototype);\n        Object.setPrototypeOf(_this, proto);\n        Object.defineProperty(_this, \"name\", {\n            configurable: true,\n            enumerable: false,\n            value: DecodeError.name,\n        });\n        return _this;\n    }\n    return DecodeError;\n}(Error));\n\n//# sourceMappingURL=DecodeError.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataViewIndexOutOfBoundsError: () => (/* binding */ DataViewIndexOutOfBoundsError),\n/* harmony export */   Decoder: () => (/* binding */ Decoder)\n/* harmony export */ });\n/* harmony import */ var _utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/prettyByte.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n/* harmony import */ var _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CachedKeyDecoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs\");\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __asyncValues = (undefined && undefined.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\n\n\n\n\n\n\n\nvar STATE_ARRAY = \"array\";\nvar STATE_MAP_KEY = \"map_key\";\nvar STATE_MAP_VALUE = \"map_value\";\nvar isValidMapKeyType = function (key) {\n    return typeof key === \"string\" || typeof key === \"number\";\n};\nvar HEAD_BYTE_REQUIRED = -1;\nvar EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nvar EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n}\ncatch (e) {\n    if (!(e instanceof RangeError)) {\n        throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n    }\n}\nvar DataViewIndexOutOfBoundsError = RangeError;\nvar MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\nvar sharedCachedKeyDecoder = new _CachedKeyDecoder_mjs__WEBPACK_IMPORTED_MODULE_0__.CachedKeyDecoder();\nvar Decoder = /** @class */ (function () {\n    function Decoder(options) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.totalPos = 0;\n        this.pos = 0;\n        this.view = EMPTY_VIEW;\n        this.bytes = EMPTY_BYTES;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack = [];\n        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtensionCodec.defaultCodec;\n        this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;\n        this.maxStrLength = (_c = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _c !== void 0 ? _c : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxBinLength = (_d = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _d !== void 0 ? _d : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxArrayLength = (_e = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _e !== void 0 ? _e : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxMapLength = (_f = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _f !== void 0 ? _f : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.maxExtLength = (_g = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _g !== void 0 ? _g : _utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.UINT32_MAX;\n        this.keyDecoder = ((options === null || options === void 0 ? void 0 : options.keyDecoder) !== undefined) ? options.keyDecoder : sharedCachedKeyDecoder;\n    }\n    Decoder.prototype.reinitializeState = function () {\n        this.totalPos = 0;\n        this.headByte = HEAD_BYTE_REQUIRED;\n        this.stack.length = 0;\n        // view, bytes, and pos will be re-initialized in setBuffer()\n    };\n    Decoder.prototype.setBuffer = function (buffer) {\n        this.bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n        this.view = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.createDataView)(this.bytes);\n        this.pos = 0;\n    };\n    Decoder.prototype.appendBuffer = function (buffer) {\n        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n            this.setBuffer(buffer);\n        }\n        else {\n            var remainingData = this.bytes.subarray(this.pos);\n            var newData = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_3__.ensureUint8Array)(buffer);\n            // concat remainingData + newData\n            var newBuffer = new Uint8Array(remainingData.length + newData.length);\n            newBuffer.set(remainingData);\n            newBuffer.set(newData, remainingData.length);\n            this.setBuffer(newBuffer);\n        }\n    };\n    Decoder.prototype.hasRemaining = function (size) {\n        return this.view.byteLength - this.pos >= size;\n    };\n    Decoder.prototype.createExtraByteError = function (posToShow) {\n        var _a = this, view = _a.view, pos = _a.pos;\n        return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n    };\n    /**\n     * @throws {@link DecodeError}\n     * @throws {@link RangeError}\n     */\n    Decoder.prototype.decode = function (buffer) {\n        this.reinitializeState();\n        this.setBuffer(buffer);\n        var object = this.doDecodeSync();\n        if (this.hasRemaining(1)) {\n            throw this.createExtraByteError(this.pos);\n        }\n        return object;\n    };\n    Decoder.prototype.decodeMulti = function (buffer) {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    this.reinitializeState();\n                    this.setBuffer(buffer);\n                    _a.label = 1;\n                case 1:\n                    if (!this.hasRemaining(1)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, this.doDecodeSync()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    Decoder.prototype.decodeAsync = function (stream) {\n        var _a, stream_1, stream_1_1;\n        var _b, e_1, _c, _d;\n        return __awaiter(this, void 0, void 0, function () {\n            var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        decoded = false;\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 6, 7, 12]);\n                        _a = true, stream_1 = __asyncValues(stream);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, stream_1.next()];\n                    case 3:\n                        if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3 /*break*/, 5];\n                        _d = stream_1_1.value;\n                        _a = false;\n                        try {\n                            buffer = _d;\n                            if (decoded) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            this.appendBuffer(buffer);\n                            try {\n                                object = this.doDecodeSync();\n                                decoded = true;\n                            }\n                            catch (e) {\n                                if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n                                    throw e; // rethrow\n                                }\n                                // fallthrough\n                            }\n                            this.totalPos += this.pos;\n                        }\n                        finally {\n                            _a = true;\n                        }\n                        _f.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _f.trys.push([7, , 10, 11]);\n                        if (!(!_a && !_b && (_c = stream_1.return))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _c.call(stream_1)];\n                    case 8:\n                        _f.sent();\n                        _f.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12:\n                        if (decoded) {\n                            if (this.hasRemaining(1)) {\n                                throw this.createExtraByteError(this.totalPos);\n                            }\n                            return [2 /*return*/, object];\n                        }\n                        _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;\n                        throw new RangeError(\"Insufficient data in parsing \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n                }\n            });\n        });\n    };\n    Decoder.prototype.decodeArrayStream = function (stream) {\n        return this.decodeMultiAsync(stream, true);\n    };\n    Decoder.prototype.decodeStream = function (stream) {\n        return this.decodeMultiAsync(stream, false);\n    };\n    Decoder.prototype.decodeMultiAsync = function (stream, isArray) {\n        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {\n            var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;\n            var _b, e_3, _c, _d;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        isArrayHeaderRequired = isArray;\n                        arrayItemsLeft = -1;\n                        _e.label = 1;\n                    case 1:\n                        _e.trys.push([1, 15, 16, 21]);\n                        _a = true, stream_2 = __asyncValues(stream);\n                        _e.label = 2;\n                    case 2: return [4 /*yield*/, __await(stream_2.next())];\n                    case 3:\n                        if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3 /*break*/, 14];\n                        _d = stream_2_1.value;\n                        _a = false;\n                        _e.label = 4;\n                    case 4:\n                        _e.trys.push([4, , 12, 13]);\n                        buffer = _d;\n                        if (isArray && arrayItemsLeft === 0) {\n                            throw this.createExtraByteError(this.totalPos);\n                        }\n                        this.appendBuffer(buffer);\n                        if (isArrayHeaderRequired) {\n                            arrayItemsLeft = this.readArraySize();\n                            isArrayHeaderRequired = false;\n                            this.complete();\n                        }\n                        _e.label = 5;\n                    case 5:\n                        _e.trys.push([5, 10, , 11]);\n                        _e.label = 6;\n                    case 6:\n                        if (false) {}\n                        return [4 /*yield*/, __await(this.doDecodeSync())];\n                    case 7: return [4 /*yield*/, _e.sent()];\n                    case 8:\n                        _e.sent();\n                        if (--arrayItemsLeft === 0) {\n                            return [3 /*break*/, 9];\n                        }\n                        return [3 /*break*/, 6];\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        e_2 = _e.sent();\n                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {\n                            throw e_2; // rethrow\n                        }\n                        return [3 /*break*/, 11];\n                    case 11:\n                        this.totalPos += this.pos;\n                        return [3 /*break*/, 13];\n                    case 12:\n                        _a = true;\n                        return [7 /*endfinally*/];\n                    case 13: return [3 /*break*/, 2];\n                    case 14: return [3 /*break*/, 21];\n                    case 15:\n                        e_3_1 = _e.sent();\n                        e_3 = { error: e_3_1 };\n                        return [3 /*break*/, 21];\n                    case 16:\n                        _e.trys.push([16, , 19, 20]);\n                        if (!(!_a && !_b && (_c = stream_2.return))) return [3 /*break*/, 18];\n                        return [4 /*yield*/, __await(_c.call(stream_2))];\n                    case 17:\n                        _e.sent();\n                        _e.label = 18;\n                    case 18: return [3 /*break*/, 20];\n                    case 19:\n                        if (e_3) throw e_3.error;\n                        return [7 /*endfinally*/];\n                    case 20: return [7 /*endfinally*/];\n                    case 21: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Decoder.prototype.doDecodeSync = function () {\n        DECODE: while (true) {\n            var headByte = this.readHeadByte();\n            var object = void 0;\n            if (headByte >= 0xe0) {\n                // negative fixint (111x xxxx) 0xe0 - 0xff\n                object = headByte - 0x100;\n            }\n            else if (headByte < 0xc0) {\n                if (headByte < 0x80) {\n                    // positive fixint (0xxx xxxx) 0x00 - 0x7f\n                    object = headByte;\n                }\n                else if (headByte < 0x90) {\n                    // fixmap (1000 xxxx) 0x80 - 0x8f\n                    var size = headByte - 0x80;\n                    if (size !== 0) {\n                        this.pushMapState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = {};\n                    }\n                }\n                else if (headByte < 0xa0) {\n                    // fixarray (1001 xxxx) 0x90 - 0x9f\n                    var size = headByte - 0x90;\n                    if (size !== 0) {\n                        this.pushArrayState(size);\n                        this.complete();\n                        continue DECODE;\n                    }\n                    else {\n                        object = [];\n                    }\n                }\n                else {\n                    // fixstr (101x xxxx) 0xa0 - 0xbf\n                    var byteLength = headByte - 0xa0;\n                    object = this.decodeUtf8String(byteLength, 0);\n                }\n            }\n            else if (headByte === 0xc0) {\n                // nil\n                object = null;\n            }\n            else if (headByte === 0xc2) {\n                // false\n                object = false;\n            }\n            else if (headByte === 0xc3) {\n                // true\n                object = true;\n            }\n            else if (headByte === 0xca) {\n                // float 32\n                object = this.readF32();\n            }\n            else if (headByte === 0xcb) {\n                // float 64\n                object = this.readF64();\n            }\n            else if (headByte === 0xcc) {\n                // uint 8\n                object = this.readU8();\n            }\n            else if (headByte === 0xcd) {\n                // uint 16\n                object = this.readU16();\n            }\n            else if (headByte === 0xce) {\n                // uint 32\n                object = this.readU32();\n            }\n            else if (headByte === 0xcf) {\n                // uint 64\n                if (this.useBigInt64) {\n                    object = this.readU64AsBigInt();\n                }\n                else {\n                    object = this.readU64();\n                }\n            }\n            else if (headByte === 0xd0) {\n                // int 8\n                object = this.readI8();\n            }\n            else if (headByte === 0xd1) {\n                // int 16\n                object = this.readI16();\n            }\n            else if (headByte === 0xd2) {\n                // int 32\n                object = this.readI32();\n            }\n            else if (headByte === 0xd3) {\n                // int 64\n                if (this.useBigInt64) {\n                    object = this.readI64AsBigInt();\n                }\n                else {\n                    object = this.readI64();\n                }\n            }\n            else if (headByte === 0xd9) {\n                // str 8\n                var byteLength = this.lookU8();\n                object = this.decodeUtf8String(byteLength, 1);\n            }\n            else if (headByte === 0xda) {\n                // str 16\n                var byteLength = this.lookU16();\n                object = this.decodeUtf8String(byteLength, 2);\n            }\n            else if (headByte === 0xdb) {\n                // str 32\n                var byteLength = this.lookU32();\n                object = this.decodeUtf8String(byteLength, 4);\n            }\n            else if (headByte === 0xdc) {\n                // array 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xdd) {\n                // array 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushArrayState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = [];\n                }\n            }\n            else if (headByte === 0xde) {\n                // map 16\n                var size = this.readU16();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xdf) {\n                // map 32\n                var size = this.readU32();\n                if (size !== 0) {\n                    this.pushMapState(size);\n                    this.complete();\n                    continue DECODE;\n                }\n                else {\n                    object = {};\n                }\n            }\n            else if (headByte === 0xc4) {\n                // bin 8\n                var size = this.lookU8();\n                object = this.decodeBinary(size, 1);\n            }\n            else if (headByte === 0xc5) {\n                // bin 16\n                var size = this.lookU16();\n                object = this.decodeBinary(size, 2);\n            }\n            else if (headByte === 0xc6) {\n                // bin 32\n                var size = this.lookU32();\n                object = this.decodeBinary(size, 4);\n            }\n            else if (headByte === 0xd4) {\n                // fixext 1\n                object = this.decodeExtension(1, 0);\n            }\n            else if (headByte === 0xd5) {\n                // fixext 2\n                object = this.decodeExtension(2, 0);\n            }\n            else if (headByte === 0xd6) {\n                // fixext 4\n                object = this.decodeExtension(4, 0);\n            }\n            else if (headByte === 0xd7) {\n                // fixext 8\n                object = this.decodeExtension(8, 0);\n            }\n            else if (headByte === 0xd8) {\n                // fixext 16\n                object = this.decodeExtension(16, 0);\n            }\n            else if (headByte === 0xc7) {\n                // ext 8\n                var size = this.lookU8();\n                object = this.decodeExtension(size, 1);\n            }\n            else if (headByte === 0xc8) {\n                // ext 16\n                var size = this.lookU16();\n                object = this.decodeExtension(size, 2);\n            }\n            else if (headByte === 0xc9) {\n                // ext 32\n                var size = this.lookU32();\n                object = this.decodeExtension(size, 4);\n            }\n            else {\n                throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n            }\n            this.complete();\n            var stack = this.stack;\n            while (stack.length > 0) {\n                // arrays and maps\n                var state = stack[stack.length - 1];\n                if (state.type === STATE_ARRAY) {\n                    state.array[state.position] = object;\n                    state.position++;\n                    if (state.position === state.size) {\n                        stack.pop();\n                        object = state.array;\n                    }\n                    else {\n                        continue DECODE;\n                    }\n                }\n                else if (state.type === STATE_MAP_KEY) {\n                    if (!isValidMapKeyType(object)) {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The type of key must be string or number but \" + typeof object);\n                    }\n                    if (object === \"__proto__\") {\n                        throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"The key __proto__ is not allowed\");\n                    }\n                    state.key = object;\n                    state.type = STATE_MAP_VALUE;\n                    continue DECODE;\n                }\n                else {\n                    // it must be `state.type === State.MAP_VALUE` here\n                    state.map[state.key] = object;\n                    state.readCount++;\n                    if (state.readCount === state.size) {\n                        stack.pop();\n                        object = state.map;\n                    }\n                    else {\n                        state.key = null;\n                        state.type = STATE_MAP_KEY;\n                        continue DECODE;\n                    }\n                }\n            }\n            return object;\n        }\n    };\n    Decoder.prototype.readHeadByte = function () {\n        if (this.headByte === HEAD_BYTE_REQUIRED) {\n            this.headByte = this.readU8();\n            // console.log(\"headByte\", prettyByte(this.headByte));\n        }\n        return this.headByte;\n    };\n    Decoder.prototype.complete = function () {\n        this.headByte = HEAD_BYTE_REQUIRED;\n    };\n    Decoder.prototype.readArraySize = function () {\n        var headByte = this.readHeadByte();\n        switch (headByte) {\n            case 0xdc:\n                return this.readU16();\n            case 0xdd:\n                return this.readU32();\n            default: {\n                if (headByte < 0xa0) {\n                    return headByte - 0x90;\n                }\n                else {\n                    throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Unrecognized array type byte: \".concat((0,_utils_prettyByte_mjs__WEBPACK_IMPORTED_MODULE_4__.prettyByte)(headByte)));\n                }\n            }\n        }\n    };\n    Decoder.prototype.pushMapState = function (size) {\n        if (size > this.maxMapLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n        }\n        this.stack.push({\n            type: STATE_MAP_KEY,\n            size: size,\n            key: null,\n            readCount: 0,\n            map: {},\n        });\n    };\n    Decoder.prototype.pushArrayState = function (size) {\n        if (size > this.maxArrayLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n        }\n        this.stack.push({\n            type: STATE_ARRAY,\n            size: size,\n            array: new Array(size),\n            position: 0,\n        });\n    };\n    Decoder.prototype.decodeUtf8String = function (byteLength, headerOffset) {\n        var _a;\n        if (byteLength > this.maxStrLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n        }\n        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headerOffset;\n        var object;\n        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {\n            object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n        }\n        else {\n            object = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_6__.utf8Decode)(this.bytes, offset, byteLength);\n        }\n        this.pos += headerOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.stateIsMapKey = function () {\n        if (this.stack.length > 0) {\n            var state = this.stack[this.stack.length - 1];\n            return state.type === STATE_MAP_KEY;\n        }\n        return false;\n    };\n    Decoder.prototype.decodeBinary = function (byteLength, headOffset) {\n        if (byteLength > this.maxBinLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n        }\n        if (!this.hasRemaining(byteLength + headOffset)) {\n            throw MORE_DATA;\n        }\n        var offset = this.pos + headOffset;\n        var object = this.bytes.subarray(offset, offset + byteLength);\n        this.pos += headOffset + byteLength;\n        return object;\n    };\n    Decoder.prototype.decodeExtension = function (size, headOffset) {\n        if (size > this.maxExtLength) {\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_5__.DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n        }\n        var extType = this.view.getInt8(this.pos + headOffset);\n        var data = this.decodeBinary(size, headOffset + 1 /* extType */);\n        return this.extensionCodec.decode(data, extType, this.context);\n    };\n    Decoder.prototype.lookU8 = function () {\n        return this.view.getUint8(this.pos);\n    };\n    Decoder.prototype.lookU16 = function () {\n        return this.view.getUint16(this.pos);\n    };\n    Decoder.prototype.lookU32 = function () {\n        return this.view.getUint32(this.pos);\n    };\n    Decoder.prototype.readU8 = function () {\n        var value = this.view.getUint8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readI8 = function () {\n        var value = this.view.getInt8(this.pos);\n        this.pos++;\n        return value;\n    };\n    Decoder.prototype.readU16 = function () {\n        var value = this.view.getUint16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readI16 = function () {\n        var value = this.view.getInt16(this.pos);\n        this.pos += 2;\n        return value;\n    };\n    Decoder.prototype.readU32 = function () {\n        var value = this.view.getUint32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readI32 = function () {\n        var value = this.view.getInt32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readU64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getUint64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64 = function () {\n        var value = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_2__.getInt64)(this.view, this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readU64AsBigInt = function () {\n        var value = this.view.getBigUint64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readI64AsBigInt = function () {\n        var value = this.view.getBigInt64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    Decoder.prototype.readF32 = function () {\n        var value = this.view.getFloat32(this.pos);\n        this.pos += 4;\n        return value;\n    };\n    Decoder.prototype.readF64 = function () {\n        var value = this.view.getFloat64(this.pos);\n        this.pos += 8;\n        return value;\n    };\n    return Decoder;\n}());\n\n//# sourceMappingURL=Decoder.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_INITIAL_BUFFER_SIZE: () => (/* binding */ DEFAULT_INITIAL_BUFFER_SIZE),\n/* harmony export */   DEFAULT_MAX_DEPTH: () => (/* binding */ DEFAULT_MAX_DEPTH),\n/* harmony export */   Encoder: () => (/* binding */ Encoder)\n/* harmony export */ });\n/* harmony import */ var _utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/utf8.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs\");\n/* harmony import */ var _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExtensionCodec.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n/* harmony import */ var _utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/typedArrays.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs\");\n\n\n\n\nvar DEFAULT_MAX_DEPTH = 100;\nvar DEFAULT_INITIAL_BUFFER_SIZE = 2048;\nvar Encoder = /** @class */ (function () {\n    function Encoder(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : _ExtensionCodec_mjs__WEBPACK_IMPORTED_MODULE_0__.ExtensionCodec.defaultCodec;\n        this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n        this.useBigInt64 = (_b = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _b !== void 0 ? _b : false;\n        this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;\n        this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;\n        this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;\n        this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;\n        this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;\n        this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;\n        this.pos = 0;\n        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n        this.bytes = new Uint8Array(this.view.buffer);\n    }\n    Encoder.prototype.reinitializeState = function () {\n        this.pos = 0;\n    };\n    /**\n     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n     *\n     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n     */\n    Encoder.prototype.encodeSharedRef = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.subarray(0, this.pos);\n    };\n    /**\n     * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n     */\n    Encoder.prototype.encode = function (object) {\n        this.reinitializeState();\n        this.doEncode(object, 1);\n        return this.bytes.slice(0, this.pos);\n    };\n    Encoder.prototype.doEncode = function (object, depth) {\n        if (depth > this.maxDepth) {\n            throw new Error(\"Too deep objects in depth \".concat(depth));\n        }\n        if (object == null) {\n            this.encodeNil();\n        }\n        else if (typeof object === \"boolean\") {\n            this.encodeBoolean(object);\n        }\n        else if (typeof object === \"number\") {\n            if (!this.forceIntegerToFloat) {\n                this.encodeNumber(object);\n            }\n            else {\n                this.encodeNumberAsFloat(object);\n            }\n        }\n        else if (typeof object === \"string\") {\n            this.encodeString(object);\n        }\n        else if (this.useBigInt64 && typeof object === \"bigint\") {\n            this.encodeBigInt64(object);\n        }\n        else {\n            this.encodeObject(object, depth);\n        }\n    };\n    Encoder.prototype.ensureBufferSizeToWrite = function (sizeToWrite) {\n        var requiredSize = this.pos + sizeToWrite;\n        if (this.view.byteLength < requiredSize) {\n            this.resizeBuffer(requiredSize * 2);\n        }\n    };\n    Encoder.prototype.resizeBuffer = function (newSize) {\n        var newBuffer = new ArrayBuffer(newSize);\n        var newBytes = new Uint8Array(newBuffer);\n        var newView = new DataView(newBuffer);\n        newBytes.set(this.bytes);\n        this.view = newView;\n        this.bytes = newBytes;\n    };\n    Encoder.prototype.encodeNil = function () {\n        this.writeU8(0xc0);\n    };\n    Encoder.prototype.encodeBoolean = function (object) {\n        if (object === false) {\n            this.writeU8(0xc2);\n        }\n        else {\n            this.writeU8(0xc3);\n        }\n    };\n    Encoder.prototype.encodeNumber = function (object) {\n        if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n            if (object >= 0) {\n                if (object < 0x80) {\n                    // positive fixint\n                    this.writeU8(object);\n                }\n                else if (object < 0x100) {\n                    // uint 8\n                    this.writeU8(0xcc);\n                    this.writeU8(object);\n                }\n                else if (object < 0x10000) {\n                    // uint 16\n                    this.writeU8(0xcd);\n                    this.writeU16(object);\n                }\n                else if (object < 0x100000000) {\n                    // uint 32\n                    this.writeU8(0xce);\n                    this.writeU32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // uint 64\n                    this.writeU8(0xcf);\n                    this.writeU64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n            else {\n                if (object >= -0x20) {\n                    // negative fixint\n                    this.writeU8(0xe0 | (object + 0x20));\n                }\n                else if (object >= -0x80) {\n                    // int 8\n                    this.writeU8(0xd0);\n                    this.writeI8(object);\n                }\n                else if (object >= -0x8000) {\n                    // int 16\n                    this.writeU8(0xd1);\n                    this.writeI16(object);\n                }\n                else if (object >= -0x80000000) {\n                    // int 32\n                    this.writeU8(0xd2);\n                    this.writeI32(object);\n                }\n                else if (!this.useBigInt64) {\n                    // int 64\n                    this.writeU8(0xd3);\n                    this.writeI64(object);\n                }\n                else {\n                    this.encodeNumberAsFloat(object);\n                }\n            }\n        }\n        else {\n            this.encodeNumberAsFloat(object);\n        }\n    };\n    Encoder.prototype.encodeNumberAsFloat = function (object) {\n        if (this.forceFloat32) {\n            // float 32\n            this.writeU8(0xca);\n            this.writeF32(object);\n        }\n        else {\n            // float 64\n            this.writeU8(0xcb);\n            this.writeF64(object);\n        }\n    };\n    Encoder.prototype.encodeBigInt64 = function (object) {\n        if (object >= BigInt(0)) {\n            // uint 64\n            this.writeU8(0xcf);\n            this.writeBigUint64(object);\n        }\n        else {\n            // int 64\n            this.writeU8(0xd3);\n            this.writeBigInt64(object);\n        }\n    };\n    Encoder.prototype.writeStringHeader = function (byteLength) {\n        if (byteLength < 32) {\n            // fixstr\n            this.writeU8(0xa0 + byteLength);\n        }\n        else if (byteLength < 0x100) {\n            // str 8\n            this.writeU8(0xd9);\n            this.writeU8(byteLength);\n        }\n        else if (byteLength < 0x10000) {\n            // str 16\n            this.writeU8(0xda);\n            this.writeU16(byteLength);\n        }\n        else if (byteLength < 0x100000000) {\n            // str 32\n            this.writeU8(0xdb);\n            this.writeU32(byteLength);\n        }\n        else {\n            throw new Error(\"Too long string: \".concat(byteLength, \" bytes in UTF-8\"));\n        }\n    };\n    Encoder.prototype.encodeString = function (object) {\n        var maxHeaderSize = 1 + 4;\n        var byteLength = (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Count)(object);\n        this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n        this.writeStringHeader(byteLength);\n        (0,_utils_utf8_mjs__WEBPACK_IMPORTED_MODULE_1__.utf8Encode)(object, this.bytes, this.pos);\n        this.pos += byteLength;\n    };\n    Encoder.prototype.encodeObject = function (object, depth) {\n        // try to encode objects with custom codec first of non-primitives\n        var ext = this.extensionCodec.tryToEncode(object, this.context);\n        if (ext != null) {\n            this.encodeExtension(ext);\n        }\n        else if (Array.isArray(object)) {\n            this.encodeArray(object, depth);\n        }\n        else if (ArrayBuffer.isView(object)) {\n            this.encodeBinary(object);\n        }\n        else if (typeof object === \"object\") {\n            this.encodeMap(object, depth);\n        }\n        else {\n            // symbol, function and other special object come here unless extensionCodec handles them.\n            throw new Error(\"Unrecognized object: \".concat(Object.prototype.toString.apply(object)));\n        }\n    };\n    Encoder.prototype.encodeBinary = function (object) {\n        var size = object.byteLength;\n        if (size < 0x100) {\n            // bin 8\n            this.writeU8(0xc4);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // bin 16\n            this.writeU8(0xc5);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // bin 32\n            this.writeU8(0xc6);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large binary: \".concat(size));\n        }\n        var bytes = (0,_utils_typedArrays_mjs__WEBPACK_IMPORTED_MODULE_2__.ensureUint8Array)(object);\n        this.writeU8a(bytes);\n    };\n    Encoder.prototype.encodeArray = function (object, depth) {\n        var size = object.length;\n        if (size < 16) {\n            // fixarray\n            this.writeU8(0x90 + size);\n        }\n        else if (size < 0x10000) {\n            // array 16\n            this.writeU8(0xdc);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // array 32\n            this.writeU8(0xdd);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large array: \".concat(size));\n        }\n        for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {\n            var item = object_1[_i];\n            this.doEncode(item, depth + 1);\n        }\n    };\n    Encoder.prototype.countWithoutUndefined = function (object, keys) {\n        var count = 0;\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            if (object[key] !== undefined) {\n                count++;\n            }\n        }\n        return count;\n    };\n    Encoder.prototype.encodeMap = function (object, depth) {\n        var keys = Object.keys(object);\n        if (this.sortKeys) {\n            keys.sort();\n        }\n        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n        if (size < 16) {\n            // fixmap\n            this.writeU8(0x80 + size);\n        }\n        else if (size < 0x10000) {\n            // map 16\n            this.writeU8(0xde);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // map 32\n            this.writeU8(0xdf);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large map object: \".concat(size));\n        }\n        for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {\n            var key = keys_2[_i];\n            var value = object[key];\n            if (!(this.ignoreUndefined && value === undefined)) {\n                this.encodeString(key);\n                this.doEncode(value, depth + 1);\n            }\n        }\n    };\n    Encoder.prototype.encodeExtension = function (ext) {\n        var size = ext.data.length;\n        if (size === 1) {\n            // fixext 1\n            this.writeU8(0xd4);\n        }\n        else if (size === 2) {\n            // fixext 2\n            this.writeU8(0xd5);\n        }\n        else if (size === 4) {\n            // fixext 4\n            this.writeU8(0xd6);\n        }\n        else if (size === 8) {\n            // fixext 8\n            this.writeU8(0xd7);\n        }\n        else if (size === 16) {\n            // fixext 16\n            this.writeU8(0xd8);\n        }\n        else if (size < 0x100) {\n            // ext 8\n            this.writeU8(0xc7);\n            this.writeU8(size);\n        }\n        else if (size < 0x10000) {\n            // ext 16\n            this.writeU8(0xc8);\n            this.writeU16(size);\n        }\n        else if (size < 0x100000000) {\n            // ext 32\n            this.writeU8(0xc9);\n            this.writeU32(size);\n        }\n        else {\n            throw new Error(\"Too large extension object: \".concat(size));\n        }\n        this.writeI8(ext.type);\n        this.writeU8a(ext.data);\n    };\n    Encoder.prototype.writeU8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setUint8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU8a = function (values) {\n        var size = values.length;\n        this.ensureBufferSizeToWrite(size);\n        this.bytes.set(values, this.pos);\n        this.pos += size;\n    };\n    Encoder.prototype.writeI8 = function (value) {\n        this.ensureBufferSizeToWrite(1);\n        this.view.setInt8(this.pos, value);\n        this.pos++;\n    };\n    Encoder.prototype.writeU16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setUint16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeI16 = function (value) {\n        this.ensureBufferSizeToWrite(2);\n        this.view.setInt16(this.pos, value);\n        this.pos += 2;\n    };\n    Encoder.prototype.writeU32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setUint32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeI32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setInt32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF32 = function (value) {\n        this.ensureBufferSizeToWrite(4);\n        this.view.setFloat32(this.pos, value);\n        this.pos += 4;\n    };\n    Encoder.prototype.writeF64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setFloat64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeU64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setUint64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeI64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_3__.setInt64)(this.view, this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeBigUint64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigUint64(this.pos, value);\n        this.pos += 8;\n    };\n    Encoder.prototype.writeBigInt64 = function (value) {\n        this.ensureBufferSizeToWrite(8);\n        this.view.setBigInt64(this.pos, value);\n        this.pos += 8;\n    };\n    return Encoder;\n}());\n\n//# sourceMappingURL=Encoder.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtData: () => (/* binding */ ExtData)\n/* harmony export */ });\n/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nvar ExtData = /** @class */ (function () {\n    function ExtData(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n    return ExtData;\n}());\n\n//# sourceMappingURL=ExtData.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtensionCodec: () => (/* binding */ ExtensionCodec)\n/* harmony export */ });\n/* harmony import */ var _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExtData.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs\");\n/* harmony import */ var _timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timestamp.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs\");\n// ExtensionCodec to handle MessagePack extensions\n\n\nvar ExtensionCodec = /** @class */ (function () {\n    function ExtensionCodec() {\n        // built-in extensions\n        this.builtInEncoders = [];\n        this.builtInDecoders = [];\n        // custom extensions\n        this.encoders = [];\n        this.decoders = [];\n        this.register(_timestamp_mjs__WEBPACK_IMPORTED_MODULE_0__.timestampExtension);\n    }\n    ExtensionCodec.prototype.register = function (_a) {\n        var type = _a.type, encode = _a.encode, decode = _a.decode;\n        if (type >= 0) {\n            // custom extensions\n            this.encoders[type] = encode;\n            this.decoders[type] = decode;\n        }\n        else {\n            // built-in extensions\n            var index = 1 + type;\n            this.builtInEncoders[index] = encode;\n            this.builtInDecoders[index] = decode;\n        }\n    };\n    ExtensionCodec.prototype.tryToEncode = function (object, context) {\n        // built-in extensions\n        for (var i = 0; i < this.builtInEncoders.length; i++) {\n            var encodeExt = this.builtInEncoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = -1 - i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        // custom extensions\n        for (var i = 0; i < this.encoders.length; i++) {\n            var encodeExt = this.encoders[i];\n            if (encodeExt != null) {\n                var data = encodeExt(object, context);\n                if (data != null) {\n                    var type = i;\n                    return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n                }\n            }\n        }\n        if (object instanceof _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData) {\n            // to keep ExtData as is\n            return object;\n        }\n        return null;\n    };\n    ExtensionCodec.prototype.decode = function (data, type, context) {\n        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n        if (decodeExt) {\n            return decodeExt(data, type, context);\n        }\n        else {\n            // decode() does not fail, returns ExtData instead.\n            return new _ExtData_mjs__WEBPACK_IMPORTED_MODULE_1__.ExtData(type, data);\n        }\n    };\n    ExtensionCodec.defaultCodec = new ExtensionCodec();\n    return ExtensionCodec;\n}());\n//# sourceMappingURL=ExtensionCodec.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultEncodeOptions: () => (/* binding */ defaultEncodeOptions),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Encoder.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n\n/**\n * @deprecated No longer supported.\n */\nvar defaultEncodeOptions = undefined;\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nfunction encode(value, options) {\n    var encoder = new _Encoder_mjs__WEBPACK_IMPORTED_MODULE_0__.Encoder(options);\n    return encoder.encodeSharedRef(value);\n}\n//# sourceMappingURL=encode.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXT_TIMESTAMP: () => (/* binding */ EXT_TIMESTAMP),\n/* harmony export */   decodeTimestampExtension: () => (/* binding */ decodeTimestampExtension),\n/* harmony export */   decodeTimestampToTimeSpec: () => (/* binding */ decodeTimestampToTimeSpec),\n/* harmony export */   encodeDateToTimeSpec: () => (/* binding */ encodeDateToTimeSpec),\n/* harmony export */   encodeTimeSpecToTimestamp: () => (/* binding */ encodeTimeSpecToTimestamp),\n/* harmony export */   encodeTimestampExtension: () => (/* binding */ encodeTimestampExtension),\n/* harmony export */   timestampExtension: () => (/* binding */ timestampExtension)\n/* harmony export */ });\n/* harmony import */ var _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DecodeError.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs\");\n/* harmony import */ var _utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/int.mjs */ \"./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs\");\n// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n\n\nvar EXT_TIMESTAMP = -1;\nvar TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nvar TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\nfunction encodeTimeSpecToTimestamp(_a) {\n    var sec = _a.sec, nsec = _a.nsec;\n    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n        // Here sec >= 0 && nsec >= 0\n        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n            // timestamp 32 = { sec32 (unsigned) }\n            var rv = new Uint8Array(4);\n            var view = new DataView(rv.buffer);\n            view.setUint32(0, sec);\n            return rv;\n        }\n        else {\n            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n            var secHigh = sec / 0x100000000;\n            var secLow = sec & 0xffffffff;\n            var rv = new Uint8Array(8);\n            var view = new DataView(rv.buffer);\n            // nsec30 | secHigh2\n            view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n            // secLow32\n            view.setUint32(4, secLow);\n            return rv;\n        }\n    }\n    else {\n        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n        var rv = new Uint8Array(12);\n        var view = new DataView(rv.buffer);\n        view.setUint32(0, nsec);\n        (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.setInt64)(view, 4, sec);\n        return rv;\n    }\n}\nfunction encodeDateToTimeSpec(date) {\n    var msec = date.getTime();\n    var sec = Math.floor(msec / 1e3);\n    var nsec = (msec - sec * 1e3) * 1e6;\n    // Normalizes { sec, nsec } to ensure nsec is unsigned.\n    var nsecInSec = Math.floor(nsec / 1e9);\n    return {\n        sec: sec + nsecInSec,\n        nsec: nsec - nsecInSec * 1e9,\n    };\n}\nfunction encodeTimestampExtension(object) {\n    if (object instanceof Date) {\n        var timeSpec = encodeDateToTimeSpec(object);\n        return encodeTimeSpecToTimestamp(timeSpec);\n    }\n    else {\n        return null;\n    }\n}\nfunction decodeTimestampToTimeSpec(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // data may be 32, 64, or 96 bits\n    switch (data.byteLength) {\n        case 4: {\n            // timestamp 32 = { sec32 }\n            var sec = view.getUint32(0);\n            var nsec = 0;\n            return { sec: sec, nsec: nsec };\n        }\n        case 8: {\n            // timestamp 64 = { nsec30, sec34 }\n            var nsec30AndSecHigh2 = view.getUint32(0);\n            var secLow32 = view.getUint32(4);\n            var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n            var nsec = nsec30AndSecHigh2 >>> 2;\n            return { sec: sec, nsec: nsec };\n        }\n        case 12: {\n            // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n            var sec = (0,_utils_int_mjs__WEBPACK_IMPORTED_MODULE_0__.getInt64)(view, 4);\n            var nsec = view.getUint32(0);\n            return { sec: sec, nsec: nsec };\n        }\n        default:\n            throw new _DecodeError_mjs__WEBPACK_IMPORTED_MODULE_1__.DecodeError(\"Unrecognized data size for timestamp (expected 4, 8, or 12): \".concat(data.length));\n    }\n}\nfunction decodeTimestampExtension(data) {\n    var timeSpec = decodeTimestampToTimeSpec(data);\n    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\nvar timestampExtension = {\n    type: EXT_TIMESTAMP,\n    encode: encodeTimestampExtension,\n    decode: decodeTimestampExtension,\n};\n//# sourceMappingURL=timestamp.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX),\n/* harmony export */   getInt64: () => (/* binding */ getInt64),\n/* harmony export */   getUint64: () => (/* binding */ getUint64),\n/* harmony export */   setInt64: () => (/* binding */ setInt64),\n/* harmony export */   setUint64: () => (/* binding */ setUint64)\n/* harmony export */ });\n// Integer Utility\nvar UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nfunction setUint64(view, offset, value) {\n    var high = value / 4294967296;\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction setInt64(view, offset, value) {\n    var high = Math.floor(value / 4294967296);\n    var low = value; // high bits are truncated by DataView\n    view.setUint32(offset, high);\n    view.setUint32(offset + 4, low);\n}\nfunction getInt64(view, offset) {\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\nfunction getUint64(view, offset) {\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    return high * 4294967296 + low;\n}\n//# sourceMappingURL=int.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prettyByte: () => (/* binding */ prettyByte)\n/* harmony export */ });\nfunction prettyByte(byte) {\n    return \"\".concat(byte < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(byte).toString(16).padStart(2, \"0\"));\n}\n//# sourceMappingURL=prettyByte.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDataView: () => (/* binding */ createDataView),\n/* harmony export */   ensureUint8Array: () => (/* binding */ ensureUint8Array)\n/* harmony export */ });\nfunction ensureUint8Array(buffer) {\n    if (buffer instanceof Uint8Array) {\n        return buffer;\n    }\n    else if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n    else if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n    }\n    else {\n        // ArrayLike<number>\n        return Uint8Array.from(buffer);\n    }\n}\nfunction createDataView(buffer) {\n    if (buffer instanceof ArrayBuffer) {\n        return new DataView(buffer);\n    }\n    var bufferView = ensureUint8Array(buffer);\n    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n//# sourceMappingURL=typedArrays.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs?");

/***/ }),

/***/ "./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   utf8Count: () => (/* binding */ utf8Count),\n/* harmony export */   utf8Decode: () => (/* binding */ utf8Decode),\n/* harmony export */   utf8DecodeJs: () => (/* binding */ utf8DecodeJs),\n/* harmony export */   utf8DecodeTD: () => (/* binding */ utf8DecodeTD),\n/* harmony export */   utf8Encode: () => (/* binding */ utf8Encode),\n/* harmony export */   utf8EncodeJs: () => (/* binding */ utf8EncodeJs),\n/* harmony export */   utf8EncodeTE: () => (/* binding */ utf8EncodeTE)\n/* harmony export */ });\nfunction utf8Count(str) {\n    var strLength = str.length;\n    var byteLength = 0;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            byteLength++;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            byteLength += 2;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                byteLength += 3;\n            }\n            else {\n                // 4-byte\n                byteLength += 4;\n            }\n        }\n    }\n    return byteLength;\n}\nfunction utf8EncodeJs(str, output, outputOffset) {\n    var strLength = str.length;\n    var offset = outputOffset;\n    var pos = 0;\n    while (pos < strLength) {\n        var value = str.charCodeAt(pos++);\n        if ((value & 0xffffff80) === 0) {\n            // 1-byte\n            output[offset++] = value;\n            continue;\n        }\n        else if ((value & 0xfffff800) === 0) {\n            // 2-bytes\n            output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n        }\n        else {\n            // handle surrogate pair\n            if (value >= 0xd800 && value <= 0xdbff) {\n                // high surrogate\n                if (pos < strLength) {\n                    var extra = str.charCodeAt(pos);\n                    if ((extra & 0xfc00) === 0xdc00) {\n                        ++pos;\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n                    }\n                }\n            }\n            if ((value & 0xffff0000) === 0) {\n                // 3-byte\n                output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n            else {\n                // 4-byte\n                output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n                output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n                output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n            }\n        }\n        output[offset++] = (value & 0x3f) | 0x80;\n    }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nvar sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nvar TEXT_ENCODER_THRESHOLD = 50;\nfunction utf8EncodeTE(str, output, outputOffset) {\n    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nfunction utf8Encode(str, output, outputOffset) {\n    if (str.length > TEXT_ENCODER_THRESHOLD) {\n        utf8EncodeTE(str, output, outputOffset);\n    }\n    else {\n        utf8EncodeJs(str, output, outputOffset);\n    }\n}\nvar CHUNK_SIZE = 4096;\nfunction utf8DecodeJs(bytes, inputOffset, byteLength) {\n    var offset = inputOffset;\n    var end = offset + byteLength;\n    var units = [];\n    var result = \"\";\n    while (offset < end) {\n        var byte1 = bytes[offset++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        }\n        else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 6) | byte2);\n        }\n        else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n        }\n        else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            var byte2 = bytes[offset++] & 0x3f;\n            var byte3 = bytes[offset++] & 0x3f;\n            var byte4 = bytes[offset++] & 0x3f;\n            var unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n                unit = 0xdc00 | (unit & 0x3ff);\n            }\n            units.push(unit);\n        }\n        else {\n            units.push(byte1);\n        }\n        if (units.length >= CHUNK_SIZE) {\n            result += String.fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += String.fromCharCode.apply(String, units);\n    }\n    return result;\n}\nvar sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nvar TEXT_DECODER_THRESHOLD = 200;\nfunction utf8DecodeTD(bytes, inputOffset, byteLength) {\n    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n    return sharedTextDecoder.decode(stringBytes);\n}\nfunction utf8Decode(bytes, inputOffset, byteLength) {\n    if (byteLength > TEXT_DECODER_THRESHOLD) {\n        return utf8DecodeTD(bytes, inputOffset, byteLength);\n    }\n    else {\n        return utf8DecodeJs(bytes, inputOffset, byteLength);\n    }\n}\n//# sourceMappingURL=utf8.mjs.map\n\n//# sourceURL=webpack://hypha-core/./node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/harmony module decorator */
/******/ (() => {
/******/ 	__webpack_require__.hmd = (module) => {
/******/ 		module = Object.create(module);
/******/ 		if (!module.children) module.children = [];
/******/ 		Object.defineProperty(module, 'exports', {
/******/ 			enumerable: true,
/******/ 			set: () => {
/******/ 				throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 			}
/******/ 		});
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/hypha-core.js");
/******/ var __webpack_exports__HyphaCore = __webpack_exports__.HyphaCore;
/******/ var __webpack_exports__WebSocket = __webpack_exports__.WebSocket;
/******/ var __webpack_exports__WebsocketRPCConnection = __webpack_exports__.WebsocketRPCConnection;
/******/ var __webpack_exports__Workspace = __webpack_exports__.Workspace;
/******/ var __webpack_exports__connectToServer = __webpack_exports__.connectToServer;
/******/ var __webpack_exports__hyphaWebsocketClient = __webpack_exports__.hyphaWebsocketClient;
/******/ var __webpack_exports__imjoyRPC = __webpack_exports__.imjoyRPC;
/******/ export { __webpack_exports__HyphaCore as HyphaCore, __webpack_exports__WebSocket as WebSocket, __webpack_exports__WebsocketRPCConnection as WebsocketRPCConnection, __webpack_exports__Workspace as Workspace, __webpack_exports__connectToServer as connectToServer, __webpack_exports__hyphaWebsocketClient as hyphaWebsocketClient, __webpack_exports__imjoyRPC as imjoyRPC };
/******/ 
