<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypha Core Integration Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }
        .test-section h3 {
            margin-top: 0;
            color: #34495e;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.pending {
            background: #f39c12;
            color: white;
        }
        .status.success {
            background: #27ae60;
            color: white;
        }
        .status.error {
            background: #e74c3c;
            color: white;
        }
        .log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #2980b9;
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .test-results {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
        }
        .error-details {
            color: #e74c3c;
            font-family: monospace;
            background: #fdf2f2;
            padding: 10px;
            border-radius: 4px;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Hypha Core Integration Tests</h1>
        <p>Comprehensive testing of all HyphaCore functionality as described in the README.</p>
        
        <div class="test-section">
            <h3>Test Controls</h3>
            <button onclick="runAllTests()">üöÄ Run All Tests</button>
            <button onclick="clearLog()">üóëÔ∏è Clear Log</button>
            <button onclick="runSpecificTest('basic')">üîß Basic Setup</button>
            <button onclick="runSpecificTest('auth')">üîê Authentication</button>
            <button onclick="runSpecificTest('services')">‚ö° Services</button>
            <button onclick="runSpecificTest('security')">üîí Security</button>
            <button onclick="runSpecificTest('standalone')">üì± Standalone App</button>
            <button onclick="runSpecificTest('webworker')">‚öôÔ∏è Custom Web Worker</button>
        </div>

        <div class="test-section">
            <h3>üìã Test Status Overview</h3>
            <div id="test-overview">
                <div>1. Basic HyphaCore Setup <span id="status-basic" class="status pending">PENDING</span></div>
                <div>2. JWT Authentication System <span id="status-auth" class="status pending">PENDING</span></div>
                <div>3. Service Registration & Communication <span id="status-services" class="status pending">PENDING</span></div>
                <div>4. Cross-Workspace Security <span id="status-security" class="status pending">PENDING</span></div>
                <div>5. Standalone App Integration <span id="status-standalone" class="status pending">PENDING</span></div>
                <div>6. Custom Web Worker Script <span id="status-webworker" class="status pending">PENDING</span></div>
            </div>
        </div>

        <div class="test-section">
            <h3>üìù Test Execution Log</h3>
            <div id="log" class="log"></div>
        </div>

        <div class="results">
            <div class="test-results">
                <h4>‚úÖ Successful Tests</h4>
                <div id="success-results"></div>
            </div>
            <div class="test-results">
                <h4>‚ùå Failed Tests</h4>
                <div id="error-results"></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { HyphaCore } from './hypha-core.mjs';

        // Expose HyphaCore globally for Playwright tests immediately
        window.HyphaCore = HyphaCore;
        
        // Set a ready flag for tests to know when the module is loaded
        window.hyphaModuleReady = true;

        // Test state management
        let hyphaCore = null;
        let rootApi = null;
        let clientApi = null;
        let workerApi = null;
        let testWorker = null;

        // Window management for standalone app testing
        function setupWindowHandler() {
            if (hyphaCore) {
                hyphaCore.on("add_window", (config) => {
                    log(`Creating window: ${config.name || config.src}`);
                    
                    // Create an iframe element similar to workspace.js
                    const elem = document.createElement("iframe");
                    elem.src = config.src;
                    elem.id = config.window_id || "window-" + Date.now();
                    elem.style.width = config.width ? config.width + "px" : "800px";
                    elem.style.height = config.height ? config.height + "px" : "600px";
                    elem.style.border = "1px solid #ddd";
                    elem.style.borderRadius = "4px";
                    elem.style.margin = "10px 0";
                    elem.style.display = "block";
                    
                    // Add a title for the iframe
                    const title = document.createElement("h4");
                    title.textContent = config.name || "Test Window";
                    title.style.margin = "10px 0 5px 0";
                    title.style.color = "#34495e";
                    
                    // Create a container for better organization
                    const container = document.createElement("div");
                    container.style.margin = "20px 0";
                    container.style.padding = "15px";
                    container.style.background = "#f9f9f9";
                    container.style.borderRadius = "5px";
                    
                    container.appendChild(title);
                    container.appendChild(elem);
                    
                    // Append to the main container instead of body
                    const mainContainer = document.querySelector('.container');
                    if (mainContainer) {
                        mainContainer.appendChild(container);
                    } else {
                        document.body.appendChild(container);
                    }
                    
                    log(`‚úì Iframe created successfully: ${config.name || config.src}`);
                    
                    // Store reference for cleanup
                    if (!window.testIframes) window.testIframes = [];
                    window.testIframes.push({ container, iframe: elem });
                });
            }
        }

        // Logging utilities
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warn' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            logElement.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${type.toUpperCase()}]`, message);
        }

        function updateStatus(testId, status) {
            const statusElement = document.getElementById(`status-${testId}`);
            if (statusElement) {
                statusElement.className = `status ${status}`;
                statusElement.textContent = status.toUpperCase();
            }
        }

        function addResult(testName, success, details = '') {
            const container = success ? 'success-results' : 'error-results';
            const resultElement = document.getElementById(container);
            const div = document.createElement('div');
            div.innerHTML = `
                <strong>${testName}</strong>
                ${details ? `<div class="error-details">${details}</div>` : ''}
            `;
            resultElement.appendChild(div);
        }

        // Test 1: Basic HyphaCore Setup
        async function testBasicSetup() {
            log('üîß Starting Basic HyphaCore Setup Test...');
            updateStatus('basic', 'pending');

            try {
                // Step 1: Create HyphaCore instance
                log('Step 1: Creating HyphaCore instance...');
                hyphaCore = new HyphaCore({
                    jwtSecret: 'test-integration-secret-key-2024',
                    port: 8080 + Math.floor(Math.random() * 1000) // Random port to avoid conflicts
                });
                
                log(`‚úì HyphaCore created with URL: ${hyphaCore.url}`);
                log(`‚úì WebSocket URL: ${hyphaCore.wsUrl}`);
                log(`‚úì JWT Secret configured: ${hyphaCore.jwtSecret ? 'Yes' : 'No'}`);

                // Step 2: Start the server
                log('Step 2: Starting HyphaCore server...');
                rootApi = await hyphaCore.start();
                
                log('‚úì Server started successfully');
                log(`‚úì Root API obtained with methods: ${Object.keys(rootApi).filter(k => typeof rootApi[k] === 'function').join(', ')}`);

                // Step 3: Setup window handler for standalone app testing
                log('Step 3: Setting up window handler...');
                setupWindowHandler();
                log('‚úì Window handler configured');

                // Step 4: Verify API methods
                const requiredMethods = ['generateToken', 'registerService', 'getService', 'listServices'];
                const availableMethods = Object.keys(rootApi).filter(k => typeof rootApi[k] === 'function');
                
                for (const method of requiredMethods) {
                    if (!availableMethods.includes(method)) {
                        throw new Error(`Required method ${method} not found in root API`);
                    }
                }
                
                log('‚úì All required API methods verified');
                
                updateStatus('basic', 'success');
                addResult('Basic HyphaCore Setup', true);
                log('üéâ Basic setup test completed successfully!', 'success');
                return true;

            } catch (error) {
                log(`‚ùå Basic setup test failed: ${error.message}`, 'error');
                updateStatus('basic', 'error');
                addResult('Basic HyphaCore Setup', false, error.message);
                return false;
            }
        }

        // Test 2: JWT Authentication System
        async function testAuthentication() {
            log('üîê Starting JWT Authentication Test...');
            updateStatus('auth', 'pending');

            try {
                if (!rootApi) {
                    throw new Error('Root API not available - run basic setup first');
                }

                // Step 1: Generate JWT token
                log('Step 1: Generating JWT token...');
                const token = await rootApi.generateToken({
                    user_id: 'test-user-123',
                    workspace: 'test-workspace',
                    email: 'test@example.com',
                    roles: ['user', 'tester'],
                    expires_in: 3600
                });

                log('‚úì JWT token generated successfully');
                log(`‚úì Token length: ${token.length} characters`);
                
                // Verify JWT structure
                const tokenParts = token.split('.');
                if (tokenParts.length !== 3) {
                    throw new Error(`Invalid JWT structure: expected 3 parts, got ${tokenParts.length}`);
                }
                
                log('‚úì JWT has correct structure (header.payload.signature)');

                // Step 2: Decode and verify payload
                const payload = JSON.parse(atob(tokenParts[1]));
                log(`‚úì Token payload decoded: ${JSON.stringify(payload, null, 2)}`);
                
                if (payload.sub !== 'test-user-123') {
                    throw new Error(`Expected subject 'test-user-123', got '${payload.sub}'`);
                }
                
                if (payload.workspace !== 'test-workspace') {
                    throw new Error(`Expected workspace 'test-workspace', got '${payload.workspace}'`);
                }

                log('‚úì Token payload verified');

                // Step 3: Connect using token
                log('Step 2: Connecting client with JWT token...');
                clientApi = await hyphaCore.connect({
                    token: token,
                    client_id: 'test-client-001',
                    workspace: 'test-workspace'
                });

                log('‚úì Client connected successfully with JWT token');
                log(`‚úì Client API methods: ${Object.keys(clientApi).filter(k => typeof clientApi[k] === 'function').join(', ')}`);

                // Step 4: Test cross-workspace access control
                log('Step 3: Testing workspace access controls...');
                
                try {
                    await clientApi.generateToken({
                        workspace: 'unauthorized-workspace'
                    });
                    throw new Error('Expected access denied error but token was generated');
                } catch (accessError) {
                    if (accessError.message.includes('Access denied')) {
                        log('‚úì Cross-workspace access properly denied');
                    } else {
                        throw accessError;
                    }
                }

                // Step 5: Test same-workspace token generation
                log('Step 4: Testing same-workspace token generation...');
                const sameWorkspaceToken = await clientApi.generateToken({
                    user_id: 'assistant-user',
                    workspace: 'test-workspace'
                });

                log('‚úì Same-workspace token generated successfully');
                
                const assistantPayload = JSON.parse(atob(sameWorkspaceToken.split('.')[1]));
                if (assistantPayload.workspace !== 'test-workspace') {
                    throw new Error('Same-workspace token has incorrect workspace');
                }

                updateStatus('auth', 'success');
                addResult('JWT Authentication System', true);
                log('üéâ Authentication test completed successfully!', 'success');
                return true;

            } catch (error) {
                log(`‚ùå Authentication test failed: ${error.message}`, 'error');
                updateStatus('auth', 'error');
                addResult('JWT Authentication System', false, error.message);
                return false;
            }
        }

        // Test 3: Service Registration & Communication
        async function testServices() {
            log('‚ö° Starting Service Registration Test...');
            updateStatus('services', 'pending');

            try {
                if (!rootApi || !clientApi) {
                    throw new Error('APIs not available - run previous tests first');
                }

                // Step 1: Register service with client API (same workspace)
                log('Step 1: Registering math service with client API in test-workspace...');
                await clientApi.registerService({
                    id: 'math-service',
                    name: 'Mathematical Operations Service',
                    description: 'A service that performs mathematical operations',
                    config: {
                        require_context: true,
                        visibility: 'public'
                    },
                    overwrite: true,
                    add: function(a, b, context) {
                        log(`Math service: Adding ${a} + ${b} (called from ${context?.from || 'unknown'})`);
                        return a + b;
                    },
                    multiply: function(a, b, context) {
                        log(`Math service: Multiplying ${a} * ${b} (called from ${context?.from || 'unknown'})`);
                        return a * b;
                    },
                    getWorkspaceInfo: function(context) {
                        return {
                            workspace: context?.ws || 'unknown',
                            caller: context?.from || 'unknown',
                            timestamp: new Date().toISOString()
                        };
                    }
                });

                log('‚úì Math service registered successfully');

                // Step 2: Register service with client API
                log('Step 2: Registering string service...');
                await clientApi.registerService({
                    id: 'string-service',
                    name: 'String Operations Service',
                    config: {
                        require_context: true,
                        visibility: 'protected' // Only within same workspace
                    },
                    overwrite: true,
                    reverse: function(str, context) {
                        log(`String service: Reversing "${str}" (workspace: ${context?.ws})`);
                        return str.split('').reverse().join('');
                    },
                    uppercase: function(str, context) {
                        log(`String service: Converting "${str}" to uppercase`);
                        return str.toUpperCase();
                    }
                });

                log('‚úì String service registered successfully');

                // Step 3: List services
                log('Step 3: Listing available services...');
                const services = await clientApi.listServices();
                log(`‚úì Found ${services.length} services`);
                
                for (const service of services) {
                    log(`  - ${service.name} (${service.id})`);
                }

                // Step 4: Get and call math service
                log('Step 4: Getting and calling math service...');
                const mathService = await clientApi.getService('math-service');
                
                if (!mathService) {
                    throw new Error('Math service not found');
                }

                log('‚úì Math service retrieved');

                // Test math operations
                const sum = await mathService.add(15, 27);
                log(`‚úì Math service add(15, 27) = ${sum}`);
                
                if (sum !== 42) {
                    throw new Error(`Expected 42, got ${sum}`);
                }

                const product = await mathService.multiply(6, 7);
                log(`‚úì Math service multiply(6, 7) = ${product}`);
                
                if (product !== 42) {
                    throw new Error(`Expected 42, got ${product}`);
                }

                const workspaceInfo = await mathService.getWorkspaceInfo();
                log(`‚úì Workspace info: ${JSON.stringify(workspaceInfo)}`);

                // Step 5: Get and call string service
                log('Step 5: Testing string service...');
                const stringService = await clientApi.getService('string-service');
                
                if (!stringService) {
                    throw new Error('String service not found');
                }

                const reversed = await stringService.reverse('Hello World');
                log(`‚úì String service reverse("Hello World") = "${reversed}"`);
                
                if (reversed !== 'dlroW olleH') {
                    throw new Error(`Expected "dlroW olleH", got "${reversed}"`);
                }

                const uppercase = await stringService.uppercase('integration test');
                log(`‚úì String service uppercase("integration test") = "${uppercase}"`);
                
                if (uppercase !== 'INTEGRATION TEST') {
                    throw new Error(`Expected "INTEGRATION TEST", got "${uppercase}"`);
                }

                updateStatus('services', 'success');
                addResult('Service Registration & Communication', true);
                log('üéâ Service registration test completed successfully!', 'success');
                return true;

            } catch (error) {
                log(`‚ùå Service registration test failed: ${error.message}`, 'error');
                updateStatus('services', 'error');
                addResult('Service Registration & Communication', false, error.message);
                return false;
            }
        }

        // Test 4: Cross-Workspace Security
        async function testSecurity() {
            log('üîí Starting Cross-Workspace Security Test...');
            updateStatus('security', 'pending');

            try {
                if (!rootApi) {
                    throw new Error('Root API not available - run basic setup first');
                }

                // Step 1: Create multiple workspace tokens
                log('Step 1: Creating multiple workspace tokens...');
                
                const alphaToken = await rootApi.generateToken({
                    user_id: 'alpha-user',
                    workspace: 'workspace-alpha',
                    roles: ['user']
                });

                const betaToken = await rootApi.generateToken({
                    user_id: 'beta-user', 
                    workspace: 'workspace-beta',
                    roles: ['user']
                });

                log('‚úì Multiple workspace tokens created');

                // Step 2: Connect clients to different workspaces
                log('Step 2: Connecting clients to different workspaces...');
                
                const alphaClient = await hyphaCore.connect({
                    token: alphaToken,
                    client_id: 'alpha-client',
                    workspace: 'workspace-alpha'
                });

                const betaClient = await hyphaCore.connect({
                    token: betaToken,
                    client_id: 'beta-client', 
                    workspace: 'workspace-beta'
                });

                log('‚úì Multi-workspace clients connected');

                // Step 3: Register workspace-specific services
                log('Step 3: Registering workspace-specific services...');
                
                await alphaClient.registerService({
                    id: 'alpha-secret',
                    name: 'Alpha Secret Service',
                    config: {
                        require_context: true,
                        visibility: 'protected' // Only within workspace-alpha
                    },
                    overwrite: true,
                    getSecret: function(context) {
                        return {
                            secret: 'alpha-classified-data',
                            workspace: context.ws,
                            timestamp: new Date().toISOString()
                        };
                    }
                });

                await betaClient.registerService({
                    id: 'beta-secret',
                    name: 'Beta Secret Service', 
                    config: {
                        require_context: true,
                        visibility: 'protected' // Only within workspace-beta
                    },
                    overwrite: true,
                    getSecret: function(context) {
                        return {
                            secret: 'beta-classified-data',
                            workspace: context.ws,
                            timestamp: new Date().toISOString()
                        };
                    }
                });

                log('‚úì Workspace-specific secret services registered');

                // Step 4: Test workspace isolation
                log('Step 4: Testing workspace isolation...');

                // Wait a bit for service registration to propagate
                await new Promise(resolve => setTimeout(resolve, 500));

                // Alpha client should access alpha service
                log('Checking alpha services...');
                const alphaServices = await alphaClient.listServices();
                log(`Alpha client sees ${alphaServices.length} services:`);
                for (const service of alphaServices) {
                    log(`  - ${service.name} (${service.id})`);
                }

                // Find the alpha secret service
                const alphaSecretServiceInfo = alphaServices.find(s => s.id.includes('alpha-secret'));
                if (!alphaSecretServiceInfo) {
                    throw new Error('Alpha secret service not found in service list');
                }

                // Extract just the service ID part (e.g., "alpha-secret" from "workspace-alpha/alpha-client:alpha-secret")
                const alphaServiceId = alphaSecretServiceInfo.id
                log(`Attempting to get alpha service with ID: ${alphaServiceId}`);

                const alphaService = await alphaClient.getService(alphaServiceId);
                if (!alphaService) {
                    throw new Error('Alpha client cannot access its own service');
                }

                const alphaSecret = await alphaService.getSecret();
                log(`‚úì Alpha client accessed alpha secret: ${alphaSecret.secret}`);

                // Beta client should access beta service
                log('Checking beta services...');
                const betaServices = await betaClient.listServices();
                log(`Beta client sees ${betaServices.length} services:`);
                for (const service of betaServices) {
                    log(`  - ${service.name} (${service.id})`);
                }

                // Find the beta secret service
                const betaSecretServiceInfo = betaServices.find(s => s.id.includes('beta-secret'));
                if (!betaSecretServiceInfo) {
                    throw new Error('Beta secret service not found in service list');
                }

                // Extract just the service ID part (e.g., "beta-secret" from "workspace-beta/beta-client:beta-secret")
                const betaServiceId = betaSecretServiceInfo.id
                log(`Attempting to get beta service with ID: ${betaServiceId}`);

                const betaService = await betaClient.getService(betaServiceId);
                if (!betaService) {
                    throw new Error('Beta client cannot access its own service');
                }

                const betaSecret = await betaService.getSecret();
                log(`‚úì Beta client accessed beta secret: ${betaSecret.secret}`);

                // Step 5: Test cross-workspace access denial
                log('Step 5: Testing cross-workspace access denial...');

                // Alpha client should not see beta services in its service list
                const alphaAccessibleServices = await alphaClient.listServices();
                const alphaSeesBeta = alphaAccessibleServices.some(s => s.id.includes('beta-secret'));
                
                if (alphaSeesBeta) {
                    log('‚ö†Ô∏è Alpha client can see beta service in list - checking direct access...');
                    try {
                        const betaFromAlpha = await alphaClient.getService(betaServiceId);
                        if (betaFromAlpha) {
                            throw new Error('Alpha client should not access beta service');
                        }
                    } catch (accessError) {
                        log('‚úì Alpha client properly denied direct access to beta service');
                    }
                } else {
                    log('‚úì Alpha client properly cannot see beta service in service list');
                }

                // Beta client should not see alpha services in its service list  
                const betaAccessibleServices = await betaClient.listServices();
                const betaSeesAlpha = betaAccessibleServices.some(s => s.id.includes('alpha-secret'));
                
                if (betaSeesAlpha) {
                    log('‚ö†Ô∏è Beta client can see alpha service in list - checking direct access...');
                    try {
                        const alphaFromBeta = await betaClient.getService(alphaServiceId);
                        if (alphaFromBeta) {
                            throw new Error('Beta client should not access alpha service');
                        }
                    } catch (accessError) {
                        log('‚úì Beta client properly denied direct access to alpha service');
                    }
                } else {
                    log('‚úì Beta client properly cannot see alpha service in service list');
                }

                // Step 6: Test token generation restrictions
                log('Step 6: Testing token generation restrictions...');

                try {
                    await alphaClient.generateToken({
                        workspace: 'workspace-beta' // Cross-workspace attempt
                    });
                    throw new Error('Alpha client should not generate beta workspace tokens');
                } catch (tokenError) {
                    if (tokenError.message.includes('Access denied')) {
                        log('‚úì Cross-workspace token generation properly denied');
                    } else {
                        throw tokenError;
                    }
                }

                updateStatus('security', 'success');
                addResult('Cross-Workspace Security', true);
                log('üéâ Cross-workspace security test completed successfully!', 'success');
                return true;

            } catch (error) {
                log(`‚ùå Cross-workspace security test failed: ${error.message}`, 'error');
                updateStatus('security', 'error');
                addResult('Cross-Workspace Security', false, error.message);
                return false;
            }
        }

        // Test 5: Standalone App Integration
        async function testStandaloneApp() {
            log('üì± Starting Standalone App Integration Test...');
            updateStatus('standalone', 'pending');

            try {
                if (!rootApi) {
                    throw new Error('Root API not available - run basic setup first');
                }

               
                // Step 1: Create a test window with standalone app
                log('Step 1: Creating standalone app window...');
                const baseUrl = window.location.origin;
                const windowConfig = {
                    src: `${baseUrl}/standalone-app-example.html`,
                    name: "Standalone App Test",
                    width: 600,
                    height: 400
                };

                // Create window using the rootApi
                const app = await rootApi.createWindow(windowConfig);
                log('‚úì Standalone app window created');

                // Step 2: Test updateUI API
                log('Step 2: Testing updateUI API...');
                await app.updateUI({
                    title: "Standalone App Test",
                    message: "This is a test message from integration test"
                });
                log('‚úì updateUI API tested successfully');

                // Step 3: Test processData API with different data types
                log('Step 3: Testing processData API...');
                
                // Test with array
                const arrayResult = await app.processData([1, 2, 3, 4]);
                log(`‚úì processData with array: ${JSON.stringify(arrayResult)}`);
                
                // Test with string
                const stringResult = await app.processData('hello world');
                log(`‚úì processData with string: ${stringResult}`);
                
                // Test with object
                const objectResult = await app.processData({ test: true, value: 42 });
                log(`‚úì processData with object: ${JSON.stringify(objectResult)}`);

                // Step 4: Test performMath API
                log('Step 4: Testing performMath API...');
                
                const addMathResult = await app.performMath('add', 10, 20, 30);
                log(`‚úì performMath add(10, 20, 30) = ${addMathResult}`);
                if (addMathResult !== 60) {
                    throw new Error(`Expected 60, got ${addMathResult}`);
                }
                
                const multiplyResult = await app.performMath('multiply', 3, 4, 5);
                log(`‚úì performMath multiply(3, 4, 5) = ${multiplyResult}`);
                if (multiplyResult !== 60) {
                    throw new Error(`Expected 60, got ${multiplyResult}`);
                }
                
                const averageResult = await app.performMath('average', 10, 20, 30);
                log(`‚úì performMath average(10, 20, 30) = ${averageResult}`);
                if (averageResult !== 20) {
                    throw new Error(`Expected 20, got ${averageResult}`);
                }

                // Step 5: Test getAppState API
                log('Step 5: Testing getAppState API...');
                const appState = await app.getAppState();
                log(`‚úì getAppState result: ${JSON.stringify(appState, null, 2)}`);
                
                // Verify app state structure
                if (!appState.title) {
                    throw new Error('App state missing title');
                }
                if (!appState.timestamp) {
                    throw new Error('App state missing timestamp');
                }
                if (appState.connected !== true) {
                    throw new Error('App state shows not connected');
                }
                if (!appState.url) {
                    throw new Error('App state missing URL');
                }
                
                log('‚úì App state structure verified');

                // Step 6: Test complex interaction - update UI and check state
                log('Step 6: Testing complex interaction...');
                await app.updateUI({
                    title: "Integration Test Complete",
                    message: "All API tests passed successfully!",
                    style: {
                        backgroundColor: '#d4edda'
                    }
                });
                
                const finalState = await app.getAppState();
                if (!finalState.title.includes('Integration Test Complete')) {
                    throw new Error('UI update not reflected in app state');
                }
                
                log('‚úì Complex interaction test passed');

                log('‚úì All standalone app APIs tested successfully');
                updateStatus('standalone', 'success');
                addResult('Standalone App Integration', true);
                log('üéâ Standalone app integration test completed successfully!', 'success');
                log('üí° Check the created iframe to see if the standalone app loaded correctly');
                return true;

            } catch (error) {
                log(`‚ùå Standalone app integration test failed: ${error.message}`, 'error');
                updateStatus('standalone', 'error');
                addResult('Standalone App Integration', false, error.message);
                return false;
            }
        }

        // Test 6: Custom Web Worker Script
        async function testCustomWebWorker() {
            log('‚öôÔ∏è Starting Custom Web Worker Script Test...');
            updateStatus('webworker', 'pending');

            try {
                if (!rootApi) {
                    throw new Error('Root API not available - run basic setup first');
                }

                // Step 1: Use the existing test-worker.js file
                log('Step 1: Using existing test-worker.js for custom worker test...');
                
                const testWorkerBaseUrl = window.location.origin;
                const workerUrl = `${testWorkerBaseUrl}/test-worker.js`;
                
                log(`‚úì Using test worker at: ${workerUrl}`);

                // Step 2: Load the custom web worker using loadApp
                log('Step 2: Loading custom web worker via loadApp...');
                
                const workerApp = await rootApi.loadApp({
                    type: 'web-worker',
                    src: workerUrl,
                    name: 'Test Worker with Computational Services',
                    description: 'Custom web worker with full Hypha RPC integration'
                });
                
                log('‚úì Custom web worker loaded successfully');
                log(`‚úì Worker app service ID: ${workerApp.id}`);

                // Step 3: Test computational services
                log('Step 3: Testing computational services...');
                
                // Test fibonacci calculation
                const fibResult = await workerApp.fibonacci(10);
                log(`‚úì Fibonacci(10) = ${fibResult}`);
                if (fibResult !== 55) {
                    throw new Error(`Expected fibonacci(10) = 55, got ${fibResult}`);
                }
                
                // Test factorial calculation
                const factResult = await workerApp.factorial(5);
                log(`‚úì Factorial(5) = ${factResult}`);
                if (factResult !== 120) {
                    throw new Error(`Expected factorial(5) = 120, got ${factResult}`);
                }
                
                // Test prime checking
                const primeResult = await workerApp.isPrime(17);
                log(`‚úì isPrime(17) = ${primeResult}`);
                if (primeResult !== true) {
                    throw new Error(`Expected isPrime(17) = true, got ${primeResult}`);
                }
                
                // Test array processing
                const arrayResult = await workerApp.processArray([1, 2, 3, 4, 5], 'sum');
                log(`‚úì processArray([1,2,3,4,5], 'sum') = ${arrayResult}`);
                if (arrayResult !== 15) {
                    throw new Error(`Expected array sum = 15, got ${arrayResult}`);
                }
                
                // Test worker info
                const workerInfo = await workerApp.getWorkerInfo();
                log(`‚úì Worker info: ${workerInfo.type}, capabilities: ${workerInfo.capabilities?.length || 0} functions`);
                
                log('‚úì All computational service tests passed!');

                // Step 4: Test error handling - try invalid worker URL
                log('Step 4: Testing error handling with invalid worker URL...');
                
                try {
                    await rootApi.loadApp({
                        type: 'web-worker',
                        src: 'https://nonexistent-domain.invalid/worker.js',
                        name: 'Invalid Worker Test'
                    });
                    throw new Error('Expected error for invalid worker URL');
                } catch (expectedError) {
                    if (expectedError.message.includes('Expected error')) {
                        throw expectedError; // Re-throw our own error
                    }
                    log('‚úì Invalid worker URL properly handled');
                }

                // Step 4: Test service listing to verify worker services are registered
                log('Step 4: Verifying worker services are registered...');
                
                const allServices = await rootApi.listServices();
                const workerServices = allServices.filter(s => s.id && s.id.includes('computational-services'));
                
                if (workerServices.length > 0) {
                    log(`‚úì Found ${workerServices.length} computational services registered by worker`);
                    for (const service of workerServices) {
                        log(`  - ${service.name}: ${service.description}`);
                    }
                } else {
                    log('‚ö†Ô∏è No computational services found (worker may not have fully registered yet)');
                }

                // Step 5: Test performance benchmark
                log('Step 5: Testing worker performance benchmark...');
                
                try {
                    const benchmarkResult = await workerApp.benchmark('fibonacci', 20);
                    log(`‚úì Fibonacci benchmark: ${benchmarkResult.duration.toFixed(2)}ms for fibonacci(${benchmarkResult.parameter})`);
                } catch (benchError) {
                    log(`‚ö†Ô∏è Benchmark test failed: ${benchError.message}`);
                }

                // Step 6: Test worker cleanup and status
                log('Step 6: Testing worker status and capabilities...');
                
                const finalWorkerInfo = await workerApp.getWorkerInfo();
                log(`‚úì Final worker status - Type: ${finalWorkerInfo.type}, Capabilities: ${finalWorkerInfo.capabilities.length} functions`);
                log(`‚úì Custom web worker test completed successfully using real Hypha RPC integration`);

                updateStatus('webworker', 'success');
                addResult('Custom Web Worker Script', true);
                log('üéâ Custom web worker script test completed successfully!', 'success');
                return true;

            } catch (error) {
                log(`‚ùå Custom web worker test failed: ${error.message}`, 'error');
                updateStatus('webworker', 'error');
                addResult('Custom Web Worker Script', false, error.message);
                return false;
            }
        }

        // Main test orchestration
        async function runAllTests() {
            log('üöÄ Starting Comprehensive Integration Tests...');
            log('='.repeat(50));
            
            // Clear previous results
            document.getElementById('success-results').innerHTML = '';
            document.getElementById('error-results').innerHTML = '';

            const tests = [
                { name: 'Basic Setup', fn: testBasicSetup },
                { name: 'Authentication', fn: testAuthentication },
                { name: 'Services', fn: testServices },
                { name: 'Security', fn: testSecurity },
                { name: 'Standalone App', fn: testStandaloneApp },
                { name: 'Custom Web Worker', fn: testCustomWebWorker }
            ];

            let passed = 0;
            let failed = 0;

            for (const test of tests) {
                try {
                    log(`\nüîÑ Running ${test.name} test...`);
                    const success = await test.fn();
                    if (success) {
                        passed++;
                    } else {
                        failed++;
                    }
                } catch (error) {
                    log(`üí• Test ${test.name} threw exception: ${error.message}`, 'error');
                    failed++;
                }
                
                // Small delay between tests
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            log('\n' + '='.repeat(50));
            log(`üèÅ All tests completed! Passed: ${passed}, Failed: ${failed}`);
            
            if (failed === 0) {
                log('üéâ All integration tests passed successfully!', 'success');
            } else {
                log(`‚ö†Ô∏è ${failed} test(s) failed. Please check the error details above.`, 'warn');
            }
        }

        async function runSpecificTest(testType) {
            const tests = {
                basic: testBasicSetup,
                auth: testAuthentication,
                services: testServices,
                security: testSecurity,
                standalone: testStandaloneApp,
                webworker: testCustomWebWorker
            };

            if (tests[testType]) {
                await tests[testType]();
            } else {
                log(`Unknown test type: ${testType}`, 'error');
            }
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            document.getElementById('success-results').innerHTML = '';
            document.getElementById('error-results').innerHTML = '';
            
            // Reset all status indicators
            const statuses = ['basic', 'auth', 'services', 'security', 'standalone', 'webworker'];
            statuses.forEach(status => updateStatus(status, 'pending'));
            
            // Close any test windows
            if (window.testIframes) {
                window.testIframes.forEach(item => {
                    try {
                        if (item.container) {
                            item.container.remove();
                        }
                    } catch (e) {
                        // Ignore errors when closing windows
                    }
                });
                window.testIframes = [];
            }
            
            // Restore initial messages
            log('üìÑ Integration test page loaded');
            log('üí° Click "Run All Tests" to execute comprehensive integration tests');
            log('üéØ Or run individual test categories using the specific test buttons');
        }

        // Expose functions globally
        window.runAllTests = runAllTests;
        window.runSpecificTest = runSpecificTest;
        window.clearLog = clearLog;

        // Auto-run basic setup on page load
        log('üìÑ Integration test page loaded');
        log('üí° Click "Run All Tests" to execute comprehensive integration tests');
        log('üéØ Or run individual test categories using the specific test buttons');

    </script>
</body>
</html> 